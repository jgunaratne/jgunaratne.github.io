//javascript/closure/base.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will write out Closure's deps file, unless the
 * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
 * include their own deps file(s) from different locations.
 *
 * @author pupius@google.com (Dan Pupius)
 * @author arv@google.com (Erik Arvidsson)
 *
 * @provideGoog
 */


/**
 * @define {boolean} Overridden to true by the compiler when --closure_pass
 *     or --mark_as_compiled is specified.
 */
var COMPILED = false;


/**
 * Base namespace for the Closure library.  Checks to see goog is already
 * defined in the current scope before assigning to prevent clobbering if
 * base.js is loaded more than once.
 *
 * @const
 */
var goog = goog || {};


/**
 * Reference to the global context.  In most cases this will be 'window'.
 */
goog.global = this;


/**
 * A hook for overriding the define values in uncompiled mode.
 *
 * In uncompiled mode, {@code CLOSURE_DEFINES} may be defined before loading
 * base.js.  If a key is defined in {@code CLOSURE_DEFINES}, {@code goog.define}
 * will use the value instead of the default value.  This allows flags to be
 * overwritten without compilation (this is normally accomplished with the
 * compiler's "define" flag).
 *
 * Example:
 * <pre>
 *   var CLOSURE_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object.<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_DEFINES;


/**
 * Builds an object structure for the provided namespace path, ensuring that
 * names that already exist are not overwritten. For example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name name of the object that this file defines.
 * @param {*=} opt_object the object to expose at the end of the path.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is |goog.global|.
 * @private
 */
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
  var parts = name.split('.');
  var cur = opt_objectToExportTo || goog.global;

  // Internet Explorer exhibits strange behavior when throwing errors from
  // methods externed in this manner.  See the testExportSymbolExceptions in
  // base_test.html for an example.
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript('var ' + parts[0]);
  }

  // Certain browsers cannot parse code in the form for((a in b); c;);
  // This pattern is produced by the JSCompiler when it collapses the
  // statement above into the conditional loop below. To prevent this from
  // happening, use a for-loop and reserve the init logic as below.

  // Parentheses added to eliminate strict JS warning in Firefox.
  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && opt_object !== undefined) {
      // last part and we have an object; use it
      cur[part] = opt_object;
    } else if (cur[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};


/**
 * Defines a named value. In uncompiled mode, the value is retreived from
 * CLOSURE_DEFINES if the object is defined and has the property specified,
 * and otherwise used the defined defaultValue. When compiled, the default
 * can be overridden using compiler command-line options.
 *
 * @param {string} name The distinguished name to provide.
 * @param {string|number|boolean} defaultValue
 */
goog.define = function(name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    if (goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(
        goog.global.CLOSURE_DEFINES, name)) {
      value = goog.global.CLOSURE_DEFINES[name];
    }
  }
  goog.exportPath_(name, value);
};


/**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production js_binary can be easily stripped
 * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
 * toString() methods should be declared inside an "if (goog.DEBUG)" conditional
 * because they are generally used for debugging purposes and it is difficult
 * for the JSCompiler to statically determine whether they are used.
 */
goog.DEBUG = true;


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
 */
goog.define('goog.LOCALE', 'en');  // default to en


/**
 * @define {boolean} Whether this code is running on trusted sites.
 *
 * On untrusted sites, several native functions can be defined or overridden by
 * external libraries like Prototype, Datejs, and JQuery and setting this flag
 * to false forces closure to use its own implementations when possible.
 *
 * If your JavaScript can be loaded by a third party site and you are wary about
 * relying on non-standard implementations, specify
 * "--define goog.TRUSTED_SITE=false" to the JSCompiler.
 */
goog.define('goog.TRUSTED_SITE', true);


/**
 * Creates object stubs for a namespace.  The presence of one or more
 * goog.provide() calls indicate that the file defines the given
 * objects/namespaces.  Build tools also scan for provide/require statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 * @see goog.require
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 */
goog.provide = function(name) {
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice. This is intended
    // to teach new developers that 'goog.provide' is effectively a variable
    // declaration. And when JSCompiler transforms goog.provide into a real
    // variable declaration, the compiled JS should work the same as the raw
    // JS--even when the raw JS uses goog.provide incorrectly.
    if (goog.isProvided_(name)) {
      throw Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];

    var namespace = name;
    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }

  goog.exportPath_(name);
};


/**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 *
 * In the case of unit tests, the message may optionally be an exact namespace
 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
 * provide (if not explicitly defined in the code).
 *
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */
goog.setTestOnly = function(opt_message) {
  if (COMPILED && !goog.DEBUG) {
    opt_message = opt_message || '';
    throw Error('Importing test-only code into non-debug environment' +
                opt_message ? ': ' + opt_message : '.');
  }
};


if (!COMPILED) {

  /**
   * Check if the given name has been goog.provided. This will return false for
   * names that are available only as implicit namespaces.
   * @param {string} name name of the object to look for.
   * @return {boolean} Whether the name has been provided.
   * @private
   */
  goog.isProvided_ = function(name) {
    return !goog.implicitNamespaces_[name] && !!goog.getObjectByName(name);
  };

  /**
   * Namespaces implicitly defined by goog.provide. For example,
   * goog.provide('goog.events.Event') implicitly declares that 'goog' and
   * 'goog.events' must be namespaces.
   *
   * @type {Object}
   * @private
   */
  goog.implicitNamespaces_ = {};
}


/**
 * Returns an object based on its fully qualified external name.  If you are
 * using a compilation pass that renames property names beware that using this
 * function will not find renamed properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */
goog.getObjectByName = function(name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var part; part = parts.shift(); ) {
    if (goog.isDefAndNotNull(cur[part])) {
      cur = cur[part];
    } else {
      return null;
    }
  }
  return cur;
};


/**
 * Globalizes a whole namespace, such as goog or goog.lang.
 *
 * @param {Object} obj The namespace to globalize.
 * @param {Object=} opt_global The object to add the properties to.
 * @deprecated Properties may be explicitly exported to the global scope, but
 *     this should no longer be done in bulk.
 */
goog.globalize = function(obj, opt_global) {
  var global = opt_global || goog.global;
  for (var x in obj) {
    global[x] = obj[x];
  }
};


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {Array} provides An array of strings with the names of the objects
 *                         this file provides.
 * @param {Array} requires An array of strings with the names of the objects
 *                         this file requires.
 */
goog.addDependency = function(relPath, provides, requires) {
  if (goog.DEPENDENCIES_ENABLED) {
    var provide, require;
    var path = relPath.replace(/\\/g, '/');
    var deps = goog.dependencies_;
    for (var i = 0; provide = provides[i]; i++) {
      deps.nameToPath[provide] = path;
      if (!(path in deps.pathToNames)) {
        deps.pathToNames[path] = {};
      }
      deps.pathToNames[path][provide] = true;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(path in deps.requires)) {
        deps.requires[path] = {};
      }
      deps.requires[path][require] = true;
    }
  }
};


// MOE:begin_strip
/**
 * Whether goog.require should throw an exception if it fails.
 * @type {boolean}
 */
goog.useStrictRequires = false;


// MOE:end_strip


// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
// User-defined namespaces may need their own deps file.  See http://go/js_deps,
// http://go/genjsdeps, or, externally, DepsWriter.
// http://code.google.com/closure/library/docs/depswriter.html
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work is being done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.


/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.define('goog.ENABLE_DEBUG_LOADER', true);


/**
 * Implements a system for the dynamic resolution of dependencies that works in
 * parallel with the BUILD system. Note that all calls to goog.require will be
 * stripped by the JSCompiler when the --closure_pass option is used.
 * @see goog.provide
 * @param {string} name Namespace to include (as was given in goog.provide()) in
 *     the form "goog.package.part".
 */
goog.require = function(name) {

  // If the object already exists we do not need do do anything.
  // TODO(arv): If we start to support require based on file name this has to
  //            change.
  // TODO(arv): If we allow goog.foo.* this has to change.
  // TODO(arv): If we implement dynamic load after page load we should probably
  //            not remove this code for the compiled output.
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      return;
    }

    if (goog.ENABLE_DEBUG_LOADER) {
      var path = goog.getPathFromDeps_(name);
      if (path) {
        goog.included_[path] = true;
        goog.writeScripts_();
        return;
      }
    }

    var errorMessage = 'goog.require could not find: ' + name;
    if (goog.global.console) {
      goog.global.console['error'](errorMessage);
    }

    // MOE:begin_strip

    // NOTE(nicksantos): We could always throw an error, but this would break
    // legacy users that depended on this failing silently. Instead, the
    // compiler should warn us when there are invalid goog.require calls.
    // For now, we simply give clients a way to turn strict mode on.
    if (goog.useStrictRequires) {
      // MOE:end_strip

      throw Error(errorMessage);

      // MOE:begin_strip
    }
    // MOE:end_strip
  }
};


/**
 * Path for included scripts.
 * @type {string}
 */
goog.basePath = '';


/**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */
goog.global.CLOSURE_BASE_PATH;


/**
 * Whether to write out Closure's deps file. By default, the deps are written.
 * @type {boolean|undefined}
 */
goog.global.CLOSURE_NO_DEPS;


/**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The function is passed the script source, which is a relative URI. It should
 * return true if the script was imported, false otherwise.
 */
goog.global.CLOSURE_IMPORT_SCRIPT;


/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
goog.nullFunction = function() {};


/**
 * The identity function. Returns its first argument.
 *
 * @param {*=} opt_returnValue The single value that will be returned.
 * @param {...*} var_args Optional trailing arguments. These are ignored.
 * @return {?} The first argument. We can't know the type -- just pass it along
 *      without type.
 * @deprecated Use goog.functions.identity instead.
 */
goog.identityFunction = function(opt_returnValue, var_args) {
  return opt_returnValue;
};


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * Note: This does not take the name of the function to override as an argument
 * because that would make it more difficult to obfuscate our JavaScript code.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
goog.abstractMethod = function() {
  throw Error('unimplemented abstract method');
};


/**
 * Adds a {@code getInstance} static method that always returns the same
 * instance object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 */
goog.addSingletonGetter = function(ctor) {
  ctor.getInstance = function() {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      // NOTE: JSCompiler can't optimize away Array#push.
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    return ctor.instance_ = new ctor;
  };
};


/**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the {@code goog.testing.singleton} module. The compiler
 * removes this variable if unused.
 * @type {!Array.<!Function>}
 * @private
 */
goog.instantiatedSingletons_ = [];


/**
 * True if goog.dependencies_ is available.
 * @const {boolean}
 */
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;


if (goog.DEPENDENCIES_ENABLED) {
  /**
   * Object used to keep track of urls that have already been added. This record
   * allows the prevention of circular dependencies.
   * @type {Object}
   * @private
   */
  goog.included_ = {};


  /**
   * This object is used to keep track of dependencies and other data that is
   * used for loading scripts.
   * @private
   * @type {Object}
   */
  goog.dependencies_ = {
    pathToNames: {}, // 1 to many
    nameToPath: {}, // 1 to 1
    requires: {}, // 1 to many
    // Used when resolving dependencies to prevent us from visiting file twice.
    visited: {},
    written: {} // Used to keep track of script files we have written.
  };


  /**
   * Tries to detect whether is in the context of an HTML document.
   * @return {boolean} True if it looks like HTML document.
   * @private
   */
  goog.inHtmlDocument_ = function() {
    var doc = goog.global.document;
    return typeof doc != 'undefined' &&
           'write' in doc;  // XULDocument misses write.
  };


  /**
   * Tries to detect the base path of base.js script that bootstraps Closure.
   * @private
   */
  goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    var doc = goog.global.document;
    var scripts = doc.getElementsByTagName('script');
    // Search backwards since the current script is in almost all cases the one
    // that has base.js.
    for (var i = scripts.length - 1; i >= 0; --i) {
      var src = scripts[i].src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == 'base.js') {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };


  /**
   * Imports a script if, and only if, that script hasn't already been imported.
   * (Must be called at execution time)
   * @param {string} src Script source.
   * @private
   */
  goog.importScript_ = function(src) {
    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
        goog.writeScriptTag_;
    if (!goog.dependencies_.written[src] && importScript(src)) {
      goog.dependencies_.written[src] = true;
    }
  };


  /**
   * The default implementation of the import function. Writes a script tag to
   * import the script.
   *
   * @param {string} src The script source.
   * @return {boolean} True if the script was imported, false otherwise.
   * @private
   */
  goog.writeScriptTag_ = function(src) {
    if (goog.inHtmlDocument_()) {
      var doc = goog.global.document;

      // If the user tries to require a new symbol after document load,
      // something has gone terribly wrong. Doing a document.write would
      // wipe out the page.
      if (doc.readyState == 'complete') {
        // Certain test frameworks load base.js multiple times, which tries
        // to write deps.js each time. If that happens, just fail silently.
        // These frameworks wipe the page between each load of base.js, so this
        // is OK.
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw Error('Cannot write "' + src + '" after document load');
        }
      }

      doc.write(
          '<script type="text/javascript" src="' + src + '"></' + 'script>');
      return true;
    } else {
      return false;
    }
  };


  /**
   * Resolves dependencies based on the dependencies added using addDependency
   * and calls importScript_ in the correct order.
   * @private
   */
  goog.writeScripts_ = function() {
    // The scripts we need to write this time.
    var scripts = [];
    var seenScript = {};
    var deps = goog.dependencies_;

    function visitNode(path) {
      if (path in deps.written) {
        return;
      }

      // We have already visited this one. We can get here if we have cyclic
      // dependencies.
      if (path in deps.visited) {
        if (!(path in seenScript)) {
          seenScript[path] = true;
          scripts.push(path);
        }
        return;
      }

      deps.visited[path] = true;

      if (path in deps.requires) {
        for (var requireName in deps.requires[path]) {
          // If the required name is defined, we assume that it was already
          // bootstrapped by other means.
          if (!goog.isProvided_(requireName)) {
            if (requireName in deps.nameToPath) {
              visitNode(deps.nameToPath[requireName]);
            } else {
              throw Error('Undefined nameToPath for ' + requireName);
            }
          }
        }
      }

      if (!(path in seenScript)) {
        seenScript[path] = true;
        scripts.push(path);
      }
    }

    for (var path in goog.included_) {
      if (!deps.written[path]) {
        visitNode(path);
      }
    }

    for (var i = 0; i < scripts.length; i++) {
      if (scripts[i]) {
        goog.importScript_(goog.basePath + scripts[i]);
      } else {
        throw Error('Undefined script input');
      }
    }
  };


  /**
   * Looks at the dependency rules and tries to determine the script file that
   * fulfills a particular rule.
   * @param {string} rule In the form goog.namespace.Class or project.script.
   * @return {?string} Url corresponding to the rule, or null.
   * @private
   */
  goog.getPathFromDeps_ = function(rule) {
    if (rule in goog.dependencies_.nameToPath) {
      return goog.dependencies_.nameToPath[rule];
    } else {
      return null;
    }
  };

  goog.findBasePath_();

  // Allow projects to manage the deps files themselves.
  if (!goog.global.CLOSURE_NO_DEPS) {
    //goog.importScript_(goog.basePath + 'deps.js');
  }
}



//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {*} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function(value) {
  var s = typeof value;
  if (s == 'object') {
    if (value) {
      // Check these first, so we can avoid calling Object.prototype.toString if
      // possible.
      //
      // IE improperly marshals tyepof across execution contexts, but a
      // cross-context object will still return false for "instanceof Object".
      if (value instanceof Array) {
        return 'array';
      } else if (value instanceof Object) {
        return s;
      }

      // HACK: In order to use an Object prototype method on the arbitrary
      //   value, the compiler requires the value be cast to type Object,
      //   even though the ECMA spec explicitly allows it.
      var className = Object.prototype.toString.call(
          /** @type {Object} */ (value));
      // In Firefox 3.6, attempting to access iframe window objects' length
      // property throws an NS_ERROR_FAILURE, so we need to special-case it
      // here.
      if (className == '[object Window]') {
        return 'object';
      }

      // We cannot always use constructor == Array or instanceof Array because
      // different frames have different Array objects. In IE6, if the iframe
      // where the array was created is destroyed, the array loses its
      // prototype. Then dereferencing val.splice here throws an exception, so
      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
      // so that will work. In this case, this function will return false and
      // most array functions will still work because the array is still
      // array-like (supports length and []) even though it has lost its
      // prototype.
      // Mark Miller noticed that Object.prototype.toString
      // allows access to the unforgeable [[Class]] property.
      //  15.2.4.2 Object.prototype.toString ( )
      //  When the toString method is called, the following steps are taken:
      //      1. Get the [[Class]] property of this object.
      //      2. Compute a string value by concatenating the three strings
      //         "[object ", Result(1), and "]".
      //      3. Return Result(2).
      // and this behavior survives the destruction of the execution context.
      if ((className == '[object Array]' ||
           // In IE all non value types are wrapped as objects across window
           // boundaries (not iframe though) so we have to do object detection
           // for this edge case.
           typeof value.length == 'number' &&
           typeof value.splice != 'undefined' &&
           typeof value.propertyIsEnumerable != 'undefined' &&
           !value.propertyIsEnumerable('splice')

          )) {
        return 'array';
      }
      // HACK: There is still an array case that fails.
      //     function ArrayImpostor() {}
      //     ArrayImpostor.prototype = [];
      //     var impostor = new ArrayImpostor;
      // this can be fixed by getting rid of the fast path
      // (value instanceof Array) and solely relying on
      // (value && Object.prototype.toString.vall(value) === '[object Array]')
      // but that would require many more function calls and is not warranted
      // unless closure code is receiving objects from untrusted sources.

      // IE in cross-window calls does not correctly marshal the function type
      // (it appears just as an object) so we cannot use just typeof val ==
      // 'function'. However, if the object has a call property, it is a
      // function.
      if ((className == '[object Function]' ||
          typeof value.call != 'undefined' &&
          typeof value.propertyIsEnumerable != 'undefined' &&
          !value.propertyIsEnumerable('call'))) {
        return 'function';
      }

    } else {
      return 'null';
    }

  } else if (s == 'function' && typeof value.call == 'undefined') {
    // In Safari typeof nodeList returns 'function', and on Firefox typeof
    // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
    // would like to return object for those and we can detect an invalid
    // function by making sure that the function object has a call method.
    return 'object';
  }
  return s;
};


/**
 * Returns true if the specified value is not undefined.
 * WARNING: Do not use this to test if an object has a property. Use the in
 * operator instead.  Additionally, this function assumes that the global
 * undefined variable has not been redefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
goog.isDef = function(val) {
  return val !== undefined;
};


/**
 * Returns true if the specified value is null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is null.
 */
goog.isNull = function(val) {
  return val === null;
};


/**
 * Returns true if the specified value is defined and not null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */
goog.isDefAndNotNull = function(val) {
  // Note that undefined == null.
  return val != null;
};


/**
 * Returns true if the specified value is an array.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArray = function(val) {
  return goog.typeOf(val) == 'array';
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is a string.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */
goog.isString = function(val) {
  return typeof val == 'string';
};


/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
goog.isBoolean = function(val) {
  return typeof val == 'boolean';
};


/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
goog.isNumber = function(val) {
  return typeof val == 'number';
};


/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
goog.isFunction = function(val) {
  return goog.typeOf(val) == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function(val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
  // return Object(val) === val also works, but is slower, especially if val is
  // not an object.
};


/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. The unique ID is
 * guaranteed to be unique across the current session amongst objects that are
 * passed into {@code getUid}. There is no guarantee that the ID is unique or
 * consistent across sessions. It is unsafe to generate unique ID for function
 * prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In Opera window.hasOwnProperty exists but always returns false so we avoid
  // using it. As a consequence the unique ID generated for BaseClass.prototype
  // and SubClass.prototype will be the same.
  return obj[goog.UID_PROPERTY_] ||
      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Whether the given object is alreay assigned a unique ID.
 *
 * This does not modify the object.
 *
 * @param {Object} obj The object to check.
 * @return {boolean} Whether there an assigned unique id for the object.
 */
goog.hasUid = function(obj) {
  return !!obj[goog.UID_PROPERTY_];
};


/**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using {@code goog.getUid} in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */
goog.removeUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In IE, DOM nodes are not instances of Object and throw an exception if we
  // try to delete.  Instead we try to use removeAttribute.
  if ('removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }
  /** @preserveTry */
  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure JavaScript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Adds a hash code field to an object. The hash code is unique for the
 * given object.
 * @param {Object} obj The object to get the hash code for.
 * @return {number} The hash code for the object.
 * @deprecated Use goog.getUid instead.
 */
goog.getHashCode = goog.getUid;


/**
 * Removes the hash code field from an object.
 * @param {Object} obj The object to remove the field from.
 * @deprecated Use goog.removeUid instead.
 */
goog.removeHashCode = goog.removeUid;


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */
goog.cloneObject = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * A native implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 * @suppress {deprecated} The compiler thinks that Function.prototype.bind is
 *     deprecated because some people have declared a pure-JS version.
 *     Only the pure-JS version is truly deprecated.
 */
goog.bindNative_ = function(fn, selfObj, var_args) {
  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 */
goog.bindJs_ = function(fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }

  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      // Prepend the bound arguments to the current arguments.
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };

  } else {
    return function() {
      return fn.apply(selfObj, arguments);
    };
  }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of this 'pre-specified'.
 *
 * Remaining arguments specified at call-time are appended to the pre-specified
 * ones.
 *
 * Also see: {@link #partial}.
 *
 * Usage:
 * <pre>var barMethBound = bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @template T
 * @suppress {deprecated} See above.
 */
goog.bind = function(fn, selfObj, var_args) {
  // TODO(nicksantos): narrow the type signature.
  if (Function.prototype.bind &&
      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
      // extension environment. This means that for Chrome extensions, they get
      // the implementation of Function.prototype.bind that calls goog.bind
      // instead of the native one. Even worse, we don't want to introduce a
      // circular dependency between goog.bind and Function.prototype.bind, so
      // we have to hack this to make sure it works correctly.
      Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};


/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};


/**
 * Copies all the members of a source object to a target object. This method
 * does not work on all browsers for all objects that contain keys such as
 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
 * @param {Object} target Target.
 * @param {Object} source Source.
 */
goog.mixin = function(target, source) {
  for (var x in source) {
    target[x] = source[x];
  }

  // For IE7 or lower, the for-in-loop does not contain any properties that are
  // not enumerable on the prototype object (for example, isPrototypeOf from
  // Object.prototype) but also it will not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 */
goog.now = (goog.TRUSTED_SITE && Date.now) || (function() {
  // Unary plus operator converts its operand to a number which in the case of
  // a date is done by calling getTime().
  return +new Date();
});


/**
 * Evals JavaScript in the global scope.  In IE this uses execScript, other
 * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
 * global scope (for example, in Safari), appends a script tag instead.
 * Throws an exception if neither execScript or eval is defined.
 * @param {string} script JavaScript string.
 */
goog.globalEval = function(script) {
  if (goog.global.execScript) {
    goog.global.execScript(script, 'JavaScript');
  } else if (goog.global.eval) {
    // Test to see if eval works
    if (goog.evalWorksForGlobals_ == null) {
      goog.global.eval('var _et_ = 1;');
      if (typeof goog.global['_et_'] != 'undefined') {
        delete goog.global['_et_'];
        goog.evalWorksForGlobals_ = true;
      } else {
        goog.evalWorksForGlobals_ = false;
      }
    }

    if (goog.evalWorksForGlobals_) {
      goog.global.eval(script);
    } else {
      var doc = goog.global.document;
      var scriptElt = doc.createElement('script');
      scriptElt.type = 'text/javascript';
      scriptElt.defer = false;
      // Note(pupius): can't use .innerHTML since "t('<test>')" will fail and
      // .text doesn't work in Safari 2.  Therefore we append a text node.
      scriptElt.appendChild(doc.createTextNode(script));
      doc.body.appendChild(scriptElt);
      doc.body.removeChild(scriptElt);
    }
  } else {
    throw Error('goog.globalEval not available');
  }
};


/**
 * Indicates whether or not we can call 'eval' directly to eval code in the
 * global scope. Set to a Boolean by the first call to goog.globalEval (which
 * empirically tests whether eval works for globals). @see goog.globalEval
 * @type {?boolean}
 * @private
 */
goog.evalWorksForGlobals_ = null;


/**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @type {Object|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMapping_;


/**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMappingStyle_;


/**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a hyphen and
 * passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which these
 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
 * style, the full css name is looked up in the map directly. If a rewrite is
 * not specified by the map, the compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls to
 * goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x= 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed only the
 * modifier will be processed, as it is assumed the first argument was generated
 * as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */
goog.getCssName = function(className, opt_modifier) {
  var getMapping = function(cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };

  var renameByParts = function(cssName) {
    // Remap all the parts individually.
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };

  var rename;
  if (goog.cssNameMapping_) {
    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ?
        getMapping : renameByParts;
  } else {
    rename = function(a) {
      return a;
    };
  }

  if (opt_modifier) {
    return className + '-' + rename(opt_modifier);
  } else {
    return rename(className);
  }
};


/**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --closure_pass flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */
goog.setCssNameMapping = function(mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};


/**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {Object|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAPPING;


if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  // This does not call goog.setCssNameMapping() because the JSCompiler
  // requires that goog.setCssNameMapping() be called with an object literal.
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}


/**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object=} opt_values Map of place holder name to value.
 * @return {string} message with placeholders filled.
 */
goog.getMsg = function(str, opt_values) {
  var values = opt_values || {};
  for (var key in values) {
    var value = ('' + values[key]).replace(/\$/g, '$$$$');
    str = str.replace(new RegExp('\\{\\$' + key + '\\}', 'gi'), value);
  }
  return str;
};


/**
 * Gets a localized message. If the message does not have a translation, gives a
 * fallback message.
 *
 * This is useful when introducing a new message that has not yet been
 * translated into all languages.
 *
 * This function is a compiler primtive. Must be used in the form:
 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
 * where MSG_A and MSG_B were initialized with goog.getMsg.
 *
 * @param {string} a The preferred message.
 * @param {string} b The fallback message.
 * @return {string} The best translated message.
 */
goog.getMsgWithFallback = function(a, b) {
  return a;
};


/**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated, unless they are
 * exported in turn via this function or goog.exportProperty.
 *
 * Also handy for making public items that are defined in anonymous closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is goog.global.
 */
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
  goog.exportPath_(publicPath, object, opt_objectToExportTo);
};


/**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */
goog.exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { }
 *
 * function ChildClass(a, b, c) {
 *   goog.base(this, a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // This works.
 * </pre>
 *
 * In addition, a superclass' implementation of a method can be invoked as
 * follows:
 *
 * <pre>
 * ChildClass.prototype.foo = function(a) {
 *   ChildClass.superClass_.foo.call(this, a);
 *   // Other code here.
 * };
 * </pre>
 *
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 */
goog.inherits = function(childCtor, parentCtor) {
  /** @constructor */
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /** @override */
  childCtor.prototype.constructor = childCtor;

  /**
   * WARNING: DO NOT USE YET! JSCOMPILER SUPPORT HAS NOT BEEN IMPLEMENTED YET.
   *
   * Calls superclass constructor/method.
   *
   * This function is only available if you use goog.inherits to
   * express inheritance relationships between classes.
   *
   * NOTE: This is a replacement for goog.base and for superClass_
   * property defined in childCtor.
   *
   * @param {!Object} me Should always be "this".
   * @param {string} methodName The method name to call. Calling
   *     superclass constructor can be done with the special string
   *     'constructor'.
   * @param {...*} var_args The arguments to pass to superclass
   *     method/constructor.
   * @return {*} The return value of the superclass method/constructor.
   */
  childCtor.base = function(me, methodName, var_args) {
    var args = Array.prototype.slice.call(arguments, 2);
    return parentCtor.prototype[methodName].apply(me, args);
  };
};


/**
 * Call up to the superclass.
 *
 * If this is called from a constructor, then this calls the superclass
 * contsructor with arguments 1-N.
 *
 * If this is called from a prototype method, then you must pass the name of the
 * method as the second argument to this function. If you do not, you will get a
 * runtime error. This calls the superclass' method with arguments 2-N.
 *
 * This function only works if you use goog.inherits to express inheritance
 * relationships between your classes.
 *
 * This function is a compiler primitive. At compile-time, the compiler will do
 * macro expansion to remove a lot of the extra overhead that this function
 * introduces. The compiler will also enforce a lot of the assumptions that this
 * function makes, and treat it as a compiler error if you break them.
 *
 * @param {!Object} me Should always be "this".
 * @param {*=} opt_methodName The method name if calling a super method.
 * @param {...*} var_args The rest of the arguments.
 * @return {*} The return value of the superclass method.
 */
goog.base = function(me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;

  if (goog.DEBUG) {
    if (!caller) {
      throw Error('arguments.caller not defined.  goog.base() expects not ' +
                  'to be running in strict mode. See ' +
                  'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
    }
  }

  if (caller.superClass_) {
    // This is a constructor. Call the superclass constructor.
    return caller.superClass_.constructor.apply(
        me, Array.prototype.slice.call(arguments, 1));
  }

  var args = Array.prototype.slice.call(arguments, 2);
  var foundCaller = false;
  for (var ctor = me.constructor;
       ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = true;
    } else if (foundCaller) {
      return ctor.prototype[opt_methodName].apply(me, args);
    }
  }

  // If we did not find the caller in the prototype chain, then one of two
  // things happened:
  // 1) The caller is an instance method.
  // 2) This method was not called by the right caller.
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw Error(
        'goog.base called from a method of one name ' +
        'to a method of a different name');
  }
};


/**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the aliases
 * applied.  In uncompiled code the function is simply run since the aliases as
 * written are valid JavaScript.
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *     (e.g. "var Timer = goog.Timer").
 */
goog.scope = function(fn) {
  fn.call(goog.global);
};


// MOE:begin_strip

// The section between this token and the end token below will be stripped
// automatically by the open source release scripts.  Please leave in place.

//==============================================================================
// Extending Function
//==============================================================================


/**
 * @define {boolean} Whether to extend Function.prototype.
 *     Use --define='goog.MODIFY_FUNCTION_PROTOTYPES=false' to change.
 */
goog.define('goog.MODIFY_FUNCTION_PROTOTYPES', true);

if (goog.MODIFY_FUNCTION_PROTOTYPES) {
  /**
   * An alias to the {@link goog.bind()} global function. Deprecated: use
   * goog.bind instead.
   *
   * Usage:
   * var g = f.bind(obj, arg1, arg2);
   * g(arg3, arg4);
   *
   * @param {Object|undefined} selfObj Specifies the object to which this should
   *     point when the function is run. If the value is null or undefined, it
   *     will default to the global object.
   * @param {...*} var_args Additional arguments that are partially applied to
   *     fn.
   * @return {!Function} A partially-applied form of the Function on which
   *     bind() was invoked as a method.
   * @suppress {duplicate}
   */
  Function.prototype.bind =
      Function.prototype.bind || function(selfObj, var_args) {
    if (arguments.length > 1) {
      var args = Array.prototype.slice.call(arguments, 1);
      args.unshift(this, selfObj);
      return goog.bind.apply(null, args);
    } else {
      return goog.bind(this, selfObj);
    }
  };


  /**
   * An alias to the {@link goog.partial()} static function.
   *
   * Usage:
   * var g = f.partial(arg1, arg2);
   * g(arg3, arg4);
   *
   * @param {...*} var_args Additional arguments that are partially applied to
   *     fn.
   * @return {!Function} A partially-applied form of the function partial() was
   *     invoked as a method of.
   * @deprecated Use the static function goog.partial instead.
   */
  Function.prototype.partial = function(var_args) {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(this, null);
    return goog.bind.apply(null, args);
  };


  /**
   * Inherit the prototype methods from one constructor into another.
   * @param {Function} parentCtor Parent class.
   * @see goog.inherits
   * @deprecated Use the static function goog.inherits instead.
   */
  Function.prototype.inherits = function(parentCtor) {
    goog.inherits(this, parentCtor);
  };


  /**
   * Mixes in an object's properties and methods into the callee's prototype.
   * Basically mixin based inheritance, thus providing an alternative method for
   * adding properties and methods to a class' prototype.
   *
   * <pre>
   * function X() {}
   * X.mixin({
   *   one: 1,
   *   two: 2,
   *   three: 3,
   *   doit: function() { return this.one + this.two + this.three; }
   * });
   *
   * function Y() {}
   * Y.mixin(X.prototype);
   * Y.prototype.four = 15;
   * Y.prototype.doit2 = function() { return this.doit() + this.four; }
   *
   * // or
   *
   * function Y() {}
   * Y.inherits(X);
   * Y.mixin({
   *   one: 10,
   *   four: 15,
   *   doit2: function() { return this.doit() + this.four; }
   * });
   * </pre>
   *
   * @param {Object} source from which to copy properties.
   * @see goog.mixin
   * @deprecated Use the static function goog.object.extend instead.
   */
  Function.prototype.mixin = function(source) {
    goog.mixin(this.prototype, source);
  };
}

// MOE:end_strip

//javascript/closure/deps.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file has been auto-generated by GenJsDeps, please do not edit.

goog.addDependency('../../third_party/javascript/closure/caja/string/html/htmlparser.js', ['goog.string.html.HtmlParser', 'goog.string.html.HtmlParser.EFlags', 'goog.string.html.HtmlParser.Elements', 'goog.string.html.HtmlParser.Entities', 'goog.string.html.HtmlSaxHandler'], []);
goog.addDependency('../../third_party/javascript/closure/caja/string/html/htmlsanitizer.js', ['goog.string.html.HtmlSanitizer', 'goog.string.html.HtmlSanitizer.AttributeType', 'goog.string.html.HtmlSanitizer.Attributes', 'goog.string.html.htmlSanitize'], ['goog.string.StringBuffer', 'goog.string.html.HtmlParser', 'goog.string.html.HtmlParser.EFlags', 'goog.string.html.HtmlParser.Elements', 'goog.string.html.HtmlSaxHandler']);
goog.addDependency('../../third_party/javascript/closure/dojo/dom/query.js', ['goog.dom.query'], ['goog.array', 'goog.dom', 'goog.functions', 'goog.string', 'goog.userAgent']);
goog.addDependency('../../third_party/javascript/closure/jpeg_encoder/jpeg_encoder_basic.js', ['goog.crypt.JpegEncoder'], ['goog.crypt.base64']);
goog.addDependency('../../third_party/javascript/closure/loremipsum/text/loremipsum.js', ['goog.text.LoremIpsum'], ['goog.array', 'goog.math', 'goog.string', 'goog.structs.Map', 'goog.structs.Set']);
goog.addDependency('../../third_party/javascript/closure/mochikit/async/deferred.js', ['goog.async.Deferred', 'goog.async.Deferred.AlreadyCalledError', 'goog.async.Deferred.CanceledError'], ['goog.array', 'goog.asserts', 'goog.debug.Error', 'goog.labs.Promise', 'goog.labs.Thenable']);
goog.addDependency('../../third_party/javascript/closure/mochikit/async/deferredlist.js', ['goog.async.DeferredList'], ['goog.async.Deferred']);
goog.addDependency('../../third_party/javascript/closure/osapi/osapi.js', ['goog.osapi'], []);
goog.addDependency('../../third_party/javascript/closure/svgpan/svgpan.js', ['svgpan.SvgPan'], ['goog.Disposable', 'goog.events', 'goog.events.EventType', 'goog.events.MouseWheelHandler']);
goog.addDependency('a11y/aria/announcer.js', ['goog.a11y.aria.Announcer'], ['goog.Disposable', 'goog.a11y.aria', 'goog.a11y.aria.LivePriority', 'goog.a11y.aria.State', 'goog.dom', 'goog.object']);
goog.addDependency('a11y/aria/aria.js', ['goog.a11y.aria'], ['goog.a11y.aria.Role', 'goog.a11y.aria.State', 'goog.a11y.aria.datatables', 'goog.array', 'goog.asserts', 'goog.dom', 'goog.dom.TagName', 'goog.object']);
goog.addDependency('a11y/aria/attributes.js', ['goog.a11y.aria.AutoCompleteValues', 'goog.a11y.aria.CheckedValues', 'goog.a11y.aria.DropEffectValues', 'goog.a11y.aria.ExpandedValues', 'goog.a11y.aria.GrabbedValues', 'goog.a11y.aria.InvalidValues', 'goog.a11y.aria.LivePriority', 'goog.a11y.aria.OrientationValues', 'goog.a11y.aria.PressedValues', 'goog.a11y.aria.RelevantValues', 'goog.a11y.aria.SelectedValues', 'goog.a11y.aria.SortValues', 'goog.a11y.aria.State'], []);
goog.addDependency('a11y/aria/datatables.js', ['goog.a11y.aria.datatables'], ['goog.a11y.aria.State', 'goog.object']);
goog.addDependency('a11y/aria/roles.js', ['goog.a11y.aria.Role'], []);
goog.addDependency('array/array.js', ['goog.array', 'goog.array.ArrayLike'], ['goog.asserts']);
goog.addDependency('asserts/asserts.js', ['goog.asserts', 'goog.asserts.AssertionError'], ['goog.debug.Error', 'goog.dom.NodeType', 'goog.string']);
goog.addDependency('async/animationdelay.js', ['goog.async.AnimationDelay'], ['goog.Disposable', 'goog.events', 'goog.functions']);
goog.addDependency('async/conditionaldelay.js', ['goog.async.ConditionalDelay'], ['goog.Disposable', 'goog.async.Delay']);
goog.addDependency('async/delay.js', ['goog.Delay', 'goog.async.Delay'], ['goog.Disposable', 'goog.Timer']);
goog.addDependency('async/nexttick.js', ['goog.async.nextTick'], ['goog.debug.entryPointRegistry', 'goog.functions']);
goog.addDependency('async/run.js', ['goog.async.run', 'goog.async.throwException'], ['goog.async.nextTick', 'goog.testing.watchers']);
goog.addDependency('async/run_test.js', ['goog.async.runTest'], ['goog.async.run', 'goog.testing.MockClock', 'goog.testing.jsunit', 'goog.testing.recordFunction']);
goog.addDependency('async/throttle.js', ['goog.Throttle', 'goog.async.Throttle'], ['goog.Disposable', 'goog.Timer']);
goog.addDependency('base.js', ['goog'], []);
goog.addDependency('base_test.js', ['an.existing.path', 'dup.base', 'far.out', 'goog.baseTest', 'goog.explicit', 'goog.implicit.explicit', 'goog.test', 'goog.test.name', 'goog.test.name.space', 'goog.xy', 'goog.xy.z', 'ns', 'testDep.bar'], ['goog.Timer', 'goog.functions', 'goog.testing.PropertyReplacer', 'goog.testing.jsunit', 'goog.testing.recordFunction', 'goog.userAgent']);
goog.addDependency('color/alpha.js', ['goog.color.alpha'], ['goog.color']);
goog.addDependency('color/color.js', ['goog.color'], ['goog.color.names', 'goog.math']);
goog.addDependency('color/names.js', ['goog.color.names'], []);
goog.addDependency('crypt/aes.js', ['goog.crypt.Aes'], ['goog.asserts', 'goog.crypt.BlockCipher']);
goog.addDependency('crypt/arc4.js', ['goog.crypt.Arc4'], ['goog.asserts']);
goog.addDependency('crypt/base64.js', ['goog.crypt.base64'], ['goog.crypt', 'goog.userAgent']);
goog.addDependency('crypt/basen.js', ['goog.crypt.baseN'], []);
goog.addDependency('crypt/blobhasher.js', ['goog.crypt.BlobHasher', 'goog.crypt.BlobHasher.EventType'], ['goog.asserts', 'goog.crypt', 'goog.crypt.Hash', 'goog.events.EventTarget', 'goog.fs', 'goog.log']);
goog.addDependency('crypt/blockcipher.js', ['goog.crypt.BlockCipher'], []);
goog.addDependency('crypt/cbc.js', ['goog.crypt.Cbc'], ['goog.array', 'goog.crypt']);
goog.addDependency('crypt/cbc_test.js', ['goog.crypt.CbcTest'], ['goog.crypt', 'goog.crypt.Aes', 'goog.crypt.Cbc', 'goog.testing.jsunit']);
goog.addDependency('crypt/crypt.js', ['goog.crypt'], ['goog.array']);
goog.addDependency('crypt/hash.js', ['goog.crypt.Hash'], []);
goog.addDependency('crypt/hash32.js', ['goog.crypt.hash32'], ['goog.crypt']);
goog.addDependency('crypt/hashtester.js', ['goog.crypt.hashTester'], ['goog.array', 'goog.crypt', 'goog.testing.PerformanceTable', 'goog.testing.PseudoRandom', 'goog.testing.asserts']);
goog.addDependency('crypt/hmac.js', ['goog.crypt.Hmac'], ['goog.asserts', 'goog.crypt.Hash']);
goog.addDependency('crypt/md5.js', ['goog.crypt.Md5'], ['goog.crypt.Hash']);
goog.addDependency('crypt/pbkdf2.js', ['goog.crypt.pbkdf2'], ['goog.asserts', 'goog.crypt', 'goog.crypt.Hmac', 'goog.crypt.Sha1']);
goog.addDependency('crypt/sha1.js', ['goog.crypt.Sha1'], ['goog.crypt.Hash']);
goog.addDependency('crypt/sha2.js', ['goog.crypt.Sha2'], ['goog.array', 'goog.asserts', 'goog.crypt.Hash']);
goog.addDependency('crypt/sha224.js', ['goog.crypt.Sha224'], ['goog.crypt.Sha2']);
goog.addDependency('crypt/sha256.js', ['goog.crypt.Sha256'], ['goog.crypt.Sha2']);
goog.addDependency('cssom/cssom.js', ['goog.cssom', 'goog.cssom.CssRuleType'], ['goog.array', 'goog.dom']);
goog.addDependency('cssom/iframe/style.js', ['goog.cssom.iframe.style'], ['goog.cssom', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.TagName', 'goog.dom.classes', 'goog.string', 'goog.style', 'goog.userAgent']);
goog.addDependency('datasource/datamanager.js', ['goog.ds.DataManager'], ['goog.ds.BasicNodeList', 'goog.ds.DataNode', 'goog.ds.Expr', 'goog.string', 'goog.structs', 'goog.structs.Map']);
goog.addDependency('datasource/datasource.js', ['goog.ds.BaseDataNode', 'goog.ds.BasicNodeList', 'goog.ds.DataNode', 'goog.ds.DataNodeList', 'goog.ds.EmptyNodeList', 'goog.ds.LoadState', 'goog.ds.SortedNodeList', 'goog.ds.Util', 'goog.ds.logger'], ['goog.array', 'goog.log']);
goog.addDependency('datasource/expr.js', ['goog.ds.Expr'], ['goog.ds.BasicNodeList', 'goog.ds.EmptyNodeList', 'goog.string']);
goog.addDependency('datasource/fastdatanode.js', ['goog.ds.AbstractFastDataNode', 'goog.ds.FastDataNode', 'goog.ds.FastListNode', 'goog.ds.PrimitiveFastDataNode'], ['goog.ds.DataManager', 'goog.ds.EmptyNodeList', 'goog.string']);
goog.addDependency('datasource/jsdatasource.js', ['goog.ds.JsDataSource', 'goog.ds.JsPropertyDataSource'], ['goog.ds.BaseDataNode', 'goog.ds.BasicNodeList', 'goog.ds.DataManager', 'goog.ds.EmptyNodeList', 'goog.ds.LoadState']);
goog.addDependency('datasource/jsondatasource.js', ['goog.ds.JsonDataSource'], ['goog.Uri', 'goog.dom', 'goog.ds.DataManager', 'goog.ds.JsDataSource', 'goog.ds.LoadState', 'goog.ds.logger']);
goog.addDependency('datasource/jsxmlhttpdatasource.js', ['goog.ds.JsXmlHttpDataSource'], ['goog.Uri', 'goog.ds.DataManager', 'goog.ds.FastDataNode', 'goog.ds.LoadState', 'goog.ds.logger', 'goog.events', 'goog.log', 'goog.net.EventType', 'goog.net.XhrIo']);
goog.addDependency('datasource/xmldatasource.js', ['goog.ds.XmlDataSource', 'goog.ds.XmlHttpDataSource'], ['goog.Uri', 'goog.dom.NodeType', 'goog.dom.xml', 'goog.ds.BasicNodeList', 'goog.ds.DataManager', 'goog.ds.LoadState', 'goog.ds.logger', 'goog.net.XhrIo', 'goog.string']);
goog.addDependency('date/date.js', ['goog.date', 'goog.date.Date', 'goog.date.DateTime', 'goog.date.Interval', 'goog.date.month', 'goog.date.weekDay'], ['goog.asserts', 'goog.date.DateLike', 'goog.i18n.DateTimeSymbols', 'goog.string']);
goog.addDependency('date/datelike.js', ['goog.date.DateLike'], []);
goog.addDependency('date/daterange.js', ['goog.date.DateRange', 'goog.date.DateRange.Iterator', 'goog.date.DateRange.StandardDateRangeKeys'], ['goog.date.Date', 'goog.date.Interval', 'goog.iter.Iterator', 'goog.iter.StopIteration']);
goog.addDependency('date/duration.js', ['goog.date.duration'], ['goog.i18n.DateTimeFormat', 'goog.i18n.MessageFormat']);
goog.addDependency('date/relative.js', ['goog.date.relative'], ['goog.i18n.DateTimeFormat']);
goog.addDependency('date/utcdatetime.js', ['goog.date.UtcDateTime'], ['goog.date', 'goog.date.Date', 'goog.date.DateTime', 'goog.date.Interval']);
goog.addDependency('db/cursor.js', ['goog.db.Cursor'], ['goog.async.Deferred', 'goog.db.Error', 'goog.debug', 'goog.events.EventTarget']);
goog.addDependency('db/db.js', ['goog.db'], ['goog.async.Deferred', 'goog.db.Error', 'goog.db.IndexedDb', 'goog.db.Transaction']);
goog.addDependency('db/error.js', ['goog.db.Error', 'goog.db.Error.ErrorCode', 'goog.db.Error.ErrorName', 'goog.db.Error.VersionChangeBlockedError'], ['goog.debug.Error']);
goog.addDependency('db/index.js', ['goog.db.Index'], ['goog.async.Deferred', 'goog.db.Cursor', 'goog.db.Error', 'goog.debug']);
goog.addDependency('db/indexeddb.js', ['goog.db.IndexedDb'], ['goog.async.Deferred', 'goog.db.Error', 'goog.db.Error.VersionChangeBlockedError', 'goog.db.ObjectStore', 'goog.db.Transaction', 'goog.db.Transaction.TransactionMode', 'goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventTarget']);
goog.addDependency('db/keyrange.js', ['goog.db.KeyRange'], []);
goog.addDependency('db/objectstore.js', ['goog.db.ObjectStore'], ['goog.async.Deferred', 'goog.db.Cursor', 'goog.db.Error', 'goog.db.Index', 'goog.debug', 'goog.events']);
goog.addDependency('db/transaction.js', ['goog.db.Transaction', 'goog.db.Transaction.TransactionMode'], ['goog.async.Deferred', 'goog.db.Error', 'goog.db.ObjectStore', 'goog.events.EventHandler', 'goog.events.EventTarget']);
goog.addDependency('debug/console.js', ['goog.debug.Console'], ['goog.debug.LogManager', 'goog.debug.Logger.Level', 'goog.debug.TextFormatter']);
goog.addDependency('debug/debug.js', ['goog.debug'], ['goog.array', 'goog.string', 'goog.structs.Set', 'goog.userAgent']);
goog.addDependency('debug/debugwindow.js', ['goog.debug.DebugWindow'], ['goog.debug.HtmlFormatter', 'goog.debug.LogManager', 'goog.debug.Logger', 'goog.structs.CircularBuffer', 'goog.userAgent']);
goog.addDependency('debug/devcss/devcss.js', ['goog.debug.DevCss', 'goog.debug.DevCss.UserAgent'], ['goog.cssom', 'goog.dom.classes', 'goog.events', 'goog.events.EventType', 'goog.string', 'goog.userAgent']);
goog.addDependency('debug/devcss/devcssrunner.js', ['goog.debug.devCssRunner'], ['goog.debug.DevCss']);
goog.addDependency('debug/divconsole.js', ['goog.debug.DivConsole'], ['goog.debug.HtmlFormatter', 'goog.debug.LogManager', 'goog.style']);
goog.addDependency('debug/entrypointregistry.js', ['goog.debug.EntryPointMonitor', 'goog.debug.entryPointRegistry'], ['goog.asserts']);
goog.addDependency('debug/error.js', ['goog.debug.Error'], []);
goog.addDependency('debug/errorhandler.js', ['goog.debug.ErrorHandler', 'goog.debug.ErrorHandler.ProtectedFunctionError'], ['goog.asserts', 'goog.debug', 'goog.debug.EntryPointMonitor', 'goog.debug.Trace']);
goog.addDependency('debug/errorhandlerweakdep.js', ['goog.debug.errorHandlerWeakDep'], []);
goog.addDependency('debug/errorreporter.js', ['goog.debug.ErrorReporter', 'goog.debug.ErrorReporter.ExceptionEvent'], ['goog.asserts', 'goog.debug', 'goog.debug.ErrorHandler', 'goog.debug.entryPointRegistry', 'goog.events', 'goog.events.Event', 'goog.events.EventTarget', 'goog.log', 'goog.net.XhrIo', 'goog.object', 'goog.string', 'goog.uri.utils', 'goog.userAgent']);
goog.addDependency('debug/fancywindow.js', ['goog.debug.FancyWindow'], ['goog.debug.DebugWindow', 'goog.debug.LogManager', 'goog.debug.Logger', 'goog.dom.DomHelper', 'goog.object', 'goog.string', 'goog.userAgent']);
goog.addDependency('debug/formatter.js', ['goog.debug.Formatter', 'goog.debug.HtmlFormatter', 'goog.debug.TextFormatter'], ['goog.debug.RelativeTimeProvider', 'goog.string']);
goog.addDependency('debug/fpsdisplay.js', ['goog.debug.FpsDisplay'], ['goog.asserts', 'goog.async.AnimationDelay', 'goog.ui.Component']);
goog.addDependency('debug/gcdiagnostics.js', ['goog.debug.GcDiagnostics'], ['goog.debug.Trace', 'goog.log', 'goog.userAgent']);
goog.addDependency('debug/logbuffer.js', ['goog.debug.LogBuffer'], ['goog.asserts', 'goog.debug.LogRecord']);
goog.addDependency('debug/logger.js', ['goog.debug.LogManager', 'goog.debug.Loggable', 'goog.debug.Logger', 'goog.debug.Logger.Level'], ['goog.array', 'goog.asserts', 'goog.debug', 'goog.debug.LogBuffer', 'goog.debug.LogRecord']);
goog.addDependency('debug/logrecord.js', ['goog.debug.LogRecord'], []);
goog.addDependency('debug/logrecordserializer.js', ['goog.debug.logRecordSerializer'], ['goog.debug.LogRecord', 'goog.debug.Logger.Level', 'goog.json', 'goog.object']);
goog.addDependency('debug/reflect.js', ['goog.debug.reflect'], []);
goog.addDependency('debug/relativetimeprovider.js', ['goog.debug.RelativeTimeProvider'], []);
goog.addDependency('debug/tracer.js', ['goog.debug.Trace'], ['goog.array', 'goog.iter', 'goog.log', 'goog.structs.Map', 'goog.structs.SimplePool']);
goog.addDependency('disposable/disposable.js', ['goog.Disposable', 'goog.dispose', 'goog.disposeAll'], ['goog.disposable.IDisposable']);
goog.addDependency('disposable/idisposable.js', ['goog.disposable.IDisposable'], []);
goog.addDependency('dom/abstractmultirange.js', ['goog.dom.AbstractMultiRange'], ['goog.array', 'goog.dom', 'goog.dom.AbstractRange']);
goog.addDependency('dom/abstractrange.js', ['goog.dom.AbstractRange', 'goog.dom.RangeIterator', 'goog.dom.RangeType'], ['goog.dom', 'goog.dom.NodeType', 'goog.dom.SavedCaretRange', 'goog.dom.TagIterator', 'goog.userAgent']);
goog.addDependency('dom/annotate.js', ['goog.dom.annotate'], ['goog.array', 'goog.dom', 'goog.dom.NodeType', 'goog.string']);
goog.addDependency('dom/browserfeature.js', ['goog.dom.BrowserFeature'], ['goog.userAgent']);
goog.addDependency('dom/browserrange/abstractrange.js', ['goog.dom.browserrange.AbstractRange'], ['goog.array', 'goog.asserts', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.RangeEndpoint', 'goog.dom.TagName', 'goog.dom.TextRangeIterator', 'goog.iter', 'goog.math.Coordinate', 'goog.string', 'goog.string.StringBuffer', 'goog.userAgent']);
goog.addDependency('dom/browserrange/browserrange.js', ['goog.dom.browserrange', 'goog.dom.browserrange.Error'], ['goog.dom', 'goog.dom.NodeType', 'goog.dom.browserrange.GeckoRange', 'goog.dom.browserrange.IeRange', 'goog.dom.browserrange.OperaRange', 'goog.dom.browserrange.W3cRange', 'goog.dom.browserrange.WebKitRange', 'goog.userAgent']);
goog.addDependency('dom/browserrange/geckorange.js', ['goog.dom.browserrange.GeckoRange'], ['goog.dom.browserrange.W3cRange']);
goog.addDependency('dom/browserrange/ierange.js', ['goog.dom.browserrange.IeRange'], ['goog.array', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.RangeEndpoint', 'goog.dom.TagName', 'goog.dom.browserrange.AbstractRange', 'goog.log', 'goog.string']);
goog.addDependency('dom/browserrange/operarange.js', ['goog.dom.browserrange.OperaRange'], ['goog.dom.browserrange.W3cRange']);
goog.addDependency('dom/browserrange/w3crange.js', ['goog.dom.browserrange.W3cRange'], ['goog.dom', 'goog.dom.NodeType', 'goog.dom.RangeEndpoint', 'goog.dom.browserrange.AbstractRange', 'goog.string']);
goog.addDependency('dom/browserrange/webkitrange.js', ['goog.dom.browserrange.WebKitRange'], ['goog.dom.RangeEndpoint', 'goog.dom.browserrange.W3cRange', 'goog.userAgent']);
goog.addDependency('dom/bufferedviewportsizemonitor.js', ['goog.dom.BufferedViewportSizeMonitor'], ['goog.asserts', 'goog.async.Delay', 'goog.events', 'goog.events.EventTarget', 'goog.events.EventType']);
goog.addDependency('dom/bufferedviewportsizemonitor_test.js', ['goog.dom.BufferedViewportSizeMonitorTest'], ['goog.dom.BufferedViewportSizeMonitor', 'goog.dom.ViewportSizeMonitor', 'goog.events', 'goog.events.EventType', 'goog.math.Size', 'goog.testing.MockClock', 'goog.testing.events', 'goog.testing.events.Event', 'goog.testing.jsunit']);
goog.addDependency('dom/classes.js', ['goog.dom.classes'], ['goog.array']);
goog.addDependency('dom/classes_test.js', ['goog.dom.classes_test'], ['goog.dom', 'goog.dom.classes', 'goog.testing.jsunit']);
goog.addDependency('dom/classlist.js', ['goog.dom.classlist'], ['goog.array', 'goog.asserts']);
goog.addDependency('dom/classlist_test.js', ['goog.dom.classlist_test'], ['goog.dom', 'goog.dom.classlist', 'goog.testing.jsunit']);
goog.addDependency('dom/controlrange.js', ['goog.dom.ControlRange', 'goog.dom.ControlRangeIterator'], ['goog.array', 'goog.dom', 'goog.dom.AbstractMultiRange', 'goog.dom.AbstractRange', 'goog.dom.RangeIterator', 'goog.dom.RangeType', 'goog.dom.SavedRange', 'goog.dom.TagWalkType', 'goog.dom.TextRange', 'goog.iter.StopIteration', 'goog.userAgent']);
goog.addDependency('dom/dataset.js', ['goog.dom.dataset'], ['goog.string']);
goog.addDependency('dom/dom.js', ['goog.dom', 'goog.dom.Appendable', 'goog.dom.DomHelper'], ['goog.array', 'goog.asserts', 'goog.dom.BrowserFeature', 'goog.dom.NodeType', 'goog.dom.TagName', 'goog.dom.classes', 'goog.functions', 'goog.math.Coordinate', 'goog.math.Size', 'goog.object', 'goog.string', 'goog.userAgent']);
goog.addDependency('dom/dom_test.js', ['goog.dom.dom_test'], ['goog.dom', 'goog.dom.BrowserFeature', 'goog.dom.DomHelper', 'goog.dom.NodeType', 'goog.dom.TagName', 'goog.functions', 'goog.object', 'goog.string.Unicode', 'goog.testing.PropertyReplacer', 'goog.testing.asserts', 'goog.userAgent', 'goog.userAgent.product', 'goog.userAgent.product.isVersion']);
goog.addDependency('dom/fontsizemonitor.js', ['goog.dom.FontSizeMonitor', 'goog.dom.FontSizeMonitor.EventType'], ['goog.dom', 'goog.events', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.userAgent']);
goog.addDependency('dom/forms.js', ['goog.dom.forms'], ['goog.structs.Map']);
goog.addDependency('dom/fullscreen.js', ['goog.dom.fullscreen', 'goog.dom.fullscreen.EventType'], ['goog.dom', 'goog.userAgent']);
goog.addDependency('dom/iframe.js', ['goog.dom.iframe'], ['goog.dom', 'goog.userAgent']);
goog.addDependency('dom/iter.js', ['goog.dom.iter.AncestorIterator', 'goog.dom.iter.ChildIterator', 'goog.dom.iter.SiblingIterator'], ['goog.iter.Iterator', 'goog.iter.StopIteration']);
goog.addDependency('dom/multirange.js', ['goog.dom.MultiRange', 'goog.dom.MultiRangeIterator'], ['goog.array', 'goog.dom.AbstractMultiRange', 'goog.dom.AbstractRange', 'goog.dom.RangeIterator', 'goog.dom.RangeType', 'goog.dom.SavedRange', 'goog.dom.TextRange', 'goog.iter.StopIteration', 'goog.log']);
goog.addDependency('dom/nodeiterator.js', ['goog.dom.NodeIterator'], ['goog.dom.TagIterator']);
goog.addDependency('dom/nodeoffset.js', ['goog.dom.NodeOffset'], ['goog.Disposable', 'goog.dom.TagName']);
goog.addDependency('dom/nodetype.js', ['goog.dom.NodeType'], []);
goog.addDependency('dom/pattern/abstractpattern.js', ['goog.dom.pattern.AbstractPattern'], ['goog.dom.pattern.MatchType']);
goog.addDependency('dom/pattern/allchildren.js', ['goog.dom.pattern.AllChildren'], ['goog.dom.pattern.AbstractPattern', 'goog.dom.pattern.MatchType']);
goog.addDependency('dom/pattern/callback/callback.js', ['goog.dom.pattern.callback'], ['goog.dom', 'goog.dom.TagWalkType', 'goog.iter']);
goog.addDependency('dom/pattern/callback/counter.js', ['goog.dom.pattern.callback.Counter'], []);
goog.addDependency('dom/pattern/callback/test.js', ['goog.dom.pattern.callback.Test'], ['goog.iter.StopIteration']);
goog.addDependency('dom/pattern/childmatches.js', ['goog.dom.pattern.ChildMatches'], ['goog.dom.pattern.AllChildren', 'goog.dom.pattern.MatchType']);
goog.addDependency('dom/pattern/endtag.js', ['goog.dom.pattern.EndTag'], ['goog.dom.TagWalkType', 'goog.dom.pattern.Tag']);
goog.addDependency('dom/pattern/fulltag.js', ['goog.dom.pattern.FullTag'], ['goog.dom.pattern.MatchType', 'goog.dom.pattern.StartTag', 'goog.dom.pattern.Tag']);
goog.addDependency('dom/pattern/matcher.js', ['goog.dom.pattern.Matcher'], ['goog.dom.TagIterator', 'goog.dom.pattern.MatchType', 'goog.iter']);
goog.addDependency('dom/pattern/nodetype.js', ['goog.dom.pattern.NodeType'], ['goog.dom.pattern.AbstractPattern', 'goog.dom.pattern.MatchType']);
goog.addDependency('dom/pattern/pattern.js', ['goog.dom.pattern', 'goog.dom.pattern.MatchType'], []);
goog.addDependency('dom/pattern/repeat.js', ['goog.dom.pattern.Repeat'], ['goog.dom.NodeType', 'goog.dom.pattern.AbstractPattern', 'goog.dom.pattern.MatchType']);
goog.addDependency('dom/pattern/sequence.js', ['goog.dom.pattern.Sequence'], ['goog.dom.NodeType', 'goog.dom.pattern.AbstractPattern', 'goog.dom.pattern.MatchType']);
goog.addDependency('dom/pattern/starttag.js', ['goog.dom.pattern.StartTag'], ['goog.dom.TagWalkType', 'goog.dom.pattern.Tag']);
goog.addDependency('dom/pattern/tag.js', ['goog.dom.pattern.Tag'], ['goog.dom.pattern', 'goog.dom.pattern.AbstractPattern', 'goog.dom.pattern.MatchType', 'goog.object']);
goog.addDependency('dom/pattern/text.js', ['goog.dom.pattern.Text'], ['goog.dom.NodeType', 'goog.dom.pattern', 'goog.dom.pattern.AbstractPattern', 'goog.dom.pattern.MatchType']);
goog.addDependency('dom/range.js', ['goog.dom.Range'], ['goog.dom', 'goog.dom.AbstractRange', 'goog.dom.ControlRange', 'goog.dom.MultiRange', 'goog.dom.NodeType', 'goog.dom.TextRange', 'goog.userAgent']);
goog.addDependency('dom/rangeendpoint.js', ['goog.dom.RangeEndpoint'], []);
goog.addDependency('dom/safe.js', ['goog.dom.safe'], ['goog.html.SafeHtml']);
goog.addDependency('dom/savedcaretrange.js', ['goog.dom.SavedCaretRange'], ['goog.array', 'goog.dom', 'goog.dom.SavedRange', 'goog.dom.TagName', 'goog.string']);
goog.addDependency('dom/savedrange.js', ['goog.dom.SavedRange'], ['goog.Disposable', 'goog.log']);
goog.addDependency('dom/selection.js', ['goog.dom.selection'], ['goog.string', 'goog.userAgent']);
goog.addDependency('dom/tagiterator.js', ['goog.dom.TagIterator', 'goog.dom.TagWalkType'], ['goog.dom.NodeType', 'goog.iter.Iterator', 'goog.iter.StopIteration']);
goog.addDependency('dom/tagname.js', ['goog.dom.TagName'], []);
goog.addDependency('dom/textrange.js', ['goog.dom.TextRange'], ['goog.array', 'goog.dom', 'goog.dom.AbstractRange', 'goog.dom.RangeType', 'goog.dom.SavedRange', 'goog.dom.TagName', 'goog.dom.TextRangeIterator', 'goog.dom.browserrange', 'goog.string', 'goog.userAgent']);
goog.addDependency('dom/textrangeiterator.js', ['goog.dom.TextRangeIterator'], ['goog.array', 'goog.dom.NodeType', 'goog.dom.RangeIterator', 'goog.dom.TagName', 'goog.iter.StopIteration']);
goog.addDependency('dom/vendor.js', ['goog.dom.vendor'], ['goog.string', 'goog.userAgent']);
goog.addDependency('dom/viewportsizemonitor.js', ['goog.dom.ViewportSizeMonitor'], ['goog.dom', 'goog.events', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.math.Size']);
goog.addDependency('dom/xml.js', ['goog.dom.xml'], ['goog.dom', 'goog.dom.NodeType']);
goog.addDependency('editor/browserfeature.js', ['goog.editor.BrowserFeature'], ['goog.editor.defines', 'goog.userAgent', 'goog.userAgent.product', 'goog.userAgent.product.isVersion']);
goog.addDependency('editor/clicktoeditwrapper.js', ['goog.editor.ClickToEditWrapper'], ['goog.Disposable', 'goog.asserts', 'goog.dom', 'goog.dom.Range', 'goog.dom.TagName', 'goog.editor.BrowserFeature', 'goog.editor.Command', 'goog.editor.Field.EventType', 'goog.editor.range', 'goog.events.BrowserEvent.MouseButton', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.log']);
goog.addDependency('editor/command.js', ['goog.editor.Command'], []);
goog.addDependency('editor/contenteditablefield.js', ['goog.editor.ContentEditableField'], ['goog.asserts', 'goog.editor.Field', 'goog.log']);
goog.addDependency('editor/defines.js', ['goog.editor.defines'], []);
goog.addDependency('editor/field.js', ['goog.editor.Field', 'goog.editor.Field.EventType'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.array', 'goog.asserts', 'goog.async.Delay', 'goog.dom', 'goog.dom.Range', 'goog.dom.TagName', 'goog.editor.BrowserFeature', 'goog.editor.Command', 'goog.editor.Plugin', 'goog.editor.icontent', 'goog.editor.icontent.FieldFormatInfo', 'goog.editor.icontent.FieldStyleInfo', 'goog.editor.node', 'goog.editor.range', 'goog.events', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.functions', 'goog.log', 'goog.string', 'goog.string.Unicode', 'goog.style', 'goog.userAgent', 'goog.userAgent.product']);
goog.addDependency('editor/field_test.js', ['goog.editor.field_test'], ['goog.dom', 'goog.dom.Range', 'goog.editor.BrowserFeature', 'goog.editor.Field', 'goog.editor.Plugin', 'goog.editor.range', 'goog.events', 'goog.events.BrowserEvent', 'goog.events.KeyCodes', 'goog.functions', 'goog.testing.LooseMock', 'goog.testing.MockClock', 'goog.testing.dom', 'goog.testing.events', 'goog.testing.events.Event', 'goog.testing.recordFunction', 'goog.userAgent']);
goog.addDependency('editor/focus.js', ['goog.editor.focus'], ['goog.dom.selection']);
goog.addDependency('editor/icontent.js', ['goog.editor.icontent', 'goog.editor.icontent.FieldFormatInfo', 'goog.editor.icontent.FieldStyleInfo'], ['goog.editor.BrowserFeature', 'goog.style', 'goog.userAgent']);
goog.addDependency('editor/link.js', ['goog.editor.Link'], ['goog.array', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.Range', 'goog.dom.TagName', 'goog.editor.BrowserFeature', 'goog.editor.Command', 'goog.editor.node', 'goog.editor.range', 'goog.string', 'goog.string.Unicode', 'goog.uri.utils', 'goog.uri.utils.ComponentIndex']);
goog.addDependency('editor/node.js', ['goog.editor.node'], ['goog.dom', 'goog.dom.NodeType', 'goog.dom.TagName', 'goog.dom.iter.ChildIterator', 'goog.dom.iter.SiblingIterator', 'goog.iter', 'goog.object', 'goog.string', 'goog.string.Unicode', 'goog.userAgent']);
goog.addDependency('editor/plugin.js', ['goog.editor.Plugin'], ['goog.editor.Command', 'goog.events.EventTarget', 'goog.functions', 'goog.log', 'goog.object', 'goog.reflect']);
goog.addDependency('editor/plugins/abstractbubbleplugin.js', ['goog.editor.plugins.AbstractBubblePlugin'], ['goog.dom', 'goog.dom.NodeType', 'goog.dom.Range', 'goog.dom.TagName', 'goog.editor.Plugin', 'goog.editor.style', 'goog.events', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.events.actionEventWrapper', 'goog.functions', 'goog.string.Unicode', 'goog.ui.Component', 'goog.ui.editor.Bubble', 'goog.userAgent']);
goog.addDependency('editor/plugins/abstractdialogplugin.js', ['goog.editor.plugins.AbstractDialogPlugin', 'goog.editor.plugins.AbstractDialogPlugin.EventType'], ['goog.dom', 'goog.dom.Range', 'goog.editor.Field.EventType', 'goog.editor.Plugin', 'goog.editor.range', 'goog.events', 'goog.ui.editor.AbstractDialog.EventType']);
goog.addDependency('editor/plugins/abstracttabhandler.js', ['goog.editor.plugins.AbstractTabHandler'], ['goog.editor.Plugin', 'goog.events.KeyCodes']);
goog.addDependency('editor/plugins/basictextformatter.js', ['goog.editor.plugins.BasicTextFormatter', 'goog.editor.plugins.BasicTextFormatter.COMMAND'], ['goog.array', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.Range', 'goog.dom.TagName', 'goog.editor.BrowserFeature', 'goog.editor.Command', 'goog.editor.Link', 'goog.editor.Plugin', 'goog.editor.node', 'goog.editor.range', 'goog.editor.style', 'goog.iter', 'goog.iter.StopIteration', 'goog.log', 'goog.object', 'goog.string', 'goog.string.Unicode', 'goog.style', 'goog.ui.editor.messages', 'goog.userAgent']);
goog.addDependency('editor/plugins/blockquote.js', ['goog.editor.plugins.Blockquote'], ['goog.dom', 'goog.dom.NodeType', 'goog.dom.TagName', 'goog.dom.classlist', 'goog.editor.BrowserFeature', 'goog.editor.Command', 'goog.editor.Plugin', 'goog.editor.node', 'goog.functions', 'goog.log']);
goog.addDependency('editor/plugins/emoticons.js', ['goog.editor.plugins.Emoticons'], ['goog.dom.TagName', 'goog.editor.Plugin', 'goog.editor.range', 'goog.functions', 'goog.ui.emoji.Emoji', 'goog.userAgent']);
goog.addDependency('editor/plugins/enterhandler.js', ['goog.editor.plugins.EnterHandler'], ['goog.dom', 'goog.dom.NodeOffset', 'goog.dom.NodeType', 'goog.dom.Range', 'goog.dom.TagName', 'goog.editor.BrowserFeature', 'goog.editor.Plugin', 'goog.editor.node', 'goog.editor.plugins.Blockquote', 'goog.editor.range', 'goog.editor.style', 'goog.events.KeyCodes', 'goog.functions', 'goog.object', 'goog.string', 'goog.userAgent']);
goog.addDependency('editor/plugins/equationeditorbubble.js', ['goog.editor.plugins.equation.EquationBubble'], ['goog.dom', 'goog.dom.TagName', 'goog.editor.Command', 'goog.editor.plugins.AbstractBubblePlugin', 'goog.string.Unicode', 'goog.ui.editor.Bubble', 'goog.ui.equation.ImageRenderer']);
goog.addDependency('editor/plugins/equationeditorplugin.js', ['goog.editor.plugins.EquationEditorPlugin'], ['goog.dom', 'goog.editor.Command', 'goog.editor.plugins.AbstractDialogPlugin', 'goog.editor.range', 'goog.events', 'goog.events.EventType', 'goog.functions', 'goog.log', 'goog.ui.editor.AbstractDialog', 'goog.ui.editor.EquationEditorDialog', 'goog.ui.equation.ImageRenderer', 'goog.ui.equation.PaletteManager']);
goog.addDependency('editor/plugins/firststrong.js', ['goog.editor.plugins.FirstStrong'], ['goog.dom.NodeType', 'goog.dom.TagIterator', 'goog.dom.TagName', 'goog.editor.Command', 'goog.editor.Plugin', 'goog.editor.node', 'goog.editor.range', 'goog.i18n.bidi', 'goog.i18n.uChar', 'goog.iter', 'goog.userAgent']);
goog.addDependency('editor/plugins/headerformatter.js', ['goog.editor.plugins.HeaderFormatter'], ['goog.editor.Command', 'goog.editor.Plugin', 'goog.userAgent']);
goog.addDependency('editor/plugins/linkbubble.js', ['goog.editor.plugins.LinkBubble', 'goog.editor.plugins.LinkBubble.Action'], ['goog.array', 'goog.dom', 'goog.editor.BrowserFeature', 'goog.editor.Command', 'goog.editor.Link', 'goog.editor.plugins.AbstractBubblePlugin', 'goog.editor.range', 'goog.string', 'goog.style', 'goog.ui.editor.messages', 'goog.uri.utils', 'goog.window']);
goog.addDependency('editor/plugins/linkdialogplugin.js', ['goog.editor.plugins.LinkDialogPlugin'], ['goog.array', 'goog.dom', 'goog.editor.Command', 'goog.editor.plugins.AbstractDialogPlugin', 'goog.events.EventHandler', 'goog.functions', 'goog.ui.editor.AbstractDialog.EventType', 'goog.ui.editor.LinkDialog', 'goog.ui.editor.LinkDialog.EventType', 'goog.ui.editor.LinkDialog.OkEvent', 'goog.uri.utils']);
goog.addDependency('editor/plugins/linkshortcutplugin.js', ['goog.editor.plugins.LinkShortcutPlugin'], ['goog.editor.Command', 'goog.editor.Link', 'goog.editor.Plugin', 'goog.string']);
goog.addDependency('editor/plugins/listtabhandler.js', ['goog.editor.plugins.ListTabHandler'], ['goog.dom.TagName', 'goog.editor.Command', 'goog.editor.plugins.AbstractTabHandler']);
goog.addDependency('editor/plugins/loremipsum.js', ['goog.editor.plugins.LoremIpsum'], ['goog.asserts', 'goog.dom', 'goog.editor.Command', 'goog.editor.Plugin', 'goog.editor.node', 'goog.functions']);
goog.addDependency('editor/plugins/removeformatting.js', ['goog.editor.plugins.RemoveFormatting'], ['goog.dom', 'goog.dom.NodeType', 'goog.dom.Range', 'goog.dom.TagName', 'goog.editor.BrowserFeature', 'goog.editor.Plugin', 'goog.editor.node', 'goog.editor.range', 'goog.string', 'goog.userAgent']);
goog.addDependency('editor/plugins/spacestabhandler.js', ['goog.editor.plugins.SpacesTabHandler'], ['goog.dom', 'goog.dom.TagName', 'goog.editor.plugins.AbstractTabHandler', 'goog.editor.range']);
goog.addDependency('editor/plugins/tableeditor.js', ['goog.editor.plugins.TableEditor'], ['goog.array', 'goog.dom', 'goog.dom.TagName', 'goog.editor.Plugin', 'goog.editor.Table', 'goog.editor.node', 'goog.editor.range', 'goog.object']);
goog.addDependency('editor/plugins/tagonenterhandler.js', ['goog.editor.plugins.TagOnEnterHandler'], ['goog.dom', 'goog.dom.NodeType', 'goog.dom.Range', 'goog.dom.TagName', 'goog.editor.Command', 'goog.editor.node', 'goog.editor.plugins.EnterHandler', 'goog.editor.range', 'goog.editor.style', 'goog.events.KeyCodes', 'goog.string', 'goog.style', 'goog.userAgent']);
goog.addDependency('editor/plugins/undoredo.js', ['goog.editor.plugins.UndoRedo'], ['goog.dom', 'goog.dom.NodeOffset', 'goog.dom.Range', 'goog.editor.BrowserFeature', 'goog.editor.Command', 'goog.editor.Field.EventType', 'goog.editor.Plugin', 'goog.editor.node', 'goog.editor.plugins.UndoRedoManager', 'goog.editor.plugins.UndoRedoState', 'goog.events', 'goog.events.EventHandler', 'goog.log']);
goog.addDependency('editor/plugins/undoredomanager.js', ['goog.editor.plugins.UndoRedoManager', 'goog.editor.plugins.UndoRedoManager.EventType'], ['goog.editor.plugins.UndoRedoState', 'goog.events.EventTarget']);
goog.addDependency('editor/plugins/undoredostate.js', ['goog.editor.plugins.UndoRedoState'], ['goog.events.EventTarget']);
goog.addDependency('editor/range.js', ['goog.editor.range', 'goog.editor.range.Point'], ['goog.array', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.Range', 'goog.dom.RangeEndpoint', 'goog.dom.SavedCaretRange', 'goog.editor.node', 'goog.editor.style', 'goog.iter', 'goog.userAgent']);
goog.addDependency('editor/seamlessfield.js', ['goog.editor.SeamlessField'], ['goog.cssom.iframe.style', 'goog.dom', 'goog.dom.Range', 'goog.dom.TagName', 'goog.editor.BrowserFeature', 'goog.editor.Field', 'goog.editor.icontent', 'goog.editor.icontent.FieldFormatInfo', 'goog.editor.icontent.FieldStyleInfo', 'goog.editor.node', 'goog.events', 'goog.events.EventType', 'goog.log', 'goog.style']);
goog.addDependency('editor/seamlessfield_test.js', ['goog.editor.seamlessfield_test'], ['goog.dom', 'goog.dom.DomHelper', 'goog.dom.Range', 'goog.editor.BrowserFeature', 'goog.editor.Field', 'goog.editor.SeamlessField', 'goog.events', 'goog.functions', 'goog.style', 'goog.testing.MockClock', 'goog.testing.MockRange', 'goog.testing.jsunit']);
goog.addDependency('editor/style.js', ['goog.editor.style'], ['goog.dom', 'goog.dom.NodeType', 'goog.editor.BrowserFeature', 'goog.events.EventType', 'goog.object', 'goog.style', 'goog.userAgent']);
goog.addDependency('editor/table.js', ['goog.editor.Table', 'goog.editor.TableCell', 'goog.editor.TableRow'], ['goog.dom', 'goog.dom.DomHelper', 'goog.dom.NodeType', 'goog.dom.TagName', 'goog.log', 'goog.string.Unicode', 'goog.style']);
goog.addDependency('events/actioneventwrapper.js', ['goog.events.actionEventWrapper'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.events', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.events.EventWrapper', 'goog.events.KeyCodes', 'goog.userAgent']);
goog.addDependency('events/actionhandler.js', ['goog.events.ActionEvent', 'goog.events.ActionHandler', 'goog.events.ActionHandler.EventType', 'goog.events.BeforeActionEvent'], ['goog.events', 'goog.events.BrowserEvent', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.userAgent']);
goog.addDependency('events/browserevent.js', ['goog.events.BrowserEvent', 'goog.events.BrowserEvent.MouseButton'], ['goog.events.BrowserFeature', 'goog.events.Event', 'goog.events.EventType', 'goog.reflect', 'goog.userAgent']);
goog.addDependency('events/browserfeature.js', ['goog.events.BrowserFeature'], ['goog.userAgent']);
goog.addDependency('events/event.js', ['goog.events.Event', 'goog.events.EventLike'], ['goog.Disposable', 'goog.events.EventId']);
goog.addDependency('events/eventhandler.js', ['goog.events.EventHandler'], ['goog.Disposable', 'goog.events', 'goog.object']);
goog.addDependency('events/eventid.js', ['goog.events.EventId'], []);
goog.addDependency('events/events.js', ['goog.events', 'goog.events.CaptureSimulationMode', 'goog.events.Key', 'goog.events.ListenableType'], ['goog.array', 'goog.asserts', 'goog.debug.entryPointRegistry', 'goog.events.BrowserEvent', 'goog.events.BrowserFeature', 'goog.events.Listenable', 'goog.events.ListenerMap']);
goog.addDependency('events/eventtarget.js', ['goog.events.EventTarget'], ['goog.Disposable', 'goog.array', 'goog.asserts', 'goog.events', 'goog.events.Event', 'goog.events.Listenable', 'goog.events.ListenerMap', 'goog.object']);
goog.addDependency('events/eventtargettester.js', ['goog.events.eventTargetTester', 'goog.events.eventTargetTester.KeyType', 'goog.events.eventTargetTester.UnlistenReturnType'], ['goog.array', 'goog.events', 'goog.events.Event', 'goog.events.EventTarget', 'goog.testing.asserts', 'goog.testing.recordFunction']);
goog.addDependency('events/eventtype.js', ['goog.events.EventType'], ['goog.userAgent']);
goog.addDependency('events/eventwrapper.js', ['goog.events.EventWrapper'], []);
goog.addDependency('events/filedrophandler.js', ['goog.events.FileDropHandler', 'goog.events.FileDropHandler.EventType'], ['goog.array', 'goog.dom', 'goog.events', 'goog.events.BrowserEvent', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.log']);
goog.addDependency('events/focushandler.js', ['goog.events.FocusHandler', 'goog.events.FocusHandler.EventType'], ['goog.events', 'goog.events.BrowserEvent', 'goog.events.EventTarget', 'goog.userAgent']);
goog.addDependency('events/imehandler.js', ['goog.events.ImeHandler', 'goog.events.ImeHandler.Event', 'goog.events.ImeHandler.EventType'], ['goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.userAgent']);
goog.addDependency('events/inputhandler.js', ['goog.events.InputHandler', 'goog.events.InputHandler.EventType'], ['goog.Timer', 'goog.dom', 'goog.events.BrowserEvent', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.KeyCodes', 'goog.userAgent']);
goog.addDependency('events/keycodes.js', ['goog.events.KeyCodes'], ['goog.userAgent']);
goog.addDependency('events/keyhandler.js', ['goog.events.KeyEvent', 'goog.events.KeyHandler', 'goog.events.KeyHandler.EventType'], ['goog.events', 'goog.events.BrowserEvent', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.userAgent']);
goog.addDependency('events/keynames.js', ['goog.events.KeyNames'], []);
goog.addDependency('events/listenable.js', ['goog.events.Listenable', 'goog.events.ListenableKey'], ['goog.events.EventId']);
goog.addDependency('events/listener.js', ['goog.events.Listener'], ['goog.events.ListenableKey']);
goog.addDependency('events/listenermap.js', ['goog.events.ListenerMap'], ['goog.array', 'goog.events.Listener', 'goog.object']);
goog.addDependency('events/listenermap_test.js', ['goog.events.ListenerMapTest'], ['goog.dispose', 'goog.events.EventTarget', 'goog.events.ListenerMap', 'goog.testing.jsunit']);
goog.addDependency('events/mousewheelhandler.js', ['goog.events.MouseWheelEvent', 'goog.events.MouseWheelHandler', 'goog.events.MouseWheelHandler.EventType'], ['goog.dom', 'goog.events', 'goog.events.BrowserEvent', 'goog.events.EventTarget', 'goog.math', 'goog.style', 'goog.userAgent']);
goog.addDependency('events/onlinehandler.js', ['goog.events.OnlineHandler', 'goog.events.OnlineHandler.EventType'], ['goog.Timer', 'goog.events.BrowserFeature', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.net.NetworkStatusMonitor', 'goog.userAgent']);
goog.addDependency('events/pastehandler.js', ['goog.events.PasteHandler', 'goog.events.PasteHandler.EventType', 'goog.events.PasteHandler.State'], ['goog.Timer', 'goog.async.ConditionalDelay', 'goog.events.BrowserEvent', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.log', 'goog.userAgent']);
goog.addDependency('format/emailaddress.js', ['goog.format.EmailAddress'], ['goog.string']);
goog.addDependency('format/format.js', ['goog.format'], ['goog.i18n.GraphemeBreak', 'goog.string', 'goog.userAgent']);
goog.addDependency('format/htmlprettyprinter.js', ['goog.format.HtmlPrettyPrinter', 'goog.format.HtmlPrettyPrinter.Buffer'], ['goog.object', 'goog.string.StringBuffer']);
goog.addDependency('format/jsonprettyprinter.js', ['goog.format.JsonPrettyPrinter', 'goog.format.JsonPrettyPrinter.HtmlDelimiters', 'goog.format.JsonPrettyPrinter.TextDelimiters'], ['goog.json', 'goog.json.Serializer', 'goog.string', 'goog.string.StringBuffer', 'goog.string.format']);
goog.addDependency('fs/entry.js', ['goog.fs.DirectoryEntry', 'goog.fs.DirectoryEntry.Behavior', 'goog.fs.Entry', 'goog.fs.FileEntry'], []);
goog.addDependency('fs/entryimpl.js', ['goog.fs.DirectoryEntryImpl', 'goog.fs.EntryImpl', 'goog.fs.FileEntryImpl'], ['goog.array', 'goog.async.Deferred', 'goog.fs.DirectoryEntry', 'goog.fs.Entry', 'goog.fs.Error', 'goog.fs.FileEntry', 'goog.fs.FileWriter', 'goog.functions', 'goog.string']);
goog.addDependency('fs/error.js', ['goog.fs.Error', 'goog.fs.Error.ErrorCode'], ['goog.debug.Error', 'goog.string']);
goog.addDependency('fs/filereader.js', ['goog.fs.FileReader', 'goog.fs.FileReader.EventType', 'goog.fs.FileReader.ReadyState'], ['goog.async.Deferred', 'goog.events.EventTarget', 'goog.fs.Error', 'goog.fs.ProgressEvent']);
goog.addDependency('fs/filesaver.js', ['goog.fs.FileSaver', 'goog.fs.FileSaver.EventType', 'goog.fs.FileSaver.ProgressEvent', 'goog.fs.FileSaver.ReadyState'], ['goog.events.Event', 'goog.events.EventTarget', 'goog.fs.Error', 'goog.fs.ProgressEvent']);
goog.addDependency('fs/filesystem.js', ['goog.fs.FileSystem'], []);
goog.addDependency('fs/filesystemimpl.js', ['goog.fs.FileSystemImpl'], ['goog.fs.DirectoryEntryImpl', 'goog.fs.FileSystem']);
goog.addDependency('fs/filewriter.js', ['goog.fs.FileWriter'], ['goog.fs.Error', 'goog.fs.FileSaver']);
goog.addDependency('fs/fs.js', ['goog.fs'], ['goog.array', 'goog.async.Deferred', 'goog.fs.Error', 'goog.fs.FileReader', 'goog.fs.FileSystemImpl', 'goog.userAgent']);
goog.addDependency('fs/progressevent.js', ['goog.fs.ProgressEvent'], ['goog.events.Event']);
goog.addDependency('functions/functions.js', ['goog.functions'], []);
goog.addDependency('functions/functions_test.js', ['goog.functionsTest'], ['goog.functions', 'goog.testing.PropertyReplacer', 'goog.testing.jsunit', 'goog.testing.recordFunction']);
goog.addDependency('fx/abstractdragdrop.js', ['goog.fx.AbstractDragDrop', 'goog.fx.AbstractDragDrop.EventType', 'goog.fx.DragDropEvent', 'goog.fx.DragDropItem'], ['goog.dom', 'goog.dom.classlist', 'goog.events', 'goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.fx.Dragger', 'goog.math.Box', 'goog.math.Coordinate', 'goog.style']);
goog.addDependency('fx/anim/anim.js', ['goog.fx.anim', 'goog.fx.anim.Animated'], ['goog.async.AnimationDelay', 'goog.async.Delay', 'goog.object']);
goog.addDependency('fx/animation.js', ['goog.fx.Animation', 'goog.fx.Animation.EventType', 'goog.fx.Animation.State', 'goog.fx.AnimationEvent'], ['goog.array', 'goog.events.Event', 'goog.fx.Transition', 'goog.fx.Transition.EventType', 'goog.fx.TransitionBase.State', 'goog.fx.anim', 'goog.fx.anim.Animated']);
goog.addDependency('fx/animationqueue.js', ['goog.fx.AnimationParallelQueue', 'goog.fx.AnimationQueue', 'goog.fx.AnimationSerialQueue'], ['goog.array', 'goog.asserts', 'goog.events.EventHandler', 'goog.fx.Transition.EventType', 'goog.fx.TransitionBase', 'goog.fx.TransitionBase.State']);
goog.addDependency('fx/css3/fx.js', ['goog.fx.css3'], ['goog.fx.css3.Transition']);
goog.addDependency('fx/css3/transition.js', ['goog.fx.css3.Transition'], ['goog.Timer', 'goog.fx.TransitionBase', 'goog.style', 'goog.style.transition']);
goog.addDependency('fx/cssspriteanimation.js', ['goog.fx.CssSpriteAnimation'], ['goog.fx.Animation']);
goog.addDependency('fx/dom.js', ['goog.fx.dom', 'goog.fx.dom.BgColorTransform', 'goog.fx.dom.ColorTransform', 'goog.fx.dom.Fade', 'goog.fx.dom.FadeIn', 'goog.fx.dom.FadeInAndShow', 'goog.fx.dom.FadeOut', 'goog.fx.dom.FadeOutAndHide', 'goog.fx.dom.PredefinedEffect', 'goog.fx.dom.Resize', 'goog.fx.dom.ResizeHeight', 'goog.fx.dom.ResizeWidth', 'goog.fx.dom.Scroll', 'goog.fx.dom.Slide', 'goog.fx.dom.SlideFrom', 'goog.fx.dom.Swipe'], ['goog.color', 'goog.events', 'goog.fx.Animation', 'goog.fx.Transition.EventType', 'goog.style', 'goog.style.bidi']);
goog.addDependency('fx/dragdrop.js', ['goog.fx.DragDrop'], ['goog.fx.AbstractDragDrop', 'goog.fx.DragDropItem']);
goog.addDependency('fx/dragdropgroup.js', ['goog.fx.DragDropGroup'], ['goog.dom', 'goog.fx.AbstractDragDrop', 'goog.fx.DragDropItem']);
goog.addDependency('fx/dragger.js', ['goog.fx.DragEvent', 'goog.fx.Dragger', 'goog.fx.Dragger.EventType'], ['goog.dom', 'goog.events', 'goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.math.Coordinate', 'goog.math.Rect', 'goog.style', 'goog.style.bidi', 'goog.userAgent']);
goog.addDependency('fx/draglistgroup.js', ['goog.fx.DragListDirection', 'goog.fx.DragListGroup', 'goog.fx.DragListGroup.EventType', 'goog.fx.DragListGroupEvent'], ['goog.array', 'goog.asserts', 'goog.dom', 'goog.dom.classlist', 'goog.events', 'goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.fx.Dragger', 'goog.math.Coordinate', 'goog.string', 'goog.style']);
goog.addDependency('fx/dragscrollsupport.js', ['goog.fx.DragScrollSupport'], ['goog.Disposable', 'goog.Timer', 'goog.dom', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.math.Coordinate', 'goog.style']);
goog.addDependency('fx/easing.js', ['goog.fx.easing'], []);
goog.addDependency('fx/fx.js', ['goog.fx'], ['goog.asserts', 'goog.fx.Animation', 'goog.fx.Animation.EventType', 'goog.fx.Animation.State', 'goog.fx.AnimationEvent', 'goog.fx.Transition.EventType', 'goog.fx.easing']);
goog.addDependency('fx/transition.js', ['goog.fx.Transition', 'goog.fx.Transition.EventType'], []);
goog.addDependency('fx/transitionbase.js', ['goog.fx.TransitionBase', 'goog.fx.TransitionBase.State'], ['goog.events.EventTarget', 'goog.fx.Transition', 'goog.fx.Transition.EventType']);
goog.addDependency('graphics/abstractgraphics.js', ['goog.graphics.AbstractGraphics'], ['goog.dom', 'goog.graphics.Path', 'goog.math.Coordinate', 'goog.math.Size', 'goog.style', 'goog.ui.Component']);
goog.addDependency('graphics/affinetransform.js', ['goog.graphics.AffineTransform'], ['goog.math']);
goog.addDependency('graphics/canvaselement.js', ['goog.graphics.CanvasEllipseElement', 'goog.graphics.CanvasGroupElement', 'goog.graphics.CanvasImageElement', 'goog.graphics.CanvasPathElement', 'goog.graphics.CanvasRectElement', 'goog.graphics.CanvasTextElement'], ['goog.array', 'goog.dom', 'goog.dom.TagName', 'goog.graphics.EllipseElement', 'goog.graphics.GroupElement', 'goog.graphics.ImageElement', 'goog.graphics.Path', 'goog.graphics.PathElement', 'goog.graphics.RectElement', 'goog.graphics.TextElement', 'goog.math', 'goog.string']);
goog.addDependency('graphics/canvasgraphics.js', ['goog.graphics.CanvasGraphics'], ['goog.events.EventType', 'goog.graphics.AbstractGraphics', 'goog.graphics.CanvasEllipseElement', 'goog.graphics.CanvasGroupElement', 'goog.graphics.CanvasImageElement', 'goog.graphics.CanvasPathElement', 'goog.graphics.CanvasRectElement', 'goog.graphics.CanvasTextElement', 'goog.graphics.SolidFill', 'goog.math.Size', 'goog.style']);
goog.addDependency('graphics/element.js', ['goog.graphics.Element'], ['goog.events', 'goog.events.EventTarget', 'goog.events.Listenable', 'goog.graphics.AffineTransform', 'goog.math']);
goog.addDependency('graphics/ellipseelement.js', ['goog.graphics.EllipseElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/ext/coordinates.js', ['goog.graphics.ext.coordinates'], ['goog.string']);
goog.addDependency('graphics/ext/element.js', ['goog.graphics.ext.Element'], ['goog.events', 'goog.events.EventTarget', 'goog.functions', 'goog.graphics', 'goog.graphics.ext.coordinates']);
goog.addDependency('graphics/ext/ellipse.js', ['goog.graphics.ext.Ellipse'], ['goog.graphics.ext.StrokeAndFillElement']);
goog.addDependency('graphics/ext/ext.js', ['goog.graphics.ext'], ['goog.graphics.ext.Ellipse', 'goog.graphics.ext.Graphics', 'goog.graphics.ext.Group', 'goog.graphics.ext.Image', 'goog.graphics.ext.Rectangle', 'goog.graphics.ext.Shape', 'goog.graphics.ext.coordinates']);
goog.addDependency('graphics/ext/graphics.js', ['goog.graphics.ext.Graphics'], ['goog.events.EventType', 'goog.graphics.ext.Group']);
goog.addDependency('graphics/ext/group.js', ['goog.graphics.ext.Group'], ['goog.graphics.ext.Element']);
goog.addDependency('graphics/ext/image.js', ['goog.graphics.ext.Image'], ['goog.graphics.ext.Element']);
goog.addDependency('graphics/ext/path.js', ['goog.graphics.ext.Path'], ['goog.graphics.AffineTransform', 'goog.graphics.Path', 'goog.math', 'goog.math.Rect']);
goog.addDependency('graphics/ext/rectangle.js', ['goog.graphics.ext.Rectangle'], ['goog.graphics.ext.StrokeAndFillElement']);
goog.addDependency('graphics/ext/shape.js', ['goog.graphics.ext.Shape'], ['goog.graphics.ext.Path', 'goog.graphics.ext.StrokeAndFillElement', 'goog.math.Rect']);
goog.addDependency('graphics/ext/strokeandfillelement.js', ['goog.graphics.ext.StrokeAndFillElement'], ['goog.graphics.ext.Element']);
goog.addDependency('graphics/fill.js', ['goog.graphics.Fill'], []);
goog.addDependency('graphics/font.js', ['goog.graphics.Font'], []);
goog.addDependency('graphics/graphics.js', ['goog.graphics'], ['goog.graphics.CanvasGraphics', 'goog.graphics.SvgGraphics', 'goog.graphics.VmlGraphics', 'goog.userAgent']);
goog.addDependency('graphics/groupelement.js', ['goog.graphics.GroupElement'], ['goog.graphics.Element']);
goog.addDependency('graphics/imageelement.js', ['goog.graphics.ImageElement'], ['goog.graphics.Element']);
goog.addDependency('graphics/lineargradient.js', ['goog.graphics.LinearGradient'], ['goog.asserts', 'goog.graphics.Fill']);
goog.addDependency('graphics/path.js', ['goog.graphics.Path', 'goog.graphics.Path.Segment'], ['goog.array', 'goog.math']);
goog.addDependency('graphics/pathelement.js', ['goog.graphics.PathElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/paths.js', ['goog.graphics.paths'], ['goog.graphics.Path', 'goog.math.Coordinate']);
goog.addDependency('graphics/rectelement.js', ['goog.graphics.RectElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/solidfill.js', ['goog.graphics.SolidFill'], ['goog.graphics.Fill']);
goog.addDependency('graphics/stroke.js', ['goog.graphics.Stroke'], []);
goog.addDependency('graphics/strokeandfillelement.js', ['goog.graphics.StrokeAndFillElement'], ['goog.graphics.Element']);
goog.addDependency('graphics/svgelement.js', ['goog.graphics.SvgEllipseElement', 'goog.graphics.SvgGroupElement', 'goog.graphics.SvgImageElement', 'goog.graphics.SvgPathElement', 'goog.graphics.SvgRectElement', 'goog.graphics.SvgTextElement'], ['goog.dom', 'goog.graphics.EllipseElement', 'goog.graphics.GroupElement', 'goog.graphics.ImageElement', 'goog.graphics.PathElement', 'goog.graphics.RectElement', 'goog.graphics.TextElement']);
goog.addDependency('graphics/svggraphics.js', ['goog.graphics.SvgGraphics'], ['goog.Timer', 'goog.dom', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.graphics.AbstractGraphics', 'goog.graphics.LinearGradient', 'goog.graphics.Path', 'goog.graphics.SolidFill', 'goog.graphics.Stroke', 'goog.graphics.SvgEllipseElement', 'goog.graphics.SvgGroupElement', 'goog.graphics.SvgImageElement', 'goog.graphics.SvgPathElement', 'goog.graphics.SvgRectElement', 'goog.graphics.SvgTextElement', 'goog.math', 'goog.math.Size', 'goog.style', 'goog.userAgent']);
goog.addDependency('graphics/textelement.js', ['goog.graphics.TextElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/vmlelement.js', ['goog.graphics.VmlEllipseElement', 'goog.graphics.VmlGroupElement', 'goog.graphics.VmlImageElement', 'goog.graphics.VmlPathElement', 'goog.graphics.VmlRectElement', 'goog.graphics.VmlTextElement'], ['goog.dom', 'goog.graphics.EllipseElement', 'goog.graphics.GroupElement', 'goog.graphics.ImageElement', 'goog.graphics.PathElement', 'goog.graphics.RectElement', 'goog.graphics.TextElement']);
goog.addDependency('graphics/vmlgraphics.js', ['goog.graphics.VmlGraphics'], ['goog.array', 'goog.events', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.graphics.AbstractGraphics', 'goog.graphics.LinearGradient', 'goog.graphics.Path', 'goog.graphics.SolidFill', 'goog.graphics.VmlEllipseElement', 'goog.graphics.VmlGroupElement', 'goog.graphics.VmlImageElement', 'goog.graphics.VmlPathElement', 'goog.graphics.VmlRectElement', 'goog.graphics.VmlTextElement', 'goog.math', 'goog.math.Size', 'goog.string', 'goog.style']);
goog.addDependency('history/event.js', ['goog.history.Event'], ['goog.events.Event', 'goog.history.EventType']);
goog.addDependency('history/eventtype.js', ['goog.history.EventType'], []);
goog.addDependency('history/history.js', ['goog.History', 'goog.History.Event', 'goog.History.EventType'], ['goog.Timer', 'goog.dom', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.history.Event', 'goog.history.EventType', 'goog.memoize', 'goog.string', 'goog.userAgent']);
goog.addDependency('history/history_test.js', ['goog.HistoryTest'], ['goog.History', 'goog.testing.jsunit', 'goog.userAgent']);
goog.addDependency('history/html5history.js', ['goog.history.Html5History', 'goog.history.Html5History.TokenTransformer'], ['goog.asserts', 'goog.events', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.history.Event', 'goog.history.EventType']);
goog.addDependency('html/legacyconversions.js', ['goog.html.legacyconversions'], ['goog.html.SafeHtml']);
goog.addDependency('html/legacyconversions_test.js', ['goog.html.legacyconversionsTest'], ['goog.html.SafeHtml', 'goog.html.legacyconversions', 'goog.testing.PropertyReplacer', 'goog.testing.jsunit']);
goog.addDependency('html/safehtml.js', ['goog.html.SafeHtml'], ['goog.asserts', 'goog.i18n.bidi.DirectionalString', 'goog.string', 'goog.string.TypedString']);
goog.addDependency('html/safehtml_test.js', ['goog.html.safeHtmlTest'], ['goog.html.SafeHtml', 'goog.html.SafeUrl', 'goog.html.testing', 'goog.html.uncheckedconversions', 'goog.i18n.bidi.Dir', 'goog.string.Const', 'goog.testing.jsunit']);
goog.addDependency('html/safeurl.js', ['goog.html.SafeUrl'], ['goog.asserts', 'goog.i18n.bidi.Dir', 'goog.i18n.bidi.DirectionalString', 'goog.string.Const', 'goog.string.TypedString']);
goog.addDependency('html/safeurl_test.js', ['goog.html.safeUrlTest'], ['goog.html.SafeUrl', 'goog.html.uncheckedconversions', 'goog.i18n.bidi.Dir', 'goog.string.Const', 'goog.testing.jsunit']);
goog.addDependency('html/testing.js', ['goog.html.testing'], ['goog.html.SafeHtml', 'goog.html.SafeUrl']);
goog.addDependency('html/uncheckedconversions.js', ['goog.html.uncheckedconversions'], ['goog.asserts', 'goog.html.SafeHtml', 'goog.html.SafeUrl', 'goog.string.Const']);
goog.addDependency('html/utils.js', ['goog.html.utils'], ['goog.string']);
goog.addDependency('html/utils_test.js', ['goog.html.UtilsTest'], ['goog.array', 'goog.dom.TagName', 'goog.html.utils', 'goog.object', 'goog.testing.jsunit']);
goog.addDependency('i18n/bidi.js', ['goog.i18n.bidi', 'goog.i18n.bidi.Dir', 'goog.i18n.bidi.DirectionalString', 'goog.i18n.bidi.Format'], []);
goog.addDependency('i18n/bidiformatter.js', ['goog.i18n.BidiFormatter'], ['goog.i18n.bidi', 'goog.i18n.bidi.Dir', 'goog.i18n.bidi.Format', 'goog.string']);
goog.addDependency('i18n/charlistdecompressor.js', ['goog.i18n.CharListDecompressor'], ['goog.array', 'goog.i18n.uChar']);
goog.addDependency('i18n/charpickerdata.js', ['goog.i18n.CharPickerData'], []);
goog.addDependency('i18n/collation.js', ['goog.i18n.collation'], []);
goog.addDependency('i18n/compactnumberformatsymbols.js', ['goog.i18n.CompactNumberFormatSymbols', 'goog.i18n.CompactNumberFormatSymbols_af', 'goog.i18n.CompactNumberFormatSymbols_af_ZA', 'goog.i18n.CompactNumberFormatSymbols_am', 'goog.i18n.CompactNumberFormatSymbols_am_ET', 'goog.i18n.CompactNumberFormatSymbols_ar', 'goog.i18n.CompactNumberFormatSymbols_ar_001', 'goog.i18n.CompactNumberFormatSymbols_ar_EG', 'goog.i18n.CompactNumberFormatSymbols_bg', 'goog.i18n.CompactNumberFormatSymbols_bg_BG', 'goog.i18n.CompactNumberFormatSymbols_bn', 'goog.i18n.CompactNumberFormatSymbols_bn_BD', 'goog.i18n.CompactNumberFormatSymbols_br', 'goog.i18n.CompactNumberFormatSymbols_br_FR', 'goog.i18n.CompactNumberFormatSymbols_ca', 'goog.i18n.CompactNumberFormatSymbols_ca_AD', 'goog.i18n.CompactNumberFormatSymbols_ca_ES', 'goog.i18n.CompactNumberFormatSymbols_chr', 'goog.i18n.CompactNumberFormatSymbols_chr_US', 'goog.i18n.CompactNumberFormatSymbols_cs', 'goog.i18n.CompactNumberFormatSymbols_cs_CZ', 'goog.i18n.CompactNumberFormatSymbols_cy', 'goog.i18n.CompactNumberFormatSymbols_cy_GB', 'goog.i18n.CompactNumberFormatSymbols_da', 'goog.i18n.CompactNumberFormatSymbols_da_DK', 'goog.i18n.CompactNumberFormatSymbols_de', 'goog.i18n.CompactNumberFormatSymbols_de_AT', 'goog.i18n.CompactNumberFormatSymbols_de_BE', 'goog.i18n.CompactNumberFormatSymbols_de_CH', 'goog.i18n.CompactNumberFormatSymbols_de_DE', 'goog.i18n.CompactNumberFormatSymbols_de_LU', 'goog.i18n.CompactNumberFormatSymbols_el', 'goog.i18n.CompactNumberFormatSymbols_el_GR', 'goog.i18n.CompactNumberFormatSymbols_en', 'goog.i18n.CompactNumberFormatSymbols_en_AS', 'goog.i18n.CompactNumberFormatSymbols_en_AU', 'goog.i18n.CompactNumberFormatSymbols_en_Dsrt_US', 'goog.i18n.CompactNumberFormatSymbols_en_FM', 'goog.i18n.CompactNumberFormatSymbols_en_GB', 'goog.i18n.CompactNumberFormatSymbols_en_GU', 'goog.i18n.CompactNumberFormatSymbols_en_IE', 'goog.i18n.CompactNumberFormatSymbols_en_IN', 'goog.i18n.CompactNumberFormatSymbols_en_MH', 'goog.i18n.CompactNumberFormatSymbols_en_MP', 'goog.i18n.CompactNumberFormatSymbols_en_PR', 'goog.i18n.CompactNumberFormatSymbols_en_PW', 'goog.i18n.CompactNumberFormatSymbols_en_SG', 'goog.i18n.CompactNumberFormatSymbols_en_TC', 'goog.i18n.CompactNumberFormatSymbols_en_UM', 'goog.i18n.CompactNumberFormatSymbols_en_US', 'goog.i18n.CompactNumberFormatSymbols_en_VG', 'goog.i18n.CompactNumberFormatSymbols_en_VI', 'goog.i18n.CompactNumberFormatSymbols_en_ZA', 'goog.i18n.CompactNumberFormatSymbols_es', 'goog.i18n.CompactNumberFormatSymbols_es_419', 'goog.i18n.CompactNumberFormatSymbols_es_EA', 'goog.i18n.CompactNumberFormatSymbols_es_ES', 'goog.i18n.CompactNumberFormatSymbols_es_IC', 'goog.i18n.CompactNumberFormatSymbols_et', 'goog.i18n.CompactNumberFormatSymbols_et_EE', 'goog.i18n.CompactNumberFormatSymbols_eu', 'goog.i18n.CompactNumberFormatSymbols_eu_ES', 'goog.i18n.CompactNumberFormatSymbols_fa', 'goog.i18n.CompactNumberFormatSymbols_fa_IR', 'goog.i18n.CompactNumberFormatSymbols_fi', 'goog.i18n.CompactNumberFormatSymbols_fi_FI', 'goog.i18n.CompactNumberFormatSymbols_fil', 'goog.i18n.CompactNumberFormatSymbols_fil_PH', 'goog.i18n.CompactNumberFormatSymbols_fr', 'goog.i18n.CompactNumberFormatSymbols_fr_BL', 'goog.i18n.CompactNumberFormatSymbols_fr_CA', 'goog.i18n.CompactNumberFormatSymbols_fr_FR', 'goog.i18n.CompactNumberFormatSymbols_fr_GF', 'goog.i18n.CompactNumberFormatSymbols_fr_GP', 'goog.i18n.CompactNumberFormatSymbols_fr_MC', 'goog.i18n.CompactNumberFormatSymbols_fr_MF', 'goog.i18n.CompactNumberFormatSymbols_fr_MQ', 'goog.i18n.CompactNumberFormatSymbols_fr_RE', 'goog.i18n.CompactNumberFormatSymbols_fr_YT', 'goog.i18n.CompactNumberFormatSymbols_gl', 'goog.i18n.CompactNumberFormatSymbols_gl_ES', 'goog.i18n.CompactNumberFormatSymbols_gsw', 'goog.i18n.CompactNumberFormatSymbols_gsw_CH', 'goog.i18n.CompactNumberFormatSymbols_gu', 'goog.i18n.CompactNumberFormatSymbols_gu_IN', 'goog.i18n.CompactNumberFormatSymbols_haw', 'goog.i18n.CompactNumberFormatSymbols_haw_US', 'goog.i18n.CompactNumberFormatSymbols_he', 'goog.i18n.CompactNumberFormatSymbols_he_IL', 'goog.i18n.CompactNumberFormatSymbols_hi', 'goog.i18n.CompactNumberFormatSymbols_hi_IN', 'goog.i18n.CompactNumberFormatSymbols_hr', 'goog.i18n.CompactNumberFormatSymbols_hr_HR', 'goog.i18n.CompactNumberFormatSymbols_hu', 'goog.i18n.CompactNumberFormatSymbols_hu_HU', 'goog.i18n.CompactNumberFormatSymbols_id', 'goog.i18n.CompactNumberFormatSymbols_id_ID', 'goog.i18n.CompactNumberFormatSymbols_in', 'goog.i18n.CompactNumberFormatSymbols_is', 'goog.i18n.CompactNumberFormatSymbols_is_IS', 'goog.i18n.CompactNumberFormatSymbols_it', 'goog.i18n.CompactNumberFormatSymbols_it_IT', 'goog.i18n.CompactNumberFormatSymbols_it_SM', 'goog.i18n.CompactNumberFormatSymbols_iw', 'goog.i18n.CompactNumberFormatSymbols_ja', 'goog.i18n.CompactNumberFormatSymbols_ja_JP', 'goog.i18n.CompactNumberFormatSymbols_kn', 'goog.i18n.CompactNumberFormatSymbols_kn_IN', 'goog.i18n.CompactNumberFormatSymbols_ko', 'goog.i18n.CompactNumberFormatSymbols_ko_KR', 'goog.i18n.CompactNumberFormatSymbols_ln', 'goog.i18n.CompactNumberFormatSymbols_ln_CD', 'goog.i18n.CompactNumberFormatSymbols_lt', 'goog.i18n.CompactNumberFormatSymbols_lt_LT', 'goog.i18n.CompactNumberFormatSymbols_lv', 'goog.i18n.CompactNumberFormatSymbols_lv_LV', 'goog.i18n.CompactNumberFormatSymbols_ml', 'goog.i18n.CompactNumberFormatSymbols_ml_IN', 'goog.i18n.CompactNumberFormatSymbols_mr', 'goog.i18n.CompactNumberFormatSymbols_mr_IN', 'goog.i18n.CompactNumberFormatSymbols_ms', 'goog.i18n.CompactNumberFormatSymbols_ms_Latn_MY', 'goog.i18n.CompactNumberFormatSymbols_mt', 'goog.i18n.CompactNumberFormatSymbols_mt_MT', 'goog.i18n.CompactNumberFormatSymbols_nb', 'goog.i18n.CompactNumberFormatSymbols_nb_NO', 'goog.i18n.CompactNumberFormatSymbols_nl', 'goog.i18n.CompactNumberFormatSymbols_nl_NL', 'goog.i18n.CompactNumberFormatSymbols_no', 'goog.i18n.CompactNumberFormatSymbols_or', 'goog.i18n.CompactNumberFormatSymbols_or_IN', 'goog.i18n.CompactNumberFormatSymbols_pl', 'goog.i18n.CompactNumberFormatSymbols_pl_PL', 'goog.i18n.CompactNumberFormatSymbols_pt', 'goog.i18n.CompactNumberFormatSymbols_pt_BR', 'goog.i18n.CompactNumberFormatSymbols_pt_PT', 'goog.i18n.CompactNumberFormatSymbols_ro', 'goog.i18n.CompactNumberFormatSymbols_ro_RO', 'goog.i18n.CompactNumberFormatSymbols_ru', 'goog.i18n.CompactNumberFormatSymbols_ru_RU', 'goog.i18n.CompactNumberFormatSymbols_sk', 'goog.i18n.CompactNumberFormatSymbols_sk_SK', 'goog.i18n.CompactNumberFormatSymbols_sl', 'goog.i18n.CompactNumberFormatSymbols_sl_SI', 'goog.i18n.CompactNumberFormatSymbols_sq', 'goog.i18n.CompactNumberFormatSymbols_sq_AL', 'goog.i18n.CompactNumberFormatSymbols_sr', 'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_RS', 'goog.i18n.CompactNumberFormatSymbols_sv', 'goog.i18n.CompactNumberFormatSymbols_sv_SE', 'goog.i18n.CompactNumberFormatSymbols_sw', 'goog.i18n.CompactNumberFormatSymbols_sw_TZ', 'goog.i18n.CompactNumberFormatSymbols_ta', 'goog.i18n.CompactNumberFormatSymbols_ta_IN', 'goog.i18n.CompactNumberFormatSymbols_te', 'goog.i18n.CompactNumberFormatSymbols_te_IN', 'goog.i18n.CompactNumberFormatSymbols_th', 'goog.i18n.CompactNumberFormatSymbols_th_TH', 'goog.i18n.CompactNumberFormatSymbols_tl', 'goog.i18n.CompactNumberFormatSymbols_tr', 'goog.i18n.CompactNumberFormatSymbols_tr_TR', 'goog.i18n.CompactNumberFormatSymbols_uk', 'goog.i18n.CompactNumberFormatSymbols_uk_UA', 'goog.i18n.CompactNumberFormatSymbols_ur', 'goog.i18n.CompactNumberFormatSymbols_ur_PK', 'goog.i18n.CompactNumberFormatSymbols_vi', 'goog.i18n.CompactNumberFormatSymbols_vi_VN', 'goog.i18n.CompactNumberFormatSymbols_zh', 'goog.i18n.CompactNumberFormatSymbols_zh_CN', 'goog.i18n.CompactNumberFormatSymbols_zh_HK', 'goog.i18n.CompactNumberFormatSymbols_zh_Hans_CN', 'goog.i18n.CompactNumberFormatSymbols_zh_TW', 'goog.i18n.CompactNumberFormatSymbols_zu', 'goog.i18n.CompactNumberFormatSymbols_zu_ZA'], []);
goog.addDependency('i18n/compactnumberformatsymbols_ext.js', ['goog.i18n.CompactNumberFormatSymbolsExt', 'goog.i18n.CompactNumberFormatSymbols_aa', 'goog.i18n.CompactNumberFormatSymbols_aa_DJ', 'goog.i18n.CompactNumberFormatSymbols_aa_ER', 'goog.i18n.CompactNumberFormatSymbols_aa_ET', 'goog.i18n.CompactNumberFormatSymbols_af_NA', 'goog.i18n.CompactNumberFormatSymbols_agq', 'goog.i18n.CompactNumberFormatSymbols_agq_CM', 'goog.i18n.CompactNumberFormatSymbols_ak', 'goog.i18n.CompactNumberFormatSymbols_ak_GH', 'goog.i18n.CompactNumberFormatSymbols_ar_AE', 'goog.i18n.CompactNumberFormatSymbols_ar_BH', 'goog.i18n.CompactNumberFormatSymbols_ar_DJ', 'goog.i18n.CompactNumberFormatSymbols_ar_DZ', 'goog.i18n.CompactNumberFormatSymbols_ar_EH', 'goog.i18n.CompactNumberFormatSymbols_ar_ER', 'goog.i18n.CompactNumberFormatSymbols_ar_IL', 'goog.i18n.CompactNumberFormatSymbols_ar_IQ', 'goog.i18n.CompactNumberFormatSymbols_ar_JO', 'goog.i18n.CompactNumberFormatSymbols_ar_KM', 'goog.i18n.CompactNumberFormatSymbols_ar_KW', 'goog.i18n.CompactNumberFormatSymbols_ar_LB', 'goog.i18n.CompactNumberFormatSymbols_ar_LY', 'goog.i18n.CompactNumberFormatSymbols_ar_MA', 'goog.i18n.CompactNumberFormatSymbols_ar_MR', 'goog.i18n.CompactNumberFormatSymbols_ar_OM', 'goog.i18n.CompactNumberFormatSymbols_ar_PS', 'goog.i18n.CompactNumberFormatSymbols_ar_QA', 'goog.i18n.CompactNumberFormatSymbols_ar_SA', 'goog.i18n.CompactNumberFormatSymbols_ar_SD', 'goog.i18n.CompactNumberFormatSymbols_ar_SO', 'goog.i18n.CompactNumberFormatSymbols_ar_SY', 'goog.i18n.CompactNumberFormatSymbols_ar_TD', 'goog.i18n.CompactNumberFormatSymbols_ar_TN', 'goog.i18n.CompactNumberFormatSymbols_ar_YE', 'goog.i18n.CompactNumberFormatSymbols_as', 'goog.i18n.CompactNumberFormatSymbols_as_IN', 'goog.i18n.CompactNumberFormatSymbols_asa', 'goog.i18n.CompactNumberFormatSymbols_asa_TZ', 'goog.i18n.CompactNumberFormatSymbols_ast', 'goog.i18n.CompactNumberFormatSymbols_ast_ES', 'goog.i18n.CompactNumberFormatSymbols_az', 'goog.i18n.CompactNumberFormatSymbols_az_Cyrl', 'goog.i18n.CompactNumberFormatSymbols_az_Cyrl_AZ', 'goog.i18n.CompactNumberFormatSymbols_az_Latn', 'goog.i18n.CompactNumberFormatSymbols_az_Latn_AZ', 'goog.i18n.CompactNumberFormatSymbols_bas', 'goog.i18n.CompactNumberFormatSymbols_bas_CM', 'goog.i18n.CompactNumberFormatSymbols_be', 'goog.i18n.CompactNumberFormatSymbols_be_BY', 'goog.i18n.CompactNumberFormatSymbols_bem', 'goog.i18n.CompactNumberFormatSymbols_bem_ZM', 'goog.i18n.CompactNumberFormatSymbols_bez', 'goog.i18n.CompactNumberFormatSymbols_bez_TZ', 'goog.i18n.CompactNumberFormatSymbols_bm', 'goog.i18n.CompactNumberFormatSymbols_bm_ML', 'goog.i18n.CompactNumberFormatSymbols_bn_IN', 'goog.i18n.CompactNumberFormatSymbols_bo', 'goog.i18n.CompactNumberFormatSymbols_bo_CN', 'goog.i18n.CompactNumberFormatSymbols_bo_IN', 'goog.i18n.CompactNumberFormatSymbols_brx', 'goog.i18n.CompactNumberFormatSymbols_brx_IN', 'goog.i18n.CompactNumberFormatSymbols_bs', 'goog.i18n.CompactNumberFormatSymbols_bs_Cyrl', 'goog.i18n.CompactNumberFormatSymbols_bs_Cyrl_BA', 'goog.i18n.CompactNumberFormatSymbols_bs_Latn', 'goog.i18n.CompactNumberFormatSymbols_bs_Latn_BA', 'goog.i18n.CompactNumberFormatSymbols_byn', 'goog.i18n.CompactNumberFormatSymbols_byn_ER', 'goog.i18n.CompactNumberFormatSymbols_cgg', 'goog.i18n.CompactNumberFormatSymbols_cgg_UG', 'goog.i18n.CompactNumberFormatSymbols_ckb', 'goog.i18n.CompactNumberFormatSymbols_ckb_Arab', 'goog.i18n.CompactNumberFormatSymbols_ckb_Arab_IQ', 'goog.i18n.CompactNumberFormatSymbols_ckb_Arab_IR', 'goog.i18n.CompactNumberFormatSymbols_ckb_IQ', 'goog.i18n.CompactNumberFormatSymbols_ckb_IR', 'goog.i18n.CompactNumberFormatSymbols_ckb_Latn', 'goog.i18n.CompactNumberFormatSymbols_ckb_Latn_IQ', 'goog.i18n.CompactNumberFormatSymbols_dav', 'goog.i18n.CompactNumberFormatSymbols_dav_KE', 'goog.i18n.CompactNumberFormatSymbols_de_LI', 'goog.i18n.CompactNumberFormatSymbols_dje', 'goog.i18n.CompactNumberFormatSymbols_dje_NE', 'goog.i18n.CompactNumberFormatSymbols_dua', 'goog.i18n.CompactNumberFormatSymbols_dua_CM', 'goog.i18n.CompactNumberFormatSymbols_dyo', 'goog.i18n.CompactNumberFormatSymbols_dyo_SN', 'goog.i18n.CompactNumberFormatSymbols_dz', 'goog.i18n.CompactNumberFormatSymbols_dz_BT', 'goog.i18n.CompactNumberFormatSymbols_ebu', 'goog.i18n.CompactNumberFormatSymbols_ebu_KE', 'goog.i18n.CompactNumberFormatSymbols_ee', 'goog.i18n.CompactNumberFormatSymbols_ee_GH', 'goog.i18n.CompactNumberFormatSymbols_ee_TG', 'goog.i18n.CompactNumberFormatSymbols_el_CY', 'goog.i18n.CompactNumberFormatSymbols_en_150', 'goog.i18n.CompactNumberFormatSymbols_en_AG', 'goog.i18n.CompactNumberFormatSymbols_en_BB', 'goog.i18n.CompactNumberFormatSymbols_en_BE', 'goog.i18n.CompactNumberFormatSymbols_en_BM', 'goog.i18n.CompactNumberFormatSymbols_en_BS', 'goog.i18n.CompactNumberFormatSymbols_en_BW', 'goog.i18n.CompactNumberFormatSymbols_en_BZ', 'goog.i18n.CompactNumberFormatSymbols_en_CA', 'goog.i18n.CompactNumberFormatSymbols_en_CM', 'goog.i18n.CompactNumberFormatSymbols_en_DM', 'goog.i18n.CompactNumberFormatSymbols_en_Dsrt', 'goog.i18n.CompactNumberFormatSymbols_en_FJ', 'goog.i18n.CompactNumberFormatSymbols_en_GD', 'goog.i18n.CompactNumberFormatSymbols_en_GG', 'goog.i18n.CompactNumberFormatSymbols_en_GH', 'goog.i18n.CompactNumberFormatSymbols_en_GI', 'goog.i18n.CompactNumberFormatSymbols_en_GM', 'goog.i18n.CompactNumberFormatSymbols_en_GY', 'goog.i18n.CompactNumberFormatSymbols_en_HK', 'goog.i18n.CompactNumberFormatSymbols_en_IM', 'goog.i18n.CompactNumberFormatSymbols_en_JE', 'goog.i18n.CompactNumberFormatSymbols_en_JM', 'goog.i18n.CompactNumberFormatSymbols_en_KE', 'goog.i18n.CompactNumberFormatSymbols_en_KI', 'goog.i18n.CompactNumberFormatSymbols_en_KN', 'goog.i18n.CompactNumberFormatSymbols_en_KY', 'goog.i18n.CompactNumberFormatSymbols_en_LC', 'goog.i18n.CompactNumberFormatSymbols_en_LR', 'goog.i18n.CompactNumberFormatSymbols_en_LS', 'goog.i18n.CompactNumberFormatSymbols_en_MG', 'goog.i18n.CompactNumberFormatSymbols_en_MT', 'goog.i18n.CompactNumberFormatSymbols_en_MU', 'goog.i18n.CompactNumberFormatSymbols_en_MW', 'goog.i18n.CompactNumberFormatSymbols_en_NA', 'goog.i18n.CompactNumberFormatSymbols_en_NG', 'goog.i18n.CompactNumberFormatSymbols_en_NZ', 'goog.i18n.CompactNumberFormatSymbols_en_PG', 'goog.i18n.CompactNumberFormatSymbols_en_PH', 'goog.i18n.CompactNumberFormatSymbols_en_PK', 'goog.i18n.CompactNumberFormatSymbols_en_SB', 'goog.i18n.CompactNumberFormatSymbols_en_SC', 'goog.i18n.CompactNumberFormatSymbols_en_SL', 'goog.i18n.CompactNumberFormatSymbols_en_SS', 'goog.i18n.CompactNumberFormatSymbols_en_SZ', 'goog.i18n.CompactNumberFormatSymbols_en_TO', 'goog.i18n.CompactNumberFormatSymbols_en_TT', 'goog.i18n.CompactNumberFormatSymbols_en_TZ', 'goog.i18n.CompactNumberFormatSymbols_en_UG', 'goog.i18n.CompactNumberFormatSymbols_en_VC', 'goog.i18n.CompactNumberFormatSymbols_en_VU', 'goog.i18n.CompactNumberFormatSymbols_en_WS', 'goog.i18n.CompactNumberFormatSymbols_en_ZM', 'goog.i18n.CompactNumberFormatSymbols_en_ZW', 'goog.i18n.CompactNumberFormatSymbols_eo', 'goog.i18n.CompactNumberFormatSymbols_es_AR', 'goog.i18n.CompactNumberFormatSymbols_es_BO', 'goog.i18n.CompactNumberFormatSymbols_es_CL', 'goog.i18n.CompactNumberFormatSymbols_es_CO', 'goog.i18n.CompactNumberFormatSymbols_es_CR', 'goog.i18n.CompactNumberFormatSymbols_es_CU', 'goog.i18n.CompactNumberFormatSymbols_es_DO', 'goog.i18n.CompactNumberFormatSymbols_es_EC', 'goog.i18n.CompactNumberFormatSymbols_es_GQ', 'goog.i18n.CompactNumberFormatSymbols_es_GT', 'goog.i18n.CompactNumberFormatSymbols_es_HN', 'goog.i18n.CompactNumberFormatSymbols_es_MX', 'goog.i18n.CompactNumberFormatSymbols_es_NI', 'goog.i18n.CompactNumberFormatSymbols_es_PA', 'goog.i18n.CompactNumberFormatSymbols_es_PE', 'goog.i18n.CompactNumberFormatSymbols_es_PH', 'goog.i18n.CompactNumberFormatSymbols_es_PR', 'goog.i18n.CompactNumberFormatSymbols_es_PY', 'goog.i18n.CompactNumberFormatSymbols_es_SV', 'goog.i18n.CompactNumberFormatSymbols_es_US', 'goog.i18n.CompactNumberFormatSymbols_es_UY', 'goog.i18n.CompactNumberFormatSymbols_es_VE', 'goog.i18n.CompactNumberFormatSymbols_ewo', 'goog.i18n.CompactNumberFormatSymbols_ewo_CM', 'goog.i18n.CompactNumberFormatSymbols_fa_AF', 'goog.i18n.CompactNumberFormatSymbols_ff', 'goog.i18n.CompactNumberFormatSymbols_ff_SN', 'goog.i18n.CompactNumberFormatSymbols_fo', 'goog.i18n.CompactNumberFormatSymbols_fo_FO', 'goog.i18n.CompactNumberFormatSymbols_fr_BE', 'goog.i18n.CompactNumberFormatSymbols_fr_BF', 'goog.i18n.CompactNumberFormatSymbols_fr_BI', 'goog.i18n.CompactNumberFormatSymbols_fr_BJ', 'goog.i18n.CompactNumberFormatSymbols_fr_CD', 'goog.i18n.CompactNumberFormatSymbols_fr_CF', 'goog.i18n.CompactNumberFormatSymbols_fr_CG', 'goog.i18n.CompactNumberFormatSymbols_fr_CH', 'goog.i18n.CompactNumberFormatSymbols_fr_CI', 'goog.i18n.CompactNumberFormatSymbols_fr_CM', 'goog.i18n.CompactNumberFormatSymbols_fr_DJ', 'goog.i18n.CompactNumberFormatSymbols_fr_DZ', 'goog.i18n.CompactNumberFormatSymbols_fr_GA', 'goog.i18n.CompactNumberFormatSymbols_fr_GN', 'goog.i18n.CompactNumberFormatSymbols_fr_GQ', 'goog.i18n.CompactNumberFormatSymbols_fr_HT', 'goog.i18n.CompactNumberFormatSymbols_fr_KM', 'goog.i18n.CompactNumberFormatSymbols_fr_LU', 'goog.i18n.CompactNumberFormatSymbols_fr_MA', 'goog.i18n.CompactNumberFormatSymbols_fr_MG', 'goog.i18n.CompactNumberFormatSymbols_fr_ML', 'goog.i18n.CompactNumberFormatSymbols_fr_MR', 'goog.i18n.CompactNumberFormatSymbols_fr_MU', 'goog.i18n.CompactNumberFormatSymbols_fr_NC', 'goog.i18n.CompactNumberFormatSymbols_fr_NE', 'goog.i18n.CompactNumberFormatSymbols_fr_PF', 'goog.i18n.CompactNumberFormatSymbols_fr_RW', 'goog.i18n.CompactNumberFormatSymbols_fr_SC', 'goog.i18n.CompactNumberFormatSymbols_fr_SN', 'goog.i18n.CompactNumberFormatSymbols_fr_SY', 'goog.i18n.CompactNumberFormatSymbols_fr_TD', 'goog.i18n.CompactNumberFormatSymbols_fr_TG', 'goog.i18n.CompactNumberFormatSymbols_fr_TN', 'goog.i18n.CompactNumberFormatSymbols_fr_VU', 'goog.i18n.CompactNumberFormatSymbols_fur', 'goog.i18n.CompactNumberFormatSymbols_fur_IT', 'goog.i18n.CompactNumberFormatSymbols_ga', 'goog.i18n.CompactNumberFormatSymbols_ga_IE', 'goog.i18n.CompactNumberFormatSymbols_gd', 'goog.i18n.CompactNumberFormatSymbols_gd_GB', 'goog.i18n.CompactNumberFormatSymbols_guz', 'goog.i18n.CompactNumberFormatSymbols_guz_KE', 'goog.i18n.CompactNumberFormatSymbols_gv', 'goog.i18n.CompactNumberFormatSymbols_gv_GB', 'goog.i18n.CompactNumberFormatSymbols_ha', 'goog.i18n.CompactNumberFormatSymbols_ha_Latn', 'goog.i18n.CompactNumberFormatSymbols_ha_Latn_GH', 'goog.i18n.CompactNumberFormatSymbols_ha_Latn_NE', 'goog.i18n.CompactNumberFormatSymbols_ha_Latn_NG', 'goog.i18n.CompactNumberFormatSymbols_hr_BA', 'goog.i18n.CompactNumberFormatSymbols_hy', 'goog.i18n.CompactNumberFormatSymbols_hy_AM', 'goog.i18n.CompactNumberFormatSymbols_ia', 'goog.i18n.CompactNumberFormatSymbols_ia_FR', 'goog.i18n.CompactNumberFormatSymbols_ig', 'goog.i18n.CompactNumberFormatSymbols_ig_NG', 'goog.i18n.CompactNumberFormatSymbols_ii', 'goog.i18n.CompactNumberFormatSymbols_ii_CN', 'goog.i18n.CompactNumberFormatSymbols_it_CH', 'goog.i18n.CompactNumberFormatSymbols_jgo', 'goog.i18n.CompactNumberFormatSymbols_jgo_CM', 'goog.i18n.CompactNumberFormatSymbols_jmc', 'goog.i18n.CompactNumberFormatSymbols_jmc_TZ', 'goog.i18n.CompactNumberFormatSymbols_ka', 'goog.i18n.CompactNumberFormatSymbols_ka_GE', 'goog.i18n.CompactNumberFormatSymbols_kab', 'goog.i18n.CompactNumberFormatSymbols_kab_DZ', 'goog.i18n.CompactNumberFormatSymbols_kam', 'goog.i18n.CompactNumberFormatSymbols_kam_KE', 'goog.i18n.CompactNumberFormatSymbols_kde', 'goog.i18n.CompactNumberFormatSymbols_kde_TZ', 'goog.i18n.CompactNumberFormatSymbols_kea', 'goog.i18n.CompactNumberFormatSymbols_kea_CV', 'goog.i18n.CompactNumberFormatSymbols_khq', 'goog.i18n.CompactNumberFormatSymbols_khq_ML', 'goog.i18n.CompactNumberFormatSymbols_ki', 'goog.i18n.CompactNumberFormatSymbols_ki_KE', 'goog.i18n.CompactNumberFormatSymbols_kk', 'goog.i18n.CompactNumberFormatSymbols_kk_Cyrl', 'goog.i18n.CompactNumberFormatSymbols_kk_Cyrl_KZ', 'goog.i18n.CompactNumberFormatSymbols_kkj', 'goog.i18n.CompactNumberFormatSymbols_kkj_CM', 'goog.i18n.CompactNumberFormatSymbols_kl', 'goog.i18n.CompactNumberFormatSymbols_kl_GL', 'goog.i18n.CompactNumberFormatSymbols_kln', 'goog.i18n.CompactNumberFormatSymbols_kln_KE', 'goog.i18n.CompactNumberFormatSymbols_km', 'goog.i18n.CompactNumberFormatSymbols_km_KH', 'goog.i18n.CompactNumberFormatSymbols_ko_KP', 'goog.i18n.CompactNumberFormatSymbols_kok', 'goog.i18n.CompactNumberFormatSymbols_kok_IN', 'goog.i18n.CompactNumberFormatSymbols_ks', 'goog.i18n.CompactNumberFormatSymbols_ks_Arab', 'goog.i18n.CompactNumberFormatSymbols_ks_Arab_IN', 'goog.i18n.CompactNumberFormatSymbols_ksb', 'goog.i18n.CompactNumberFormatSymbols_ksb_TZ', 'goog.i18n.CompactNumberFormatSymbols_ksf', 'goog.i18n.CompactNumberFormatSymbols_ksf_CM', 'goog.i18n.CompactNumberFormatSymbols_ksh', 'goog.i18n.CompactNumberFormatSymbols_ksh_DE', 'goog.i18n.CompactNumberFormatSymbols_kw', 'goog.i18n.CompactNumberFormatSymbols_kw_GB', 'goog.i18n.CompactNumberFormatSymbols_ky', 'goog.i18n.CompactNumberFormatSymbols_ky_KG', 'goog.i18n.CompactNumberFormatSymbols_lag', 'goog.i18n.CompactNumberFormatSymbols_lag_TZ', 'goog.i18n.CompactNumberFormatSymbols_lg', 'goog.i18n.CompactNumberFormatSymbols_lg_UG', 'goog.i18n.CompactNumberFormatSymbols_ln_AO', 'goog.i18n.CompactNumberFormatSymbols_ln_CF', 'goog.i18n.CompactNumberFormatSymbols_ln_CG', 'goog.i18n.CompactNumberFormatSymbols_lo', 'goog.i18n.CompactNumberFormatSymbols_lo_LA', 'goog.i18n.CompactNumberFormatSymbols_lu', 'goog.i18n.CompactNumberFormatSymbols_lu_CD', 'goog.i18n.CompactNumberFormatSymbols_luo', 'goog.i18n.CompactNumberFormatSymbols_luo_KE', 'goog.i18n.CompactNumberFormatSymbols_luy', 'goog.i18n.CompactNumberFormatSymbols_luy_KE', 'goog.i18n.CompactNumberFormatSymbols_mas', 'goog.i18n.CompactNumberFormatSymbols_mas_KE', 'goog.i18n.CompactNumberFormatSymbols_mas_TZ', 'goog.i18n.CompactNumberFormatSymbols_mer', 'goog.i18n.CompactNumberFormatSymbols_mer_KE', 'goog.i18n.CompactNumberFormatSymbols_mfe', 'goog.i18n.CompactNumberFormatSymbols_mfe_MU', 'goog.i18n.CompactNumberFormatSymbols_mg', 'goog.i18n.CompactNumberFormatSymbols_mg_MG', 'goog.i18n.CompactNumberFormatSymbols_mgh', 'goog.i18n.CompactNumberFormatSymbols_mgh_MZ', 'goog.i18n.CompactNumberFormatSymbols_mgo', 'goog.i18n.CompactNumberFormatSymbols_mgo_CM', 'goog.i18n.CompactNumberFormatSymbols_mk', 'goog.i18n.CompactNumberFormatSymbols_mk_MK', 'goog.i18n.CompactNumberFormatSymbols_mn', 'goog.i18n.CompactNumberFormatSymbols_mn_Cyrl', 'goog.i18n.CompactNumberFormatSymbols_mn_Cyrl_MN', 'goog.i18n.CompactNumberFormatSymbols_ms_Latn', 'goog.i18n.CompactNumberFormatSymbols_ms_Latn_BN', 'goog.i18n.CompactNumberFormatSymbols_ms_Latn_SG', 'goog.i18n.CompactNumberFormatSymbols_mua', 'goog.i18n.CompactNumberFormatSymbols_mua_CM', 'goog.i18n.CompactNumberFormatSymbols_my', 'goog.i18n.CompactNumberFormatSymbols_my_MM', 'goog.i18n.CompactNumberFormatSymbols_naq', 'goog.i18n.CompactNumberFormatSymbols_naq_NA', 'goog.i18n.CompactNumberFormatSymbols_nd', 'goog.i18n.CompactNumberFormatSymbols_nd_ZW', 'goog.i18n.CompactNumberFormatSymbols_ne', 'goog.i18n.CompactNumberFormatSymbols_ne_IN', 'goog.i18n.CompactNumberFormatSymbols_ne_NP', 'goog.i18n.CompactNumberFormatSymbols_nl_AW', 'goog.i18n.CompactNumberFormatSymbols_nl_BE', 'goog.i18n.CompactNumberFormatSymbols_nl_CW', 'goog.i18n.CompactNumberFormatSymbols_nl_SR', 'goog.i18n.CompactNumberFormatSymbols_nl_SX', 'goog.i18n.CompactNumberFormatSymbols_nmg', 'goog.i18n.CompactNumberFormatSymbols_nmg_CM', 'goog.i18n.CompactNumberFormatSymbols_nn', 'goog.i18n.CompactNumberFormatSymbols_nn_NO', 'goog.i18n.CompactNumberFormatSymbols_nnh', 'goog.i18n.CompactNumberFormatSymbols_nnh_CM', 'goog.i18n.CompactNumberFormatSymbols_nr', 'goog.i18n.CompactNumberFormatSymbols_nr_ZA', 'goog.i18n.CompactNumberFormatSymbols_nso', 'goog.i18n.CompactNumberFormatSymbols_nso_ZA', 'goog.i18n.CompactNumberFormatSymbols_nus', 'goog.i18n.CompactNumberFormatSymbols_nus_SD', 'goog.i18n.CompactNumberFormatSymbols_nyn', 'goog.i18n.CompactNumberFormatSymbols_nyn_UG', 'goog.i18n.CompactNumberFormatSymbols_om', 'goog.i18n.CompactNumberFormatSymbols_om_ET', 'goog.i18n.CompactNumberFormatSymbols_om_KE', 'goog.i18n.CompactNumberFormatSymbols_os', 'goog.i18n.CompactNumberFormatSymbols_os_GE', 'goog.i18n.CompactNumberFormatSymbols_os_RU', 'goog.i18n.CompactNumberFormatSymbols_pa', 'goog.i18n.CompactNumberFormatSymbols_pa_Arab', 'goog.i18n.CompactNumberFormatSymbols_pa_Arab_PK', 'goog.i18n.CompactNumberFormatSymbols_pa_Guru', 'goog.i18n.CompactNumberFormatSymbols_pa_Guru_IN', 'goog.i18n.CompactNumberFormatSymbols_ps', 'goog.i18n.CompactNumberFormatSymbols_ps_AF', 'goog.i18n.CompactNumberFormatSymbols_pt_AO', 'goog.i18n.CompactNumberFormatSymbols_pt_CV', 'goog.i18n.CompactNumberFormatSymbols_pt_GW', 'goog.i18n.CompactNumberFormatSymbols_pt_MO', 'goog.i18n.CompactNumberFormatSymbols_pt_MZ', 'goog.i18n.CompactNumberFormatSymbols_pt_ST', 'goog.i18n.CompactNumberFormatSymbols_pt_TL', 'goog.i18n.CompactNumberFormatSymbols_rm', 'goog.i18n.CompactNumberFormatSymbols_rm_CH', 'goog.i18n.CompactNumberFormatSymbols_rn', 'goog.i18n.CompactNumberFormatSymbols_rn_BI', 'goog.i18n.CompactNumberFormatSymbols_ro_MD', 'goog.i18n.CompactNumberFormatSymbols_rof', 'goog.i18n.CompactNumberFormatSymbols_rof_TZ', 'goog.i18n.CompactNumberFormatSymbols_ru_BY', 'goog.i18n.CompactNumberFormatSymbols_ru_KG', 'goog.i18n.CompactNumberFormatSymbols_ru_KZ', 'goog.i18n.CompactNumberFormatSymbols_ru_MD', 'goog.i18n.CompactNumberFormatSymbols_ru_UA', 'goog.i18n.CompactNumberFormatSymbols_rw', 'goog.i18n.CompactNumberFormatSymbols_rw_RW', 'goog.i18n.CompactNumberFormatSymbols_rwk', 'goog.i18n.CompactNumberFormatSymbols_rwk_TZ', 'goog.i18n.CompactNumberFormatSymbols_sah', 'goog.i18n.CompactNumberFormatSymbols_sah_RU', 'goog.i18n.CompactNumberFormatSymbols_saq', 'goog.i18n.CompactNumberFormatSymbols_saq_KE', 'goog.i18n.CompactNumberFormatSymbols_sbp', 'goog.i18n.CompactNumberFormatSymbols_sbp_TZ', 'goog.i18n.CompactNumberFormatSymbols_se', 'goog.i18n.CompactNumberFormatSymbols_se_FI', 'goog.i18n.CompactNumberFormatSymbols_se_NO', 'goog.i18n.CompactNumberFormatSymbols_seh', 'goog.i18n.CompactNumberFormatSymbols_seh_MZ', 'goog.i18n.CompactNumberFormatSymbols_ses', 'goog.i18n.CompactNumberFormatSymbols_ses_ML', 'goog.i18n.CompactNumberFormatSymbols_sg', 'goog.i18n.CompactNumberFormatSymbols_sg_CF', 'goog.i18n.CompactNumberFormatSymbols_shi', 'goog.i18n.CompactNumberFormatSymbols_shi_Latn', 'goog.i18n.CompactNumberFormatSymbols_shi_Latn_MA', 'goog.i18n.CompactNumberFormatSymbols_shi_Tfng', 'goog.i18n.CompactNumberFormatSymbols_shi_Tfng_MA', 'goog.i18n.CompactNumberFormatSymbols_si', 'goog.i18n.CompactNumberFormatSymbols_si_LK', 'goog.i18n.CompactNumberFormatSymbols_sn', 'goog.i18n.CompactNumberFormatSymbols_sn_ZW', 'goog.i18n.CompactNumberFormatSymbols_so', 'goog.i18n.CompactNumberFormatSymbols_so_DJ', 'goog.i18n.CompactNumberFormatSymbols_so_ET', 'goog.i18n.CompactNumberFormatSymbols_so_KE', 'goog.i18n.CompactNumberFormatSymbols_so_SO', 'goog.i18n.CompactNumberFormatSymbols_sq_MK', 'goog.i18n.CompactNumberFormatSymbols_sq_XK', 'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl', 'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_BA', 'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_ME', 'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_XK', 'goog.i18n.CompactNumberFormatSymbols_sr_Latn', 'goog.i18n.CompactNumberFormatSymbols_sr_Latn_BA', 'goog.i18n.CompactNumberFormatSymbols_sr_Latn_ME', 'goog.i18n.CompactNumberFormatSymbols_sr_Latn_RS', 'goog.i18n.CompactNumberFormatSymbols_sr_Latn_XK', 'goog.i18n.CompactNumberFormatSymbols_ss', 'goog.i18n.CompactNumberFormatSymbols_ss_SZ', 'goog.i18n.CompactNumberFormatSymbols_ss_ZA', 'goog.i18n.CompactNumberFormatSymbols_ssy', 'goog.i18n.CompactNumberFormatSymbols_ssy_ER', 'goog.i18n.CompactNumberFormatSymbols_st', 'goog.i18n.CompactNumberFormatSymbols_st_LS', 'goog.i18n.CompactNumberFormatSymbols_st_ZA', 'goog.i18n.CompactNumberFormatSymbols_sv_AX', 'goog.i18n.CompactNumberFormatSymbols_sv_FI', 'goog.i18n.CompactNumberFormatSymbols_sw_KE', 'goog.i18n.CompactNumberFormatSymbols_sw_UG', 'goog.i18n.CompactNumberFormatSymbols_swc', 'goog.i18n.CompactNumberFormatSymbols_swc_CD', 'goog.i18n.CompactNumberFormatSymbols_ta_LK', 'goog.i18n.CompactNumberFormatSymbols_ta_MY', 'goog.i18n.CompactNumberFormatSymbols_ta_SG', 'goog.i18n.CompactNumberFormatSymbols_teo', 'goog.i18n.CompactNumberFormatSymbols_teo_KE', 'goog.i18n.CompactNumberFormatSymbols_teo_UG', 'goog.i18n.CompactNumberFormatSymbols_tg', 'goog.i18n.CompactNumberFormatSymbols_tg_Cyrl', 'goog.i18n.CompactNumberFormatSymbols_tg_Cyrl_TJ', 'goog.i18n.CompactNumberFormatSymbols_ti', 'goog.i18n.CompactNumberFormatSymbols_ti_ER', 'goog.i18n.CompactNumberFormatSymbols_ti_ET', 'goog.i18n.CompactNumberFormatSymbols_tig', 'goog.i18n.CompactNumberFormatSymbols_tig_ER', 'goog.i18n.CompactNumberFormatSymbols_tn', 'goog.i18n.CompactNumberFormatSymbols_tn_BW', 'goog.i18n.CompactNumberFormatSymbols_tn_ZA', 'goog.i18n.CompactNumberFormatSymbols_to', 'goog.i18n.CompactNumberFormatSymbols_to_TO', 'goog.i18n.CompactNumberFormatSymbols_tr_CY', 'goog.i18n.CompactNumberFormatSymbols_ts', 'goog.i18n.CompactNumberFormatSymbols_ts_ZA', 'goog.i18n.CompactNumberFormatSymbols_twq', 'goog.i18n.CompactNumberFormatSymbols_twq_NE', 'goog.i18n.CompactNumberFormatSymbols_tzm', 'goog.i18n.CompactNumberFormatSymbols_tzm_Latn', 'goog.i18n.CompactNumberFormatSymbols_tzm_Latn_MA', 'goog.i18n.CompactNumberFormatSymbols_ur_IN', 'goog.i18n.CompactNumberFormatSymbols_uz', 'goog.i18n.CompactNumberFormatSymbols_uz_Arab', 'goog.i18n.CompactNumberFormatSymbols_uz_Arab_AF', 'goog.i18n.CompactNumberFormatSymbols_uz_Cyrl', 'goog.i18n.CompactNumberFormatSymbols_uz_Cyrl_UZ', 'goog.i18n.CompactNumberFormatSymbols_uz_Latn', 'goog.i18n.CompactNumberFormatSymbols_uz_Latn_UZ', 'goog.i18n.CompactNumberFormatSymbols_vai', 'goog.i18n.CompactNumberFormatSymbols_vai_Latn', 'goog.i18n.CompactNumberFormatSymbols_vai_Latn_LR', 'goog.i18n.CompactNumberFormatSymbols_vai_Vaii', 'goog.i18n.CompactNumberFormatSymbols_vai_Vaii_LR', 'goog.i18n.CompactNumberFormatSymbols_ve', 'goog.i18n.CompactNumberFormatSymbols_ve_ZA', 'goog.i18n.CompactNumberFormatSymbols_vo', 'goog.i18n.CompactNumberFormatSymbols_vun', 'goog.i18n.CompactNumberFormatSymbols_vun_TZ', 'goog.i18n.CompactNumberFormatSymbols_wae', 'goog.i18n.CompactNumberFormatSymbols_wae_CH', 'goog.i18n.CompactNumberFormatSymbols_wal', 'goog.i18n.CompactNumberFormatSymbols_wal_ET', 'goog.i18n.CompactNumberFormatSymbols_xh', 'goog.i18n.CompactNumberFormatSymbols_xh_ZA', 'goog.i18n.CompactNumberFormatSymbols_xog', 'goog.i18n.CompactNumberFormatSymbols_xog_UG', 'goog.i18n.CompactNumberFormatSymbols_yav', 'goog.i18n.CompactNumberFormatSymbols_yav_CM', 'goog.i18n.CompactNumberFormatSymbols_yo', 'goog.i18n.CompactNumberFormatSymbols_yo_NG', 'goog.i18n.CompactNumberFormatSymbols_zh_Hans', 'goog.i18n.CompactNumberFormatSymbols_zh_Hans_HK', 'goog.i18n.CompactNumberFormatSymbols_zh_Hans_MO', 'goog.i18n.CompactNumberFormatSymbols_zh_Hans_SG', 'goog.i18n.CompactNumberFormatSymbols_zh_Hant', 'goog.i18n.CompactNumberFormatSymbols_zh_Hant_HK', 'goog.i18n.CompactNumberFormatSymbols_zh_Hant_MO', 'goog.i18n.CompactNumberFormatSymbols_zh_Hant_TW'], []);
goog.addDependency('i18n/currency.js', ['goog.i18n.currency', 'goog.i18n.currency.CurrencyInfo', 'goog.i18n.currency.CurrencyInfoTier2'], []);
goog.addDependency('i18n/currencycodemap.js', ['goog.i18n.currencyCodeMap', 'goog.i18n.currencyCodeMapTier2'], []);
goog.addDependency('i18n/datetimeformat.js', ['goog.i18n.DateTimeFormat', 'goog.i18n.DateTimeFormat.Format'], ['goog.asserts', 'goog.date', 'goog.i18n.DateTimeSymbols', 'goog.i18n.TimeZone', 'goog.string']);
goog.addDependency('i18n/datetimeparse.js', ['goog.i18n.DateTimeParse'], ['goog.date', 'goog.i18n.DateTimeFormat', 'goog.i18n.DateTimeSymbols']);
goog.addDependency('i18n/datetimepatterns.js', ['goog.i18n.DateTimePatterns', 'goog.i18n.DateTimePatterns_af', 'goog.i18n.DateTimePatterns_am', 'goog.i18n.DateTimePatterns_ar', 'goog.i18n.DateTimePatterns_bg', 'goog.i18n.DateTimePatterns_bn', 'goog.i18n.DateTimePatterns_br', 'goog.i18n.DateTimePatterns_ca', 'goog.i18n.DateTimePatterns_chr', 'goog.i18n.DateTimePatterns_cs', 'goog.i18n.DateTimePatterns_cy', 'goog.i18n.DateTimePatterns_da', 'goog.i18n.DateTimePatterns_de', 'goog.i18n.DateTimePatterns_de_AT', 'goog.i18n.DateTimePatterns_de_CH', 'goog.i18n.DateTimePatterns_el', 'goog.i18n.DateTimePatterns_en', 'goog.i18n.DateTimePatterns_en_AU', 'goog.i18n.DateTimePatterns_en_GB', 'goog.i18n.DateTimePatterns_en_IE', 'goog.i18n.DateTimePatterns_en_IN', 'goog.i18n.DateTimePatterns_en_SG', 'goog.i18n.DateTimePatterns_en_US', 'goog.i18n.DateTimePatterns_en_ZA', 'goog.i18n.DateTimePatterns_es', 'goog.i18n.DateTimePatterns_es_419', 'goog.i18n.DateTimePatterns_es_ES', 'goog.i18n.DateTimePatterns_et', 'goog.i18n.DateTimePatterns_eu', 'goog.i18n.DateTimePatterns_fa', 'goog.i18n.DateTimePatterns_fi', 'goog.i18n.DateTimePatterns_fil', 'goog.i18n.DateTimePatterns_fr', 'goog.i18n.DateTimePatterns_fr_CA', 'goog.i18n.DateTimePatterns_gl', 'goog.i18n.DateTimePatterns_gsw', 'goog.i18n.DateTimePatterns_gu', 'goog.i18n.DateTimePatterns_haw', 'goog.i18n.DateTimePatterns_he', 'goog.i18n.DateTimePatterns_hi', 'goog.i18n.DateTimePatterns_hr', 'goog.i18n.DateTimePatterns_hu', 'goog.i18n.DateTimePatterns_id', 'goog.i18n.DateTimePatterns_in', 'goog.i18n.DateTimePatterns_is', 'goog.i18n.DateTimePatterns_it', 'goog.i18n.DateTimePatterns_iw', 'goog.i18n.DateTimePatterns_ja', 'goog.i18n.DateTimePatterns_kn', 'goog.i18n.DateTimePatterns_ko', 'goog.i18n.DateTimePatterns_ln', 'goog.i18n.DateTimePatterns_lt', 'goog.i18n.DateTimePatterns_lv', 'goog.i18n.DateTimePatterns_ml', 'goog.i18n.DateTimePatterns_mo', 'goog.i18n.DateTimePatterns_mr', 'goog.i18n.DateTimePatterns_ms', 'goog.i18n.DateTimePatterns_mt', 'goog.i18n.DateTimePatterns_nb', 'goog.i18n.DateTimePatterns_nl', 'goog.i18n.DateTimePatterns_no', 'goog.i18n.DateTimePatterns_or', 'goog.i18n.DateTimePatterns_pl', 'goog.i18n.DateTimePatterns_pt', 'goog.i18n.DateTimePatterns_pt_BR', 'goog.i18n.DateTimePatterns_pt_PT', 'goog.i18n.DateTimePatterns_ro', 'goog.i18n.DateTimePatterns_ru', 'goog.i18n.DateTimePatterns_sk', 'goog.i18n.DateTimePatterns_sl', 'goog.i18n.DateTimePatterns_sq', 'goog.i18n.DateTimePatterns_sr', 'goog.i18n.DateTimePatterns_sv', 'goog.i18n.DateTimePatterns_sw', 'goog.i18n.DateTimePatterns_ta', 'goog.i18n.DateTimePatterns_te', 'goog.i18n.DateTimePatterns_th', 'goog.i18n.DateTimePatterns_tl', 'goog.i18n.DateTimePatterns_tr', 'goog.i18n.DateTimePatterns_uk', 'goog.i18n.DateTimePatterns_ur', 'goog.i18n.DateTimePatterns_vi', 'goog.i18n.DateTimePatterns_zh', 'goog.i18n.DateTimePatterns_zh_CN', 'goog.i18n.DateTimePatterns_zh_HK', 'goog.i18n.DateTimePatterns_zh_TW', 'goog.i18n.DateTimePatterns_zu'], []);
goog.addDependency('i18n/datetimepatternsext.js', ['goog.i18n.DateTimePatternsExt', 'goog.i18n.DateTimePatterns_af_NA', 'goog.i18n.DateTimePatterns_af_ZA', 'goog.i18n.DateTimePatterns_agq', 'goog.i18n.DateTimePatterns_agq_CM', 'goog.i18n.DateTimePatterns_ak', 'goog.i18n.DateTimePatterns_ak_GH', 'goog.i18n.DateTimePatterns_am_ET', 'goog.i18n.DateTimePatterns_ar_001', 'goog.i18n.DateTimePatterns_ar_AE', 'goog.i18n.DateTimePatterns_ar_BH', 'goog.i18n.DateTimePatterns_ar_DJ', 'goog.i18n.DateTimePatterns_ar_DZ', 'goog.i18n.DateTimePatterns_ar_EG', 'goog.i18n.DateTimePatterns_ar_EH', 'goog.i18n.DateTimePatterns_ar_ER', 'goog.i18n.DateTimePatterns_ar_IL', 'goog.i18n.DateTimePatterns_ar_IQ', 'goog.i18n.DateTimePatterns_ar_JO', 'goog.i18n.DateTimePatterns_ar_KM', 'goog.i18n.DateTimePatterns_ar_KW', 'goog.i18n.DateTimePatterns_ar_LB', 'goog.i18n.DateTimePatterns_ar_LY', 'goog.i18n.DateTimePatterns_ar_MA', 'goog.i18n.DateTimePatterns_ar_MR', 'goog.i18n.DateTimePatterns_ar_OM', 'goog.i18n.DateTimePatterns_ar_PS', 'goog.i18n.DateTimePatterns_ar_QA', 'goog.i18n.DateTimePatterns_ar_SA', 'goog.i18n.DateTimePatterns_ar_SD', 'goog.i18n.DateTimePatterns_ar_SO', 'goog.i18n.DateTimePatterns_ar_SY', 'goog.i18n.DateTimePatterns_ar_TD', 'goog.i18n.DateTimePatterns_ar_TN', 'goog.i18n.DateTimePatterns_ar_YE', 'goog.i18n.DateTimePatterns_as', 'goog.i18n.DateTimePatterns_as_IN', 'goog.i18n.DateTimePatterns_asa', 'goog.i18n.DateTimePatterns_asa_TZ', 'goog.i18n.DateTimePatterns_az', 'goog.i18n.DateTimePatterns_az_Cyrl', 'goog.i18n.DateTimePatterns_az_Cyrl_AZ', 'goog.i18n.DateTimePatterns_az_Latn', 'goog.i18n.DateTimePatterns_az_Latn_AZ', 'goog.i18n.DateTimePatterns_bas', 'goog.i18n.DateTimePatterns_bas_CM', 'goog.i18n.DateTimePatterns_be', 'goog.i18n.DateTimePatterns_be_BY', 'goog.i18n.DateTimePatterns_bem', 'goog.i18n.DateTimePatterns_bem_ZM', 'goog.i18n.DateTimePatterns_bez', 'goog.i18n.DateTimePatterns_bez_TZ', 'goog.i18n.DateTimePatterns_bg_BG', 'goog.i18n.DateTimePatterns_bm', 'goog.i18n.DateTimePatterns_bm_ML', 'goog.i18n.DateTimePatterns_bn_BD', 'goog.i18n.DateTimePatterns_bn_IN', 'goog.i18n.DateTimePatterns_bo', 'goog.i18n.DateTimePatterns_bo_CN', 'goog.i18n.DateTimePatterns_bo_IN', 'goog.i18n.DateTimePatterns_br_FR', 'goog.i18n.DateTimePatterns_brx', 'goog.i18n.DateTimePatterns_brx_IN', 'goog.i18n.DateTimePatterns_bs', 'goog.i18n.DateTimePatterns_bs_Cyrl', 'goog.i18n.DateTimePatterns_bs_Cyrl_BA', 'goog.i18n.DateTimePatterns_bs_Latn', 'goog.i18n.DateTimePatterns_bs_Latn_BA', 'goog.i18n.DateTimePatterns_ca_AD', 'goog.i18n.DateTimePatterns_ca_ES', 'goog.i18n.DateTimePatterns_cgg', 'goog.i18n.DateTimePatterns_cgg_UG', 'goog.i18n.DateTimePatterns_chr_US', 'goog.i18n.DateTimePatterns_cs_CZ', 'goog.i18n.DateTimePatterns_cy_GB', 'goog.i18n.DateTimePatterns_da_DK', 'goog.i18n.DateTimePatterns_dav', 'goog.i18n.DateTimePatterns_dav_KE', 'goog.i18n.DateTimePatterns_de_BE', 'goog.i18n.DateTimePatterns_de_DE', 'goog.i18n.DateTimePatterns_de_LI', 'goog.i18n.DateTimePatterns_de_LU', 'goog.i18n.DateTimePatterns_dje', 'goog.i18n.DateTimePatterns_dje_NE', 'goog.i18n.DateTimePatterns_dua', 'goog.i18n.DateTimePatterns_dua_CM', 'goog.i18n.DateTimePatterns_dyo', 'goog.i18n.DateTimePatterns_dyo_SN', 'goog.i18n.DateTimePatterns_dz', 'goog.i18n.DateTimePatterns_dz_BT', 'goog.i18n.DateTimePatterns_ebu', 'goog.i18n.DateTimePatterns_ebu_KE', 'goog.i18n.DateTimePatterns_ee', 'goog.i18n.DateTimePatterns_ee_GH', 'goog.i18n.DateTimePatterns_ee_TG', 'goog.i18n.DateTimePatterns_el_CY', 'goog.i18n.DateTimePatterns_el_GR', 'goog.i18n.DateTimePatterns_en_150', 'goog.i18n.DateTimePatterns_en_AG', 'goog.i18n.DateTimePatterns_en_AS', 'goog.i18n.DateTimePatterns_en_BB', 'goog.i18n.DateTimePatterns_en_BE', 'goog.i18n.DateTimePatterns_en_BM', 'goog.i18n.DateTimePatterns_en_BS', 'goog.i18n.DateTimePatterns_en_BW', 'goog.i18n.DateTimePatterns_en_BZ', 'goog.i18n.DateTimePatterns_en_CA', 'goog.i18n.DateTimePatterns_en_CM', 'goog.i18n.DateTimePatterns_en_DM', 'goog.i18n.DateTimePatterns_en_FJ', 'goog.i18n.DateTimePatterns_en_FM', 'goog.i18n.DateTimePatterns_en_GD', 'goog.i18n.DateTimePatterns_en_GG', 'goog.i18n.DateTimePatterns_en_GH', 'goog.i18n.DateTimePatterns_en_GI', 'goog.i18n.DateTimePatterns_en_GM', 'goog.i18n.DateTimePatterns_en_GU', 'goog.i18n.DateTimePatterns_en_GY', 'goog.i18n.DateTimePatterns_en_HK', 'goog.i18n.DateTimePatterns_en_IM', 'goog.i18n.DateTimePatterns_en_JE', 'goog.i18n.DateTimePatterns_en_JM', 'goog.i18n.DateTimePatterns_en_KE', 'goog.i18n.DateTimePatterns_en_KI', 'goog.i18n.DateTimePatterns_en_KN', 'goog.i18n.DateTimePatterns_en_KY', 'goog.i18n.DateTimePatterns_en_LC', 'goog.i18n.DateTimePatterns_en_LR', 'goog.i18n.DateTimePatterns_en_LS', 'goog.i18n.DateTimePatterns_en_MG', 'goog.i18n.DateTimePatterns_en_MH', 'goog.i18n.DateTimePatterns_en_MP', 'goog.i18n.DateTimePatterns_en_MT', 'goog.i18n.DateTimePatterns_en_MU', 'goog.i18n.DateTimePatterns_en_MW', 'goog.i18n.DateTimePatterns_en_NA', 'goog.i18n.DateTimePatterns_en_NG', 'goog.i18n.DateTimePatterns_en_NZ', 'goog.i18n.DateTimePatterns_en_PG', 'goog.i18n.DateTimePatterns_en_PH', 'goog.i18n.DateTimePatterns_en_PK', 'goog.i18n.DateTimePatterns_en_PR', 'goog.i18n.DateTimePatterns_en_PW', 'goog.i18n.DateTimePatterns_en_SB', 'goog.i18n.DateTimePatterns_en_SC', 'goog.i18n.DateTimePatterns_en_SL', 'goog.i18n.DateTimePatterns_en_SS', 'goog.i18n.DateTimePatterns_en_SZ', 'goog.i18n.DateTimePatterns_en_TC', 'goog.i18n.DateTimePatterns_en_TO', 'goog.i18n.DateTimePatterns_en_TT', 'goog.i18n.DateTimePatterns_en_TZ', 'goog.i18n.DateTimePatterns_en_UG', 'goog.i18n.DateTimePatterns_en_UM', 'goog.i18n.DateTimePatterns_en_US_POSIX', 'goog.i18n.DateTimePatterns_en_VC', 'goog.i18n.DateTimePatterns_en_VG', 'goog.i18n.DateTimePatterns_en_VI', 'goog.i18n.DateTimePatterns_en_VU', 'goog.i18n.DateTimePatterns_en_WS', 'goog.i18n.DateTimePatterns_en_ZM', 'goog.i18n.DateTimePatterns_en_ZW', 'goog.i18n.DateTimePatterns_eo', 'goog.i18n.DateTimePatterns_es_AR', 'goog.i18n.DateTimePatterns_es_BO', 'goog.i18n.DateTimePatterns_es_CL', 'goog.i18n.DateTimePatterns_es_CO', 'goog.i18n.DateTimePatterns_es_CR', 'goog.i18n.DateTimePatterns_es_CU', 'goog.i18n.DateTimePatterns_es_DO', 'goog.i18n.DateTimePatterns_es_EA', 'goog.i18n.DateTimePatterns_es_EC', 'goog.i18n.DateTimePatterns_es_GQ', 'goog.i18n.DateTimePatterns_es_GT', 'goog.i18n.DateTimePatterns_es_HN', 'goog.i18n.DateTimePatterns_es_IC', 'goog.i18n.DateTimePatterns_es_MX', 'goog.i18n.DateTimePatterns_es_NI', 'goog.i18n.DateTimePatterns_es_PA', 'goog.i18n.DateTimePatterns_es_PE', 'goog.i18n.DateTimePatterns_es_PH', 'goog.i18n.DateTimePatterns_es_PR', 'goog.i18n.DateTimePatterns_es_PY', 'goog.i18n.DateTimePatterns_es_SV', 'goog.i18n.DateTimePatterns_es_US', 'goog.i18n.DateTimePatterns_es_UY', 'goog.i18n.DateTimePatterns_es_VE', 'goog.i18n.DateTimePatterns_et_EE', 'goog.i18n.DateTimePatterns_eu_ES', 'goog.i18n.DateTimePatterns_ewo', 'goog.i18n.DateTimePatterns_ewo_CM', 'goog.i18n.DateTimePatterns_fa_AF', 'goog.i18n.DateTimePatterns_fa_IR', 'goog.i18n.DateTimePatterns_ff', 'goog.i18n.DateTimePatterns_ff_SN', 'goog.i18n.DateTimePatterns_fi_FI', 'goog.i18n.DateTimePatterns_fil_PH', 'goog.i18n.DateTimePatterns_fo', 'goog.i18n.DateTimePatterns_fo_FO', 'goog.i18n.DateTimePatterns_fr_BE', 'goog.i18n.DateTimePatterns_fr_BF', 'goog.i18n.DateTimePatterns_fr_BI', 'goog.i18n.DateTimePatterns_fr_BJ', 'goog.i18n.DateTimePatterns_fr_BL', 'goog.i18n.DateTimePatterns_fr_CD', 'goog.i18n.DateTimePatterns_fr_CF', 'goog.i18n.DateTimePatterns_fr_CG', 'goog.i18n.DateTimePatterns_fr_CH', 'goog.i18n.DateTimePatterns_fr_CI', 'goog.i18n.DateTimePatterns_fr_CM', 'goog.i18n.DateTimePatterns_fr_DJ', 'goog.i18n.DateTimePatterns_fr_DZ', 'goog.i18n.DateTimePatterns_fr_FR', 'goog.i18n.DateTimePatterns_fr_GA', 'goog.i18n.DateTimePatterns_fr_GF', 'goog.i18n.DateTimePatterns_fr_GN', 'goog.i18n.DateTimePatterns_fr_GP', 'goog.i18n.DateTimePatterns_fr_GQ', 'goog.i18n.DateTimePatterns_fr_HT', 'goog.i18n.DateTimePatterns_fr_KM', 'goog.i18n.DateTimePatterns_fr_LU', 'goog.i18n.DateTimePatterns_fr_MA', 'goog.i18n.DateTimePatterns_fr_MC', 'goog.i18n.DateTimePatterns_fr_MF', 'goog.i18n.DateTimePatterns_fr_MG', 'goog.i18n.DateTimePatterns_fr_ML', 'goog.i18n.DateTimePatterns_fr_MQ', 'goog.i18n.DateTimePatterns_fr_MR', 'goog.i18n.DateTimePatterns_fr_MU', 'goog.i18n.DateTimePatterns_fr_NC', 'goog.i18n.DateTimePatterns_fr_NE', 'goog.i18n.DateTimePatterns_fr_PF', 'goog.i18n.DateTimePatterns_fr_RE', 'goog.i18n.DateTimePatterns_fr_RW', 'goog.i18n.DateTimePatterns_fr_SC', 'goog.i18n.DateTimePatterns_fr_SN', 'goog.i18n.DateTimePatterns_fr_SY', 'goog.i18n.DateTimePatterns_fr_TD', 'goog.i18n.DateTimePatterns_fr_TG', 'goog.i18n.DateTimePatterns_fr_TN', 'goog.i18n.DateTimePatterns_fr_VU', 'goog.i18n.DateTimePatterns_fr_YT', 'goog.i18n.DateTimePatterns_ga', 'goog.i18n.DateTimePatterns_ga_IE', 'goog.i18n.DateTimePatterns_gl_ES', 'goog.i18n.DateTimePatterns_gsw_CH', 'goog.i18n.DateTimePatterns_gu_IN', 'goog.i18n.DateTimePatterns_guz', 'goog.i18n.DateTimePatterns_guz_KE', 'goog.i18n.DateTimePatterns_gv', 'goog.i18n.DateTimePatterns_gv_GB', 'goog.i18n.DateTimePatterns_ha', 'goog.i18n.DateTimePatterns_ha_Latn', 'goog.i18n.DateTimePatterns_ha_Latn_GH', 'goog.i18n.DateTimePatterns_ha_Latn_NE', 'goog.i18n.DateTimePatterns_ha_Latn_NG', 'goog.i18n.DateTimePatterns_haw_US', 'goog.i18n.DateTimePatterns_he_IL', 'goog.i18n.DateTimePatterns_hi_IN', 'goog.i18n.DateTimePatterns_hr_BA', 'goog.i18n.DateTimePatterns_hr_HR', 'goog.i18n.DateTimePatterns_hu_HU', 'goog.i18n.DateTimePatterns_hy', 'goog.i18n.DateTimePatterns_hy_AM', 'goog.i18n.DateTimePatterns_id_ID', 'goog.i18n.DateTimePatterns_ig', 'goog.i18n.DateTimePatterns_ig_NG', 'goog.i18n.DateTimePatterns_ii', 'goog.i18n.DateTimePatterns_ii_CN', 'goog.i18n.DateTimePatterns_is_IS', 'goog.i18n.DateTimePatterns_it_CH', 'goog.i18n.DateTimePatterns_it_IT', 'goog.i18n.DateTimePatterns_it_SM', 'goog.i18n.DateTimePatterns_ja_JP', 'goog.i18n.DateTimePatterns_jgo', 'goog.i18n.DateTimePatterns_jgo_CM', 'goog.i18n.DateTimePatterns_jmc', 'goog.i18n.DateTimePatterns_jmc_TZ', 'goog.i18n.DateTimePatterns_ka', 'goog.i18n.DateTimePatterns_ka_GE', 'goog.i18n.DateTimePatterns_kab', 'goog.i18n.DateTimePatterns_kab_DZ', 'goog.i18n.DateTimePatterns_kam', 'goog.i18n.DateTimePatterns_kam_KE', 'goog.i18n.DateTimePatterns_kde', 'goog.i18n.DateTimePatterns_kde_TZ', 'goog.i18n.DateTimePatterns_kea', 'goog.i18n.DateTimePatterns_kea_CV', 'goog.i18n.DateTimePatterns_khq', 'goog.i18n.DateTimePatterns_khq_ML', 'goog.i18n.DateTimePatterns_ki', 'goog.i18n.DateTimePatterns_ki_KE', 'goog.i18n.DateTimePatterns_kk', 'goog.i18n.DateTimePatterns_kk_Cyrl', 'goog.i18n.DateTimePatterns_kk_Cyrl_KZ', 'goog.i18n.DateTimePatterns_kl', 'goog.i18n.DateTimePatterns_kl_GL', 'goog.i18n.DateTimePatterns_kln', 'goog.i18n.DateTimePatterns_kln_KE', 'goog.i18n.DateTimePatterns_km', 'goog.i18n.DateTimePatterns_km_KH', 'goog.i18n.DateTimePatterns_kn_IN', 'goog.i18n.DateTimePatterns_ko_KP', 'goog.i18n.DateTimePatterns_ko_KR', 'goog.i18n.DateTimePatterns_kok', 'goog.i18n.DateTimePatterns_kok_IN', 'goog.i18n.DateTimePatterns_ks', 'goog.i18n.DateTimePatterns_ks_Arab', 'goog.i18n.DateTimePatterns_ks_Arab_IN', 'goog.i18n.DateTimePatterns_ksb', 'goog.i18n.DateTimePatterns_ksb_TZ', 'goog.i18n.DateTimePatterns_ksf', 'goog.i18n.DateTimePatterns_ksf_CM', 'goog.i18n.DateTimePatterns_kw', 'goog.i18n.DateTimePatterns_kw_GB', 'goog.i18n.DateTimePatterns_lag', 'goog.i18n.DateTimePatterns_lag_TZ', 'goog.i18n.DateTimePatterns_lg', 'goog.i18n.DateTimePatterns_lg_UG', 'goog.i18n.DateTimePatterns_ln_AO', 'goog.i18n.DateTimePatterns_ln_CD', 'goog.i18n.DateTimePatterns_ln_CF', 'goog.i18n.DateTimePatterns_ln_CG', 'goog.i18n.DateTimePatterns_lo', 'goog.i18n.DateTimePatterns_lo_LA', 'goog.i18n.DateTimePatterns_lt_LT', 'goog.i18n.DateTimePatterns_lu', 'goog.i18n.DateTimePatterns_lu_CD', 'goog.i18n.DateTimePatterns_luo', 'goog.i18n.DateTimePatterns_luo_KE', 'goog.i18n.DateTimePatterns_luy', 'goog.i18n.DateTimePatterns_luy_KE', 'goog.i18n.DateTimePatterns_lv_LV', 'goog.i18n.DateTimePatterns_mas', 'goog.i18n.DateTimePatterns_mas_KE', 'goog.i18n.DateTimePatterns_mas_TZ', 'goog.i18n.DateTimePatterns_mer', 'goog.i18n.DateTimePatterns_mer_KE', 'goog.i18n.DateTimePatterns_mfe', 'goog.i18n.DateTimePatterns_mfe_MU', 'goog.i18n.DateTimePatterns_mg', 'goog.i18n.DateTimePatterns_mg_MG', 'goog.i18n.DateTimePatterns_mgh', 'goog.i18n.DateTimePatterns_mgh_MZ', 'goog.i18n.DateTimePatterns_mgo', 'goog.i18n.DateTimePatterns_mgo_CM', 'goog.i18n.DateTimePatterns_mk', 'goog.i18n.DateTimePatterns_mk_MK', 'goog.i18n.DateTimePatterns_ml_IN', 'goog.i18n.DateTimePatterns_mn', 'goog.i18n.DateTimePatterns_mn_Cyrl', 'goog.i18n.DateTimePatterns_mn_Cyrl_MN', 'goog.i18n.DateTimePatterns_mr_IN', 'goog.i18n.DateTimePatterns_ms_Latn', 'goog.i18n.DateTimePatterns_ms_Latn_BN', 'goog.i18n.DateTimePatterns_ms_Latn_MY', 'goog.i18n.DateTimePatterns_ms_Latn_SG', 'goog.i18n.DateTimePatterns_mt_MT', 'goog.i18n.DateTimePatterns_mua', 'goog.i18n.DateTimePatterns_mua_CM', 'goog.i18n.DateTimePatterns_my', 'goog.i18n.DateTimePatterns_my_MM', 'goog.i18n.DateTimePatterns_naq', 'goog.i18n.DateTimePatterns_naq_NA', 'goog.i18n.DateTimePatterns_nb_NO', 'goog.i18n.DateTimePatterns_nd', 'goog.i18n.DateTimePatterns_nd_ZW', 'goog.i18n.DateTimePatterns_ne', 'goog.i18n.DateTimePatterns_ne_IN', 'goog.i18n.DateTimePatterns_ne_NP', 'goog.i18n.DateTimePatterns_nl_AW', 'goog.i18n.DateTimePatterns_nl_BE', 'goog.i18n.DateTimePatterns_nl_CW', 'goog.i18n.DateTimePatterns_nl_NL', 'goog.i18n.DateTimePatterns_nl_SR', 'goog.i18n.DateTimePatterns_nl_SX', 'goog.i18n.DateTimePatterns_nmg', 'goog.i18n.DateTimePatterns_nmg_CM', 'goog.i18n.DateTimePatterns_nn', 'goog.i18n.DateTimePatterns_nn_NO', 'goog.i18n.DateTimePatterns_nus', 'goog.i18n.DateTimePatterns_nus_SD', 'goog.i18n.DateTimePatterns_nyn', 'goog.i18n.DateTimePatterns_nyn_UG', 'goog.i18n.DateTimePatterns_om', 'goog.i18n.DateTimePatterns_om_ET', 'goog.i18n.DateTimePatterns_om_KE', 'goog.i18n.DateTimePatterns_or_IN', 'goog.i18n.DateTimePatterns_pa', 'goog.i18n.DateTimePatterns_pa_Arab', 'goog.i18n.DateTimePatterns_pa_Arab_PK', 'goog.i18n.DateTimePatterns_pa_Guru', 'goog.i18n.DateTimePatterns_pa_Guru_IN', 'goog.i18n.DateTimePatterns_pl_PL', 'goog.i18n.DateTimePatterns_ps', 'goog.i18n.DateTimePatterns_ps_AF', 'goog.i18n.DateTimePatterns_pt_AO', 'goog.i18n.DateTimePatterns_pt_CV', 'goog.i18n.DateTimePatterns_pt_GW', 'goog.i18n.DateTimePatterns_pt_MO', 'goog.i18n.DateTimePatterns_pt_MZ', 'goog.i18n.DateTimePatterns_pt_ST', 'goog.i18n.DateTimePatterns_pt_TL', 'goog.i18n.DateTimePatterns_rm', 'goog.i18n.DateTimePatterns_rm_CH', 'goog.i18n.DateTimePatterns_rn', 'goog.i18n.DateTimePatterns_rn_BI', 'goog.i18n.DateTimePatterns_ro_MD', 'goog.i18n.DateTimePatterns_ro_RO', 'goog.i18n.DateTimePatterns_rof', 'goog.i18n.DateTimePatterns_rof_TZ', 'goog.i18n.DateTimePatterns_ru_BY', 'goog.i18n.DateTimePatterns_ru_KG', 'goog.i18n.DateTimePatterns_ru_KZ', 'goog.i18n.DateTimePatterns_ru_MD', 'goog.i18n.DateTimePatterns_ru_RU', 'goog.i18n.DateTimePatterns_ru_UA', 'goog.i18n.DateTimePatterns_rw', 'goog.i18n.DateTimePatterns_rw_RW', 'goog.i18n.DateTimePatterns_rwk', 'goog.i18n.DateTimePatterns_rwk_TZ', 'goog.i18n.DateTimePatterns_saq', 'goog.i18n.DateTimePatterns_saq_KE', 'goog.i18n.DateTimePatterns_sbp', 'goog.i18n.DateTimePatterns_sbp_TZ', 'goog.i18n.DateTimePatterns_seh', 'goog.i18n.DateTimePatterns_seh_MZ', 'goog.i18n.DateTimePatterns_ses', 'goog.i18n.DateTimePatterns_ses_ML', 'goog.i18n.DateTimePatterns_sg', 'goog.i18n.DateTimePatterns_sg_CF', 'goog.i18n.DateTimePatterns_shi', 'goog.i18n.DateTimePatterns_shi_Latn', 'goog.i18n.DateTimePatterns_shi_Latn_MA', 'goog.i18n.DateTimePatterns_shi_Tfng', 'goog.i18n.DateTimePatterns_shi_Tfng_MA', 'goog.i18n.DateTimePatterns_si', 'goog.i18n.DateTimePatterns_si_LK', 'goog.i18n.DateTimePatterns_sk_SK', 'goog.i18n.DateTimePatterns_sl_SI', 'goog.i18n.DateTimePatterns_sn', 'goog.i18n.DateTimePatterns_sn_ZW', 'goog.i18n.DateTimePatterns_so', 'goog.i18n.DateTimePatterns_so_DJ', 'goog.i18n.DateTimePatterns_so_ET', 'goog.i18n.DateTimePatterns_so_KE', 'goog.i18n.DateTimePatterns_so_SO', 'goog.i18n.DateTimePatterns_sq_AL', 'goog.i18n.DateTimePatterns_sq_MK', 'goog.i18n.DateTimePatterns_sr_Cyrl', 'goog.i18n.DateTimePatterns_sr_Cyrl_BA', 'goog.i18n.DateTimePatterns_sr_Cyrl_ME', 'goog.i18n.DateTimePatterns_sr_Cyrl_RS', 'goog.i18n.DateTimePatterns_sr_Latn', 'goog.i18n.DateTimePatterns_sr_Latn_BA', 'goog.i18n.DateTimePatterns_sr_Latn_ME', 'goog.i18n.DateTimePatterns_sr_Latn_RS', 'goog.i18n.DateTimePatterns_sv_AX', 'goog.i18n.DateTimePatterns_sv_FI', 'goog.i18n.DateTimePatterns_sv_SE', 'goog.i18n.DateTimePatterns_sw_KE', 'goog.i18n.DateTimePatterns_sw_TZ', 'goog.i18n.DateTimePatterns_sw_UG', 'goog.i18n.DateTimePatterns_swc', 'goog.i18n.DateTimePatterns_swc_CD', 'goog.i18n.DateTimePatterns_ta_IN', 'goog.i18n.DateTimePatterns_ta_LK', 'goog.i18n.DateTimePatterns_ta_MY', 'goog.i18n.DateTimePatterns_ta_SG', 'goog.i18n.DateTimePatterns_te_IN', 'goog.i18n.DateTimePatterns_teo', 'goog.i18n.DateTimePatterns_teo_KE', 'goog.i18n.DateTimePatterns_teo_UG', 'goog.i18n.DateTimePatterns_th_TH', 'goog.i18n.DateTimePatterns_ti', 'goog.i18n.DateTimePatterns_ti_ER', 'goog.i18n.DateTimePatterns_ti_ET', 'goog.i18n.DateTimePatterns_to', 'goog.i18n.DateTimePatterns_to_TO', 'goog.i18n.DateTimePatterns_tr_CY', 'goog.i18n.DateTimePatterns_tr_TR', 'goog.i18n.DateTimePatterns_twq', 'goog.i18n.DateTimePatterns_twq_NE', 'goog.i18n.DateTimePatterns_tzm', 'goog.i18n.DateTimePatterns_tzm_Latn', 'goog.i18n.DateTimePatterns_tzm_Latn_MA', 'goog.i18n.DateTimePatterns_uk_UA', 'goog.i18n.DateTimePatterns_ur_IN', 'goog.i18n.DateTimePatterns_ur_PK', 'goog.i18n.DateTimePatterns_uz', 'goog.i18n.DateTimePatterns_uz_Arab', 'goog.i18n.DateTimePatterns_uz_Arab_AF', 'goog.i18n.DateTimePatterns_uz_Cyrl', 'goog.i18n.DateTimePatterns_uz_Cyrl_UZ', 'goog.i18n.DateTimePatterns_uz_Latn', 'goog.i18n.DateTimePatterns_uz_Latn_UZ', 'goog.i18n.DateTimePatterns_vai', 'goog.i18n.DateTimePatterns_vai_Latn', 'goog.i18n.DateTimePatterns_vai_Latn_LR', 'goog.i18n.DateTimePatterns_vai_Vaii', 'goog.i18n.DateTimePatterns_vai_Vaii_LR', 'goog.i18n.DateTimePatterns_vi_VN', 'goog.i18n.DateTimePatterns_vun', 'goog.i18n.DateTimePatterns_vun_TZ', 'goog.i18n.DateTimePatterns_xog', 'goog.i18n.DateTimePatterns_xog_UG', 'goog.i18n.DateTimePatterns_yav', 'goog.i18n.DateTimePatterns_yav_CM', 'goog.i18n.DateTimePatterns_yo', 'goog.i18n.DateTimePatterns_yo_NG', 'goog.i18n.DateTimePatterns_zh_Hans', 'goog.i18n.DateTimePatterns_zh_Hans_CN', 'goog.i18n.DateTimePatterns_zh_Hans_HK', 'goog.i18n.DateTimePatterns_zh_Hans_MO', 'goog.i18n.DateTimePatterns_zh_Hans_SG', 'goog.i18n.DateTimePatterns_zh_Hant', 'goog.i18n.DateTimePatterns_zh_Hant_HK', 'goog.i18n.DateTimePatterns_zh_Hant_MO', 'goog.i18n.DateTimePatterns_zh_Hant_TW', 'goog.i18n.DateTimePatterns_zu_ZA'], ['goog.i18n.DateTimePatterns']);
goog.addDependency('i18n/datetimesymbols.js', ['goog.i18n.DateTimeSymbols', 'goog.i18n.DateTimeSymbols_af', 'goog.i18n.DateTimeSymbols_am', 'goog.i18n.DateTimeSymbols_ar', 'goog.i18n.DateTimeSymbols_bg', 'goog.i18n.DateTimeSymbols_bn', 'goog.i18n.DateTimeSymbols_br', 'goog.i18n.DateTimeSymbols_ca', 'goog.i18n.DateTimeSymbols_chr', 'goog.i18n.DateTimeSymbols_cs', 'goog.i18n.DateTimeSymbols_cy', 'goog.i18n.DateTimeSymbols_da', 'goog.i18n.DateTimeSymbols_de', 'goog.i18n.DateTimeSymbols_de_AT', 'goog.i18n.DateTimeSymbols_de_CH', 'goog.i18n.DateTimeSymbols_el', 'goog.i18n.DateTimeSymbols_en', 'goog.i18n.DateTimeSymbols_en_AU', 'goog.i18n.DateTimeSymbols_en_GB', 'goog.i18n.DateTimeSymbols_en_IE', 'goog.i18n.DateTimeSymbols_en_IN', 'goog.i18n.DateTimeSymbols_en_ISO', 'goog.i18n.DateTimeSymbols_en_SG', 'goog.i18n.DateTimeSymbols_en_US', 'goog.i18n.DateTimeSymbols_en_ZA', 'goog.i18n.DateTimeSymbols_es', 'goog.i18n.DateTimeSymbols_es_419', 'goog.i18n.DateTimeSymbols_es_ES', 'goog.i18n.DateTimeSymbols_et', 'goog.i18n.DateTimeSymbols_eu', 'goog.i18n.DateTimeSymbols_fa', 'goog.i18n.DateTimeSymbols_fi', 'goog.i18n.DateTimeSymbols_fil', 'goog.i18n.DateTimeSymbols_fr', 'goog.i18n.DateTimeSymbols_fr_CA', 'goog.i18n.DateTimeSymbols_gl', 'goog.i18n.DateTimeSymbols_gsw', 'goog.i18n.DateTimeSymbols_gu', 'goog.i18n.DateTimeSymbols_haw', 'goog.i18n.DateTimeSymbols_he', 'goog.i18n.DateTimeSymbols_hi', 'goog.i18n.DateTimeSymbols_hr', 'goog.i18n.DateTimeSymbols_hu', 'goog.i18n.DateTimeSymbols_id', 'goog.i18n.DateTimeSymbols_in', 'goog.i18n.DateTimeSymbols_is', 'goog.i18n.DateTimeSymbols_it', 'goog.i18n.DateTimeSymbols_iw', 'goog.i18n.DateTimeSymbols_ja', 'goog.i18n.DateTimeSymbols_kn', 'goog.i18n.DateTimeSymbols_ko', 'goog.i18n.DateTimeSymbols_ln', 'goog.i18n.DateTimeSymbols_lt', 'goog.i18n.DateTimeSymbols_lv', 'goog.i18n.DateTimeSymbols_ml', 'goog.i18n.DateTimeSymbols_mr', 'goog.i18n.DateTimeSymbols_ms', 'goog.i18n.DateTimeSymbols_mt', 'goog.i18n.DateTimeSymbols_nb', 'goog.i18n.DateTimeSymbols_nl', 'goog.i18n.DateTimeSymbols_no', 'goog.i18n.DateTimeSymbols_or', 'goog.i18n.DateTimeSymbols_pl', 'goog.i18n.DateTimeSymbols_pt', 'goog.i18n.DateTimeSymbols_pt_BR', 'goog.i18n.DateTimeSymbols_pt_PT', 'goog.i18n.DateTimeSymbols_ro', 'goog.i18n.DateTimeSymbols_ru', 'goog.i18n.DateTimeSymbols_sk', 'goog.i18n.DateTimeSymbols_sl', 'goog.i18n.DateTimeSymbols_sq', 'goog.i18n.DateTimeSymbols_sr', 'goog.i18n.DateTimeSymbols_sv', 'goog.i18n.DateTimeSymbols_sw', 'goog.i18n.DateTimeSymbols_ta', 'goog.i18n.DateTimeSymbols_te', 'goog.i18n.DateTimeSymbols_th', 'goog.i18n.DateTimeSymbols_tl', 'goog.i18n.DateTimeSymbols_tr', 'goog.i18n.DateTimeSymbols_uk', 'goog.i18n.DateTimeSymbols_ur', 'goog.i18n.DateTimeSymbols_vi', 'goog.i18n.DateTimeSymbols_zh', 'goog.i18n.DateTimeSymbols_zh_CN', 'goog.i18n.DateTimeSymbols_zh_HK', 'goog.i18n.DateTimeSymbols_zh_TW', 'goog.i18n.DateTimeSymbols_zu'], []);
goog.addDependency('i18n/datetimesymbolsext.js', ['goog.i18n.DateTimeSymbolsExt', 'goog.i18n.DateTimeSymbols_aa', 'goog.i18n.DateTimeSymbols_aa_DJ', 'goog.i18n.DateTimeSymbols_aa_ER', 'goog.i18n.DateTimeSymbols_aa_ET', 'goog.i18n.DateTimeSymbols_af_NA', 'goog.i18n.DateTimeSymbols_af_ZA', 'goog.i18n.DateTimeSymbols_agq', 'goog.i18n.DateTimeSymbols_agq_CM', 'goog.i18n.DateTimeSymbols_ak', 'goog.i18n.DateTimeSymbols_ak_GH', 'goog.i18n.DateTimeSymbols_am_ET', 'goog.i18n.DateTimeSymbols_ar_001', 'goog.i18n.DateTimeSymbols_ar_AE', 'goog.i18n.DateTimeSymbols_ar_BH', 'goog.i18n.DateTimeSymbols_ar_DJ', 'goog.i18n.DateTimeSymbols_ar_DZ', 'goog.i18n.DateTimeSymbols_ar_EG', 'goog.i18n.DateTimeSymbols_ar_EH', 'goog.i18n.DateTimeSymbols_ar_ER', 'goog.i18n.DateTimeSymbols_ar_IL', 'goog.i18n.DateTimeSymbols_ar_IQ', 'goog.i18n.DateTimeSymbols_ar_JO', 'goog.i18n.DateTimeSymbols_ar_KM', 'goog.i18n.DateTimeSymbols_ar_KW', 'goog.i18n.DateTimeSymbols_ar_LB', 'goog.i18n.DateTimeSymbols_ar_LY', 'goog.i18n.DateTimeSymbols_ar_MA', 'goog.i18n.DateTimeSymbols_ar_MR', 'goog.i18n.DateTimeSymbols_ar_OM', 'goog.i18n.DateTimeSymbols_ar_PS', 'goog.i18n.DateTimeSymbols_ar_QA', 'goog.i18n.DateTimeSymbols_ar_SA', 'goog.i18n.DateTimeSymbols_ar_SD', 'goog.i18n.DateTimeSymbols_ar_SO', 'goog.i18n.DateTimeSymbols_ar_SY', 'goog.i18n.DateTimeSymbols_ar_TD', 'goog.i18n.DateTimeSymbols_ar_TN', 'goog.i18n.DateTimeSymbols_ar_YE', 'goog.i18n.DateTimeSymbols_as', 'goog.i18n.DateTimeSymbols_as_IN', 'goog.i18n.DateTimeSymbols_asa', 'goog.i18n.DateTimeSymbols_asa_TZ', 'goog.i18n.DateTimeSymbols_ast', 'goog.i18n.DateTimeSymbols_ast_ES', 'goog.i18n.DateTimeSymbols_az', 'goog.i18n.DateTimeSymbols_az_Cyrl', 'goog.i18n.DateTimeSymbols_az_Cyrl_AZ', 'goog.i18n.DateTimeSymbols_az_Latn', 'goog.i18n.DateTimeSymbols_az_Latn_AZ', 'goog.i18n.DateTimeSymbols_bas', 'goog.i18n.DateTimeSymbols_bas_CM', 'goog.i18n.DateTimeSymbols_be', 'goog.i18n.DateTimeSymbols_be_BY', 'goog.i18n.DateTimeSymbols_bem', 'goog.i18n.DateTimeSymbols_bem_ZM', 'goog.i18n.DateTimeSymbols_bez', 'goog.i18n.DateTimeSymbols_bez_TZ', 'goog.i18n.DateTimeSymbols_bg_BG', 'goog.i18n.DateTimeSymbols_bm', 'goog.i18n.DateTimeSymbols_bm_ML', 'goog.i18n.DateTimeSymbols_bn_BD', 'goog.i18n.DateTimeSymbols_bn_IN', 'goog.i18n.DateTimeSymbols_bo', 'goog.i18n.DateTimeSymbols_bo_CN', 'goog.i18n.DateTimeSymbols_bo_IN', 'goog.i18n.DateTimeSymbols_br_FR', 'goog.i18n.DateTimeSymbols_brx', 'goog.i18n.DateTimeSymbols_brx_IN', 'goog.i18n.DateTimeSymbols_bs', 'goog.i18n.DateTimeSymbols_bs_Cyrl', 'goog.i18n.DateTimeSymbols_bs_Cyrl_BA', 'goog.i18n.DateTimeSymbols_bs_Latn', 'goog.i18n.DateTimeSymbols_bs_Latn_BA', 'goog.i18n.DateTimeSymbols_byn', 'goog.i18n.DateTimeSymbols_byn_ER', 'goog.i18n.DateTimeSymbols_ca_AD', 'goog.i18n.DateTimeSymbols_ca_ES', 'goog.i18n.DateTimeSymbols_cgg', 'goog.i18n.DateTimeSymbols_cgg_UG', 'goog.i18n.DateTimeSymbols_chr_US', 'goog.i18n.DateTimeSymbols_ckb', 'goog.i18n.DateTimeSymbols_ckb_Arab', 'goog.i18n.DateTimeSymbols_ckb_Arab_IQ', 'goog.i18n.DateTimeSymbols_ckb_Arab_IR', 'goog.i18n.DateTimeSymbols_ckb_IQ', 'goog.i18n.DateTimeSymbols_ckb_IR', 'goog.i18n.DateTimeSymbols_ckb_Latn', 'goog.i18n.DateTimeSymbols_ckb_Latn_IQ', 'goog.i18n.DateTimeSymbols_cs_CZ', 'goog.i18n.DateTimeSymbols_cy_GB', 'goog.i18n.DateTimeSymbols_da_DK', 'goog.i18n.DateTimeSymbols_dav', 'goog.i18n.DateTimeSymbols_dav_KE', 'goog.i18n.DateTimeSymbols_de_BE', 'goog.i18n.DateTimeSymbols_de_DE', 'goog.i18n.DateTimeSymbols_de_LI', 'goog.i18n.DateTimeSymbols_de_LU', 'goog.i18n.DateTimeSymbols_dje', 'goog.i18n.DateTimeSymbols_dje_NE', 'goog.i18n.DateTimeSymbols_dua', 'goog.i18n.DateTimeSymbols_dua_CM', 'goog.i18n.DateTimeSymbols_dyo', 'goog.i18n.DateTimeSymbols_dyo_SN', 'goog.i18n.DateTimeSymbols_dz', 'goog.i18n.DateTimeSymbols_dz_BT', 'goog.i18n.DateTimeSymbols_ebu', 'goog.i18n.DateTimeSymbols_ebu_KE', 'goog.i18n.DateTimeSymbols_ee', 'goog.i18n.DateTimeSymbols_ee_GH', 'goog.i18n.DateTimeSymbols_ee_TG', 'goog.i18n.DateTimeSymbols_el_CY', 'goog.i18n.DateTimeSymbols_el_GR', 'goog.i18n.DateTimeSymbols_en_150', 'goog.i18n.DateTimeSymbols_en_AG', 'goog.i18n.DateTimeSymbols_en_AS', 'goog.i18n.DateTimeSymbols_en_BB', 'goog.i18n.DateTimeSymbols_en_BE', 'goog.i18n.DateTimeSymbols_en_BM', 'goog.i18n.DateTimeSymbols_en_BS', 'goog.i18n.DateTimeSymbols_en_BW', 'goog.i18n.DateTimeSymbols_en_BZ', 'goog.i18n.DateTimeSymbols_en_CA', 'goog.i18n.DateTimeSymbols_en_CM', 'goog.i18n.DateTimeSymbols_en_DM', 'goog.i18n.DateTimeSymbols_en_Dsrt', 'goog.i18n.DateTimeSymbols_en_Dsrt_US', 'goog.i18n.DateTimeSymbols_en_FJ', 'goog.i18n.DateTimeSymbols_en_FM', 'goog.i18n.DateTimeSymbols_en_GD', 'goog.i18n.DateTimeSymbols_en_GG', 'goog.i18n.DateTimeSymbols_en_GH', 'goog.i18n.DateTimeSymbols_en_GI', 'goog.i18n.DateTimeSymbols_en_GM', 'goog.i18n.DateTimeSymbols_en_GU', 'goog.i18n.DateTimeSymbols_en_GY', 'goog.i18n.DateTimeSymbols_en_HK', 'goog.i18n.DateTimeSymbols_en_IM', 'goog.i18n.DateTimeSymbols_en_JE', 'goog.i18n.DateTimeSymbols_en_JM', 'goog.i18n.DateTimeSymbols_en_KE', 'goog.i18n.DateTimeSymbols_en_KI', 'goog.i18n.DateTimeSymbols_en_KN', 'goog.i18n.DateTimeSymbols_en_KY', 'goog.i18n.DateTimeSymbols_en_LC', 'goog.i18n.DateTimeSymbols_en_LR', 'goog.i18n.DateTimeSymbols_en_LS', 'goog.i18n.DateTimeSymbols_en_MG', 'goog.i18n.DateTimeSymbols_en_MH', 'goog.i18n.DateTimeSymbols_en_MP', 'goog.i18n.DateTimeSymbols_en_MT', 'goog.i18n.DateTimeSymbols_en_MU', 'goog.i18n.DateTimeSymbols_en_MW', 'goog.i18n.DateTimeSymbols_en_NA', 'goog.i18n.DateTimeSymbols_en_NG', 'goog.i18n.DateTimeSymbols_en_NZ', 'goog.i18n.DateTimeSymbols_en_PG', 'goog.i18n.DateTimeSymbols_en_PH', 'goog.i18n.DateTimeSymbols_en_PK', 'goog.i18n.DateTimeSymbols_en_PR', 'goog.i18n.DateTimeSymbols_en_PW', 'goog.i18n.DateTimeSymbols_en_SB', 'goog.i18n.DateTimeSymbols_en_SC', 'goog.i18n.DateTimeSymbols_en_SL', 'goog.i18n.DateTimeSymbols_en_SS', 'goog.i18n.DateTimeSymbols_en_SZ', 'goog.i18n.DateTimeSymbols_en_TC', 'goog.i18n.DateTimeSymbols_en_TO', 'goog.i18n.DateTimeSymbols_en_TT', 'goog.i18n.DateTimeSymbols_en_TZ', 'goog.i18n.DateTimeSymbols_en_UG', 'goog.i18n.DateTimeSymbols_en_UM', 'goog.i18n.DateTimeSymbols_en_VC', 'goog.i18n.DateTimeSymbols_en_VG', 'goog.i18n.DateTimeSymbols_en_VI', 'goog.i18n.DateTimeSymbols_en_VU', 'goog.i18n.DateTimeSymbols_en_WS', 'goog.i18n.DateTimeSymbols_en_ZM', 'goog.i18n.DateTimeSymbols_en_ZW', 'goog.i18n.DateTimeSymbols_eo', 'goog.i18n.DateTimeSymbols_es_AR', 'goog.i18n.DateTimeSymbols_es_BO', 'goog.i18n.DateTimeSymbols_es_CL', 'goog.i18n.DateTimeSymbols_es_CO', 'goog.i18n.DateTimeSymbols_es_CR', 'goog.i18n.DateTimeSymbols_es_CU', 'goog.i18n.DateTimeSymbols_es_DO', 'goog.i18n.DateTimeSymbols_es_EA', 'goog.i18n.DateTimeSymbols_es_EC', 'goog.i18n.DateTimeSymbols_es_GQ', 'goog.i18n.DateTimeSymbols_es_GT', 'goog.i18n.DateTimeSymbols_es_HN', 'goog.i18n.DateTimeSymbols_es_IC', 'goog.i18n.DateTimeSymbols_es_MX', 'goog.i18n.DateTimeSymbols_es_NI', 'goog.i18n.DateTimeSymbols_es_PA', 'goog.i18n.DateTimeSymbols_es_PE', 'goog.i18n.DateTimeSymbols_es_PH', 'goog.i18n.DateTimeSymbols_es_PR', 'goog.i18n.DateTimeSymbols_es_PY', 'goog.i18n.DateTimeSymbols_es_SV', 'goog.i18n.DateTimeSymbols_es_US', 'goog.i18n.DateTimeSymbols_es_UY', 'goog.i18n.DateTimeSymbols_es_VE', 'goog.i18n.DateTimeSymbols_et_EE', 'goog.i18n.DateTimeSymbols_eu_ES', 'goog.i18n.DateTimeSymbols_ewo', 'goog.i18n.DateTimeSymbols_ewo_CM', 'goog.i18n.DateTimeSymbols_fa_AF', 'goog.i18n.DateTimeSymbols_fa_IR', 'goog.i18n.DateTimeSymbols_ff', 'goog.i18n.DateTimeSymbols_ff_SN', 'goog.i18n.DateTimeSymbols_fi_FI', 'goog.i18n.DateTimeSymbols_fil_PH', 'goog.i18n.DateTimeSymbols_fo', 'goog.i18n.DateTimeSymbols_fo_FO', 'goog.i18n.DateTimeSymbols_fr_BE', 'goog.i18n.DateTimeSymbols_fr_BF', 'goog.i18n.DateTimeSymbols_fr_BI', 'goog.i18n.DateTimeSymbols_fr_BJ', 'goog.i18n.DateTimeSymbols_fr_BL', 'goog.i18n.DateTimeSymbols_fr_CD', 'goog.i18n.DateTimeSymbols_fr_CF', 'goog.i18n.DateTimeSymbols_fr_CG', 'goog.i18n.DateTimeSymbols_fr_CH', 'goog.i18n.DateTimeSymbols_fr_CI', 'goog.i18n.DateTimeSymbols_fr_CM', 'goog.i18n.DateTimeSymbols_fr_DJ', 'goog.i18n.DateTimeSymbols_fr_DZ', 'goog.i18n.DateTimeSymbols_fr_FR', 'goog.i18n.DateTimeSymbols_fr_GA', 'goog.i18n.DateTimeSymbols_fr_GF', 'goog.i18n.DateTimeSymbols_fr_GN', 'goog.i18n.DateTimeSymbols_fr_GP', 'goog.i18n.DateTimeSymbols_fr_GQ', 'goog.i18n.DateTimeSymbols_fr_HT', 'goog.i18n.DateTimeSymbols_fr_KM', 'goog.i18n.DateTimeSymbols_fr_LU', 'goog.i18n.DateTimeSymbols_fr_MA', 'goog.i18n.DateTimeSymbols_fr_MC', 'goog.i18n.DateTimeSymbols_fr_MF', 'goog.i18n.DateTimeSymbols_fr_MG', 'goog.i18n.DateTimeSymbols_fr_ML', 'goog.i18n.DateTimeSymbols_fr_MQ', 'goog.i18n.DateTimeSymbols_fr_MR', 'goog.i18n.DateTimeSymbols_fr_MU', 'goog.i18n.DateTimeSymbols_fr_NC', 'goog.i18n.DateTimeSymbols_fr_NE', 'goog.i18n.DateTimeSymbols_fr_PF', 'goog.i18n.DateTimeSymbols_fr_RE', 'goog.i18n.DateTimeSymbols_fr_RW', 'goog.i18n.DateTimeSymbols_fr_SC', 'goog.i18n.DateTimeSymbols_fr_SN', 'goog.i18n.DateTimeSymbols_fr_SY', 'goog.i18n.DateTimeSymbols_fr_TD', 'goog.i18n.DateTimeSymbols_fr_TG', 'goog.i18n.DateTimeSymbols_fr_TN', 'goog.i18n.DateTimeSymbols_fr_VU', 'goog.i18n.DateTimeSymbols_fr_YT', 'goog.i18n.DateTimeSymbols_fur', 'goog.i18n.DateTimeSymbols_fur_IT', 'goog.i18n.DateTimeSymbols_ga', 'goog.i18n.DateTimeSymbols_ga_IE', 'goog.i18n.DateTimeSymbols_gd', 'goog.i18n.DateTimeSymbols_gd_GB', 'goog.i18n.DateTimeSymbols_gl_ES', 'goog.i18n.DateTimeSymbols_gsw_CH', 'goog.i18n.DateTimeSymbols_gu_IN', 'goog.i18n.DateTimeSymbols_guz', 'goog.i18n.DateTimeSymbols_guz_KE', 'goog.i18n.DateTimeSymbols_gv', 'goog.i18n.DateTimeSymbols_gv_GB', 'goog.i18n.DateTimeSymbols_ha', 'goog.i18n.DateTimeSymbols_ha_Latn', 'goog.i18n.DateTimeSymbols_ha_Latn_GH', 'goog.i18n.DateTimeSymbols_ha_Latn_NE', 'goog.i18n.DateTimeSymbols_ha_Latn_NG', 'goog.i18n.DateTimeSymbols_haw_US', 'goog.i18n.DateTimeSymbols_he_IL', 'goog.i18n.DateTimeSymbols_hi_IN', 'goog.i18n.DateTimeSymbols_hr_BA', 'goog.i18n.DateTimeSymbols_hr_HR', 'goog.i18n.DateTimeSymbols_hu_HU', 'goog.i18n.DateTimeSymbols_hy', 'goog.i18n.DateTimeSymbols_hy_AM', 'goog.i18n.DateTimeSymbols_ia', 'goog.i18n.DateTimeSymbols_ia_FR', 'goog.i18n.DateTimeSymbols_id_ID', 'goog.i18n.DateTimeSymbols_ig', 'goog.i18n.DateTimeSymbols_ig_NG', 'goog.i18n.DateTimeSymbols_ii', 'goog.i18n.DateTimeSymbols_ii_CN', 'goog.i18n.DateTimeSymbols_is_IS', 'goog.i18n.DateTimeSymbols_it_CH', 'goog.i18n.DateTimeSymbols_it_IT', 'goog.i18n.DateTimeSymbols_it_SM', 'goog.i18n.DateTimeSymbols_ja_JP', 'goog.i18n.DateTimeSymbols_jgo', 'goog.i18n.DateTimeSymbols_jgo_CM', 'goog.i18n.DateTimeSymbols_jmc', 'goog.i18n.DateTimeSymbols_jmc_TZ', 'goog.i18n.DateTimeSymbols_ka', 'goog.i18n.DateTimeSymbols_ka_GE', 'goog.i18n.DateTimeSymbols_kab', 'goog.i18n.DateTimeSymbols_kab_DZ', 'goog.i18n.DateTimeSymbols_kam', 'goog.i18n.DateTimeSymbols_kam_KE', 'goog.i18n.DateTimeSymbols_kde', 'goog.i18n.DateTimeSymbols_kde_TZ', 'goog.i18n.DateTimeSymbols_kea', 'goog.i18n.DateTimeSymbols_kea_CV', 'goog.i18n.DateTimeSymbols_khq', 'goog.i18n.DateTimeSymbols_khq_ML', 'goog.i18n.DateTimeSymbols_ki', 'goog.i18n.DateTimeSymbols_ki_KE', 'goog.i18n.DateTimeSymbols_kk', 'goog.i18n.DateTimeSymbols_kk_Cyrl', 'goog.i18n.DateTimeSymbols_kk_Cyrl_KZ', 'goog.i18n.DateTimeSymbols_kkj', 'goog.i18n.DateTimeSymbols_kkj_CM', 'goog.i18n.DateTimeSymbols_kl', 'goog.i18n.DateTimeSymbols_kl_GL', 'goog.i18n.DateTimeSymbols_kln', 'goog.i18n.DateTimeSymbols_kln_KE', 'goog.i18n.DateTimeSymbols_km', 'goog.i18n.DateTimeSymbols_km_KH', 'goog.i18n.DateTimeSymbols_kn_IN', 'goog.i18n.DateTimeSymbols_ko_KP', 'goog.i18n.DateTimeSymbols_ko_KR', 'goog.i18n.DateTimeSymbols_kok', 'goog.i18n.DateTimeSymbols_kok_IN', 'goog.i18n.DateTimeSymbols_ks', 'goog.i18n.DateTimeSymbols_ks_Arab', 'goog.i18n.DateTimeSymbols_ks_Arab_IN', 'goog.i18n.DateTimeSymbols_ksb', 'goog.i18n.DateTimeSymbols_ksb_TZ', 'goog.i18n.DateTimeSymbols_ksf', 'goog.i18n.DateTimeSymbols_ksf_CM', 'goog.i18n.DateTimeSymbols_ksh', 'goog.i18n.DateTimeSymbols_ksh_DE', 'goog.i18n.DateTimeSymbols_kw', 'goog.i18n.DateTimeSymbols_kw_GB', 'goog.i18n.DateTimeSymbols_ky', 'goog.i18n.DateTimeSymbols_ky_KG', 'goog.i18n.DateTimeSymbols_lag', 'goog.i18n.DateTimeSymbols_lag_TZ', 'goog.i18n.DateTimeSymbols_lg', 'goog.i18n.DateTimeSymbols_lg_UG', 'goog.i18n.DateTimeSymbols_ln_AO', 'goog.i18n.DateTimeSymbols_ln_CD', 'goog.i18n.DateTimeSymbols_ln_CF', 'goog.i18n.DateTimeSymbols_ln_CG', 'goog.i18n.DateTimeSymbols_lo', 'goog.i18n.DateTimeSymbols_lo_LA', 'goog.i18n.DateTimeSymbols_lt_LT', 'goog.i18n.DateTimeSymbols_lu', 'goog.i18n.DateTimeSymbols_lu_CD', 'goog.i18n.DateTimeSymbols_luo', 'goog.i18n.DateTimeSymbols_luo_KE', 'goog.i18n.DateTimeSymbols_luy', 'goog.i18n.DateTimeSymbols_luy_KE', 'goog.i18n.DateTimeSymbols_lv_LV', 'goog.i18n.DateTimeSymbols_mas', 'goog.i18n.DateTimeSymbols_mas_KE', 'goog.i18n.DateTimeSymbols_mas_TZ', 'goog.i18n.DateTimeSymbols_mer', 'goog.i18n.DateTimeSymbols_mer_KE', 'goog.i18n.DateTimeSymbols_mfe', 'goog.i18n.DateTimeSymbols_mfe_MU', 'goog.i18n.DateTimeSymbols_mg', 'goog.i18n.DateTimeSymbols_mg_MG', 'goog.i18n.DateTimeSymbols_mgh', 'goog.i18n.DateTimeSymbols_mgh_MZ', 'goog.i18n.DateTimeSymbols_mgo', 'goog.i18n.DateTimeSymbols_mgo_CM', 'goog.i18n.DateTimeSymbols_mk', 'goog.i18n.DateTimeSymbols_mk_MK', 'goog.i18n.DateTimeSymbols_ml_IN', 'goog.i18n.DateTimeSymbols_mn', 'goog.i18n.DateTimeSymbols_mn_Cyrl', 'goog.i18n.DateTimeSymbols_mn_Cyrl_MN', 'goog.i18n.DateTimeSymbols_mr_IN', 'goog.i18n.DateTimeSymbols_ms_Latn', 'goog.i18n.DateTimeSymbols_ms_Latn_BN', 'goog.i18n.DateTimeSymbols_ms_Latn_MY', 'goog.i18n.DateTimeSymbols_ms_Latn_SG', 'goog.i18n.DateTimeSymbols_mt_MT', 'goog.i18n.DateTimeSymbols_mua', 'goog.i18n.DateTimeSymbols_mua_CM', 'goog.i18n.DateTimeSymbols_my', 'goog.i18n.DateTimeSymbols_my_MM', 'goog.i18n.DateTimeSymbols_naq', 'goog.i18n.DateTimeSymbols_naq_NA', 'goog.i18n.DateTimeSymbols_nb_NO', 'goog.i18n.DateTimeSymbols_nd', 'goog.i18n.DateTimeSymbols_nd_ZW', 'goog.i18n.DateTimeSymbols_ne', 'goog.i18n.DateTimeSymbols_ne_IN', 'goog.i18n.DateTimeSymbols_ne_NP', 'goog.i18n.DateTimeSymbols_nl_AW', 'goog.i18n.DateTimeSymbols_nl_BE', 'goog.i18n.DateTimeSymbols_nl_CW', 'goog.i18n.DateTimeSymbols_nl_NL', 'goog.i18n.DateTimeSymbols_nl_SR', 'goog.i18n.DateTimeSymbols_nl_SX', 'goog.i18n.DateTimeSymbols_nmg', 'goog.i18n.DateTimeSymbols_nmg_CM', 'goog.i18n.DateTimeSymbols_nn', 'goog.i18n.DateTimeSymbols_nn_NO', 'goog.i18n.DateTimeSymbols_nnh', 'goog.i18n.DateTimeSymbols_nnh_CM', 'goog.i18n.DateTimeSymbols_nr', 'goog.i18n.DateTimeSymbols_nr_ZA', 'goog.i18n.DateTimeSymbols_nso', 'goog.i18n.DateTimeSymbols_nso_ZA', 'goog.i18n.DateTimeSymbols_nus', 'goog.i18n.DateTimeSymbols_nus_SD', 'goog.i18n.DateTimeSymbols_nyn', 'goog.i18n.DateTimeSymbols_nyn_UG', 'goog.i18n.DateTimeSymbols_om', 'goog.i18n.DateTimeSymbols_om_ET', 'goog.i18n.DateTimeSymbols_om_KE', 'goog.i18n.DateTimeSymbols_or_IN', 'goog.i18n.DateTimeSymbols_os', 'goog.i18n.DateTimeSymbols_os_GE', 'goog.i18n.DateTimeSymbols_os_RU', 'goog.i18n.DateTimeSymbols_pa', 'goog.i18n.DateTimeSymbols_pa_Arab', 'goog.i18n.DateTimeSymbols_pa_Arab_PK', 'goog.i18n.DateTimeSymbols_pa_Guru', 'goog.i18n.DateTimeSymbols_pa_Guru_IN', 'goog.i18n.DateTimeSymbols_pl_PL', 'goog.i18n.DateTimeSymbols_ps', 'goog.i18n.DateTimeSymbols_ps_AF', 'goog.i18n.DateTimeSymbols_pt_AO', 'goog.i18n.DateTimeSymbols_pt_CV', 'goog.i18n.DateTimeSymbols_pt_GW', 'goog.i18n.DateTimeSymbols_pt_MO', 'goog.i18n.DateTimeSymbols_pt_MZ', 'goog.i18n.DateTimeSymbols_pt_ST', 'goog.i18n.DateTimeSymbols_pt_TL', 'goog.i18n.DateTimeSymbols_rm', 'goog.i18n.DateTimeSymbols_rm_CH', 'goog.i18n.DateTimeSymbols_rn', 'goog.i18n.DateTimeSymbols_rn_BI', 'goog.i18n.DateTimeSymbols_ro_MD', 'goog.i18n.DateTimeSymbols_ro_RO', 'goog.i18n.DateTimeSymbols_rof', 'goog.i18n.DateTimeSymbols_rof_TZ', 'goog.i18n.DateTimeSymbols_ru_BY', 'goog.i18n.DateTimeSymbols_ru_KG', 'goog.i18n.DateTimeSymbols_ru_KZ', 'goog.i18n.DateTimeSymbols_ru_MD', 'goog.i18n.DateTimeSymbols_ru_RU', 'goog.i18n.DateTimeSymbols_ru_UA', 'goog.i18n.DateTimeSymbols_rw', 'goog.i18n.DateTimeSymbols_rw_RW', 'goog.i18n.DateTimeSymbols_rwk', 'goog.i18n.DateTimeSymbols_rwk_TZ', 'goog.i18n.DateTimeSymbols_sah', 'goog.i18n.DateTimeSymbols_sah_RU', 'goog.i18n.DateTimeSymbols_saq', 'goog.i18n.DateTimeSymbols_saq_KE', 'goog.i18n.DateTimeSymbols_sbp', 'goog.i18n.DateTimeSymbols_sbp_TZ', 'goog.i18n.DateTimeSymbols_se', 'goog.i18n.DateTimeSymbols_se_FI', 'goog.i18n.DateTimeSymbols_se_NO', 'goog.i18n.DateTimeSymbols_seh', 'goog.i18n.DateTimeSymbols_seh_MZ', 'goog.i18n.DateTimeSymbols_ses', 'goog.i18n.DateTimeSymbols_ses_ML', 'goog.i18n.DateTimeSymbols_sg', 'goog.i18n.DateTimeSymbols_sg_CF', 'goog.i18n.DateTimeSymbols_shi', 'goog.i18n.DateTimeSymbols_shi_Latn', 'goog.i18n.DateTimeSymbols_shi_Latn_MA', 'goog.i18n.DateTimeSymbols_shi_Tfng', 'goog.i18n.DateTimeSymbols_shi_Tfng_MA', 'goog.i18n.DateTimeSymbols_si', 'goog.i18n.DateTimeSymbols_si_LK', 'goog.i18n.DateTimeSymbols_sk_SK', 'goog.i18n.DateTimeSymbols_sl_SI', 'goog.i18n.DateTimeSymbols_sn', 'goog.i18n.DateTimeSymbols_sn_ZW', 'goog.i18n.DateTimeSymbols_so', 'goog.i18n.DateTimeSymbols_so_DJ', 'goog.i18n.DateTimeSymbols_so_ET', 'goog.i18n.DateTimeSymbols_so_KE', 'goog.i18n.DateTimeSymbols_so_SO', 'goog.i18n.DateTimeSymbols_sq_AL', 'goog.i18n.DateTimeSymbols_sq_MK', 'goog.i18n.DateTimeSymbols_sq_XK', 'goog.i18n.DateTimeSymbols_sr_Cyrl', 'goog.i18n.DateTimeSymbols_sr_Cyrl_BA', 'goog.i18n.DateTimeSymbols_sr_Cyrl_ME', 'goog.i18n.DateTimeSymbols_sr_Cyrl_RS', 'goog.i18n.DateTimeSymbols_sr_Cyrl_XK', 'goog.i18n.DateTimeSymbols_sr_Latn', 'goog.i18n.DateTimeSymbols_sr_Latn_BA', 'goog.i18n.DateTimeSymbols_sr_Latn_ME', 'goog.i18n.DateTimeSymbols_sr_Latn_RS', 'goog.i18n.DateTimeSymbols_sr_Latn_XK', 'goog.i18n.DateTimeSymbols_ss', 'goog.i18n.DateTimeSymbols_ss_SZ', 'goog.i18n.DateTimeSymbols_ss_ZA', 'goog.i18n.DateTimeSymbols_ssy', 'goog.i18n.DateTimeSymbols_ssy_ER', 'goog.i18n.DateTimeSymbols_st', 'goog.i18n.DateTimeSymbols_st_LS', 'goog.i18n.DateTimeSymbols_st_ZA', 'goog.i18n.DateTimeSymbols_sv_AX', 'goog.i18n.DateTimeSymbols_sv_FI', 'goog.i18n.DateTimeSymbols_sv_SE', 'goog.i18n.DateTimeSymbols_sw_KE', 'goog.i18n.DateTimeSymbols_sw_TZ', 'goog.i18n.DateTimeSymbols_sw_UG', 'goog.i18n.DateTimeSymbols_swc', 'goog.i18n.DateTimeSymbols_swc_CD', 'goog.i18n.DateTimeSymbols_ta_IN', 'goog.i18n.DateTimeSymbols_ta_LK', 'goog.i18n.DateTimeSymbols_ta_MY', 'goog.i18n.DateTimeSymbols_ta_SG', 'goog.i18n.DateTimeSymbols_te_IN', 'goog.i18n.DateTimeSymbols_teo', 'goog.i18n.DateTimeSymbols_teo_KE', 'goog.i18n.DateTimeSymbols_teo_UG', 'goog.i18n.DateTimeSymbols_tg', 'goog.i18n.DateTimeSymbols_tg_Cyrl', 'goog.i18n.DateTimeSymbols_tg_Cyrl_TJ', 'goog.i18n.DateTimeSymbols_th_TH', 'goog.i18n.DateTimeSymbols_ti', 'goog.i18n.DateTimeSymbols_ti_ER', 'goog.i18n.DateTimeSymbols_ti_ET', 'goog.i18n.DateTimeSymbols_tig', 'goog.i18n.DateTimeSymbols_tig_ER', 'goog.i18n.DateTimeSymbols_tn', 'goog.i18n.DateTimeSymbols_tn_BW', 'goog.i18n.DateTimeSymbols_tn_ZA', 'goog.i18n.DateTimeSymbols_to', 'goog.i18n.DateTimeSymbols_to_TO', 'goog.i18n.DateTimeSymbols_tr_CY', 'goog.i18n.DateTimeSymbols_tr_TR', 'goog.i18n.DateTimeSymbols_ts', 'goog.i18n.DateTimeSymbols_ts_ZA', 'goog.i18n.DateTimeSymbols_twq', 'goog.i18n.DateTimeSymbols_twq_NE', 'goog.i18n.DateTimeSymbols_tzm', 'goog.i18n.DateTimeSymbols_tzm_Latn', 'goog.i18n.DateTimeSymbols_tzm_Latn_MA', 'goog.i18n.DateTimeSymbols_uk_UA', 'goog.i18n.DateTimeSymbols_ur_IN', 'goog.i18n.DateTimeSymbols_ur_PK', 'goog.i18n.DateTimeSymbols_uz', 'goog.i18n.DateTimeSymbols_uz_Arab', 'goog.i18n.DateTimeSymbols_uz_Arab_AF', 'goog.i18n.DateTimeSymbols_uz_Cyrl', 'goog.i18n.DateTimeSymbols_uz_Cyrl_UZ', 'goog.i18n.DateTimeSymbols_uz_Latn', 'goog.i18n.DateTimeSymbols_uz_Latn_UZ', 'goog.i18n.DateTimeSymbols_vai', 'goog.i18n.DateTimeSymbols_vai_Latn', 'goog.i18n.DateTimeSymbols_vai_Latn_LR', 'goog.i18n.DateTimeSymbols_vai_Vaii', 'goog.i18n.DateTimeSymbols_vai_Vaii_LR', 'goog.i18n.DateTimeSymbols_ve', 'goog.i18n.DateTimeSymbols_ve_ZA', 'goog.i18n.DateTimeSymbols_vi_VN', 'goog.i18n.DateTimeSymbols_vo', 'goog.i18n.DateTimeSymbols_vun', 'goog.i18n.DateTimeSymbols_vun_TZ', 'goog.i18n.DateTimeSymbols_wae', 'goog.i18n.DateTimeSymbols_wae_CH', 'goog.i18n.DateTimeSymbols_wal', 'goog.i18n.DateTimeSymbols_wal_ET', 'goog.i18n.DateTimeSymbols_xh', 'goog.i18n.DateTimeSymbols_xh_ZA', 'goog.i18n.DateTimeSymbols_xog', 'goog.i18n.DateTimeSymbols_xog_UG', 'goog.i18n.DateTimeSymbols_yav', 'goog.i18n.DateTimeSymbols_yav_CM', 'goog.i18n.DateTimeSymbols_yo', 'goog.i18n.DateTimeSymbols_yo_NG', 'goog.i18n.DateTimeSymbols_zh_Hans', 'goog.i18n.DateTimeSymbols_zh_Hans_CN', 'goog.i18n.DateTimeSymbols_zh_Hans_HK', 'goog.i18n.DateTimeSymbols_zh_Hans_MO', 'goog.i18n.DateTimeSymbols_zh_Hans_SG', 'goog.i18n.DateTimeSymbols_zh_Hant', 'goog.i18n.DateTimeSymbols_zh_Hant_HK', 'goog.i18n.DateTimeSymbols_zh_Hant_MO', 'goog.i18n.DateTimeSymbols_zh_Hant_TW', 'goog.i18n.DateTimeSymbols_zu_ZA'], ['goog.i18n.DateTimeSymbols']);
goog.addDependency('i18n/graphemebreak.js', ['goog.i18n.GraphemeBreak'], ['goog.structs.InversionMap']);
goog.addDependency('i18n/messageformat.js', ['goog.i18n.MessageFormat'], ['goog.asserts', 'goog.i18n.NumberFormat', 'goog.i18n.ordinalRules', 'goog.i18n.pluralRules']);
goog.addDependency('i18n/mime.js', ['goog.i18n.mime', 'goog.i18n.mime.encode'], ['goog.array']);
goog.addDependency('i18n/numberformat.js', ['goog.i18n.NumberFormat', 'goog.i18n.NumberFormat.CurrencyStyle', 'goog.i18n.NumberFormat.Format'], ['goog.asserts', 'goog.i18n.CompactNumberFormatSymbols', 'goog.i18n.NumberFormatSymbols', 'goog.i18n.currency', 'goog.math']);
goog.addDependency('i18n/numberformatsymbols.js', ['goog.i18n.NumberFormatSymbols', 'goog.i18n.NumberFormatSymbols_af', 'goog.i18n.NumberFormatSymbols_af_ZA', 'goog.i18n.NumberFormatSymbols_am', 'goog.i18n.NumberFormatSymbols_am_ET', 'goog.i18n.NumberFormatSymbols_ar', 'goog.i18n.NumberFormatSymbols_ar_001', 'goog.i18n.NumberFormatSymbols_ar_EG', 'goog.i18n.NumberFormatSymbols_bg', 'goog.i18n.NumberFormatSymbols_bg_BG', 'goog.i18n.NumberFormatSymbols_bn', 'goog.i18n.NumberFormatSymbols_bn_BD', 'goog.i18n.NumberFormatSymbols_br', 'goog.i18n.NumberFormatSymbols_br_FR', 'goog.i18n.NumberFormatSymbols_ca', 'goog.i18n.NumberFormatSymbols_ca_AD', 'goog.i18n.NumberFormatSymbols_ca_ES', 'goog.i18n.NumberFormatSymbols_chr', 'goog.i18n.NumberFormatSymbols_chr_US', 'goog.i18n.NumberFormatSymbols_cs', 'goog.i18n.NumberFormatSymbols_cs_CZ', 'goog.i18n.NumberFormatSymbols_cy', 'goog.i18n.NumberFormatSymbols_cy_GB', 'goog.i18n.NumberFormatSymbols_da', 'goog.i18n.NumberFormatSymbols_da_DK', 'goog.i18n.NumberFormatSymbols_de', 'goog.i18n.NumberFormatSymbols_de_AT', 'goog.i18n.NumberFormatSymbols_de_BE', 'goog.i18n.NumberFormatSymbols_de_CH', 'goog.i18n.NumberFormatSymbols_de_DE', 'goog.i18n.NumberFormatSymbols_de_LU', 'goog.i18n.NumberFormatSymbols_el', 'goog.i18n.NumberFormatSymbols_el_GR', 'goog.i18n.NumberFormatSymbols_en', 'goog.i18n.NumberFormatSymbols_en_AS', 'goog.i18n.NumberFormatSymbols_en_AU', 'goog.i18n.NumberFormatSymbols_en_Dsrt_US', 'goog.i18n.NumberFormatSymbols_en_FM', 'goog.i18n.NumberFormatSymbols_en_GB', 'goog.i18n.NumberFormatSymbols_en_GU', 'goog.i18n.NumberFormatSymbols_en_IE', 'goog.i18n.NumberFormatSymbols_en_IN', 'goog.i18n.NumberFormatSymbols_en_MH', 'goog.i18n.NumberFormatSymbols_en_MP', 'goog.i18n.NumberFormatSymbols_en_PR', 'goog.i18n.NumberFormatSymbols_en_PW', 'goog.i18n.NumberFormatSymbols_en_SG', 'goog.i18n.NumberFormatSymbols_en_TC', 'goog.i18n.NumberFormatSymbols_en_UM', 'goog.i18n.NumberFormatSymbols_en_US', 'goog.i18n.NumberFormatSymbols_en_VG', 'goog.i18n.NumberFormatSymbols_en_VI', 'goog.i18n.NumberFormatSymbols_en_ZA', 'goog.i18n.NumberFormatSymbols_es', 'goog.i18n.NumberFormatSymbols_es_419', 'goog.i18n.NumberFormatSymbols_es_EA', 'goog.i18n.NumberFormatSymbols_es_ES', 'goog.i18n.NumberFormatSymbols_es_IC', 'goog.i18n.NumberFormatSymbols_et', 'goog.i18n.NumberFormatSymbols_et_EE', 'goog.i18n.NumberFormatSymbols_eu', 'goog.i18n.NumberFormatSymbols_eu_ES', 'goog.i18n.NumberFormatSymbols_fa', 'goog.i18n.NumberFormatSymbols_fa_IR', 'goog.i18n.NumberFormatSymbols_fi', 'goog.i18n.NumberFormatSymbols_fi_FI', 'goog.i18n.NumberFormatSymbols_fil', 'goog.i18n.NumberFormatSymbols_fil_PH', 'goog.i18n.NumberFormatSymbols_fr', 'goog.i18n.NumberFormatSymbols_fr_BL', 'goog.i18n.NumberFormatSymbols_fr_CA', 'goog.i18n.NumberFormatSymbols_fr_FR', 'goog.i18n.NumberFormatSymbols_fr_GF', 'goog.i18n.NumberFormatSymbols_fr_GP', 'goog.i18n.NumberFormatSymbols_fr_MC', 'goog.i18n.NumberFormatSymbols_fr_MF', 'goog.i18n.NumberFormatSymbols_fr_MQ', 'goog.i18n.NumberFormatSymbols_fr_RE', 'goog.i18n.NumberFormatSymbols_fr_YT', 'goog.i18n.NumberFormatSymbols_gl', 'goog.i18n.NumberFormatSymbols_gl_ES', 'goog.i18n.NumberFormatSymbols_gsw', 'goog.i18n.NumberFormatSymbols_gsw_CH', 'goog.i18n.NumberFormatSymbols_gu', 'goog.i18n.NumberFormatSymbols_gu_IN', 'goog.i18n.NumberFormatSymbols_haw', 'goog.i18n.NumberFormatSymbols_haw_US', 'goog.i18n.NumberFormatSymbols_he', 'goog.i18n.NumberFormatSymbols_he_IL', 'goog.i18n.NumberFormatSymbols_hi', 'goog.i18n.NumberFormatSymbols_hi_IN', 'goog.i18n.NumberFormatSymbols_hr', 'goog.i18n.NumberFormatSymbols_hr_HR', 'goog.i18n.NumberFormatSymbols_hu', 'goog.i18n.NumberFormatSymbols_hu_HU', 'goog.i18n.NumberFormatSymbols_id', 'goog.i18n.NumberFormatSymbols_id_ID', 'goog.i18n.NumberFormatSymbols_in', 'goog.i18n.NumberFormatSymbols_is', 'goog.i18n.NumberFormatSymbols_is_IS', 'goog.i18n.NumberFormatSymbols_it', 'goog.i18n.NumberFormatSymbols_it_IT', 'goog.i18n.NumberFormatSymbols_it_SM', 'goog.i18n.NumberFormatSymbols_iw', 'goog.i18n.NumberFormatSymbols_ja', 'goog.i18n.NumberFormatSymbols_ja_JP', 'goog.i18n.NumberFormatSymbols_kn', 'goog.i18n.NumberFormatSymbols_kn_IN', 'goog.i18n.NumberFormatSymbols_ko', 'goog.i18n.NumberFormatSymbols_ko_KR', 'goog.i18n.NumberFormatSymbols_ln', 'goog.i18n.NumberFormatSymbols_ln_CD', 'goog.i18n.NumberFormatSymbols_lt', 'goog.i18n.NumberFormatSymbols_lt_LT', 'goog.i18n.NumberFormatSymbols_lv', 'goog.i18n.NumberFormatSymbols_lv_LV', 'goog.i18n.NumberFormatSymbols_ml', 'goog.i18n.NumberFormatSymbols_ml_IN', 'goog.i18n.NumberFormatSymbols_mr', 'goog.i18n.NumberFormatSymbols_mr_IN', 'goog.i18n.NumberFormatSymbols_ms', 'goog.i18n.NumberFormatSymbols_ms_Latn_MY', 'goog.i18n.NumberFormatSymbols_mt', 'goog.i18n.NumberFormatSymbols_mt_MT', 'goog.i18n.NumberFormatSymbols_nb', 'goog.i18n.NumberFormatSymbols_nb_NO', 'goog.i18n.NumberFormatSymbols_nl', 'goog.i18n.NumberFormatSymbols_nl_NL', 'goog.i18n.NumberFormatSymbols_no', 'goog.i18n.NumberFormatSymbols_or', 'goog.i18n.NumberFormatSymbols_or_IN', 'goog.i18n.NumberFormatSymbols_pl', 'goog.i18n.NumberFormatSymbols_pl_PL', 'goog.i18n.NumberFormatSymbols_pt', 'goog.i18n.NumberFormatSymbols_pt_BR', 'goog.i18n.NumberFormatSymbols_pt_PT', 'goog.i18n.NumberFormatSymbols_ro', 'goog.i18n.NumberFormatSymbols_ro_RO', 'goog.i18n.NumberFormatSymbols_ru', 'goog.i18n.NumberFormatSymbols_ru_RU', 'goog.i18n.NumberFormatSymbols_sk', 'goog.i18n.NumberFormatSymbols_sk_SK', 'goog.i18n.NumberFormatSymbols_sl', 'goog.i18n.NumberFormatSymbols_sl_SI', 'goog.i18n.NumberFormatSymbols_sq', 'goog.i18n.NumberFormatSymbols_sq_AL', 'goog.i18n.NumberFormatSymbols_sr', 'goog.i18n.NumberFormatSymbols_sr_Cyrl_RS', 'goog.i18n.NumberFormatSymbols_sv', 'goog.i18n.NumberFormatSymbols_sv_SE', 'goog.i18n.NumberFormatSymbols_sw', 'goog.i18n.NumberFormatSymbols_sw_TZ', 'goog.i18n.NumberFormatSymbols_ta', 'goog.i18n.NumberFormatSymbols_ta_IN', 'goog.i18n.NumberFormatSymbols_te', 'goog.i18n.NumberFormatSymbols_te_IN', 'goog.i18n.NumberFormatSymbols_th', 'goog.i18n.NumberFormatSymbols_th_TH', 'goog.i18n.NumberFormatSymbols_tl', 'goog.i18n.NumberFormatSymbols_tr', 'goog.i18n.NumberFormatSymbols_tr_TR', 'goog.i18n.NumberFormatSymbols_uk', 'goog.i18n.NumberFormatSymbols_uk_UA', 'goog.i18n.NumberFormatSymbols_ur', 'goog.i18n.NumberFormatSymbols_ur_PK', 'goog.i18n.NumberFormatSymbols_vi', 'goog.i18n.NumberFormatSymbols_vi_VN', 'goog.i18n.NumberFormatSymbols_zh', 'goog.i18n.NumberFormatSymbols_zh_CN', 'goog.i18n.NumberFormatSymbols_zh_HK', 'goog.i18n.NumberFormatSymbols_zh_Hans_CN', 'goog.i18n.NumberFormatSymbols_zh_TW', 'goog.i18n.NumberFormatSymbols_zu', 'goog.i18n.NumberFormatSymbols_zu_ZA'], []);
goog.addDependency('i18n/numberformatsymbolsext.js', ['goog.i18n.NumberFormatSymbolsExt', 'goog.i18n.NumberFormatSymbols_aa', 'goog.i18n.NumberFormatSymbols_aa_DJ', 'goog.i18n.NumberFormatSymbols_aa_ER', 'goog.i18n.NumberFormatSymbols_aa_ET', 'goog.i18n.NumberFormatSymbols_af_NA', 'goog.i18n.NumberFormatSymbols_agq', 'goog.i18n.NumberFormatSymbols_agq_CM', 'goog.i18n.NumberFormatSymbols_ak', 'goog.i18n.NumberFormatSymbols_ak_GH', 'goog.i18n.NumberFormatSymbols_ar_AE', 'goog.i18n.NumberFormatSymbols_ar_BH', 'goog.i18n.NumberFormatSymbols_ar_DJ', 'goog.i18n.NumberFormatSymbols_ar_DZ', 'goog.i18n.NumberFormatSymbols_ar_EH', 'goog.i18n.NumberFormatSymbols_ar_ER', 'goog.i18n.NumberFormatSymbols_ar_IL', 'goog.i18n.NumberFormatSymbols_ar_IQ', 'goog.i18n.NumberFormatSymbols_ar_JO', 'goog.i18n.NumberFormatSymbols_ar_KM', 'goog.i18n.NumberFormatSymbols_ar_KW', 'goog.i18n.NumberFormatSymbols_ar_LB', 'goog.i18n.NumberFormatSymbols_ar_LY', 'goog.i18n.NumberFormatSymbols_ar_MA', 'goog.i18n.NumberFormatSymbols_ar_MR', 'goog.i18n.NumberFormatSymbols_ar_OM', 'goog.i18n.NumberFormatSymbols_ar_PS', 'goog.i18n.NumberFormatSymbols_ar_QA', 'goog.i18n.NumberFormatSymbols_ar_SA', 'goog.i18n.NumberFormatSymbols_ar_SD', 'goog.i18n.NumberFormatSymbols_ar_SO', 'goog.i18n.NumberFormatSymbols_ar_SY', 'goog.i18n.NumberFormatSymbols_ar_TD', 'goog.i18n.NumberFormatSymbols_ar_TN', 'goog.i18n.NumberFormatSymbols_ar_YE', 'goog.i18n.NumberFormatSymbols_as', 'goog.i18n.NumberFormatSymbols_as_IN', 'goog.i18n.NumberFormatSymbols_asa', 'goog.i18n.NumberFormatSymbols_asa_TZ', 'goog.i18n.NumberFormatSymbols_ast', 'goog.i18n.NumberFormatSymbols_ast_ES', 'goog.i18n.NumberFormatSymbols_az', 'goog.i18n.NumberFormatSymbols_az_Cyrl', 'goog.i18n.NumberFormatSymbols_az_Cyrl_AZ', 'goog.i18n.NumberFormatSymbols_az_Latn', 'goog.i18n.NumberFormatSymbols_az_Latn_AZ', 'goog.i18n.NumberFormatSymbols_bas', 'goog.i18n.NumberFormatSymbols_bas_CM', 'goog.i18n.NumberFormatSymbols_be', 'goog.i18n.NumberFormatSymbols_be_BY', 'goog.i18n.NumberFormatSymbols_bem', 'goog.i18n.NumberFormatSymbols_bem_ZM', 'goog.i18n.NumberFormatSymbols_bez', 'goog.i18n.NumberFormatSymbols_bez_TZ', 'goog.i18n.NumberFormatSymbols_bm', 'goog.i18n.NumberFormatSymbols_bm_ML', 'goog.i18n.NumberFormatSymbols_bn_IN', 'goog.i18n.NumberFormatSymbols_bo', 'goog.i18n.NumberFormatSymbols_bo_CN', 'goog.i18n.NumberFormatSymbols_bo_IN', 'goog.i18n.NumberFormatSymbols_brx', 'goog.i18n.NumberFormatSymbols_brx_IN', 'goog.i18n.NumberFormatSymbols_bs', 'goog.i18n.NumberFormatSymbols_bs_Cyrl', 'goog.i18n.NumberFormatSymbols_bs_Cyrl_BA', 'goog.i18n.NumberFormatSymbols_bs_Latn', 'goog.i18n.NumberFormatSymbols_bs_Latn_BA', 'goog.i18n.NumberFormatSymbols_byn', 'goog.i18n.NumberFormatSymbols_byn_ER', 'goog.i18n.NumberFormatSymbols_cgg', 'goog.i18n.NumberFormatSymbols_cgg_UG', 'goog.i18n.NumberFormatSymbols_ckb', 'goog.i18n.NumberFormatSymbols_ckb_Arab', 'goog.i18n.NumberFormatSymbols_ckb_Arab_IQ', 'goog.i18n.NumberFormatSymbols_ckb_Arab_IR', 'goog.i18n.NumberFormatSymbols_ckb_IQ', 'goog.i18n.NumberFormatSymbols_ckb_IR', 'goog.i18n.NumberFormatSymbols_ckb_Latn', 'goog.i18n.NumberFormatSymbols_ckb_Latn_IQ', 'goog.i18n.NumberFormatSymbols_dav', 'goog.i18n.NumberFormatSymbols_dav_KE', 'goog.i18n.NumberFormatSymbols_de_LI', 'goog.i18n.NumberFormatSymbols_dje', 'goog.i18n.NumberFormatSymbols_dje_NE', 'goog.i18n.NumberFormatSymbols_dua', 'goog.i18n.NumberFormatSymbols_dua_CM', 'goog.i18n.NumberFormatSymbols_dyo', 'goog.i18n.NumberFormatSymbols_dyo_SN', 'goog.i18n.NumberFormatSymbols_dz', 'goog.i18n.NumberFormatSymbols_dz_BT', 'goog.i18n.NumberFormatSymbols_ebu', 'goog.i18n.NumberFormatSymbols_ebu_KE', 'goog.i18n.NumberFormatSymbols_ee', 'goog.i18n.NumberFormatSymbols_ee_GH', 'goog.i18n.NumberFormatSymbols_ee_TG', 'goog.i18n.NumberFormatSymbols_el_CY', 'goog.i18n.NumberFormatSymbols_en_150', 'goog.i18n.NumberFormatSymbols_en_AG', 'goog.i18n.NumberFormatSymbols_en_BB', 'goog.i18n.NumberFormatSymbols_en_BE', 'goog.i18n.NumberFormatSymbols_en_BM', 'goog.i18n.NumberFormatSymbols_en_BS', 'goog.i18n.NumberFormatSymbols_en_BW', 'goog.i18n.NumberFormatSymbols_en_BZ', 'goog.i18n.NumberFormatSymbols_en_CA', 'goog.i18n.NumberFormatSymbols_en_CM', 'goog.i18n.NumberFormatSymbols_en_DM', 'goog.i18n.NumberFormatSymbols_en_Dsrt', 'goog.i18n.NumberFormatSymbols_en_FJ', 'goog.i18n.NumberFormatSymbols_en_GD', 'goog.i18n.NumberFormatSymbols_en_GG', 'goog.i18n.NumberFormatSymbols_en_GH', 'goog.i18n.NumberFormatSymbols_en_GI', 'goog.i18n.NumberFormatSymbols_en_GM', 'goog.i18n.NumberFormatSymbols_en_GY', 'goog.i18n.NumberFormatSymbols_en_HK', 'goog.i18n.NumberFormatSymbols_en_IM', 'goog.i18n.NumberFormatSymbols_en_JE', 'goog.i18n.NumberFormatSymbols_en_JM', 'goog.i18n.NumberFormatSymbols_en_KE', 'goog.i18n.NumberFormatSymbols_en_KI', 'goog.i18n.NumberFormatSymbols_en_KN', 'goog.i18n.NumberFormatSymbols_en_KY', 'goog.i18n.NumberFormatSymbols_en_LC', 'goog.i18n.NumberFormatSymbols_en_LR', 'goog.i18n.NumberFormatSymbols_en_LS', 'goog.i18n.NumberFormatSymbols_en_MG', 'goog.i18n.NumberFormatSymbols_en_MT', 'goog.i18n.NumberFormatSymbols_en_MU', 'goog.i18n.NumberFormatSymbols_en_MW', 'goog.i18n.NumberFormatSymbols_en_NA', 'goog.i18n.NumberFormatSymbols_en_NG', 'goog.i18n.NumberFormatSymbols_en_NZ', 'goog.i18n.NumberFormatSymbols_en_PG', 'goog.i18n.NumberFormatSymbols_en_PH', 'goog.i18n.NumberFormatSymbols_en_PK', 'goog.i18n.NumberFormatSymbols_en_SB', 'goog.i18n.NumberFormatSymbols_en_SC', 'goog.i18n.NumberFormatSymbols_en_SL', 'goog.i18n.NumberFormatSymbols_en_SS', 'goog.i18n.NumberFormatSymbols_en_SZ', 'goog.i18n.NumberFormatSymbols_en_TO', 'goog.i18n.NumberFormatSymbols_en_TT', 'goog.i18n.NumberFormatSymbols_en_TZ', 'goog.i18n.NumberFormatSymbols_en_UG', 'goog.i18n.NumberFormatSymbols_en_VC', 'goog.i18n.NumberFormatSymbols_en_VU', 'goog.i18n.NumberFormatSymbols_en_WS', 'goog.i18n.NumberFormatSymbols_en_ZM', 'goog.i18n.NumberFormatSymbols_en_ZW', 'goog.i18n.NumberFormatSymbols_eo', 'goog.i18n.NumberFormatSymbols_es_AR', 'goog.i18n.NumberFormatSymbols_es_BO', 'goog.i18n.NumberFormatSymbols_es_CL', 'goog.i18n.NumberFormatSymbols_es_CO', 'goog.i18n.NumberFormatSymbols_es_CR', 'goog.i18n.NumberFormatSymbols_es_CU', 'goog.i18n.NumberFormatSymbols_es_DO', 'goog.i18n.NumberFormatSymbols_es_EC', 'goog.i18n.NumberFormatSymbols_es_GQ', 'goog.i18n.NumberFormatSymbols_es_GT', 'goog.i18n.NumberFormatSymbols_es_HN', 'goog.i18n.NumberFormatSymbols_es_MX', 'goog.i18n.NumberFormatSymbols_es_NI', 'goog.i18n.NumberFormatSymbols_es_PA', 'goog.i18n.NumberFormatSymbols_es_PE', 'goog.i18n.NumberFormatSymbols_es_PH', 'goog.i18n.NumberFormatSymbols_es_PR', 'goog.i18n.NumberFormatSymbols_es_PY', 'goog.i18n.NumberFormatSymbols_es_SV', 'goog.i18n.NumberFormatSymbols_es_US', 'goog.i18n.NumberFormatSymbols_es_UY', 'goog.i18n.NumberFormatSymbols_es_VE', 'goog.i18n.NumberFormatSymbols_ewo', 'goog.i18n.NumberFormatSymbols_ewo_CM', 'goog.i18n.NumberFormatSymbols_fa_AF', 'goog.i18n.NumberFormatSymbols_ff', 'goog.i18n.NumberFormatSymbols_ff_SN', 'goog.i18n.NumberFormatSymbols_fo', 'goog.i18n.NumberFormatSymbols_fo_FO', 'goog.i18n.NumberFormatSymbols_fr_BE', 'goog.i18n.NumberFormatSymbols_fr_BF', 'goog.i18n.NumberFormatSymbols_fr_BI', 'goog.i18n.NumberFormatSymbols_fr_BJ', 'goog.i18n.NumberFormatSymbols_fr_CD', 'goog.i18n.NumberFormatSymbols_fr_CF', 'goog.i18n.NumberFormatSymbols_fr_CG', 'goog.i18n.NumberFormatSymbols_fr_CH', 'goog.i18n.NumberFormatSymbols_fr_CI', 'goog.i18n.NumberFormatSymbols_fr_CM', 'goog.i18n.NumberFormatSymbols_fr_DJ', 'goog.i18n.NumberFormatSymbols_fr_DZ', 'goog.i18n.NumberFormatSymbols_fr_GA', 'goog.i18n.NumberFormatSymbols_fr_GN', 'goog.i18n.NumberFormatSymbols_fr_GQ', 'goog.i18n.NumberFormatSymbols_fr_HT', 'goog.i18n.NumberFormatSymbols_fr_KM', 'goog.i18n.NumberFormatSymbols_fr_LU', 'goog.i18n.NumberFormatSymbols_fr_MA', 'goog.i18n.NumberFormatSymbols_fr_MG', 'goog.i18n.NumberFormatSymbols_fr_ML', 'goog.i18n.NumberFormatSymbols_fr_MR', 'goog.i18n.NumberFormatSymbols_fr_MU', 'goog.i18n.NumberFormatSymbols_fr_NC', 'goog.i18n.NumberFormatSymbols_fr_NE', 'goog.i18n.NumberFormatSymbols_fr_PF', 'goog.i18n.NumberFormatSymbols_fr_RW', 'goog.i18n.NumberFormatSymbols_fr_SC', 'goog.i18n.NumberFormatSymbols_fr_SN', 'goog.i18n.NumberFormatSymbols_fr_SY', 'goog.i18n.NumberFormatSymbols_fr_TD', 'goog.i18n.NumberFormatSymbols_fr_TG', 'goog.i18n.NumberFormatSymbols_fr_TN', 'goog.i18n.NumberFormatSymbols_fr_VU', 'goog.i18n.NumberFormatSymbols_fur', 'goog.i18n.NumberFormatSymbols_fur_IT', 'goog.i18n.NumberFormatSymbols_ga', 'goog.i18n.NumberFormatSymbols_ga_IE', 'goog.i18n.NumberFormatSymbols_gd', 'goog.i18n.NumberFormatSymbols_gd_GB', 'goog.i18n.NumberFormatSymbols_guz', 'goog.i18n.NumberFormatSymbols_guz_KE', 'goog.i18n.NumberFormatSymbols_gv', 'goog.i18n.NumberFormatSymbols_gv_GB', 'goog.i18n.NumberFormatSymbols_ha', 'goog.i18n.NumberFormatSymbols_ha_Latn', 'goog.i18n.NumberFormatSymbols_ha_Latn_GH', 'goog.i18n.NumberFormatSymbols_ha_Latn_NE', 'goog.i18n.NumberFormatSymbols_ha_Latn_NG', 'goog.i18n.NumberFormatSymbols_hr_BA', 'goog.i18n.NumberFormatSymbols_hy', 'goog.i18n.NumberFormatSymbols_hy_AM', 'goog.i18n.NumberFormatSymbols_ia', 'goog.i18n.NumberFormatSymbols_ia_FR', 'goog.i18n.NumberFormatSymbols_ig', 'goog.i18n.NumberFormatSymbols_ig_NG', 'goog.i18n.NumberFormatSymbols_ii', 'goog.i18n.NumberFormatSymbols_ii_CN', 'goog.i18n.NumberFormatSymbols_it_CH', 'goog.i18n.NumberFormatSymbols_jgo', 'goog.i18n.NumberFormatSymbols_jgo_CM', 'goog.i18n.NumberFormatSymbols_jmc', 'goog.i18n.NumberFormatSymbols_jmc_TZ', 'goog.i18n.NumberFormatSymbols_ka', 'goog.i18n.NumberFormatSymbols_ka_GE', 'goog.i18n.NumberFormatSymbols_kab', 'goog.i18n.NumberFormatSymbols_kab_DZ', 'goog.i18n.NumberFormatSymbols_kam', 'goog.i18n.NumberFormatSymbols_kam_KE', 'goog.i18n.NumberFormatSymbols_kde', 'goog.i18n.NumberFormatSymbols_kde_TZ', 'goog.i18n.NumberFormatSymbols_kea', 'goog.i18n.NumberFormatSymbols_kea_CV', 'goog.i18n.NumberFormatSymbols_khq', 'goog.i18n.NumberFormatSymbols_khq_ML', 'goog.i18n.NumberFormatSymbols_ki', 'goog.i18n.NumberFormatSymbols_ki_KE', 'goog.i18n.NumberFormatSymbols_kk', 'goog.i18n.NumberFormatSymbols_kk_Cyrl', 'goog.i18n.NumberFormatSymbols_kk_Cyrl_KZ', 'goog.i18n.NumberFormatSymbols_kkj', 'goog.i18n.NumberFormatSymbols_kkj_CM', 'goog.i18n.NumberFormatSymbols_kl', 'goog.i18n.NumberFormatSymbols_kl_GL', 'goog.i18n.NumberFormatSymbols_kln', 'goog.i18n.NumberFormatSymbols_kln_KE', 'goog.i18n.NumberFormatSymbols_km', 'goog.i18n.NumberFormatSymbols_km_KH', 'goog.i18n.NumberFormatSymbols_ko_KP', 'goog.i18n.NumberFormatSymbols_kok', 'goog.i18n.NumberFormatSymbols_kok_IN', 'goog.i18n.NumberFormatSymbols_ks', 'goog.i18n.NumberFormatSymbols_ks_Arab', 'goog.i18n.NumberFormatSymbols_ks_Arab_IN', 'goog.i18n.NumberFormatSymbols_ksb', 'goog.i18n.NumberFormatSymbols_ksb_TZ', 'goog.i18n.NumberFormatSymbols_ksf', 'goog.i18n.NumberFormatSymbols_ksf_CM', 'goog.i18n.NumberFormatSymbols_ksh', 'goog.i18n.NumberFormatSymbols_ksh_DE', 'goog.i18n.NumberFormatSymbols_kw', 'goog.i18n.NumberFormatSymbols_kw_GB', 'goog.i18n.NumberFormatSymbols_ky', 'goog.i18n.NumberFormatSymbols_ky_KG', 'goog.i18n.NumberFormatSymbols_lag', 'goog.i18n.NumberFormatSymbols_lag_TZ', 'goog.i18n.NumberFormatSymbols_lg', 'goog.i18n.NumberFormatSymbols_lg_UG', 'goog.i18n.NumberFormatSymbols_ln_AO', 'goog.i18n.NumberFormatSymbols_ln_CF', 'goog.i18n.NumberFormatSymbols_ln_CG', 'goog.i18n.NumberFormatSymbols_lo', 'goog.i18n.NumberFormatSymbols_lo_LA', 'goog.i18n.NumberFormatSymbols_lu', 'goog.i18n.NumberFormatSymbols_lu_CD', 'goog.i18n.NumberFormatSymbols_luo', 'goog.i18n.NumberFormatSymbols_luo_KE', 'goog.i18n.NumberFormatSymbols_luy', 'goog.i18n.NumberFormatSymbols_luy_KE', 'goog.i18n.NumberFormatSymbols_mas', 'goog.i18n.NumberFormatSymbols_mas_KE', 'goog.i18n.NumberFormatSymbols_mas_TZ', 'goog.i18n.NumberFormatSymbols_mer', 'goog.i18n.NumberFormatSymbols_mer_KE', 'goog.i18n.NumberFormatSymbols_mfe', 'goog.i18n.NumberFormatSymbols_mfe_MU', 'goog.i18n.NumberFormatSymbols_mg', 'goog.i18n.NumberFormatSymbols_mg_MG', 'goog.i18n.NumberFormatSymbols_mgh', 'goog.i18n.NumberFormatSymbols_mgh_MZ', 'goog.i18n.NumberFormatSymbols_mgo', 'goog.i18n.NumberFormatSymbols_mgo_CM', 'goog.i18n.NumberFormatSymbols_mk', 'goog.i18n.NumberFormatSymbols_mk_MK', 'goog.i18n.NumberFormatSymbols_mn', 'goog.i18n.NumberFormatSymbols_mn_Cyrl', 'goog.i18n.NumberFormatSymbols_mn_Cyrl_MN', 'goog.i18n.NumberFormatSymbols_ms_Latn', 'goog.i18n.NumberFormatSymbols_ms_Latn_BN', 'goog.i18n.NumberFormatSymbols_ms_Latn_SG', 'goog.i18n.NumberFormatSymbols_mua', 'goog.i18n.NumberFormatSymbols_mua_CM', 'goog.i18n.NumberFormatSymbols_my', 'goog.i18n.NumberFormatSymbols_my_MM', 'goog.i18n.NumberFormatSymbols_naq', 'goog.i18n.NumberFormatSymbols_naq_NA', 'goog.i18n.NumberFormatSymbols_nd', 'goog.i18n.NumberFormatSymbols_nd_ZW', 'goog.i18n.NumberFormatSymbols_ne', 'goog.i18n.NumberFormatSymbols_ne_IN', 'goog.i18n.NumberFormatSymbols_ne_NP', 'goog.i18n.NumberFormatSymbols_nl_AW', 'goog.i18n.NumberFormatSymbols_nl_BE', 'goog.i18n.NumberFormatSymbols_nl_CW', 'goog.i18n.NumberFormatSymbols_nl_SR', 'goog.i18n.NumberFormatSymbols_nl_SX', 'goog.i18n.NumberFormatSymbols_nmg', 'goog.i18n.NumberFormatSymbols_nmg_CM', 'goog.i18n.NumberFormatSymbols_nn', 'goog.i18n.NumberFormatSymbols_nn_NO', 'goog.i18n.NumberFormatSymbols_nnh', 'goog.i18n.NumberFormatSymbols_nnh_CM', 'goog.i18n.NumberFormatSymbols_nr', 'goog.i18n.NumberFormatSymbols_nr_ZA', 'goog.i18n.NumberFormatSymbols_nso', 'goog.i18n.NumberFormatSymbols_nso_ZA', 'goog.i18n.NumberFormatSymbols_nus', 'goog.i18n.NumberFormatSymbols_nus_SD', 'goog.i18n.NumberFormatSymbols_nyn', 'goog.i18n.NumberFormatSymbols_nyn_UG', 'goog.i18n.NumberFormatSymbols_om', 'goog.i18n.NumberFormatSymbols_om_ET', 'goog.i18n.NumberFormatSymbols_om_KE', 'goog.i18n.NumberFormatSymbols_os', 'goog.i18n.NumberFormatSymbols_os_GE', 'goog.i18n.NumberFormatSymbols_os_RU', 'goog.i18n.NumberFormatSymbols_pa', 'goog.i18n.NumberFormatSymbols_pa_Arab', 'goog.i18n.NumberFormatSymbols_pa_Arab_PK', 'goog.i18n.NumberFormatSymbols_pa_Guru', 'goog.i18n.NumberFormatSymbols_pa_Guru_IN', 'goog.i18n.NumberFormatSymbols_ps', 'goog.i18n.NumberFormatSymbols_ps_AF', 'goog.i18n.NumberFormatSymbols_pt_AO', 'goog.i18n.NumberFormatSymbols_pt_CV', 'goog.i18n.NumberFormatSymbols_pt_GW', 'goog.i18n.NumberFormatSymbols_pt_MO', 'goog.i18n.NumberFormatSymbols_pt_MZ', 'goog.i18n.NumberFormatSymbols_pt_ST', 'goog.i18n.NumberFormatSymbols_pt_TL', 'goog.i18n.NumberFormatSymbols_rm', 'goog.i18n.NumberFormatSymbols_rm_CH', 'goog.i18n.NumberFormatSymbols_rn', 'goog.i18n.NumberFormatSymbols_rn_BI', 'goog.i18n.NumberFormatSymbols_ro_MD', 'goog.i18n.NumberFormatSymbols_rof', 'goog.i18n.NumberFormatSymbols_rof_TZ', 'goog.i18n.NumberFormatSymbols_ru_BY', 'goog.i18n.NumberFormatSymbols_ru_KG', 'goog.i18n.NumberFormatSymbols_ru_KZ', 'goog.i18n.NumberFormatSymbols_ru_MD', 'goog.i18n.NumberFormatSymbols_ru_UA', 'goog.i18n.NumberFormatSymbols_rw', 'goog.i18n.NumberFormatSymbols_rw_RW', 'goog.i18n.NumberFormatSymbols_rwk', 'goog.i18n.NumberFormatSymbols_rwk_TZ', 'goog.i18n.NumberFormatSymbols_sah', 'goog.i18n.NumberFormatSymbols_sah_RU', 'goog.i18n.NumberFormatSymbols_saq', 'goog.i18n.NumberFormatSymbols_saq_KE', 'goog.i18n.NumberFormatSymbols_sbp', 'goog.i18n.NumberFormatSymbols_sbp_TZ', 'goog.i18n.NumberFormatSymbols_se', 'goog.i18n.NumberFormatSymbols_se_FI', 'goog.i18n.NumberFormatSymbols_se_NO', 'goog.i18n.NumberFormatSymbols_seh', 'goog.i18n.NumberFormatSymbols_seh_MZ', 'goog.i18n.NumberFormatSymbols_ses', 'goog.i18n.NumberFormatSymbols_ses_ML', 'goog.i18n.NumberFormatSymbols_sg', 'goog.i18n.NumberFormatSymbols_sg_CF', 'goog.i18n.NumberFormatSymbols_shi', 'goog.i18n.NumberFormatSymbols_shi_Latn', 'goog.i18n.NumberFormatSymbols_shi_Latn_MA', 'goog.i18n.NumberFormatSymbols_shi_Tfng', 'goog.i18n.NumberFormatSymbols_shi_Tfng_MA', 'goog.i18n.NumberFormatSymbols_si', 'goog.i18n.NumberFormatSymbols_si_LK', 'goog.i18n.NumberFormatSymbols_sn', 'goog.i18n.NumberFormatSymbols_sn_ZW', 'goog.i18n.NumberFormatSymbols_so', 'goog.i18n.NumberFormatSymbols_so_DJ', 'goog.i18n.NumberFormatSymbols_so_ET', 'goog.i18n.NumberFormatSymbols_so_KE', 'goog.i18n.NumberFormatSymbols_so_SO', 'goog.i18n.NumberFormatSymbols_sq_MK', 'goog.i18n.NumberFormatSymbols_sq_XK', 'goog.i18n.NumberFormatSymbols_sr_Cyrl', 'goog.i18n.NumberFormatSymbols_sr_Cyrl_BA', 'goog.i18n.NumberFormatSymbols_sr_Cyrl_ME', 'goog.i18n.NumberFormatSymbols_sr_Cyrl_XK', 'goog.i18n.NumberFormatSymbols_sr_Latn', 'goog.i18n.NumberFormatSymbols_sr_Latn_BA', 'goog.i18n.NumberFormatSymbols_sr_Latn_ME', 'goog.i18n.NumberFormatSymbols_sr_Latn_RS', 'goog.i18n.NumberFormatSymbols_sr_Latn_XK', 'goog.i18n.NumberFormatSymbols_ss', 'goog.i18n.NumberFormatSymbols_ss_SZ', 'goog.i18n.NumberFormatSymbols_ss_ZA', 'goog.i18n.NumberFormatSymbols_ssy', 'goog.i18n.NumberFormatSymbols_ssy_ER', 'goog.i18n.NumberFormatSymbols_st', 'goog.i18n.NumberFormatSymbols_st_LS', 'goog.i18n.NumberFormatSymbols_st_ZA', 'goog.i18n.NumberFormatSymbols_sv_AX', 'goog.i18n.NumberFormatSymbols_sv_FI', 'goog.i18n.NumberFormatSymbols_sw_KE', 'goog.i18n.NumberFormatSymbols_sw_UG', 'goog.i18n.NumberFormatSymbols_swc', 'goog.i18n.NumberFormatSymbols_swc_CD', 'goog.i18n.NumberFormatSymbols_ta_LK', 'goog.i18n.NumberFormatSymbols_ta_MY', 'goog.i18n.NumberFormatSymbols_ta_SG', 'goog.i18n.NumberFormatSymbols_teo', 'goog.i18n.NumberFormatSymbols_teo_KE', 'goog.i18n.NumberFormatSymbols_teo_UG', 'goog.i18n.NumberFormatSymbols_tg', 'goog.i18n.NumberFormatSymbols_tg_Cyrl', 'goog.i18n.NumberFormatSymbols_tg_Cyrl_TJ', 'goog.i18n.NumberFormatSymbols_ti', 'goog.i18n.NumberFormatSymbols_ti_ER', 'goog.i18n.NumberFormatSymbols_ti_ET', 'goog.i18n.NumberFormatSymbols_tig', 'goog.i18n.NumberFormatSymbols_tig_ER', 'goog.i18n.NumberFormatSymbols_tn', 'goog.i18n.NumberFormatSymbols_tn_BW', 'goog.i18n.NumberFormatSymbols_tn_ZA', 'goog.i18n.NumberFormatSymbols_to', 'goog.i18n.NumberFormatSymbols_to_TO', 'goog.i18n.NumberFormatSymbols_tr_CY', 'goog.i18n.NumberFormatSymbols_ts', 'goog.i18n.NumberFormatSymbols_ts_ZA', 'goog.i18n.NumberFormatSymbols_twq', 'goog.i18n.NumberFormatSymbols_twq_NE', 'goog.i18n.NumberFormatSymbols_tzm', 'goog.i18n.NumberFormatSymbols_tzm_Latn', 'goog.i18n.NumberFormatSymbols_tzm_Latn_MA', 'goog.i18n.NumberFormatSymbols_ur_IN', 'goog.i18n.NumberFormatSymbols_uz', 'goog.i18n.NumberFormatSymbols_uz_Arab', 'goog.i18n.NumberFormatSymbols_uz_Arab_AF', 'goog.i18n.NumberFormatSymbols_uz_Cyrl', 'goog.i18n.NumberFormatSymbols_uz_Cyrl_UZ', 'goog.i18n.NumberFormatSymbols_uz_Latn', 'goog.i18n.NumberFormatSymbols_uz_Latn_UZ', 'goog.i18n.NumberFormatSymbols_vai', 'goog.i18n.NumberFormatSymbols_vai_Latn', 'goog.i18n.NumberFormatSymbols_vai_Latn_LR', 'goog.i18n.NumberFormatSymbols_vai_Vaii', 'goog.i18n.NumberFormatSymbols_vai_Vaii_LR', 'goog.i18n.NumberFormatSymbols_ve', 'goog.i18n.NumberFormatSymbols_ve_ZA', 'goog.i18n.NumberFormatSymbols_vo', 'goog.i18n.NumberFormatSymbols_vun', 'goog.i18n.NumberFormatSymbols_vun_TZ', 'goog.i18n.NumberFormatSymbols_wae', 'goog.i18n.NumberFormatSymbols_wae_CH', 'goog.i18n.NumberFormatSymbols_wal', 'goog.i18n.NumberFormatSymbols_wal_ET', 'goog.i18n.NumberFormatSymbols_xh', 'goog.i18n.NumberFormatSymbols_xh_ZA', 'goog.i18n.NumberFormatSymbols_xog', 'goog.i18n.NumberFormatSymbols_xog_UG', 'goog.i18n.NumberFormatSymbols_yav', 'goog.i18n.NumberFormatSymbols_yav_CM', 'goog.i18n.NumberFormatSymbols_yo', 'goog.i18n.NumberFormatSymbols_yo_NG', 'goog.i18n.NumberFormatSymbols_zh_Hans', 'goog.i18n.NumberFormatSymbols_zh_Hans_HK', 'goog.i18n.NumberFormatSymbols_zh_Hans_MO', 'goog.i18n.NumberFormatSymbols_zh_Hans_SG', 'goog.i18n.NumberFormatSymbols_zh_Hant', 'goog.i18n.NumberFormatSymbols_zh_Hant_HK', 'goog.i18n.NumberFormatSymbols_zh_Hant_MO', 'goog.i18n.NumberFormatSymbols_zh_Hant_TW'], ['goog.i18n.NumberFormatSymbols']);
goog.addDependency('i18n/ordinalrules.js', ['goog.i18n.ordinalRules'], []);
goog.addDependency('i18n/pluralrules.js', ['goog.i18n.pluralRules'], []);
goog.addDependency('i18n/timezone.js', ['goog.i18n.TimeZone'], ['goog.array', 'goog.date.DateLike', 'goog.string']);
goog.addDependency('i18n/uchar.js', ['goog.i18n.uChar'], []);
goog.addDependency('i18n/uchar/localnamefetcher.js', ['goog.i18n.uChar.LocalNameFetcher'], ['goog.i18n.uChar', 'goog.i18n.uChar.NameFetcher', 'goog.log']);
goog.addDependency('i18n/uchar/namefetcher.js', ['goog.i18n.uChar.NameFetcher'], []);
goog.addDependency('i18n/uchar/remotenamefetcher.js', ['goog.i18n.uChar.RemoteNameFetcher'], ['goog.Disposable', 'goog.Uri', 'goog.i18n.uChar', 'goog.i18n.uChar.NameFetcher', 'goog.log', 'goog.net.XhrIo', 'goog.structs.Map']);
goog.addDependency('iter/iter.js', ['goog.iter', 'goog.iter.Iterable', 'goog.iter.Iterator', 'goog.iter.StopIteration'], ['goog.array', 'goog.asserts', 'goog.functions', 'goog.math']);
goog.addDependency('json/evaljsonprocessor.js', ['goog.json.EvalJsonProcessor'], ['goog.json', 'goog.json.Processor', 'goog.json.Serializer']);
goog.addDependency('json/hybrid.js', ['goog.json.hybrid'], ['goog.asserts', 'goog.json']);
goog.addDependency('json/hybrid_test.js', ['goog.json.hybridTest'], ['goog.json', 'goog.json.hybrid', 'goog.testing.PropertyReplacer', 'goog.testing.jsunit', 'goog.testing.recordFunction', 'goog.userAgent']);
goog.addDependency('json/hybridjsonprocessor.js', ['goog.json.HybridJsonProcessor'], ['goog.json.Processor', 'goog.json.hybrid']);
goog.addDependency('json/hybridjsonprocessor_test.js', ['goog.json.HybridJsonProcessorTest'], ['goog.json.HybridJsonProcessor', 'goog.json.hybrid', 'goog.testing.jsunit']);
goog.addDependency('json/json.js', ['goog.json', 'goog.json.Replacer', 'goog.json.Reviver', 'goog.json.Serializer'], []);
goog.addDependency('json/json_test.js', ['goog.jsonTest'], ['goog.functions', 'goog.json', 'goog.testing.jsunit', 'goog.userAgent']);
goog.addDependency('json/nativejsonprocessor.js', ['goog.json.NativeJsonProcessor'], ['goog.asserts', 'goog.json', 'goog.json.Processor']);
goog.addDependency('json/processor.js', ['goog.json.Processor'], ['goog.string.Parser', 'goog.string.Stringifier']);
goog.addDependency('labs/classdef/classdef.js', ['goog.labs.classdef'], []);
goog.addDependency('labs/dom/pagevisibilitymonitor.js', ['goog.labs.dom.PageVisibilityEvent', 'goog.labs.dom.PageVisibilityMonitor', 'goog.labs.dom.PageVisibilityState'], ['goog.dom', 'goog.dom.vendor', 'goog.events', 'goog.events.Event', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.memoize']);
goog.addDependency('labs/dom/pagevisibilitymonitor_test.js', ['goog.labs.dom.PageVisibilityMonitorTest'], ['goog.events', 'goog.functions', 'goog.labs.dom.PageVisibilityMonitor', 'goog.testing.PropertyReplacer', 'goog.testing.events', 'goog.testing.events.Event', 'goog.testing.jsunit', 'goog.testing.recordFunction']);
goog.addDependency('labs/events/nondisposableeventtarget.js', ['goog.labs.events.NonDisposableEventTarget'], ['goog.array', 'goog.asserts', 'goog.events.Event', 'goog.events.Listenable', 'goog.events.ListenerMap', 'goog.object']);
goog.addDependency('labs/events/touch.js', ['goog.labs.events.touch', 'goog.labs.events.touch.TouchData'], ['goog.array', 'goog.asserts', 'goog.events.EventType', 'goog.string']);
goog.addDependency('labs/events/touch_test.js', ['goog.labs.events.touchTest'], ['goog.labs.events.touch', 'goog.testing.jsunit']);
goog.addDependency('labs/format/csv.js', ['goog.labs.format.csv', 'goog.labs.format.csv.ParseError', 'goog.labs.format.csv.Token'], ['goog.array', 'goog.asserts', 'goog.debug.Error', 'goog.object', 'goog.string', 'goog.string.newlines']);
goog.addDependency('labs/format/csv_test.js', ['goog.labs.format.csvTest'], ['goog.labs.format.csv', 'goog.labs.format.csv.ParseError', 'goog.object', 'goog.testing.asserts', 'goog.testing.jsunit']);
goog.addDependency('labs/i18n/listformat.js', ['goog.labs.i18n.GenderInfo', 'goog.labs.i18n.GenderInfo.Gender', 'goog.labs.i18n.ListFormat'], ['goog.asserts', 'goog.labs.i18n.ListFormatSymbols']);
goog.addDependency('labs/i18n/listsymbols.js', ['goog.labs.i18n.ListFormatSymbols', 'goog.labs.i18n.ListFormatSymbols_af', 'goog.labs.i18n.ListFormatSymbols_am', 'goog.labs.i18n.ListFormatSymbols_ar', 'goog.labs.i18n.ListFormatSymbols_bg', 'goog.labs.i18n.ListFormatSymbols_bn', 'goog.labs.i18n.ListFormatSymbols_br', 'goog.labs.i18n.ListFormatSymbols_ca', 'goog.labs.i18n.ListFormatSymbols_chr', 'goog.labs.i18n.ListFormatSymbols_cs', 'goog.labs.i18n.ListFormatSymbols_cy', 'goog.labs.i18n.ListFormatSymbols_da', 'goog.labs.i18n.ListFormatSymbols_de', 'goog.labs.i18n.ListFormatSymbols_de_AT', 'goog.labs.i18n.ListFormatSymbols_de_CH', 'goog.labs.i18n.ListFormatSymbols_el', 'goog.labs.i18n.ListFormatSymbols_en', 'goog.labs.i18n.ListFormatSymbols_en_AU', 'goog.labs.i18n.ListFormatSymbols_en_GB', 'goog.labs.i18n.ListFormatSymbols_en_IE', 'goog.labs.i18n.ListFormatSymbols_en_IN', 'goog.labs.i18n.ListFormatSymbols_en_ISO', 'goog.labs.i18n.ListFormatSymbols_en_SG', 'goog.labs.i18n.ListFormatSymbols_en_US', 'goog.labs.i18n.ListFormatSymbols_en_ZA', 'goog.labs.i18n.ListFormatSymbols_es', 'goog.labs.i18n.ListFormatSymbols_es_419', 'goog.labs.i18n.ListFormatSymbols_es_ES', 'goog.labs.i18n.ListFormatSymbols_et', 'goog.labs.i18n.ListFormatSymbols_eu', 'goog.labs.i18n.ListFormatSymbols_fa', 'goog.labs.i18n.ListFormatSymbols_fi', 'goog.labs.i18n.ListFormatSymbols_fil', 'goog.labs.i18n.ListFormatSymbols_fr', 'goog.labs.i18n.ListFormatSymbols_fr_CA', 'goog.labs.i18n.ListFormatSymbols_gl', 'goog.labs.i18n.ListFormatSymbols_gsw', 'goog.labs.i18n.ListFormatSymbols_gu', 'goog.labs.i18n.ListFormatSymbols_haw', 'goog.labs.i18n.ListFormatSymbols_he', 'goog.labs.i18n.ListFormatSymbols_hi', 'goog.labs.i18n.ListFormatSymbols_hr', 'goog.labs.i18n.ListFormatSymbols_hu', 'goog.labs.i18n.ListFormatSymbols_id', 'goog.labs.i18n.ListFormatSymbols_in', 'goog.labs.i18n.ListFormatSymbols_is', 'goog.labs.i18n.ListFormatSymbols_it', 'goog.labs.i18n.ListFormatSymbols_iw', 'goog.labs.i18n.ListFormatSymbols_ja', 'goog.labs.i18n.ListFormatSymbols_kn', 'goog.labs.i18n.ListFormatSymbols_ko', 'goog.labs.i18n.ListFormatSymbols_ln', 'goog.labs.i18n.ListFormatSymbols_lt', 'goog.labs.i18n.ListFormatSymbols_lv', 'goog.labs.i18n.ListFormatSymbols_ml', 'goog.labs.i18n.ListFormatSymbols_mo', 'goog.labs.i18n.ListFormatSymbols_mr', 'goog.labs.i18n.ListFormatSymbols_ms', 'goog.labs.i18n.ListFormatSymbols_mt', 'goog.labs.i18n.ListFormatSymbols_nb', 'goog.labs.i18n.ListFormatSymbols_nl', 'goog.labs.i18n.ListFormatSymbols_no', 'goog.labs.i18n.ListFormatSymbols_or', 'goog.labs.i18n.ListFormatSymbols_pl', 'goog.labs.i18n.ListFormatSymbols_pt', 'goog.labs.i18n.ListFormatSymbols_pt_BR', 'goog.labs.i18n.ListFormatSymbols_pt_PT', 'goog.labs.i18n.ListFormatSymbols_ro', 'goog.labs.i18n.ListFormatSymbols_ru', 'goog.labs.i18n.ListFormatSymbols_sk', 'goog.labs.i18n.ListFormatSymbols_sl', 'goog.labs.i18n.ListFormatSymbols_sq', 'goog.labs.i18n.ListFormatSymbols_sr', 'goog.labs.i18n.ListFormatSymbols_sv', 'goog.labs.i18n.ListFormatSymbols_sw', 'goog.labs.i18n.ListFormatSymbols_ta', 'goog.labs.i18n.ListFormatSymbols_te', 'goog.labs.i18n.ListFormatSymbols_th', 'goog.labs.i18n.ListFormatSymbols_tl', 'goog.labs.i18n.ListFormatSymbols_tr', 'goog.labs.i18n.ListFormatSymbols_uk', 'goog.labs.i18n.ListFormatSymbols_ur', 'goog.labs.i18n.ListFormatSymbols_vi', 'goog.labs.i18n.ListFormatSymbols_zh', 'goog.labs.i18n.ListFormatSymbols_zh_CN', 'goog.labs.i18n.ListFormatSymbols_zh_HK', 'goog.labs.i18n.ListFormatSymbols_zh_TW', 'goog.labs.i18n.ListFormatSymbols_zu'], []);
goog.addDependency('labs/i18n/listsymbolsext.js', ['goog.labs.i18n.ListFormatSymbolsExt', 'goog.labs.i18n.ListFormatSymbols_af_NA', 'goog.labs.i18n.ListFormatSymbols_af_ZA', 'goog.labs.i18n.ListFormatSymbols_agq', 'goog.labs.i18n.ListFormatSymbols_agq_CM', 'goog.labs.i18n.ListFormatSymbols_ak', 'goog.labs.i18n.ListFormatSymbols_ak_GH', 'goog.labs.i18n.ListFormatSymbols_am_ET', 'goog.labs.i18n.ListFormatSymbols_ar_001', 'goog.labs.i18n.ListFormatSymbols_ar_AE', 'goog.labs.i18n.ListFormatSymbols_ar_BH', 'goog.labs.i18n.ListFormatSymbols_ar_DJ', 'goog.labs.i18n.ListFormatSymbols_ar_DZ', 'goog.labs.i18n.ListFormatSymbols_ar_EG', 'goog.labs.i18n.ListFormatSymbols_ar_EH', 'goog.labs.i18n.ListFormatSymbols_ar_ER', 'goog.labs.i18n.ListFormatSymbols_ar_IL', 'goog.labs.i18n.ListFormatSymbols_ar_IQ', 'goog.labs.i18n.ListFormatSymbols_ar_JO', 'goog.labs.i18n.ListFormatSymbols_ar_KM', 'goog.labs.i18n.ListFormatSymbols_ar_KW', 'goog.labs.i18n.ListFormatSymbols_ar_LB', 'goog.labs.i18n.ListFormatSymbols_ar_LY', 'goog.labs.i18n.ListFormatSymbols_ar_MA', 'goog.labs.i18n.ListFormatSymbols_ar_MR', 'goog.labs.i18n.ListFormatSymbols_ar_OM', 'goog.labs.i18n.ListFormatSymbols_ar_PS', 'goog.labs.i18n.ListFormatSymbols_ar_QA', 'goog.labs.i18n.ListFormatSymbols_ar_SA', 'goog.labs.i18n.ListFormatSymbols_ar_SD', 'goog.labs.i18n.ListFormatSymbols_ar_SO', 'goog.labs.i18n.ListFormatSymbols_ar_SY', 'goog.labs.i18n.ListFormatSymbols_ar_TD', 'goog.labs.i18n.ListFormatSymbols_ar_TN', 'goog.labs.i18n.ListFormatSymbols_ar_YE', 'goog.labs.i18n.ListFormatSymbols_as', 'goog.labs.i18n.ListFormatSymbols_as_IN', 'goog.labs.i18n.ListFormatSymbols_asa', 'goog.labs.i18n.ListFormatSymbols_asa_TZ', 'goog.labs.i18n.ListFormatSymbols_az', 'goog.labs.i18n.ListFormatSymbols_az_Cyrl', 'goog.labs.i18n.ListFormatSymbols_az_Cyrl_AZ', 'goog.labs.i18n.ListFormatSymbols_az_Latn', 'goog.labs.i18n.ListFormatSymbols_az_Latn_AZ', 'goog.labs.i18n.ListFormatSymbols_bas', 'goog.labs.i18n.ListFormatSymbols_bas_CM', 'goog.labs.i18n.ListFormatSymbols_be', 'goog.labs.i18n.ListFormatSymbols_be_BY', 'goog.labs.i18n.ListFormatSymbols_bem', 'goog.labs.i18n.ListFormatSymbols_bem_ZM', 'goog.labs.i18n.ListFormatSymbols_bez', 'goog.labs.i18n.ListFormatSymbols_bez_TZ', 'goog.labs.i18n.ListFormatSymbols_bg_BG', 'goog.labs.i18n.ListFormatSymbols_bm', 'goog.labs.i18n.ListFormatSymbols_bm_ML', 'goog.labs.i18n.ListFormatSymbols_bn_BD', 'goog.labs.i18n.ListFormatSymbols_bn_IN', 'goog.labs.i18n.ListFormatSymbols_bo', 'goog.labs.i18n.ListFormatSymbols_bo_CN', 'goog.labs.i18n.ListFormatSymbols_bo_IN', 'goog.labs.i18n.ListFormatSymbols_br_FR', 'goog.labs.i18n.ListFormatSymbols_brx', 'goog.labs.i18n.ListFormatSymbols_brx_IN', 'goog.labs.i18n.ListFormatSymbols_bs', 'goog.labs.i18n.ListFormatSymbols_bs_Cyrl', 'goog.labs.i18n.ListFormatSymbols_bs_Cyrl_BA', 'goog.labs.i18n.ListFormatSymbols_bs_Latn', 'goog.labs.i18n.ListFormatSymbols_bs_Latn_BA', 'goog.labs.i18n.ListFormatSymbols_ca_AD', 'goog.labs.i18n.ListFormatSymbols_ca_ES', 'goog.labs.i18n.ListFormatSymbols_cgg', 'goog.labs.i18n.ListFormatSymbols_cgg_UG', 'goog.labs.i18n.ListFormatSymbols_chr_US', 'goog.labs.i18n.ListFormatSymbols_cs_CZ', 'goog.labs.i18n.ListFormatSymbols_cy_GB', 'goog.labs.i18n.ListFormatSymbols_da_DK', 'goog.labs.i18n.ListFormatSymbols_dav', 'goog.labs.i18n.ListFormatSymbols_dav_KE', 'goog.labs.i18n.ListFormatSymbols_de_BE', 'goog.labs.i18n.ListFormatSymbols_de_DE', 'goog.labs.i18n.ListFormatSymbols_de_LI', 'goog.labs.i18n.ListFormatSymbols_de_LU', 'goog.labs.i18n.ListFormatSymbols_dje', 'goog.labs.i18n.ListFormatSymbols_dje_NE', 'goog.labs.i18n.ListFormatSymbols_dua', 'goog.labs.i18n.ListFormatSymbols_dua_CM', 'goog.labs.i18n.ListFormatSymbols_dyo', 'goog.labs.i18n.ListFormatSymbols_dyo_SN', 'goog.labs.i18n.ListFormatSymbols_dz', 'goog.labs.i18n.ListFormatSymbols_dz_BT', 'goog.labs.i18n.ListFormatSymbols_ebu', 'goog.labs.i18n.ListFormatSymbols_ebu_KE', 'goog.labs.i18n.ListFormatSymbols_ee', 'goog.labs.i18n.ListFormatSymbols_ee_GH', 'goog.labs.i18n.ListFormatSymbols_ee_TG', 'goog.labs.i18n.ListFormatSymbols_el_CY', 'goog.labs.i18n.ListFormatSymbols_el_GR', 'goog.labs.i18n.ListFormatSymbols_en_150', 'goog.labs.i18n.ListFormatSymbols_en_AG', 'goog.labs.i18n.ListFormatSymbols_en_AS', 'goog.labs.i18n.ListFormatSymbols_en_BB', 'goog.labs.i18n.ListFormatSymbols_en_BE', 'goog.labs.i18n.ListFormatSymbols_en_BM', 'goog.labs.i18n.ListFormatSymbols_en_BS', 'goog.labs.i18n.ListFormatSymbols_en_BW', 'goog.labs.i18n.ListFormatSymbols_en_BZ', 'goog.labs.i18n.ListFormatSymbols_en_CA', 'goog.labs.i18n.ListFormatSymbols_en_CM', 'goog.labs.i18n.ListFormatSymbols_en_DM', 'goog.labs.i18n.ListFormatSymbols_en_FJ', 'goog.labs.i18n.ListFormatSymbols_en_FM', 'goog.labs.i18n.ListFormatSymbols_en_GD', 'goog.labs.i18n.ListFormatSymbols_en_GG', 'goog.labs.i18n.ListFormatSymbols_en_GH', 'goog.labs.i18n.ListFormatSymbols_en_GI', 'goog.labs.i18n.ListFormatSymbols_en_GM', 'goog.labs.i18n.ListFormatSymbols_en_GU', 'goog.labs.i18n.ListFormatSymbols_en_GY', 'goog.labs.i18n.ListFormatSymbols_en_HK', 'goog.labs.i18n.ListFormatSymbols_en_IM', 'goog.labs.i18n.ListFormatSymbols_en_JE', 'goog.labs.i18n.ListFormatSymbols_en_JM', 'goog.labs.i18n.ListFormatSymbols_en_KE', 'goog.labs.i18n.ListFormatSymbols_en_KI', 'goog.labs.i18n.ListFormatSymbols_en_KN', 'goog.labs.i18n.ListFormatSymbols_en_KY', 'goog.labs.i18n.ListFormatSymbols_en_LC', 'goog.labs.i18n.ListFormatSymbols_en_LR', 'goog.labs.i18n.ListFormatSymbols_en_LS', 'goog.labs.i18n.ListFormatSymbols_en_MG', 'goog.labs.i18n.ListFormatSymbols_en_MH', 'goog.labs.i18n.ListFormatSymbols_en_MP', 'goog.labs.i18n.ListFormatSymbols_en_MT', 'goog.labs.i18n.ListFormatSymbols_en_MU', 'goog.labs.i18n.ListFormatSymbols_en_MW', 'goog.labs.i18n.ListFormatSymbols_en_NA', 'goog.labs.i18n.ListFormatSymbols_en_NG', 'goog.labs.i18n.ListFormatSymbols_en_NZ', 'goog.labs.i18n.ListFormatSymbols_en_PG', 'goog.labs.i18n.ListFormatSymbols_en_PH', 'goog.labs.i18n.ListFormatSymbols_en_PK', 'goog.labs.i18n.ListFormatSymbols_en_PR', 'goog.labs.i18n.ListFormatSymbols_en_PW', 'goog.labs.i18n.ListFormatSymbols_en_SB', 'goog.labs.i18n.ListFormatSymbols_en_SC', 'goog.labs.i18n.ListFormatSymbols_en_SL', 'goog.labs.i18n.ListFormatSymbols_en_SS', 'goog.labs.i18n.ListFormatSymbols_en_SZ', 'goog.labs.i18n.ListFormatSymbols_en_TC', 'goog.labs.i18n.ListFormatSymbols_en_TO', 'goog.labs.i18n.ListFormatSymbols_en_TT', 'goog.labs.i18n.ListFormatSymbols_en_TZ', 'goog.labs.i18n.ListFormatSymbols_en_UG', 'goog.labs.i18n.ListFormatSymbols_en_UM', 'goog.labs.i18n.ListFormatSymbols_en_US_POSIX', 'goog.labs.i18n.ListFormatSymbols_en_VC', 'goog.labs.i18n.ListFormatSymbols_en_VG', 'goog.labs.i18n.ListFormatSymbols_en_VI', 'goog.labs.i18n.ListFormatSymbols_en_VU', 'goog.labs.i18n.ListFormatSymbols_en_WS', 'goog.labs.i18n.ListFormatSymbols_en_ZM', 'goog.labs.i18n.ListFormatSymbols_en_ZW', 'goog.labs.i18n.ListFormatSymbols_eo', 'goog.labs.i18n.ListFormatSymbols_es_AR', 'goog.labs.i18n.ListFormatSymbols_es_BO', 'goog.labs.i18n.ListFormatSymbols_es_CL', 'goog.labs.i18n.ListFormatSymbols_es_CO', 'goog.labs.i18n.ListFormatSymbols_es_CR', 'goog.labs.i18n.ListFormatSymbols_es_CU', 'goog.labs.i18n.ListFormatSymbols_es_DO', 'goog.labs.i18n.ListFormatSymbols_es_EA', 'goog.labs.i18n.ListFormatSymbols_es_EC', 'goog.labs.i18n.ListFormatSymbols_es_GQ', 'goog.labs.i18n.ListFormatSymbols_es_GT', 'goog.labs.i18n.ListFormatSymbols_es_HN', 'goog.labs.i18n.ListFormatSymbols_es_IC', 'goog.labs.i18n.ListFormatSymbols_es_MX', 'goog.labs.i18n.ListFormatSymbols_es_NI', 'goog.labs.i18n.ListFormatSymbols_es_PA', 'goog.labs.i18n.ListFormatSymbols_es_PE', 'goog.labs.i18n.ListFormatSymbols_es_PH', 'goog.labs.i18n.ListFormatSymbols_es_PR', 'goog.labs.i18n.ListFormatSymbols_es_PY', 'goog.labs.i18n.ListFormatSymbols_es_SV', 'goog.labs.i18n.ListFormatSymbols_es_US', 'goog.labs.i18n.ListFormatSymbols_es_UY', 'goog.labs.i18n.ListFormatSymbols_es_VE', 'goog.labs.i18n.ListFormatSymbols_et_EE', 'goog.labs.i18n.ListFormatSymbols_eu_ES', 'goog.labs.i18n.ListFormatSymbols_ewo', 'goog.labs.i18n.ListFormatSymbols_ewo_CM', 'goog.labs.i18n.ListFormatSymbols_fa_AF', 'goog.labs.i18n.ListFormatSymbols_fa_IR', 'goog.labs.i18n.ListFormatSymbols_ff', 'goog.labs.i18n.ListFormatSymbols_ff_SN', 'goog.labs.i18n.ListFormatSymbols_fi_FI', 'goog.labs.i18n.ListFormatSymbols_fil_PH', 'goog.labs.i18n.ListFormatSymbols_fo', 'goog.labs.i18n.ListFormatSymbols_fo_FO', 'goog.labs.i18n.ListFormatSymbols_fr_BE', 'goog.labs.i18n.ListFormatSymbols_fr_BF', 'goog.labs.i18n.ListFormatSymbols_fr_BI', 'goog.labs.i18n.ListFormatSymbols_fr_BJ', 'goog.labs.i18n.ListFormatSymbols_fr_BL', 'goog.labs.i18n.ListFormatSymbols_fr_CD', 'goog.labs.i18n.ListFormatSymbols_fr_CF', 'goog.labs.i18n.ListFormatSymbols_fr_CG', 'goog.labs.i18n.ListFormatSymbols_fr_CH', 'goog.labs.i18n.ListFormatSymbols_fr_CI', 'goog.labs.i18n.ListFormatSymbols_fr_CM', 'goog.labs.i18n.ListFormatSymbols_fr_DJ', 'goog.labs.i18n.ListFormatSymbols_fr_DZ', 'goog.labs.i18n.ListFormatSymbols_fr_FR', 'goog.labs.i18n.ListFormatSymbols_fr_GA', 'goog.labs.i18n.ListFormatSymbols_fr_GF', 'goog.labs.i18n.ListFormatSymbols_fr_GN', 'goog.labs.i18n.ListFormatSymbols_fr_GP', 'goog.labs.i18n.ListFormatSymbols_fr_GQ', 'goog.labs.i18n.ListFormatSymbols_fr_HT', 'goog.labs.i18n.ListFormatSymbols_fr_KM', 'goog.labs.i18n.ListFormatSymbols_fr_LU', 'goog.labs.i18n.ListFormatSymbols_fr_MA', 'goog.labs.i18n.ListFormatSymbols_fr_MC', 'goog.labs.i18n.ListFormatSymbols_fr_MF', 'goog.labs.i18n.ListFormatSymbols_fr_MG', 'goog.labs.i18n.ListFormatSymbols_fr_ML', 'goog.labs.i18n.ListFormatSymbols_fr_MQ', 'goog.labs.i18n.ListFormatSymbols_fr_MR', 'goog.labs.i18n.ListFormatSymbols_fr_MU', 'goog.labs.i18n.ListFormatSymbols_fr_NC', 'goog.labs.i18n.ListFormatSymbols_fr_NE', 'goog.labs.i18n.ListFormatSymbols_fr_PF', 'goog.labs.i18n.ListFormatSymbols_fr_RE', 'goog.labs.i18n.ListFormatSymbols_fr_RW', 'goog.labs.i18n.ListFormatSymbols_fr_SC', 'goog.labs.i18n.ListFormatSymbols_fr_SN', 'goog.labs.i18n.ListFormatSymbols_fr_SY', 'goog.labs.i18n.ListFormatSymbols_fr_TD', 'goog.labs.i18n.ListFormatSymbols_fr_TG', 'goog.labs.i18n.ListFormatSymbols_fr_TN', 'goog.labs.i18n.ListFormatSymbols_fr_VU', 'goog.labs.i18n.ListFormatSymbols_fr_YT', 'goog.labs.i18n.ListFormatSymbols_ga', 'goog.labs.i18n.ListFormatSymbols_ga_IE', 'goog.labs.i18n.ListFormatSymbols_gl_ES', 'goog.labs.i18n.ListFormatSymbols_gsw_CH', 'goog.labs.i18n.ListFormatSymbols_gu_IN', 'goog.labs.i18n.ListFormatSymbols_guz', 'goog.labs.i18n.ListFormatSymbols_guz_KE', 'goog.labs.i18n.ListFormatSymbols_gv', 'goog.labs.i18n.ListFormatSymbols_gv_GB', 'goog.labs.i18n.ListFormatSymbols_ha', 'goog.labs.i18n.ListFormatSymbols_ha_Latn', 'goog.labs.i18n.ListFormatSymbols_ha_Latn_GH', 'goog.labs.i18n.ListFormatSymbols_ha_Latn_NE', 'goog.labs.i18n.ListFormatSymbols_ha_Latn_NG', 'goog.labs.i18n.ListFormatSymbols_haw_US', 'goog.labs.i18n.ListFormatSymbols_he_IL', 'goog.labs.i18n.ListFormatSymbols_hi_IN', 'goog.labs.i18n.ListFormatSymbols_hr_BA', 'goog.labs.i18n.ListFormatSymbols_hr_HR', 'goog.labs.i18n.ListFormatSymbols_hu_HU', 'goog.labs.i18n.ListFormatSymbols_hy', 'goog.labs.i18n.ListFormatSymbols_hy_AM', 'goog.labs.i18n.ListFormatSymbols_id_ID', 'goog.labs.i18n.ListFormatSymbols_ig', 'goog.labs.i18n.ListFormatSymbols_ig_NG', 'goog.labs.i18n.ListFormatSymbols_ii', 'goog.labs.i18n.ListFormatSymbols_ii_CN', 'goog.labs.i18n.ListFormatSymbols_is_IS', 'goog.labs.i18n.ListFormatSymbols_it_CH', 'goog.labs.i18n.ListFormatSymbols_it_IT', 'goog.labs.i18n.ListFormatSymbols_it_SM', 'goog.labs.i18n.ListFormatSymbols_ja_JP', 'goog.labs.i18n.ListFormatSymbols_jgo', 'goog.labs.i18n.ListFormatSymbols_jgo_CM', 'goog.labs.i18n.ListFormatSymbols_jmc', 'goog.labs.i18n.ListFormatSymbols_jmc_TZ', 'goog.labs.i18n.ListFormatSymbols_ka', 'goog.labs.i18n.ListFormatSymbols_ka_GE', 'goog.labs.i18n.ListFormatSymbols_kab', 'goog.labs.i18n.ListFormatSymbols_kab_DZ', 'goog.labs.i18n.ListFormatSymbols_kam', 'goog.labs.i18n.ListFormatSymbols_kam_KE', 'goog.labs.i18n.ListFormatSymbols_kde', 'goog.labs.i18n.ListFormatSymbols_kde_TZ', 'goog.labs.i18n.ListFormatSymbols_kea', 'goog.labs.i18n.ListFormatSymbols_kea_CV', 'goog.labs.i18n.ListFormatSymbols_khq', 'goog.labs.i18n.ListFormatSymbols_khq_ML', 'goog.labs.i18n.ListFormatSymbols_ki', 'goog.labs.i18n.ListFormatSymbols_ki_KE', 'goog.labs.i18n.ListFormatSymbols_kk', 'goog.labs.i18n.ListFormatSymbols_kk_Cyrl', 'goog.labs.i18n.ListFormatSymbols_kk_Cyrl_KZ', 'goog.labs.i18n.ListFormatSymbols_kl', 'goog.labs.i18n.ListFormatSymbols_kl_GL', 'goog.labs.i18n.ListFormatSymbols_kln', 'goog.labs.i18n.ListFormatSymbols_kln_KE', 'goog.labs.i18n.ListFormatSymbols_km', 'goog.labs.i18n.ListFormatSymbols_km_KH', 'goog.labs.i18n.ListFormatSymbols_kn_IN', 'goog.labs.i18n.ListFormatSymbols_ko_KP', 'goog.labs.i18n.ListFormatSymbols_ko_KR', 'goog.labs.i18n.ListFormatSymbols_kok', 'goog.labs.i18n.ListFormatSymbols_kok_IN', 'goog.labs.i18n.ListFormatSymbols_ks', 'goog.labs.i18n.ListFormatSymbols_ks_Arab', 'goog.labs.i18n.ListFormatSymbols_ks_Arab_IN', 'goog.labs.i18n.ListFormatSymbols_ksb', 'goog.labs.i18n.ListFormatSymbols_ksb_TZ', 'goog.labs.i18n.ListFormatSymbols_ksf', 'goog.labs.i18n.ListFormatSymbols_ksf_CM', 'goog.labs.i18n.ListFormatSymbols_kw', 'goog.labs.i18n.ListFormatSymbols_kw_GB', 'goog.labs.i18n.ListFormatSymbols_lag', 'goog.labs.i18n.ListFormatSymbols_lag_TZ', 'goog.labs.i18n.ListFormatSymbols_lg', 'goog.labs.i18n.ListFormatSymbols_lg_UG', 'goog.labs.i18n.ListFormatSymbols_ln_AO', 'goog.labs.i18n.ListFormatSymbols_ln_CD', 'goog.labs.i18n.ListFormatSymbols_ln_CF', 'goog.labs.i18n.ListFormatSymbols_ln_CG', 'goog.labs.i18n.ListFormatSymbols_lo', 'goog.labs.i18n.ListFormatSymbols_lo_LA', 'goog.labs.i18n.ListFormatSymbols_lt_LT', 'goog.labs.i18n.ListFormatSymbols_lu', 'goog.labs.i18n.ListFormatSymbols_lu_CD', 'goog.labs.i18n.ListFormatSymbols_luo', 'goog.labs.i18n.ListFormatSymbols_luo_KE', 'goog.labs.i18n.ListFormatSymbols_luy', 'goog.labs.i18n.ListFormatSymbols_luy_KE', 'goog.labs.i18n.ListFormatSymbols_lv_LV', 'goog.labs.i18n.ListFormatSymbols_mas', 'goog.labs.i18n.ListFormatSymbols_mas_KE', 'goog.labs.i18n.ListFormatSymbols_mas_TZ', 'goog.labs.i18n.ListFormatSymbols_mer', 'goog.labs.i18n.ListFormatSymbols_mer_KE', 'goog.labs.i18n.ListFormatSymbols_mfe', 'goog.labs.i18n.ListFormatSymbols_mfe_MU', 'goog.labs.i18n.ListFormatSymbols_mg', 'goog.labs.i18n.ListFormatSymbols_mg_MG', 'goog.labs.i18n.ListFormatSymbols_mgh', 'goog.labs.i18n.ListFormatSymbols_mgh_MZ', 'goog.labs.i18n.ListFormatSymbols_mgo', 'goog.labs.i18n.ListFormatSymbols_mgo_CM', 'goog.labs.i18n.ListFormatSymbols_mk', 'goog.labs.i18n.ListFormatSymbols_mk_MK', 'goog.labs.i18n.ListFormatSymbols_ml_IN', 'goog.labs.i18n.ListFormatSymbols_mn', 'goog.labs.i18n.ListFormatSymbols_mn_Cyrl', 'goog.labs.i18n.ListFormatSymbols_mn_Cyrl_MN', 'goog.labs.i18n.ListFormatSymbols_mr_IN', 'goog.labs.i18n.ListFormatSymbols_ms_Latn', 'goog.labs.i18n.ListFormatSymbols_ms_Latn_BN', 'goog.labs.i18n.ListFormatSymbols_ms_Latn_MY', 'goog.labs.i18n.ListFormatSymbols_ms_Latn_SG', 'goog.labs.i18n.ListFormatSymbols_mt_MT', 'goog.labs.i18n.ListFormatSymbols_mua', 'goog.labs.i18n.ListFormatSymbols_mua_CM', 'goog.labs.i18n.ListFormatSymbols_my', 'goog.labs.i18n.ListFormatSymbols_my_MM', 'goog.labs.i18n.ListFormatSymbols_naq', 'goog.labs.i18n.ListFormatSymbols_naq_NA', 'goog.labs.i18n.ListFormatSymbols_nb_NO', 'goog.labs.i18n.ListFormatSymbols_nd', 'goog.labs.i18n.ListFormatSymbols_nd_ZW', 'goog.labs.i18n.ListFormatSymbols_ne', 'goog.labs.i18n.ListFormatSymbols_ne_IN', 'goog.labs.i18n.ListFormatSymbols_ne_NP', 'goog.labs.i18n.ListFormatSymbols_nl_AW', 'goog.labs.i18n.ListFormatSymbols_nl_BE', 'goog.labs.i18n.ListFormatSymbols_nl_CW', 'goog.labs.i18n.ListFormatSymbols_nl_NL', 'goog.labs.i18n.ListFormatSymbols_nl_SR', 'goog.labs.i18n.ListFormatSymbols_nl_SX', 'goog.labs.i18n.ListFormatSymbols_nmg', 'goog.labs.i18n.ListFormatSymbols_nmg_CM', 'goog.labs.i18n.ListFormatSymbols_nn', 'goog.labs.i18n.ListFormatSymbols_nn_NO', 'goog.labs.i18n.ListFormatSymbols_nus', 'goog.labs.i18n.ListFormatSymbols_nus_SD', 'goog.labs.i18n.ListFormatSymbols_nyn', 'goog.labs.i18n.ListFormatSymbols_nyn_UG', 'goog.labs.i18n.ListFormatSymbols_om', 'goog.labs.i18n.ListFormatSymbols_om_ET', 'goog.labs.i18n.ListFormatSymbols_om_KE', 'goog.labs.i18n.ListFormatSymbols_or_IN', 'goog.labs.i18n.ListFormatSymbols_pa', 'goog.labs.i18n.ListFormatSymbols_pa_Arab', 'goog.labs.i18n.ListFormatSymbols_pa_Arab_PK', 'goog.labs.i18n.ListFormatSymbols_pa_Guru', 'goog.labs.i18n.ListFormatSymbols_pa_Guru_IN', 'goog.labs.i18n.ListFormatSymbols_pl_PL', 'goog.labs.i18n.ListFormatSymbols_ps', 'goog.labs.i18n.ListFormatSymbols_ps_AF', 'goog.labs.i18n.ListFormatSymbols_pt_AO', 'goog.labs.i18n.ListFormatSymbols_pt_CV', 'goog.labs.i18n.ListFormatSymbols_pt_GW', 'goog.labs.i18n.ListFormatSymbols_pt_MO', 'goog.labs.i18n.ListFormatSymbols_pt_MZ', 'goog.labs.i18n.ListFormatSymbols_pt_ST', 'goog.labs.i18n.ListFormatSymbols_pt_TL', 'goog.labs.i18n.ListFormatSymbols_rm', 'goog.labs.i18n.ListFormatSymbols_rm_CH', 'goog.labs.i18n.ListFormatSymbols_rn', 'goog.labs.i18n.ListFormatSymbols_rn_BI', 'goog.labs.i18n.ListFormatSymbols_ro_MD', 'goog.labs.i18n.ListFormatSymbols_ro_RO', 'goog.labs.i18n.ListFormatSymbols_rof', 'goog.labs.i18n.ListFormatSymbols_rof_TZ', 'goog.labs.i18n.ListFormatSymbols_ru_BY', 'goog.labs.i18n.ListFormatSymbols_ru_KG', 'goog.labs.i18n.ListFormatSymbols_ru_KZ', 'goog.labs.i18n.ListFormatSymbols_ru_MD', 'goog.labs.i18n.ListFormatSymbols_ru_RU', 'goog.labs.i18n.ListFormatSymbols_ru_UA', 'goog.labs.i18n.ListFormatSymbols_rw', 'goog.labs.i18n.ListFormatSymbols_rw_RW', 'goog.labs.i18n.ListFormatSymbols_rwk', 'goog.labs.i18n.ListFormatSymbols_rwk_TZ', 'goog.labs.i18n.ListFormatSymbols_saq', 'goog.labs.i18n.ListFormatSymbols_saq_KE', 'goog.labs.i18n.ListFormatSymbols_sbp', 'goog.labs.i18n.ListFormatSymbols_sbp_TZ', 'goog.labs.i18n.ListFormatSymbols_seh', 'goog.labs.i18n.ListFormatSymbols_seh_MZ', 'goog.labs.i18n.ListFormatSymbols_ses', 'goog.labs.i18n.ListFormatSymbols_ses_ML', 'goog.labs.i18n.ListFormatSymbols_sg', 'goog.labs.i18n.ListFormatSymbols_sg_CF', 'goog.labs.i18n.ListFormatSymbols_shi', 'goog.labs.i18n.ListFormatSymbols_shi_Latn', 'goog.labs.i18n.ListFormatSymbols_shi_Latn_MA', 'goog.labs.i18n.ListFormatSymbols_shi_Tfng', 'goog.labs.i18n.ListFormatSymbols_shi_Tfng_MA', 'goog.labs.i18n.ListFormatSymbols_si', 'goog.labs.i18n.ListFormatSymbols_si_LK', 'goog.labs.i18n.ListFormatSymbols_sk_SK', 'goog.labs.i18n.ListFormatSymbols_sl_SI', 'goog.labs.i18n.ListFormatSymbols_sn', 'goog.labs.i18n.ListFormatSymbols_sn_ZW', 'goog.labs.i18n.ListFormatSymbols_so', 'goog.labs.i18n.ListFormatSymbols_so_DJ', 'goog.labs.i18n.ListFormatSymbols_so_ET', 'goog.labs.i18n.ListFormatSymbols_so_KE', 'goog.labs.i18n.ListFormatSymbols_so_SO', 'goog.labs.i18n.ListFormatSymbols_sq_AL', 'goog.labs.i18n.ListFormatSymbols_sq_MK', 'goog.labs.i18n.ListFormatSymbols_sr_Cyrl', 'goog.labs.i18n.ListFormatSymbols_sr_Cyrl_BA', 'goog.labs.i18n.ListFormatSymbols_sr_Cyrl_ME', 'goog.labs.i18n.ListFormatSymbols_sr_Cyrl_RS', 'goog.labs.i18n.ListFormatSymbols_sr_Latn', 'goog.labs.i18n.ListFormatSymbols_sr_Latn_BA', 'goog.labs.i18n.ListFormatSymbols_sr_Latn_ME', 'goog.labs.i18n.ListFormatSymbols_sr_Latn_RS', 'goog.labs.i18n.ListFormatSymbols_sv_AX', 'goog.labs.i18n.ListFormatSymbols_sv_FI', 'goog.labs.i18n.ListFormatSymbols_sv_SE', 'goog.labs.i18n.ListFormatSymbols_sw_KE', 'goog.labs.i18n.ListFormatSymbols_sw_TZ', 'goog.labs.i18n.ListFormatSymbols_sw_UG', 'goog.labs.i18n.ListFormatSymbols_swc', 'goog.labs.i18n.ListFormatSymbols_swc_CD', 'goog.labs.i18n.ListFormatSymbols_ta_IN', 'goog.labs.i18n.ListFormatSymbols_ta_LK', 'goog.labs.i18n.ListFormatSymbols_ta_MY', 'goog.labs.i18n.ListFormatSymbols_ta_SG', 'goog.labs.i18n.ListFormatSymbols_te_IN', 'goog.labs.i18n.ListFormatSymbols_teo', 'goog.labs.i18n.ListFormatSymbols_teo_KE', 'goog.labs.i18n.ListFormatSymbols_teo_UG', 'goog.labs.i18n.ListFormatSymbols_th_TH', 'goog.labs.i18n.ListFormatSymbols_ti', 'goog.labs.i18n.ListFormatSymbols_ti_ER', 'goog.labs.i18n.ListFormatSymbols_ti_ET', 'goog.labs.i18n.ListFormatSymbols_to', 'goog.labs.i18n.ListFormatSymbols_to_TO', 'goog.labs.i18n.ListFormatSymbols_tr_CY', 'goog.labs.i18n.ListFormatSymbols_tr_TR', 'goog.labs.i18n.ListFormatSymbols_twq', 'goog.labs.i18n.ListFormatSymbols_twq_NE', 'goog.labs.i18n.ListFormatSymbols_tzm', 'goog.labs.i18n.ListFormatSymbols_tzm_Latn', 'goog.labs.i18n.ListFormatSymbols_tzm_Latn_MA', 'goog.labs.i18n.ListFormatSymbols_uk_UA', 'goog.labs.i18n.ListFormatSymbols_ur_IN', 'goog.labs.i18n.ListFormatSymbols_ur_PK', 'goog.labs.i18n.ListFormatSymbols_uz', 'goog.labs.i18n.ListFormatSymbols_uz_Arab', 'goog.labs.i18n.ListFormatSymbols_uz_Arab_AF', 'goog.labs.i18n.ListFormatSymbols_uz_Cyrl', 'goog.labs.i18n.ListFormatSymbols_uz_Cyrl_UZ', 'goog.labs.i18n.ListFormatSymbols_uz_Latn', 'goog.labs.i18n.ListFormatSymbols_uz_Latn_UZ', 'goog.labs.i18n.ListFormatSymbols_vai', 'goog.labs.i18n.ListFormatSymbols_vai_Latn', 'goog.labs.i18n.ListFormatSymbols_vai_Latn_LR', 'goog.labs.i18n.ListFormatSymbols_vai_Vaii', 'goog.labs.i18n.ListFormatSymbols_vai_Vaii_LR', 'goog.labs.i18n.ListFormatSymbols_vi_VN', 'goog.labs.i18n.ListFormatSymbols_vun', 'goog.labs.i18n.ListFormatSymbols_vun_TZ', 'goog.labs.i18n.ListFormatSymbols_xog', 'goog.labs.i18n.ListFormatSymbols_xog_UG', 'goog.labs.i18n.ListFormatSymbols_yav', 'goog.labs.i18n.ListFormatSymbols_yav_CM', 'goog.labs.i18n.ListFormatSymbols_yo', 'goog.labs.i18n.ListFormatSymbols_yo_NG', 'goog.labs.i18n.ListFormatSymbols_zh_Hans', 'goog.labs.i18n.ListFormatSymbols_zh_Hans_CN', 'goog.labs.i18n.ListFormatSymbols_zh_Hans_HK', 'goog.labs.i18n.ListFormatSymbols_zh_Hans_MO', 'goog.labs.i18n.ListFormatSymbols_zh_Hans_SG', 'goog.labs.i18n.ListFormatSymbols_zh_Hant', 'goog.labs.i18n.ListFormatSymbols_zh_Hant_HK', 'goog.labs.i18n.ListFormatSymbols_zh_Hant_MO', 'goog.labs.i18n.ListFormatSymbols_zh_Hant_TW', 'goog.labs.i18n.ListFormatSymbols_zu_ZA'], ['goog.labs.i18n.ListFormatSymbols']);
goog.addDependency('labs/mock/mock.js', ['goog.labs.mock'], ['goog.array', 'goog.debug', 'goog.debug.Error', 'goog.functions', 'goog.json']);
goog.addDependency('labs/net/image.js', ['goog.labs.net.image'], ['goog.events.EventHandler', 'goog.events.EventType', 'goog.net.EventType', 'goog.result.SimpleResult', 'goog.userAgent']);
goog.addDependency('labs/net/image_test.js', ['goog.labs.net.imageTest'], ['goog.events', 'goog.labs.net.image', 'goog.result', 'goog.result.Result', 'goog.string', 'goog.testing.AsyncTestCase', 'goog.testing.jsunit', 'goog.testing.recordFunction']);
goog.addDependency('labs/net/webchannel.js', ['goog.net.WebChannel'], ['goog.events', 'goog.events.Event']);
goog.addDependency('labs/net/webchannel/basetestchannel.js', ['goog.labs.net.webChannel.BaseTestChannel'], ['goog.labs.net.webChannel.Channel', 'goog.labs.net.webChannel.ChannelRequest', 'goog.labs.net.webChannel.requestStats', 'goog.labs.net.webChannel.requestStats.Stat']);
goog.addDependency('labs/net/webchannel/channel.js', ['goog.labs.net.webChannel.Channel'], []);
goog.addDependency('labs/net/webchannel/channelrequest.js', ['goog.labs.net.webChannel.ChannelRequest'], ['goog.Timer', 'goog.async.Throttle', 'goog.events.EventHandler', 'goog.labs.net.webChannel.requestStats', 'goog.labs.net.webChannel.requestStats.ServerReachability', 'goog.labs.net.webChannel.requestStats.Stat', 'goog.net.ErrorCode', 'goog.net.EventType', 'goog.net.XmlHttp', 'goog.object', 'goog.uri.utils.StandardQueryParam', 'goog.userAgent']);
goog.addDependency('labs/net/webchannel/channelrequest_test.js', ['goog.labs.net.webChannel.channelRequestTest'], ['goog.Uri', 'goog.functions', 'goog.labs.net.webChannel.ChannelRequest', 'goog.labs.net.webChannel.WebChannelDebug', 'goog.labs.net.webChannel.requestStats', 'goog.labs.net.webChannel.requestStats.ServerReachability', 'goog.testing.MockClock', 'goog.testing.PropertyReplacer', 'goog.testing.jsunit', 'goog.testing.net.XhrIo', 'goog.testing.recordFunction']);
goog.addDependency('labs/net/webchannel/connectionstate.js', ['goog.labs.net.webChannel.ConnectionState'], []);
goog.addDependency('labs/net/webchannel/forwardchannelrequestpool.js', ['goog.labs.net.webChannel.ForwardChannelRequestPool'], ['goog.structs', 'goog.structs.Set']);
goog.addDependency('labs/net/webchannel/forwardchannelrequestpool_test.js', ['goog.labs.net.webChannel.forwardChannelRequestPoolTest'], ['goog.labs.net.webChannel.ChannelRequest', 'goog.labs.net.webChannel.ForwardChannelRequestPool', 'goog.testing.PropertyReplacer', 'goog.testing.asserts', 'goog.testing.jsunit']);
goog.addDependency('labs/net/webchannel/netutils.js', ['goog.labs.net.webChannel.netUtils'], ['goog.Uri', 'goog.labs.net.webChannel.WebChannelDebug']);
goog.addDependency('labs/net/webchannel/requeststats.js', ['goog.labs.net.webChannel.requestStats', 'goog.labs.net.webChannel.requestStats.Event', 'goog.labs.net.webChannel.requestStats.ServerReachability', 'goog.labs.net.webChannel.requestStats.ServerReachabilityEvent', 'goog.labs.net.webChannel.requestStats.Stat', 'goog.labs.net.webChannel.requestStats.StatEvent', 'goog.labs.net.webChannel.requestStats.TimingEvent'], ['goog.events.Event', 'goog.events.EventTarget']);
goog.addDependency('labs/net/webchannel/webchannelbase.js', ['goog.labs.net.webChannel.WebChannelBase'], ['goog.Uri', 'goog.array', 'goog.asserts', 'goog.debug.TextFormatter', 'goog.json', 'goog.labs.net.webChannel.BaseTestChannel', 'goog.labs.net.webChannel.Channel', 'goog.labs.net.webChannel.ChannelRequest', 'goog.labs.net.webChannel.ConnectionState', 'goog.labs.net.webChannel.ForwardChannelRequestPool', 'goog.labs.net.webChannel.WebChannelDebug', 'goog.labs.net.webChannel.Wire', 'goog.labs.net.webChannel.WireV8', 'goog.labs.net.webChannel.netUtils', 'goog.labs.net.webChannel.requestStats', 'goog.labs.net.webChannel.requestStats.Stat', 'goog.log', 'goog.net.XhrIo', 'goog.string', 'goog.structs', 'goog.structs.CircularBuffer']);
goog.addDependency('labs/net/webchannel/webchannelbase_test.js', ['goog.labs.net.webChannel.webChannelBaseTest'], ['goog.Timer', 'goog.array', 'goog.dom', 'goog.functions', 'goog.json', 'goog.labs.net.webChannel.ChannelRequest', 'goog.labs.net.webChannel.ForwardChannelRequestPool', 'goog.labs.net.webChannel.WebChannelBase', 'goog.labs.net.webChannel.WebChannelBaseTransport', 'goog.labs.net.webChannel.WebChannelDebug', 'goog.labs.net.webChannel.Wire', 'goog.labs.net.webChannel.netUtils', 'goog.labs.net.webChannel.requestStats', 'goog.labs.net.webChannel.requestStats.Stat', 'goog.structs.Map', 'goog.testing.MockClock', 'goog.testing.PropertyReplacer', 'goog.testing.asserts', 'goog.testing.jsunit']);
goog.addDependency('labs/net/webchannel/webchannelbasetransport.js', ['goog.labs.net.webChannel.WebChannelBaseTransport'], ['goog.asserts', 'goog.events.EventTarget', 'goog.labs.net.webChannel.WebChannelBase', 'goog.log', 'goog.net.WebChannel', 'goog.net.WebChannelTransport', 'goog.string.path']);
goog.addDependency('labs/net/webchannel/webchannelbasetransport_test.js', ['goog.labs.net.webChannel.webChannelBaseTransportTest'], ['goog.events', 'goog.labs.net.webChannel.WebChannelBaseTransport', 'goog.net.WebChannel', 'goog.testing.jsunit']);
goog.addDependency('labs/net/webchannel/webchanneldebug.js', ['goog.labs.net.webChannel.WebChannelDebug'], ['goog.json', 'goog.log']);
goog.addDependency('labs/net/webchannel/wire.js', ['goog.labs.net.webChannel.Wire'], []);
goog.addDependency('labs/net/webchannel/wirev8.js', ['goog.labs.net.webChannel.WireV8'], ['goog.asserts', 'goog.json', 'goog.json.EvalJsonProcessor', 'goog.structs']);
goog.addDependency('labs/net/webchannel/wirev8_test.js', ['goog.labs.net.webChannel.WireV8Test'], ['goog.labs.net.webChannel.WireV8', 'goog.testing.jsunit']);
goog.addDependency('labs/net/webchanneltransport.js', ['goog.net.WebChannelTransport'], []);
goog.addDependency('labs/net/webchanneltransportfactory.js', ['goog.net.createWebChannelTransport'], ['goog.functions', 'goog.labs.net.webChannel.WebChannelBaseTransport']);
goog.addDependency('labs/net/xhr.js', ['goog.labs.net.xhr', 'goog.labs.net.xhr.Error', 'goog.labs.net.xhr.HttpError', 'goog.labs.net.xhr.TimeoutError'], ['goog.debug.Error', 'goog.json', 'goog.net.HttpStatus', 'goog.net.XmlHttp', 'goog.result', 'goog.result.SimpleResult', 'goog.string', 'goog.uri.utils']);
goog.addDependency('labs/object/object.js', ['goog.labs.object'], []);
goog.addDependency('labs/promise/promise.js', ['goog.labs.Promise'], ['goog.asserts', 'goog.async.run', 'goog.async.throwException', 'goog.debug.Error', 'goog.labs.Thenable']);
goog.addDependency('labs/promise/promise_test.js', ['goog.labs.PromiseTest'], ['goog.functions', 'goog.labs.Promise', 'goog.labs.Thenable', 'goog.testing.AsyncTestCase', 'goog.testing.MockClock', 'goog.testing.PropertyReplacer', 'goog.testing.jsunit', 'goog.testing.recordFunction']);
goog.addDependency('labs/promise/testsuiteadapter.js', ['goog.labs.promise.testSuiteAdapter'], ['goog.labs.Promise']);
goog.addDependency('labs/promise/thenable.js', ['goog.labs.Thenable'], []);
goog.addDependency('labs/storage/boundedcollectablestorage.js', ['goog.labs.storage.BoundedCollectableStorage'], ['goog.array', 'goog.asserts', 'goog.iter', 'goog.storage.CollectableStorage', 'goog.storage.ErrorCode', 'goog.storage.ExpiringStorage']);
goog.addDependency('labs/structs/map.js', ['goog.labs.structs.Map'], ['goog.array', 'goog.asserts', 'goog.labs.object', 'goog.object']);
goog.addDependency('labs/structs/map_perf.js', ['goog.labs.structs.mapPerf'], ['goog.dom', 'goog.labs.structs.Map', 'goog.structs.Map', 'goog.testing.PerformanceTable', 'goog.testing.jsunit']);
goog.addDependency('labs/structs/multimap.js', ['goog.labs.structs.Multimap'], ['goog.array', 'goog.labs.object', 'goog.labs.structs.Map']);
goog.addDependency('labs/style/pixeldensitymonitor.js', ['goog.labs.style.PixelDensityMonitor', 'goog.labs.style.PixelDensityMonitor.Density', 'goog.labs.style.PixelDensityMonitor.EventType'], ['goog.events', 'goog.events.EventTarget']);
goog.addDependency('labs/style/pixeldensitymonitor_test.js', ['goog.labs.style.PixelDensityMonitorTest'], ['goog.array', 'goog.dom.DomHelper', 'goog.events', 'goog.labs.style.PixelDensityMonitor', 'goog.testing.MockControl', 'goog.testing.jsunit', 'goog.testing.recordFunction']);
goog.addDependency('labs/testing/assertthat.js', ['goog.labs.testing.MatcherError', 'goog.labs.testing.assertThat'], ['goog.asserts', 'goog.debug.Error', 'goog.labs.testing.Matcher']);
goog.addDependency('labs/testing/decoratormatcher.js', ['goog.labs.testing.AnythingMatcher'], ['goog.labs.testing.Matcher']);
goog.addDependency('labs/testing/dictionarymatcher.js', ['goog.labs.testing.HasEntriesMatcher', 'goog.labs.testing.HasEntryMatcher', 'goog.labs.testing.HasKeyMatcher', 'goog.labs.testing.HasValueMatcher'], ['goog.array', 'goog.asserts', 'goog.labs.testing.Matcher', 'goog.string']);
goog.addDependency('labs/testing/logicmatcher.js', ['goog.labs.testing.AllOfMatcher', 'goog.labs.testing.AnyOfMatcher', 'goog.labs.testing.IsNotMatcher'], ['goog.array', 'goog.labs.testing.Matcher']);
goog.addDependency('labs/testing/matcher.js', ['goog.labs.testing.Matcher'], []);
goog.addDependency('labs/testing/numbermatcher.js', ['goog.labs.testing.CloseToMatcher', 'goog.labs.testing.EqualToMatcher', 'goog.labs.testing.GreaterThanEqualToMatcher', 'goog.labs.testing.GreaterThanMatcher', 'goog.labs.testing.LessThanEqualToMatcher', 'goog.labs.testing.LessThanMatcher'], ['goog.asserts', 'goog.labs.testing.Matcher']);
goog.addDependency('labs/testing/objectmatcher.js', ['goog.labs.testing.HasPropertyMatcher', 'goog.labs.testing.InstanceOfMatcher', 'goog.labs.testing.IsNullMatcher', 'goog.labs.testing.IsNullOrUndefinedMatcher', 'goog.labs.testing.IsUndefinedMatcher', 'goog.labs.testing.ObjectEqualsMatcher'], ['goog.labs.testing.Matcher', 'goog.string']);
goog.addDependency('labs/testing/stringmatcher.js', ['goog.labs.testing.ContainsStringMatcher', 'goog.labs.testing.EndsWithMatcher', 'goog.labs.testing.EqualToIgnoringCaseMatcher', 'goog.labs.testing.EqualToIgnoringWhitespaceMatcher', 'goog.labs.testing.EqualsMatcher', 'goog.labs.testing.RegexMatcher', 'goog.labs.testing.StartsWithMatcher', 'goog.labs.testing.StringContainsInOrderMatcher'], ['goog.asserts', 'goog.labs.testing.Matcher', 'goog.string']);
goog.addDependency('labs/useragent/browser.js', ['goog.labs.userAgent.browser'], ['goog.array', 'goog.asserts', 'goog.labs.userAgent.util', 'goog.string']);
goog.addDependency('labs/useragent/browser_test.js', ['goog.labs.userAgent.browserTest'], ['goog.labs.userAgent.browser', 'goog.labs.userAgent.testAgents', 'goog.labs.userAgent.util', 'goog.testing.jsunit']);
goog.addDependency('labs/useragent/device.js', ['goog.labs.userAgent.device'], ['goog.labs.userAgent.util']);
goog.addDependency('labs/useragent/device_test.js', ['goog.labs.userAgent.deviceTest'], ['goog.labs.userAgent.device', 'goog.labs.userAgent.testAgents', 'goog.labs.userAgent.util', 'goog.testing.jsunit']);
goog.addDependency('labs/useragent/engine.js', ['goog.labs.userAgent.engine'], ['goog.array', 'goog.labs.userAgent.util', 'goog.string']);
goog.addDependency('labs/useragent/engine_test.js', ['goog.labs.userAgent.engineTest'], ['goog.labs.userAgent.engine', 'goog.labs.userAgent.testAgents', 'goog.labs.userAgent.util', 'goog.testing.jsunit']);
goog.addDependency('labs/useragent/platform.js', ['goog.labs.userAgent.platform'], ['goog.labs.userAgent.util', 'goog.string']);
goog.addDependency('labs/useragent/platform_test.js', ['goog.labs.userAgent.platformTest'], ['goog.labs.userAgent.platform', 'goog.labs.userAgent.testAgents', 'goog.labs.userAgent.util', 'goog.testing.jsunit']);
goog.addDependency('labs/useragent/test_agents.js', ['goog.labs.userAgent.testAgents'], []);
goog.addDependency('labs/useragent/util.js', ['goog.labs.userAgent.util'], ['goog.string']);
goog.addDependency('labs/useragent/util_test.js', ['goog.labs.userAgent.utilTest'], ['goog.labs.userAgent.testAgents', 'goog.labs.userAgent.util', 'goog.testing.jsunit']);
goog.addDependency('locale/countries.js', ['goog.locale.countries'], []);
goog.addDependency('locale/defaultlocalenameconstants.js', ['goog.locale.defaultLocaleNameConstants'], []);
goog.addDependency('locale/genericfontnames.js', ['goog.locale.genericFontNames'], []);
goog.addDependency('locale/genericfontnamesdata.js', ['goog.locale.genericFontNamesData'], []);
goog.addDependency('locale/locale.js', ['goog.locale'], ['goog.locale.nativeNameConstants']);
goog.addDependency('locale/nativenameconstants.js', ['goog.locale.nativeNameConstants'], []);
goog.addDependency('locale/scriptToLanguages.js', ['goog.locale.scriptToLanguages'], ['goog.locale']);
goog.addDependency('locale/timezonedetection.js', ['goog.locale.timeZoneDetection'], ['goog.locale', 'goog.locale.TimeZoneFingerprint']);
goog.addDependency('locale/timezonefingerprint.js', ['goog.locale.TimeZoneFingerprint'], []);
goog.addDependency('locale/timezonelist.js', ['goog.locale.TimeZoneList'], ['goog.locale']);
goog.addDependency('log/log.js', ['goog.log', 'goog.log.Level', 'goog.log.LogRecord', 'goog.log.Logger'], ['goog.debug', 'goog.debug.LogRecord', 'goog.debug.Logger']);
goog.addDependency('log/log_test.js', ['goog.logTest'], ['goog.debug.LogManager', 'goog.log', 'goog.log.Level', 'goog.testing.jsunit']);
goog.addDependency('math/affinetransform.js', ['goog.math.AffineTransform'], ['goog.math']);
goog.addDependency('math/affinetransform_test.js', ['goog.math.AffineTransformTest'], ['goog.array', 'goog.math', 'goog.math.AffineTransform', 'goog.testing.jsunit']);
goog.addDependency('math/bezier.js', ['goog.math.Bezier'], ['goog.math', 'goog.math.Coordinate']);
goog.addDependency('math/box.js', ['goog.math.Box'], ['goog.math.Coordinate']);
goog.addDependency('math/coordinate.js', ['goog.math.Coordinate'], ['goog.math']);
goog.addDependency('math/coordinate3.js', ['goog.math.Coordinate3'], []);
goog.addDependency('math/exponentialbackoff.js', ['goog.math.ExponentialBackoff'], ['goog.asserts']);
goog.addDependency('math/integer.js', ['goog.math.Integer'], []);
goog.addDependency('math/interpolator/interpolator1.js', ['goog.math.interpolator.Interpolator1'], []);
goog.addDependency('math/interpolator/linear1.js', ['goog.math.interpolator.Linear1'], ['goog.array', 'goog.math', 'goog.math.interpolator.Interpolator1']);
goog.addDependency('math/interpolator/pchip1.js', ['goog.math.interpolator.Pchip1'], ['goog.math', 'goog.math.interpolator.Spline1']);
goog.addDependency('math/interpolator/spline1.js', ['goog.math.interpolator.Spline1'], ['goog.array', 'goog.math', 'goog.math.interpolator.Interpolator1', 'goog.math.tdma']);
goog.addDependency('math/line.js', ['goog.math.Line'], ['goog.math', 'goog.math.Coordinate']);
goog.addDependency('math/long.js', ['goog.math.Long'], []);
goog.addDependency('math/math.js', ['goog.math'], ['goog.array', 'goog.asserts']);
goog.addDependency('math/matrix.js', ['goog.math.Matrix'], ['goog.array', 'goog.math', 'goog.math.Size', 'goog.string']);
goog.addDependency('math/path.js', ['goog.math.Path', 'goog.math.Path.Segment'], ['goog.array', 'goog.math']);
goog.addDependency('math/path_test.js', ['goog.math.PathTest'], ['goog.array', 'goog.math.AffineTransform', 'goog.math.Path', 'goog.testing.jsunit']);
goog.addDependency('math/paths.js', ['goog.math.paths'], ['goog.math.Coordinate', 'goog.math.Path']);
goog.addDependency('math/paths_test.js', ['goog.math.pathsTest'], ['goog.math.Coordinate', 'goog.math.paths', 'goog.testing.jsunit']);
goog.addDependency('math/range.js', ['goog.math.Range'], []);
goog.addDependency('math/rangeset.js', ['goog.math.RangeSet'], ['goog.array', 'goog.iter.Iterator', 'goog.iter.StopIteration', 'goog.math.Range']);
goog.addDependency('math/rect.js', ['goog.math.Rect'], ['goog.math.Box', 'goog.math.Coordinate', 'goog.math.Size']);
goog.addDependency('math/size.js', ['goog.math.Size'], []);
goog.addDependency('math/tdma.js', ['goog.math.tdma'], []);
goog.addDependency('math/vec2.js', ['goog.math.Vec2'], ['goog.math', 'goog.math.Coordinate']);
goog.addDependency('math/vec3.js', ['goog.math.Vec3'], ['goog.math', 'goog.math.Coordinate3']);
goog.addDependency('memoize/memoize.js', ['goog.memoize'], []);
goog.addDependency('messaging/abstractchannel.js', ['goog.messaging.AbstractChannel'], ['goog.Disposable', 'goog.debug', 'goog.json', 'goog.log', 'goog.messaging.MessageChannel']);
goog.addDependency('messaging/bufferedchannel.js', ['goog.messaging.BufferedChannel'], ['goog.Timer', 'goog.Uri', 'goog.debug.Error', 'goog.events', 'goog.log', 'goog.messaging.MessageChannel', 'goog.messaging.MultiChannel']);
goog.addDependency('messaging/deferredchannel.js', ['goog.messaging.DeferredChannel'], ['goog.Disposable', 'goog.async.Deferred', 'goog.messaging.MessageChannel']);
goog.addDependency('messaging/loggerclient.js', ['goog.messaging.LoggerClient'], ['goog.Disposable', 'goog.debug', 'goog.debug.LogManager', 'goog.debug.Logger']);
goog.addDependency('messaging/loggerserver.js', ['goog.messaging.LoggerServer'], ['goog.Disposable', 'goog.log']);
goog.addDependency('messaging/messagechannel.js', ['goog.messaging.MessageChannel'], []);
goog.addDependency('messaging/messaging.js', ['goog.messaging'], ['goog.messaging.MessageChannel']);
goog.addDependency('messaging/multichannel.js', ['goog.messaging.MultiChannel', 'goog.messaging.MultiChannel.VirtualChannel'], ['goog.Disposable', 'goog.events.EventHandler', 'goog.log', 'goog.messaging.MessageChannel', 'goog.object']);
goog.addDependency('messaging/portcaller.js', ['goog.messaging.PortCaller'], ['goog.Disposable', 'goog.async.Deferred', 'goog.messaging.DeferredChannel', 'goog.messaging.PortChannel', 'goog.messaging.PortNetwork', 'goog.object']);
goog.addDependency('messaging/portchannel.js', ['goog.messaging.PortChannel'], ['goog.Timer', 'goog.array', 'goog.async.Deferred', 'goog.debug', 'goog.dom', 'goog.dom.DomHelper', 'goog.events', 'goog.events.EventType', 'goog.json', 'goog.log', 'goog.messaging.AbstractChannel', 'goog.messaging.DeferredChannel', 'goog.object', 'goog.string']);
goog.addDependency('messaging/portnetwork.js', ['goog.messaging.PortNetwork'], []);
goog.addDependency('messaging/portoperator.js', ['goog.messaging.PortOperator'], ['goog.Disposable', 'goog.asserts', 'goog.log', 'goog.messaging.PortChannel', 'goog.messaging.PortNetwork', 'goog.object']);
goog.addDependency('messaging/respondingchannel.js', ['goog.messaging.RespondingChannel'], ['goog.Disposable', 'goog.log', 'goog.messaging.MessageChannel', 'goog.messaging.MultiChannel', 'goog.messaging.MultiChannel.VirtualChannel']);
goog.addDependency('messaging/testdata/portchannel_worker.js', ['goog.messaging.testdata.portchannel_worker'], ['goog.messaging.PortChannel']);
goog.addDependency('messaging/testdata/portnetwork_worker1.js', ['goog.messaging.testdata.portnetwork_worker1'], ['goog.messaging.PortCaller', 'goog.messaging.PortChannel']);
goog.addDependency('messaging/testdata/portnetwork_worker2.js', ['goog.messaging.testdata.portnetwork_worker2'], ['goog.messaging.PortCaller', 'goog.messaging.PortChannel']);
goog.addDependency('module/abstractmoduleloader.js', ['goog.module.AbstractModuleLoader'], []);
goog.addDependency('module/basemodule.js', ['goog.module.BaseModule'], ['goog.Disposable']);
goog.addDependency('module/loader.js', ['goog.module.Loader'], ['goog.Timer', 'goog.array', 'goog.dom', 'goog.object']);
goog.addDependency('module/module.js', ['goog.module'], ['goog.array', 'goog.module.Loader']);
goog.addDependency('module/moduleinfo.js', ['goog.module.ModuleInfo'], ['goog.Disposable', 'goog.functions', 'goog.module.BaseModule', 'goog.module.ModuleLoadCallback']);
goog.addDependency('module/moduleloadcallback.js', ['goog.module.ModuleLoadCallback'], ['goog.debug.entryPointRegistry', 'goog.debug.errorHandlerWeakDep']);
goog.addDependency('module/moduleloader.js', ['goog.module.ModuleLoader'], ['goog.Timer', 'goog.array', 'goog.events', 'goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.log', 'goog.module.AbstractModuleLoader', 'goog.net.BulkLoader', 'goog.net.EventType', 'goog.net.jsloader', 'goog.userAgent.product']);
goog.addDependency('module/moduleloader_test.js', ['goog.module.ModuleLoaderTest'], ['goog.array', 'goog.dom', 'goog.functions', 'goog.module.ModuleLoader', 'goog.module.ModuleManager', 'goog.module.ModuleManager.CallbackType', 'goog.object', 'goog.testing.AsyncTestCase', 'goog.testing.PropertyReplacer', 'goog.testing.events.EventObserver', 'goog.testing.jsunit', 'goog.testing.recordFunction', 'goog.userAgent.product']);
goog.addDependency('module/modulemanager.js', ['goog.module.ModuleManager', 'goog.module.ModuleManager.CallbackType', 'goog.module.ModuleManager.FailureType'], ['goog.Disposable', 'goog.array', 'goog.asserts', 'goog.async.Deferred', 'goog.debug.Trace', 'goog.dispose', 'goog.log', 'goog.module.ModuleInfo', 'goog.module.ModuleLoadCallback', 'goog.object']);
goog.addDependency('module/testdata/modA_1.js', ['goog.module.testdata.modA_1'], []);
goog.addDependency('module/testdata/modA_2.js', ['goog.module.testdata.modA_2'], ['goog.module.ModuleManager']);
goog.addDependency('module/testdata/modB_1.js', ['goog.module.testdata.modB_1'], ['goog.module.ModuleManager']);
goog.addDependency('net/browserchannel.js', ['goog.net.BrowserChannel', 'goog.net.BrowserChannel.Error', 'goog.net.BrowserChannel.Event', 'goog.net.BrowserChannel.Handler', 'goog.net.BrowserChannel.LogSaver', 'goog.net.BrowserChannel.QueuedMap', 'goog.net.BrowserChannel.ServerReachability', 'goog.net.BrowserChannel.ServerReachabilityEvent', 'goog.net.BrowserChannel.Stat', 'goog.net.BrowserChannel.StatEvent', 'goog.net.BrowserChannel.State', 'goog.net.BrowserChannel.TimingEvent'], ['goog.Uri', 'goog.array', 'goog.asserts', 'goog.debug.TextFormatter', 'goog.events.Event', 'goog.events.EventTarget', 'goog.json', 'goog.json.EvalJsonProcessor', 'goog.log', 'goog.net.BrowserTestChannel', 'goog.net.ChannelDebug', 'goog.net.ChannelRequest', 'goog.net.XhrIo', 'goog.net.tmpnetwork', 'goog.string', 'goog.structs', 'goog.structs.CircularBuffer']);
goog.addDependency('net/browsertestchannel.js', ['goog.net.BrowserTestChannel'], ['goog.json.EvalJsonProcessor', 'goog.net.ChannelRequest', 'goog.net.ChannelRequest.Error', 'goog.net.tmpnetwork', 'goog.string.Parser', 'goog.userAgent']);
goog.addDependency('net/bulkloader.js', ['goog.net.BulkLoader'], ['goog.events.EventHandler', 'goog.events.EventTarget', 'goog.log', 'goog.net.BulkLoaderHelper', 'goog.net.EventType', 'goog.net.XhrIo']);
goog.addDependency('net/bulkloaderhelper.js', ['goog.net.BulkLoaderHelper'], ['goog.Disposable', 'goog.log']);
goog.addDependency('net/channeldebug.js', ['goog.net.ChannelDebug'], ['goog.json', 'goog.log']);
goog.addDependency('net/channelrequest.js', ['goog.net.ChannelRequest', 'goog.net.ChannelRequest.Error'], ['goog.Timer', 'goog.async.Throttle', 'goog.events.EventHandler', 'goog.net.ErrorCode', 'goog.net.EventType', 'goog.net.XmlHttp', 'goog.object', 'goog.userAgent']);
goog.addDependency('net/cookies.js', ['goog.net.Cookies', 'goog.net.cookies'], []);
goog.addDependency('net/corsxmlhttpfactory.js', ['goog.net.CorsXmlHttpFactory', 'goog.net.IeCorsXhrAdapter'], ['goog.net.HttpStatus', 'goog.net.XhrLike', 'goog.net.XmlHttp', 'goog.net.XmlHttpFactory']);
goog.addDependency('net/crossdomainrpc.js', ['goog.net.CrossDomainRpc'], ['goog.Uri', 'goog.dom', 'goog.events', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.json', 'goog.log', 'goog.net.EventType', 'goog.net.HttpStatus', 'goog.string', 'goog.userAgent']);
goog.addDependency('net/errorcode.js', ['goog.net.ErrorCode'], []);
goog.addDependency('net/eventtype.js', ['goog.net.EventType'], []);
goog.addDependency('net/filedownloader.js', ['goog.net.FileDownloader', 'goog.net.FileDownloader.Error'], ['goog.Disposable', 'goog.asserts', 'goog.async.Deferred', 'goog.crypt.hash32', 'goog.debug.Error', 'goog.events', 'goog.events.EventHandler', 'goog.fs', 'goog.fs.DirectoryEntry', 'goog.fs.Error', 'goog.fs.FileSaver', 'goog.net.EventType', 'goog.net.XhrIo', 'goog.net.XhrIoPool', 'goog.object']);
goog.addDependency('net/httpstatus.js', ['goog.net.HttpStatus'], []);
goog.addDependency('net/iframeio.js', ['goog.net.IframeIo', 'goog.net.IframeIo.IncrementalDataEvent'], ['goog.Timer', 'goog.Uri', 'goog.debug', 'goog.dom', 'goog.events', 'goog.events.Event', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.json', 'goog.log', 'goog.net.ErrorCode', 'goog.net.EventType', 'goog.reflect', 'goog.string', 'goog.structs', 'goog.userAgent']);
goog.addDependency('net/iframeloadmonitor.js', ['goog.net.IframeLoadMonitor'], ['goog.dom', 'goog.events', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.userAgent']);
goog.addDependency('net/imageloader.js', ['goog.net.ImageLoader'], ['goog.array', 'goog.dom', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.net.EventType', 'goog.object', 'goog.userAgent']);
goog.addDependency('net/ipaddress.js', ['goog.net.IpAddress', 'goog.net.Ipv4Address', 'goog.net.Ipv6Address'], ['goog.array', 'goog.math.Integer', 'goog.object', 'goog.string']);
goog.addDependency('net/jsloader.js', ['goog.net.jsloader', 'goog.net.jsloader.Error', 'goog.net.jsloader.ErrorCode', 'goog.net.jsloader.Options'], ['goog.array', 'goog.async.Deferred', 'goog.debug.Error', 'goog.dom', 'goog.dom.TagName']);
goog.addDependency('net/jsonp.js', ['goog.net.Jsonp'], ['goog.Uri', 'goog.net.jsloader']);
goog.addDependency('net/mockiframeio.js', ['goog.net.MockIFrameIo'], ['goog.events.EventTarget', 'goog.json', 'goog.net.ErrorCode', 'goog.net.EventType', 'goog.net.IframeIo']);
goog.addDependency('net/multiiframeloadmonitor.js', ['goog.net.MultiIframeLoadMonitor'], ['goog.events', 'goog.net.IframeLoadMonitor']);
goog.addDependency('net/networkstatusmonitor.js', ['goog.net.NetworkStatusMonitor'], ['goog.events.Listenable']);
goog.addDependency('net/networktester.js', ['goog.net.NetworkTester'], ['goog.Timer', 'goog.Uri', 'goog.log']);
goog.addDependency('net/testdata/jsloader_test1.js', ['goog.net.testdata.jsloader_test1'], []);
goog.addDependency('net/testdata/jsloader_test2.js', ['goog.net.testdata.jsloader_test2'], []);
goog.addDependency('net/testdata/jsloader_test3.js', ['goog.net.testdata.jsloader_test3'], []);
goog.addDependency('net/testdata/jsloader_test4.js', ['goog.net.testdata.jsloader_test4'], []);
goog.addDependency('net/tmpnetwork.js', ['goog.net.tmpnetwork'], ['goog.Uri', 'goog.net.ChannelDebug']);
goog.addDependency('net/websocket.js', ['goog.net.WebSocket', 'goog.net.WebSocket.ErrorEvent', 'goog.net.WebSocket.EventType', 'goog.net.WebSocket.MessageEvent'], ['goog.Timer', 'goog.asserts', 'goog.debug.entryPointRegistry', 'goog.events', 'goog.events.Event', 'goog.events.EventTarget', 'goog.log']);
goog.addDependency('net/wrapperxmlhttpfactory.js', ['goog.net.WrapperXmlHttpFactory'], ['goog.net.XhrLike', 'goog.net.XmlHttpFactory']);
goog.addDependency('net/xhrio.js', ['goog.net.XhrIo', 'goog.net.XhrIo.ResponseType'], ['goog.Timer', 'goog.array', 'goog.debug.entryPointRegistry', 'goog.events.EventTarget', 'goog.json', 'goog.log', 'goog.net.ErrorCode', 'goog.net.EventType', 'goog.net.HttpStatus', 'goog.net.XmlHttp', 'goog.object', 'goog.string', 'goog.structs', 'goog.structs.Map', 'goog.uri.utils', 'goog.userAgent']);
goog.addDependency('net/xhriopool.js', ['goog.net.XhrIoPool'], ['goog.net.XhrIo', 'goog.structs', 'goog.structs.PriorityPool']);
goog.addDependency('net/xhrlike.js', ['goog.net.XhrLike'], []);
goog.addDependency('net/xhrmanager.js', ['goog.net.XhrManager', 'goog.net.XhrManager.Event', 'goog.net.XhrManager.Request'], ['goog.Disposable', 'goog.events', 'goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.net.ErrorCode', 'goog.net.EventType', 'goog.net.XhrIo', 'goog.net.XhrIoPool', 'goog.structs', 'goog.structs.Map']);
goog.addDependency('net/xmlhttp.js', ['goog.net.DefaultXmlHttpFactory', 'goog.net.XmlHttp', 'goog.net.XmlHttp.OptionType', 'goog.net.XmlHttp.ReadyState'], ['goog.asserts', 'goog.net.WrapperXmlHttpFactory', 'goog.net.XmlHttpFactory']);
goog.addDependency('net/xmlhttpfactory.js', ['goog.net.XmlHttpFactory'], ['goog.net.XhrLike']);
goog.addDependency('net/xpc/crosspagechannel.js', ['goog.net.xpc.CrossPageChannel'], ['goog.Uri', 'goog.async.Deferred', 'goog.async.Delay', 'goog.dispose', 'goog.dom', 'goog.events', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.json', 'goog.log', 'goog.messaging.AbstractChannel', 'goog.net.xpc', 'goog.net.xpc.CfgFields', 'goog.net.xpc.ChannelStates', 'goog.net.xpc.CrossPageChannelRole', 'goog.net.xpc.DirectTransport', 'goog.net.xpc.FrameElementMethodTransport', 'goog.net.xpc.IframePollingTransport', 'goog.net.xpc.IframeRelayTransport', 'goog.net.xpc.NativeMessagingTransport', 'goog.net.xpc.NixTransport', 'goog.net.xpc.TransportTypes', 'goog.net.xpc.UriCfgFields', 'goog.string', 'goog.uri.utils', 'goog.userAgent']);
goog.addDependency('net/xpc/crosspagechannelrole.js', ['goog.net.xpc.CrossPageChannelRole'], []);
goog.addDependency('net/xpc/directtransport.js', ['goog.net.xpc.DirectTransport'], ['goog.Timer', 'goog.async.Deferred', 'goog.events.EventHandler', 'goog.log', 'goog.net.xpc', 'goog.net.xpc.CrossPageChannelRole', 'goog.net.xpc.Transport', 'goog.net.xpc.TransportTypes', 'goog.object']);
goog.addDependency('net/xpc/directtransport_test.js', ['goog.net.xpc.DirectTransportTest'], ['goog.dom', 'goog.log', 'goog.log.Level', 'goog.net.xpc', 'goog.net.xpc.CfgFields', 'goog.net.xpc.CrossPageChannel', 'goog.net.xpc.CrossPageChannelRole', 'goog.net.xpc.TransportTypes', 'goog.testing.AsyncTestCase', 'goog.testing.jsunit']);
goog.addDependency('net/xpc/frameelementmethodtransport.js', ['goog.net.xpc.FrameElementMethodTransport'], ['goog.log', 'goog.net.xpc', 'goog.net.xpc.CrossPageChannelRole', 'goog.net.xpc.Transport', 'goog.net.xpc.TransportTypes']);
goog.addDependency('net/xpc/iframepollingtransport.js', ['goog.net.xpc.IframePollingTransport', 'goog.net.xpc.IframePollingTransport.Receiver', 'goog.net.xpc.IframePollingTransport.Sender'], ['goog.array', 'goog.dom', 'goog.log', 'goog.log.Level', 'goog.net.xpc', 'goog.net.xpc.CfgFields', 'goog.net.xpc.CrossPageChannelRole', 'goog.net.xpc.Transport', 'goog.net.xpc.TransportTypes', 'goog.userAgent']);
goog.addDependency('net/xpc/iframerelaytransport.js', ['goog.net.xpc.IframeRelayTransport'], ['goog.dom', 'goog.events', 'goog.log', 'goog.log.Level', 'goog.net.xpc', 'goog.net.xpc.CfgFields', 'goog.net.xpc.Transport', 'goog.net.xpc.TransportTypes', 'goog.string', 'goog.userAgent']);
goog.addDependency('net/xpc/nativemessagingtransport.js', ['goog.net.xpc.NativeMessagingTransport'], ['goog.Timer', 'goog.asserts', 'goog.async.Deferred', 'goog.events', 'goog.events.EventHandler', 'goog.log', 'goog.net.xpc', 'goog.net.xpc.CrossPageChannelRole', 'goog.net.xpc.Transport', 'goog.net.xpc.TransportTypes']);
goog.addDependency('net/xpc/nixtransport.js', ['goog.net.xpc.NixTransport'], ['goog.log', 'goog.net.xpc', 'goog.net.xpc.CfgFields', 'goog.net.xpc.CrossPageChannelRole', 'goog.net.xpc.Transport', 'goog.net.xpc.TransportTypes', 'goog.reflect']);
goog.addDependency('net/xpc/relay.js', ['goog.net.xpc.relay'], []);
goog.addDependency('net/xpc/transport.js', ['goog.net.xpc.Transport'], ['goog.Disposable', 'goog.dom', 'goog.net.xpc.TransportNames']);
goog.addDependency('net/xpc/xpc.js', ['goog.net.xpc', 'goog.net.xpc.CfgFields', 'goog.net.xpc.ChannelStates', 'goog.net.xpc.TransportNames', 'goog.net.xpc.TransportTypes', 'goog.net.xpc.UriCfgFields'], ['goog.log']);
goog.addDependency('object/object.js', ['goog.object'], []);
goog.addDependency('positioning/absoluteposition.js', ['goog.positioning.AbsolutePosition'], ['goog.math.Box', 'goog.math.Coordinate', 'goog.math.Size', 'goog.positioning', 'goog.positioning.AbstractPosition']);
goog.addDependency('positioning/abstractposition.js', ['goog.positioning.AbstractPosition'], ['goog.math.Box', 'goog.math.Size', 'goog.positioning.Corner']);
goog.addDependency('positioning/anchoredposition.js', ['goog.positioning.AnchoredPosition'], ['goog.math.Box', 'goog.positioning', 'goog.positioning.AbstractPosition']);
goog.addDependency('positioning/anchoredviewportposition.js', ['goog.positioning.AnchoredViewportPosition'], ['goog.math.Box', 'goog.positioning', 'goog.positioning.AnchoredPosition', 'goog.positioning.Corner', 'goog.positioning.Overflow', 'goog.positioning.OverflowStatus']);
goog.addDependency('positioning/clientposition.js', ['goog.positioning.ClientPosition'], ['goog.asserts', 'goog.math.Box', 'goog.math.Coordinate', 'goog.math.Size', 'goog.positioning', 'goog.positioning.AbstractPosition', 'goog.style']);
goog.addDependency('positioning/clientposition_test.js', ['goog.positioning.clientPositionTest'], ['goog.dom', 'goog.positioning.ClientPosition', 'goog.style', 'goog.testing.jsunit']);
goog.addDependency('positioning/menuanchoredposition.js', ['goog.positioning.MenuAnchoredPosition'], ['goog.math.Box', 'goog.math.Size', 'goog.positioning', 'goog.positioning.AnchoredViewportPosition', 'goog.positioning.Corner', 'goog.positioning.Overflow']);
goog.addDependency('positioning/positioning.js', ['goog.positioning', 'goog.positioning.Corner', 'goog.positioning.CornerBit', 'goog.positioning.Overflow', 'goog.positioning.OverflowStatus'], ['goog.asserts', 'goog.dom', 'goog.dom.TagName', 'goog.math.Box', 'goog.math.Coordinate', 'goog.math.Size', 'goog.style', 'goog.style.bidi']);
goog.addDependency('positioning/positioning_test.js', ['goog.positioningTest'], ['goog.dom', 'goog.dom.DomHelper', 'goog.math.Box', 'goog.math.Coordinate', 'goog.math.Rect', 'goog.math.Size', 'goog.positioning', 'goog.positioning.Corner', 'goog.positioning.Overflow', 'goog.positioning.OverflowStatus', 'goog.style', 'goog.testing.ExpectedFailures', 'goog.testing.jsunit', 'goog.userAgent', 'goog.userAgent.product']);
goog.addDependency('positioning/viewportclientposition.js', ['goog.positioning.ViewportClientPosition'], ['goog.math.Box', 'goog.math.Coordinate', 'goog.math.Size', 'goog.positioning.ClientPosition']);
goog.addDependency('positioning/viewportposition.js', ['goog.positioning.ViewportPosition'], ['goog.math.Box', 'goog.math.Coordinate', 'goog.math.Size', 'goog.positioning.AbstractPosition']);
goog.addDependency('proto/proto.js', ['goog.proto'], ['goog.proto.Serializer']);
goog.addDependency('proto/serializer.js', ['goog.proto.Serializer'], ['goog.json.Serializer', 'goog.string']);
goog.addDependency('proto2/descriptor.js', ['goog.proto2.Descriptor', 'goog.proto2.Metadata'], ['goog.array', 'goog.asserts', 'goog.object', 'goog.string']);
goog.addDependency('proto2/fielddescriptor.js', ['goog.proto2.FieldDescriptor'], ['goog.asserts', 'goog.string']);
goog.addDependency('proto2/lazydeserializer.js', ['goog.proto2.LazyDeserializer'], ['goog.asserts', 'goog.proto2.Message', 'goog.proto2.Serializer']);
goog.addDependency('proto2/message.js', ['goog.proto2.Message'], ['goog.asserts', 'goog.proto2.Descriptor', 'goog.proto2.FieldDescriptor', 'goog.string']);
goog.addDependency('proto2/objectserializer.js', ['goog.proto2.ObjectSerializer'], ['goog.asserts', 'goog.proto2.Serializer', 'goog.string']);
goog.addDependency('proto2/package_test.pb.js', ['someprotopackage.TestPackageTypes'], ['goog.proto2.Message', 'proto2.TestAllTypes']);
goog.addDependency('proto2/pbliteserializer.js', ['goog.proto2.PbLiteSerializer'], ['goog.asserts', 'goog.proto2.FieldDescriptor', 'goog.proto2.LazyDeserializer', 'goog.proto2.Serializer']);
goog.addDependency('proto2/serializer.js', ['goog.proto2.Serializer'], ['goog.asserts', 'goog.proto2.FieldDescriptor', 'goog.proto2.Message']);
goog.addDependency('proto2/test.pb.js', ['proto2.TestAllTypes', 'proto2.TestAllTypes.NestedEnum', 'proto2.TestAllTypes.NestedMessage', 'proto2.TestAllTypes.OptionalGroup', 'proto2.TestAllTypes.RepeatedGroup', 'proto2.TestDefaultChild', 'proto2.TestDefaultParent'], ['goog.proto2.Message']);
goog.addDependency('proto2/textformatserializer.js', ['goog.proto2.TextFormatSerializer'], ['goog.array', 'goog.asserts', 'goog.json', 'goog.math', 'goog.object', 'goog.proto2.FieldDescriptor', 'goog.proto2.Message', 'goog.proto2.Serializer', 'goog.string']);
goog.addDependency('proto2/textformatserializer_test.js', ['goog.proto2.TextFormatSerializerTest'], ['goog.proto2.ObjectSerializer', 'goog.proto2.TextFormatSerializer', 'goog.testing.jsunit', 'proto2.TestAllTypes']);
goog.addDependency('proto2/util.js', ['goog.proto2.Util'], ['goog.asserts']);
goog.addDependency('pubsub/pubsub.js', ['goog.pubsub.PubSub'], ['goog.Disposable', 'goog.array']);
goog.addDependency('reflect/reflect.js', ['goog.reflect'], []);
goog.addDependency('result/deferredadaptor.js', ['goog.result.DeferredAdaptor'], ['goog.async.Deferred', 'goog.result', 'goog.result.Result']);
goog.addDependency('result/dependentresult.js', ['goog.result.DependentResult'], ['goog.result.Result']);
goog.addDependency('result/result_interface.js', ['goog.result.Result'], []);
goog.addDependency('result/resultutil.js', ['goog.result'], ['goog.array', 'goog.result.DependentResult', 'goog.result.Result', 'goog.result.SimpleResult']);
goog.addDependency('result/simpleresult.js', ['goog.result.SimpleResult', 'goog.result.SimpleResult.StateError'], ['goog.debug.Error', 'goog.result.Result']);
goog.addDependency('soy/data.js', ['goog.soy.data', 'goog.soy.data.SanitizedContent', 'goog.soy.data.SanitizedContentKind'], ['goog.i18n.bidi.Dir']);
goog.addDependency('soy/renderer.js', ['goog.soy.InjectedDataSupplier', 'goog.soy.Renderer'], ['goog.asserts', 'goog.dom', 'goog.html.uncheckedconversions', 'goog.soy', 'goog.soy.data.SanitizedContent', 'goog.soy.data.SanitizedContentKind', 'goog.string.Const']);
goog.addDependency('soy/soy.js', ['goog.soy'], ['goog.asserts', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.TagName', 'goog.soy.data', 'goog.string']);
goog.addDependency('soy/soy_test.js', ['goog.soy.testHelper'], ['goog.dom', 'goog.dom.TagName', 'goog.i18n.bidi.Dir', 'goog.soy.data.SanitizedContent', 'goog.soy.data.SanitizedContentKind', 'goog.string', 'goog.userAgent']);
goog.addDependency('spell/spellcheck.js', ['goog.spell.SpellCheck', 'goog.spell.SpellCheck.WordChangedEvent'], ['goog.Timer', 'goog.events.EventTarget', 'goog.structs.Set']);
goog.addDependency('stats/basicstat.js', ['goog.stats.BasicStat'], ['goog.array', 'goog.iter', 'goog.log', 'goog.object', 'goog.string.format', 'goog.structs.CircularBuffer']);
goog.addDependency('storage/collectablestorage.js', ['goog.storage.CollectableStorage'], ['goog.array', 'goog.iter', 'goog.storage.ErrorCode', 'goog.storage.ExpiringStorage', 'goog.storage.RichStorage']);
goog.addDependency('storage/collectablestoragetester.js', ['goog.storage.collectableStorageTester'], ['goog.testing.asserts']);
goog.addDependency('storage/encryptedstorage.js', ['goog.storage.EncryptedStorage'], ['goog.crypt', 'goog.crypt.Arc4', 'goog.crypt.Sha1', 'goog.crypt.base64', 'goog.json', 'goog.json.Serializer', 'goog.storage.CollectableStorage', 'goog.storage.ErrorCode', 'goog.storage.RichStorage', 'goog.storage.RichStorage.Wrapper', 'goog.storage.mechanism.IterableMechanism']);
goog.addDependency('storage/errorcode.js', ['goog.storage.ErrorCode'], []);
goog.addDependency('storage/expiringstorage.js', ['goog.storage.ExpiringStorage'], ['goog.storage.RichStorage', 'goog.storage.RichStorage.Wrapper', 'goog.storage.mechanism.Mechanism']);
goog.addDependency('storage/mechanism/errorcode.js', ['goog.storage.mechanism.ErrorCode'], []);
goog.addDependency('storage/mechanism/errorhandlingmechanism.js', ['goog.storage.mechanism.ErrorHandlingMechanism'], ['goog.storage.mechanism.Mechanism']);
goog.addDependency('storage/mechanism/html5localstorage.js', ['goog.storage.mechanism.HTML5LocalStorage'], ['goog.storage.mechanism.HTML5WebStorage']);
goog.addDependency('storage/mechanism/html5sessionstorage.js', ['goog.storage.mechanism.HTML5SessionStorage'], ['goog.storage.mechanism.HTML5WebStorage']);
goog.addDependency('storage/mechanism/html5webstorage.js', ['goog.storage.mechanism.HTML5WebStorage'], ['goog.asserts', 'goog.iter.Iterator', 'goog.iter.StopIteration', 'goog.storage.mechanism.ErrorCode', 'goog.storage.mechanism.IterableMechanism']);
goog.addDependency('storage/mechanism/ieuserdata.js', ['goog.storage.mechanism.IEUserData'], ['goog.asserts', 'goog.iter.Iterator', 'goog.iter.StopIteration', 'goog.storage.mechanism.ErrorCode', 'goog.storage.mechanism.IterableMechanism', 'goog.structs.Map', 'goog.userAgent']);
goog.addDependency('storage/mechanism/iterablemechanism.js', ['goog.storage.mechanism.IterableMechanism'], ['goog.array', 'goog.asserts', 'goog.iter', 'goog.iter.Iterator', 'goog.storage.mechanism.Mechanism']);
goog.addDependency('storage/mechanism/iterablemechanismtester.js', ['goog.storage.mechanism.iterableMechanismTester'], ['goog.iter.Iterator', 'goog.storage.mechanism.IterableMechanism', 'goog.testing.asserts']);
goog.addDependency('storage/mechanism/mechanism.js', ['goog.storage.mechanism.Mechanism'], []);
goog.addDependency('storage/mechanism/mechanismfactory.js', ['goog.storage.mechanism.mechanismfactory'], ['goog.storage.mechanism.HTML5LocalStorage', 'goog.storage.mechanism.HTML5SessionStorage', 'goog.storage.mechanism.IEUserData', 'goog.storage.mechanism.IterableMechanism', 'goog.storage.mechanism.PrefixedMechanism']);
goog.addDependency('storage/mechanism/mechanismseparationtester.js', ['goog.storage.mechanism.mechanismSeparationTester'], ['goog.iter.Iterator', 'goog.storage.mechanism.IterableMechanism', 'goog.testing.asserts']);
goog.addDependency('storage/mechanism/mechanismsharingtester.js', ['goog.storage.mechanism.mechanismSharingTester'], ['goog.iter.Iterator', 'goog.storage.mechanism.IterableMechanism', 'goog.testing.asserts']);
goog.addDependency('storage/mechanism/mechanismtester.js', ['goog.storage.mechanism.mechanismTester'], ['goog.storage.mechanism.ErrorCode', 'goog.storage.mechanism.HTML5LocalStorage', 'goog.storage.mechanism.Mechanism', 'goog.testing.asserts', 'goog.userAgent.product', 'goog.userAgent.product.isVersion']);
goog.addDependency('storage/mechanism/prefixedmechanism.js', ['goog.storage.mechanism.PrefixedMechanism'], ['goog.iter.Iterator', 'goog.storage.mechanism.IterableMechanism']);
goog.addDependency('storage/richstorage.js', ['goog.storage.RichStorage', 'goog.storage.RichStorage.Wrapper'], ['goog.storage.ErrorCode', 'goog.storage.Storage', 'goog.storage.mechanism.Mechanism']);
goog.addDependency('storage/storage.js', ['goog.storage.Storage'], ['goog.json', 'goog.json.Serializer', 'goog.storage.ErrorCode']);
goog.addDependency('storage/storage_test.js', ['goog.storage.storage_test'], ['goog.storage.Storage', 'goog.structs.Map', 'goog.testing.asserts']);
goog.addDependency('string/const.js', ['goog.string.Const'], ['goog.asserts', 'goog.string.TypedString']);
goog.addDependency('string/const_test.js', ['goog.string.constTest'], ['goog.string.Const', 'goog.testing.jsunit']);
goog.addDependency('string/linkify.js', ['goog.string.linkify'], ['goog.string']);
goog.addDependency('string/newlines.js', ['goog.string.newlines', 'goog.string.newlines.Line'], ['goog.array']);
goog.addDependency('string/newlines_test.js', ['goog.string.newlinesTest'], ['goog.string.newlines', 'goog.testing.jsunit']);
goog.addDependency('string/parser.js', ['goog.string.Parser'], []);
goog.addDependency('string/path.js', ['goog.string.path'], ['goog.array', 'goog.string']);
goog.addDependency('string/string.js', ['goog.string', 'goog.string.Unicode'], []);
goog.addDependency('string/string_test.js', ['goog.stringTest'], ['goog.functions', 'goog.object', 'goog.string', 'goog.testing.MockControl', 'goog.testing.PropertyReplacer', 'goog.testing.jsunit']);
goog.addDependency('string/stringbuffer.js', ['goog.string.StringBuffer'], []);
goog.addDependency('string/stringformat.js', ['goog.string.format'], ['goog.string']);
goog.addDependency('string/stringifier.js', ['goog.string.Stringifier'], []);
goog.addDependency('string/typedstring.js', ['goog.string.TypedString'], []);
goog.addDependency('structs/avltree.js', ['goog.structs.AvlTree', 'goog.structs.AvlTree.Node'], ['goog.structs.Collection']);
goog.addDependency('structs/circularbuffer.js', ['goog.structs.CircularBuffer'], []);
goog.addDependency('structs/collection.js', ['goog.structs.Collection'], []);
goog.addDependency('structs/heap.js', ['goog.structs.Heap'], ['goog.array', 'goog.object', 'goog.structs.Node']);
goog.addDependency('structs/inversionmap.js', ['goog.structs.InversionMap'], ['goog.array']);
goog.addDependency('structs/linkedmap.js', ['goog.structs.LinkedMap'], ['goog.structs.Map']);
goog.addDependency('structs/map.js', ['goog.structs.Map'], ['goog.iter.Iterator', 'goog.iter.StopIteration', 'goog.object']);
goog.addDependency('structs/node.js', ['goog.structs.Node'], []);
goog.addDependency('structs/pool.js', ['goog.structs.Pool'], ['goog.Disposable', 'goog.structs.Queue', 'goog.structs.Set']);
goog.addDependency('structs/prioritypool.js', ['goog.structs.PriorityPool'], ['goog.structs.Pool', 'goog.structs.PriorityQueue']);
goog.addDependency('structs/priorityqueue.js', ['goog.structs.PriorityQueue'], ['goog.structs.Heap']);
goog.addDependency('structs/quadtree.js', ['goog.structs.QuadTree', 'goog.structs.QuadTree.Node', 'goog.structs.QuadTree.Point'], ['goog.math.Coordinate']);
goog.addDependency('structs/queue.js', ['goog.structs.Queue'], ['goog.array']);
goog.addDependency('structs/set.js', ['goog.structs.Set'], ['goog.structs', 'goog.structs.Collection', 'goog.structs.Map']);
goog.addDependency('structs/simplepool.js', ['goog.structs.SimplePool'], ['goog.Disposable']);
goog.addDependency('structs/stringset.js', ['goog.structs.StringSet'], ['goog.asserts', 'goog.iter']);
goog.addDependency('structs/structs.js', ['goog.structs'], ['goog.array', 'goog.object']);
goog.addDependency('structs/treenode.js', ['goog.structs.TreeNode'], ['goog.array', 'goog.asserts', 'goog.structs.Node']);
goog.addDependency('structs/trie.js', ['goog.structs.Trie'], ['goog.object', 'goog.structs']);
goog.addDependency('style/bidi.js', ['goog.style.bidi'], ['goog.dom', 'goog.style', 'goog.userAgent']);
goog.addDependency('style/cursor.js', ['goog.style.cursor'], ['goog.userAgent']);
goog.addDependency('style/style.js', ['goog.style'], ['goog.array', 'goog.asserts', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.vendor', 'goog.math.Box', 'goog.math.Coordinate', 'goog.math.Rect', 'goog.math.Size', 'goog.object', 'goog.string', 'goog.userAgent']);
goog.addDependency('style/style_test.js', ['goog.style_test'], ['goog.array', 'goog.color', 'goog.dom', 'goog.events.BrowserEvent', 'goog.math.Box', 'goog.math.Coordinate', 'goog.math.Rect', 'goog.math.Size', 'goog.object', 'goog.string', 'goog.style', 'goog.testing.ExpectedFailures', 'goog.testing.PropertyReplacer', 'goog.testing.asserts', 'goog.testing.jsunit', 'goog.userAgent', 'goog.userAgent.product', 'goog.userAgent.product.isVersion']);
goog.addDependency('style/stylescrollbartester.js', ['goog.styleScrollbarTester'], ['goog.dom', 'goog.style', 'goog.testing.asserts']);
goog.addDependency('style/transition.js', ['goog.style.transition', 'goog.style.transition.Css3Property'], ['goog.array', 'goog.asserts', 'goog.dom.vendor', 'goog.style', 'goog.userAgent']);
goog.addDependency('testing/asserts.js', ['goog.testing.JsUnitException', 'goog.testing.asserts'], ['goog.testing.stacktrace']);
goog.addDependency('testing/async/mockcontrol.js', ['goog.testing.async.MockControl'], ['goog.asserts', 'goog.async.Deferred', 'goog.debug', 'goog.testing.asserts', 'goog.testing.mockmatchers.IgnoreArgument']);
goog.addDependency('testing/asynctestcase.js', ['goog.testing.AsyncTestCase', 'goog.testing.AsyncTestCase.ControlBreakingException'], ['goog.testing.TestCase', 'goog.testing.TestCase.Test', 'goog.testing.asserts']);
goog.addDependency('testing/benchmark.js', ['goog.testing.benchmark'], ['goog.dom', 'goog.dom.TagName', 'goog.testing.PerformanceTable', 'goog.testing.PerformanceTimer', 'goog.testing.TestCase']);
goog.addDependency('testing/continuationtestcase.js', ['goog.testing.ContinuationTestCase', 'goog.testing.ContinuationTestCase.Step', 'goog.testing.ContinuationTestCase.Test'], ['goog.array', 'goog.events.EventHandler', 'goog.testing.TestCase', 'goog.testing.TestCase.Test', 'goog.testing.asserts']);
goog.addDependency('testing/deferredtestcase.js', ['goog.testing.DeferredTestCase'], ['goog.async.Deferred', 'goog.testing.AsyncTestCase', 'goog.testing.TestCase']);
goog.addDependency('testing/dom.js', ['goog.testing.dom'], ['goog.array', 'goog.asserts', 'goog.dom', 'goog.dom.NodeIterator', 'goog.dom.NodeType', 'goog.dom.TagIterator', 'goog.dom.TagName', 'goog.dom.classlist', 'goog.iter', 'goog.object', 'goog.string', 'goog.style', 'goog.testing.asserts', 'goog.userAgent']);
goog.addDependency('testing/editor/dom.js', ['goog.testing.editor.dom'], ['goog.dom.NodeType', 'goog.dom.TagIterator', 'goog.dom.TagWalkType', 'goog.iter', 'goog.string', 'goog.testing.asserts']);
goog.addDependency('testing/editor/fieldmock.js', ['goog.testing.editor.FieldMock'], ['goog.dom', 'goog.dom.Range', 'goog.editor.Field', 'goog.testing.LooseMock', 'goog.testing.mockmatchers']);
goog.addDependency('testing/editor/testhelper.js', ['goog.testing.editor.TestHelper'], ['goog.Disposable', 'goog.dom', 'goog.dom.Range', 'goog.editor.BrowserFeature', 'goog.editor.node', 'goog.editor.plugins.AbstractBubblePlugin', 'goog.testing.dom']);
goog.addDependency('testing/events/eventobserver.js', ['goog.testing.events.EventObserver'], ['goog.array']);
goog.addDependency('testing/events/events.js', ['goog.testing.events', 'goog.testing.events.Event'], ['goog.Disposable', 'goog.asserts', 'goog.dom.NodeType', 'goog.events', 'goog.events.BrowserEvent', 'goog.events.BrowserFeature', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.object', 'goog.style', 'goog.userAgent']);
goog.addDependency('testing/events/matchers.js', ['goog.testing.events.EventMatcher'], ['goog.events.Event', 'goog.testing.mockmatchers.ArgumentMatcher']);
goog.addDependency('testing/events/onlinehandler.js', ['goog.testing.events.OnlineHandler'], ['goog.events.EventTarget', 'goog.net.NetworkStatusMonitor']);
goog.addDependency('testing/expectedfailures.js', ['goog.testing.ExpectedFailures'], ['goog.debug.DivConsole', 'goog.dom', 'goog.dom.TagName', 'goog.events', 'goog.events.EventType', 'goog.log', 'goog.style', 'goog.testing.JsUnitException', 'goog.testing.TestCase', 'goog.testing.asserts']);
goog.addDependency('testing/fs/blob.js', ['goog.testing.fs.Blob'], ['goog.crypt.base64']);
goog.addDependency('testing/fs/entry.js', ['goog.testing.fs.DirectoryEntry', 'goog.testing.fs.Entry', 'goog.testing.fs.FileEntry'], ['goog.Timer', 'goog.array', 'goog.asserts', 'goog.async.Deferred', 'goog.fs.DirectoryEntry', 'goog.fs.DirectoryEntryImpl', 'goog.fs.Entry', 'goog.fs.Error', 'goog.fs.FileEntry', 'goog.functions', 'goog.object', 'goog.string', 'goog.testing.fs.File', 'goog.testing.fs.FileWriter']);
goog.addDependency('testing/fs/file.js', ['goog.testing.fs.File'], ['goog.testing.fs.Blob']);
goog.addDependency('testing/fs/filereader.js', ['goog.testing.fs.FileReader'], ['goog.Timer', 'goog.events.EventTarget', 'goog.fs.Error', 'goog.fs.FileReader.EventType', 'goog.fs.FileReader.ReadyState', 'goog.testing.fs.File', 'goog.testing.fs.ProgressEvent']);
goog.addDependency('testing/fs/filesystem.js', ['goog.testing.fs.FileSystem'], ['goog.fs.FileSystem', 'goog.testing.fs.DirectoryEntry']);
goog.addDependency('testing/fs/filewriter.js', ['goog.testing.fs.FileWriter'], ['goog.Timer', 'goog.events.Event', 'goog.events.EventTarget', 'goog.fs.Error', 'goog.fs.FileSaver.EventType', 'goog.fs.FileSaver.ReadyState', 'goog.string', 'goog.testing.fs.File', 'goog.testing.fs.ProgressEvent']);
goog.addDependency('testing/fs/fs.js', ['goog.testing.fs'], ['goog.Timer', 'goog.array', 'goog.async.Deferred', 'goog.fs', 'goog.testing.fs.Blob', 'goog.testing.fs.FileSystem']);
goog.addDependency('testing/fs/progressevent.js', ['goog.testing.fs.ProgressEvent'], ['goog.events.Event']);
goog.addDependency('testing/functionmock.js', ['goog.testing', 'goog.testing.FunctionMock', 'goog.testing.GlobalFunctionMock', 'goog.testing.MethodMock'], ['goog.object', 'goog.testing.LooseMock', 'goog.testing.Mock', 'goog.testing.MockInterface', 'goog.testing.PropertyReplacer', 'goog.testing.StrictMock']);
goog.addDependency('testing/graphics.js', ['goog.testing.graphics'], ['goog.graphics.Path.Segment', 'goog.testing.asserts']);
goog.addDependency('testing/i18n/asserts.js', ['goog.testing.i18n.asserts'], ['goog.testing.jsunit']);
goog.addDependency('testing/i18n/asserts_test.js', ['goog.testing.i18n.assertsTest'], ['goog.testing.ExpectedFailures', 'goog.testing.i18n.asserts']);
goog.addDependency('testing/jsunit.js', ['goog.testing.jsunit'], ['goog.testing.TestCase', 'goog.testing.TestRunner']);
goog.addDependency('testing/loosemock.js', ['goog.testing.LooseExpectationCollection', 'goog.testing.LooseMock'], ['goog.array', 'goog.structs.Map', 'goog.testing.Mock']);
goog.addDependency('testing/messaging/mockmessagechannel.js', ['goog.testing.messaging.MockMessageChannel'], ['goog.messaging.AbstractChannel', 'goog.testing.asserts']);
goog.addDependency('testing/messaging/mockmessageevent.js', ['goog.testing.messaging.MockMessageEvent'], ['goog.events.BrowserEvent', 'goog.events.EventType', 'goog.testing.events']);
goog.addDependency('testing/messaging/mockmessageport.js', ['goog.testing.messaging.MockMessagePort'], ['goog.events.EventTarget']);
goog.addDependency('testing/messaging/mockportnetwork.js', ['goog.testing.messaging.MockPortNetwork'], ['goog.messaging.PortNetwork', 'goog.testing.messaging.MockMessageChannel']);
goog.addDependency('testing/mock.js', ['goog.testing.Mock', 'goog.testing.MockExpectation'], ['goog.array', 'goog.object', 'goog.testing.JsUnitException', 'goog.testing.MockInterface', 'goog.testing.mockmatchers']);
goog.addDependency('testing/mockclassfactory.js', ['goog.testing.MockClassFactory', 'goog.testing.MockClassRecord'], ['goog.array', 'goog.object', 'goog.testing.LooseMock', 'goog.testing.StrictMock', 'goog.testing.TestCase', 'goog.testing.mockmatchers']);
goog.addDependency('testing/mockclock.js', ['goog.testing.MockClock'], ['goog.Disposable', 'goog.testing.PropertyReplacer', 'goog.testing.events', 'goog.testing.events.Event', 'goog.testing.watchers']);
goog.addDependency('testing/mockcontrol.js', ['goog.testing.MockControl'], ['goog.array', 'goog.testing', 'goog.testing.LooseMock', 'goog.testing.MockInterface', 'goog.testing.StrictMock']);
goog.addDependency('testing/mockinterface.js', ['goog.testing.MockInterface'], []);
goog.addDependency('testing/mockmatchers.js', ['goog.testing.mockmatchers', 'goog.testing.mockmatchers.ArgumentMatcher', 'goog.testing.mockmatchers.IgnoreArgument', 'goog.testing.mockmatchers.InstanceOf', 'goog.testing.mockmatchers.ObjectEquals', 'goog.testing.mockmatchers.RegexpMatch', 'goog.testing.mockmatchers.SaveArgument', 'goog.testing.mockmatchers.TypeOf'], ['goog.array', 'goog.dom', 'goog.testing.asserts']);
goog.addDependency('testing/mockrandom.js', ['goog.testing.MockRandom'], ['goog.Disposable']);
goog.addDependency('testing/mockrange.js', ['goog.testing.MockRange'], ['goog.dom.AbstractRange', 'goog.testing.LooseMock']);
goog.addDependency('testing/mockstorage.js', ['goog.testing.MockStorage'], ['goog.structs.Map']);
goog.addDependency('testing/mockuseragent.js', ['goog.testing.MockUserAgent'], ['goog.Disposable', 'goog.userAgent']);
goog.addDependency('testing/multitestrunner.js', ['goog.testing.MultiTestRunner', 'goog.testing.MultiTestRunner.TestFrame'], ['goog.Timer', 'goog.array', 'goog.dom', 'goog.dom.classlist', 'goog.events.EventHandler', 'goog.functions', 'goog.string', 'goog.ui.Component', 'goog.ui.ServerChart', 'goog.ui.TableSorter']);
goog.addDependency('testing/net/xhrio.js', ['goog.testing.net.XhrIo'], ['goog.array', 'goog.dom.xml', 'goog.events', 'goog.events.EventTarget', 'goog.json', 'goog.net.ErrorCode', 'goog.net.EventType', 'goog.net.HttpStatus', 'goog.net.XhrIo', 'goog.net.XmlHttp', 'goog.object', 'goog.structs.Map']);
goog.addDependency('testing/net/xhriopool.js', ['goog.testing.net.XhrIoPool'], ['goog.net.XhrIoPool', 'goog.testing.net.XhrIo']);
goog.addDependency('testing/objectpropertystring.js', ['goog.testing.ObjectPropertyString'], []);
goog.addDependency('testing/performancetable.js', ['goog.testing.PerformanceTable'], ['goog.dom', 'goog.testing.PerformanceTimer']);
goog.addDependency('testing/performancetimer.js', ['goog.testing.PerformanceTimer', 'goog.testing.PerformanceTimer.Task'], ['goog.array', 'goog.async.Deferred', 'goog.math']);
goog.addDependency('testing/propertyreplacer.js', ['goog.testing.PropertyReplacer'], ['goog.userAgent']);
goog.addDependency('testing/proto2/proto2.js', ['goog.testing.proto2'], ['goog.proto2.Message', 'goog.proto2.ObjectSerializer', 'goog.testing.asserts']);
goog.addDependency('testing/pseudorandom.js', ['goog.testing.PseudoRandom'], ['goog.Disposable']);
goog.addDependency('testing/recordfunction.js', ['goog.testing.FunctionCall', 'goog.testing.recordConstructor', 'goog.testing.recordFunction'], ['goog.testing.asserts']);
goog.addDependency('testing/shardingtestcase.js', ['goog.testing.ShardingTestCase'], ['goog.asserts', 'goog.testing.TestCase']);
goog.addDependency('testing/singleton.js', ['goog.testing.singleton'], []);
goog.addDependency('testing/stacktrace.js', ['goog.testing.stacktrace', 'goog.testing.stacktrace.Frame'], []);
goog.addDependency('testing/storage/fakemechanism.js', ['goog.testing.storage.FakeMechanism'], ['goog.storage.mechanism.IterableMechanism', 'goog.structs.Map']);
goog.addDependency('testing/strictmock.js', ['goog.testing.StrictMock'], ['goog.array', 'goog.testing.Mock']);
goog.addDependency('testing/style/layoutasserts.js', ['goog.testing.style.layoutasserts'], ['goog.style', 'goog.testing.asserts', 'goog.testing.style']);
goog.addDependency('testing/style/style.js', ['goog.testing.style'], ['goog.dom', 'goog.math.Rect', 'goog.style']);
goog.addDependency('testing/testcase.js', ['goog.testing.TestCase', 'goog.testing.TestCase.Error', 'goog.testing.TestCase.Order', 'goog.testing.TestCase.Result', 'goog.testing.TestCase.Test'], ['goog.object', 'goog.testing.asserts', 'goog.testing.stacktrace']);
goog.addDependency('testing/testqueue.js', ['goog.testing.TestQueue'], []);
goog.addDependency('testing/testrunner.js', ['goog.testing.TestRunner'], ['goog.testing.TestCase']);
goog.addDependency('testing/ui/rendererasserts.js', ['goog.testing.ui.rendererasserts'], ['goog.testing.asserts']);
goog.addDependency('testing/ui/rendererharness.js', ['goog.testing.ui.RendererHarness'], ['goog.Disposable', 'goog.dom.NodeType', 'goog.testing.asserts', 'goog.testing.dom']);
goog.addDependency('testing/ui/style.js', ['goog.testing.ui.style'], ['goog.array', 'goog.asserts', 'goog.dom', 'goog.dom.classlist', 'goog.testing.asserts']);
goog.addDependency('testing/watchers.js', ['goog.testing.watchers'], []);
goog.addDependency('timer/timer.js', ['goog.Timer'], ['goog.events.EventTarget']);
goog.addDependency('tweak/entries.js', ['goog.tweak.BaseEntry', 'goog.tweak.BasePrimitiveSetting', 'goog.tweak.BaseSetting', 'goog.tweak.BooleanGroup', 'goog.tweak.BooleanInGroupSetting', 'goog.tweak.BooleanSetting', 'goog.tweak.ButtonAction', 'goog.tweak.NumericSetting', 'goog.tweak.StringSetting'], ['goog.array', 'goog.asserts', 'goog.log', 'goog.object']);
goog.addDependency('tweak/registry.js', ['goog.tweak.Registry'], ['goog.asserts', 'goog.log', 'goog.object', 'goog.string', 'goog.tweak.BaseEntry', 'goog.uri.utils']);
goog.addDependency('tweak/testhelpers.js', ['goog.tweak.testhelpers'], ['goog.tweak', 'goog.tweak.BooleanGroup', 'goog.tweak.BooleanInGroupSetting', 'goog.tweak.BooleanSetting', 'goog.tweak.ButtonAction', 'goog.tweak.NumericSetting', 'goog.tweak.Registry', 'goog.tweak.StringSetting']);
goog.addDependency('tweak/tweak.js', ['goog.tweak', 'goog.tweak.ConfigParams'], ['goog.asserts', 'goog.tweak.BaseSetting', 'goog.tweak.BooleanGroup', 'goog.tweak.BooleanInGroupSetting', 'goog.tweak.BooleanSetting', 'goog.tweak.ButtonAction', 'goog.tweak.NumericSetting', 'goog.tweak.Registry', 'goog.tweak.StringSetting']);
goog.addDependency('tweak/tweakui.js', ['goog.tweak.EntriesPanel', 'goog.tweak.TweakUi'], ['goog.array', 'goog.asserts', 'goog.dom.DomHelper', 'goog.object', 'goog.style', 'goog.tweak', 'goog.ui.Zippy', 'goog.userAgent']);
goog.addDependency('ui/abstractspellchecker.js', ['goog.ui.AbstractSpellChecker', 'goog.ui.AbstractSpellChecker.AsyncResult'], ['goog.a11y.aria', 'goog.array', 'goog.asserts', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.classlist', 'goog.dom.selection', 'goog.events', 'goog.events.Event', 'goog.events.EventType', 'goog.math.Coordinate', 'goog.spell.SpellCheck', 'goog.structs.Set', 'goog.style', 'goog.ui.Component', 'goog.ui.MenuItem', 'goog.ui.MenuSeparator', 'goog.ui.PopupMenu']);
goog.addDependency('ui/ac/ac.js', ['goog.ui.ac'], ['goog.ui.ac.ArrayMatcher', 'goog.ui.ac.AutoComplete', 'goog.ui.ac.InputHandler', 'goog.ui.ac.Renderer']);
goog.addDependency('ui/ac/arraymatcher.js', ['goog.ui.ac.ArrayMatcher'], ['goog.string']);
goog.addDependency('ui/ac/autocomplete.js', ['goog.ui.ac.AutoComplete', 'goog.ui.ac.AutoComplete.EventType'], ['goog.array', 'goog.asserts', 'goog.events', 'goog.events.EventTarget', 'goog.object']);
goog.addDependency('ui/ac/cachingmatcher.js', ['goog.ui.ac.CachingMatcher'], ['goog.array', 'goog.async.Throttle', 'goog.ui.ac.ArrayMatcher', 'goog.ui.ac.RenderOptions']);
goog.addDependency('ui/ac/inputhandler.js', ['goog.ui.ac.InputHandler'], ['goog.Disposable', 'goog.Timer', 'goog.a11y.aria', 'goog.dom', 'goog.dom.selection', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.events.KeyHandler', 'goog.string', 'goog.userAgent', 'goog.userAgent.product']);
goog.addDependency('ui/ac/remote.js', ['goog.ui.ac.Remote'], ['goog.ui.ac.AutoComplete', 'goog.ui.ac.InputHandler', 'goog.ui.ac.RemoteArrayMatcher', 'goog.ui.ac.Renderer']);
goog.addDependency('ui/ac/remotearraymatcher.js', ['goog.ui.ac.RemoteArrayMatcher'], ['goog.Disposable', 'goog.Uri', 'goog.events', 'goog.json', 'goog.net.EventType', 'goog.net.XhrIo']);
goog.addDependency('ui/ac/renderer.js', ['goog.ui.ac.Renderer', 'goog.ui.ac.Renderer.CustomRenderer'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.a11y.aria.State', 'goog.array', 'goog.dispose', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.classlist', 'goog.events', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.fx.dom.FadeInAndShow', 'goog.fx.dom.FadeOutAndHide', 'goog.positioning', 'goog.positioning.Corner', 'goog.positioning.Overflow', 'goog.string', 'goog.style', 'goog.ui.IdGenerator', 'goog.ui.ac.AutoComplete']);
goog.addDependency('ui/ac/renderoptions.js', ['goog.ui.ac.RenderOptions'], []);
goog.addDependency('ui/ac/richinputhandler.js', ['goog.ui.ac.RichInputHandler'], ['goog.ui.ac.InputHandler']);
goog.addDependency('ui/ac/richremote.js', ['goog.ui.ac.RichRemote'], ['goog.ui.ac.AutoComplete', 'goog.ui.ac.Remote', 'goog.ui.ac.Renderer', 'goog.ui.ac.RichInputHandler', 'goog.ui.ac.RichRemoteArrayMatcher']);
goog.addDependency('ui/ac/richremotearraymatcher.js', ['goog.ui.ac.RichRemoteArrayMatcher'], ['goog.json', 'goog.ui.ac.RemoteArrayMatcher']);
goog.addDependency('ui/activitymonitor.js', ['goog.ui.ActivityMonitor'], ['goog.array', 'goog.asserts', 'goog.dom', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType']);
goog.addDependency('ui/advancedtooltip.js', ['goog.ui.AdvancedTooltip'], ['goog.events', 'goog.events.EventType', 'goog.math.Box', 'goog.math.Coordinate', 'goog.style', 'goog.ui.Tooltip', 'goog.userAgent']);
goog.addDependency('ui/animatedzippy.js', ['goog.ui.AnimatedZippy'], ['goog.dom', 'goog.events', 'goog.fx.Animation', 'goog.fx.Transition', 'goog.fx.easing', 'goog.ui.Zippy', 'goog.ui.ZippyEvent']);
goog.addDependency('ui/attachablemenu.js', ['goog.ui.AttachableMenu'], ['goog.a11y.aria', 'goog.a11y.aria.State', 'goog.array', 'goog.asserts', 'goog.dom', 'goog.dom.classlist', 'goog.events.Event', 'goog.events.KeyCodes', 'goog.string', 'goog.style', 'goog.ui.ItemEvent', 'goog.ui.MenuBase', 'goog.ui.PopupBase', 'goog.userAgent']);
goog.addDependency('ui/bidiinput.js', ['goog.ui.BidiInput'], ['goog.dom', 'goog.events', 'goog.events.InputHandler', 'goog.i18n.bidi', 'goog.ui.Component']);
goog.addDependency('ui/bubble.js', ['goog.ui.Bubble'], ['goog.Timer', 'goog.events', 'goog.events.EventType', 'goog.math.Box', 'goog.positioning', 'goog.positioning.AbsolutePosition', 'goog.positioning.AnchoredPosition', 'goog.positioning.Corner', 'goog.positioning.CornerBit', 'goog.style', 'goog.ui.Component', 'goog.ui.Popup']);
goog.addDependency('ui/button.js', ['goog.ui.Button', 'goog.ui.Button.Side'], ['goog.events.EventType', 'goog.events.KeyCodes', 'goog.events.KeyHandler', 'goog.ui.ButtonRenderer', 'goog.ui.ButtonSide', 'goog.ui.Component', 'goog.ui.Control', 'goog.ui.NativeButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/buttonrenderer.js', ['goog.ui.ButtonRenderer'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.a11y.aria.State', 'goog.asserts', 'goog.ui.ButtonSide', 'goog.ui.Component', 'goog.ui.ControlRenderer']);
goog.addDependency('ui/buttonside.js', ['goog.ui.ButtonSide'], []);
goog.addDependency('ui/charcounter.js', ['goog.ui.CharCounter', 'goog.ui.CharCounter.Display'], ['goog.dom', 'goog.events', 'goog.events.EventTarget', 'goog.events.InputHandler']);
goog.addDependency('ui/charpicker.js', ['goog.ui.CharPicker'], ['goog.a11y.aria', 'goog.a11y.aria.State', 'goog.array', 'goog.asserts', 'goog.dom.classlist', 'goog.events', 'goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.events.InputHandler', 'goog.events.KeyCodes', 'goog.events.KeyHandler', 'goog.i18n.CharListDecompressor', 'goog.i18n.uChar', 'goog.structs.Set', 'goog.style', 'goog.ui.Button', 'goog.ui.Component', 'goog.ui.ContainerScroller', 'goog.ui.FlatButtonRenderer', 'goog.ui.HoverCard', 'goog.ui.LabelInput', 'goog.ui.Menu', 'goog.ui.MenuButton', 'goog.ui.MenuItem', 'goog.ui.Tooltip']);
goog.addDependency('ui/checkbox.js', ['goog.ui.Checkbox', 'goog.ui.Checkbox.State'], ['goog.a11y.aria', 'goog.a11y.aria.State', 'goog.asserts', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.ui.CheckboxRenderer', 'goog.ui.Component.EventType', 'goog.ui.Component.State', 'goog.ui.Control', 'goog.ui.registry']);
goog.addDependency('ui/checkboxmenuitem.js', ['goog.ui.CheckBoxMenuItem'], ['goog.ui.MenuItem', 'goog.ui.registry']);
goog.addDependency('ui/checkboxrenderer.js', ['goog.ui.CheckboxRenderer'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.a11y.aria.State', 'goog.array', 'goog.asserts', 'goog.dom.classlist', 'goog.object', 'goog.ui.ControlRenderer']);
goog.addDependency('ui/colorbutton.js', ['goog.ui.ColorButton'], ['goog.ui.Button', 'goog.ui.ColorButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/colorbuttonrenderer.js', ['goog.ui.ColorButtonRenderer'], ['goog.dom.classlist', 'goog.functions', 'goog.ui.ColorMenuButtonRenderer']);
goog.addDependency('ui/colormenubutton.js', ['goog.ui.ColorMenuButton'], ['goog.array', 'goog.object', 'goog.ui.ColorMenuButtonRenderer', 'goog.ui.ColorPalette', 'goog.ui.Component', 'goog.ui.Menu', 'goog.ui.MenuButton', 'goog.ui.registry']);
goog.addDependency('ui/colormenubuttonrenderer.js', ['goog.ui.ColorMenuButtonRenderer'], ['goog.color', 'goog.dom.classlist', 'goog.ui.MenuButtonRenderer', 'goog.userAgent']);
goog.addDependency('ui/colorpalette.js', ['goog.ui.ColorPalette'], ['goog.array', 'goog.color', 'goog.style', 'goog.ui.Palette', 'goog.ui.PaletteRenderer']);
goog.addDependency('ui/colorpicker.js', ['goog.ui.ColorPicker', 'goog.ui.ColorPicker.EventType'], ['goog.ui.ColorPalette', 'goog.ui.Component']);
goog.addDependency('ui/colorsplitbehavior.js', ['goog.ui.ColorSplitBehavior'], ['goog.ui.ColorMenuButton', 'goog.ui.SplitBehavior']);
goog.addDependency('ui/combobox.js', ['goog.ui.ComboBox', 'goog.ui.ComboBoxItem'], ['goog.Timer', 'goog.dom', 'goog.dom.classlist', 'goog.events.EventType', 'goog.events.InputHandler', 'goog.events.KeyCodes', 'goog.events.KeyHandler', 'goog.log', 'goog.positioning.Corner', 'goog.positioning.MenuAnchoredPosition', 'goog.string', 'goog.style', 'goog.ui.Component', 'goog.ui.ItemEvent', 'goog.ui.LabelInput', 'goog.ui.Menu', 'goog.ui.MenuItem', 'goog.ui.MenuSeparator', 'goog.ui.registry', 'goog.userAgent']);
goog.addDependency('ui/component.js', ['goog.ui.Component', 'goog.ui.Component.Error', 'goog.ui.Component.EventType', 'goog.ui.Component.State'], ['goog.array', 'goog.asserts', 'goog.dom', 'goog.dom.NodeType', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.object', 'goog.style', 'goog.ui.IdGenerator']);
goog.addDependency('ui/container.js', ['goog.ui.Container', 'goog.ui.Container.EventType', 'goog.ui.Container.Orientation'], ['goog.a11y.aria', 'goog.a11y.aria.State', 'goog.asserts', 'goog.dom', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.events.KeyHandler', 'goog.object', 'goog.style', 'goog.ui.Component', 'goog.ui.ContainerRenderer', 'goog.ui.Control']);
goog.addDependency('ui/containerrenderer.js', ['goog.ui.ContainerRenderer'], ['goog.a11y.aria', 'goog.array', 'goog.asserts', 'goog.dom.NodeType', 'goog.dom.classlist', 'goog.string', 'goog.style', 'goog.ui.registry', 'goog.userAgent']);
goog.addDependency('ui/containerscroller.js', ['goog.ui.ContainerScroller'], ['goog.Disposable', 'goog.Timer', 'goog.events.EventHandler', 'goog.style', 'goog.ui.Component', 'goog.ui.Container']);
goog.addDependency('ui/control.js', ['goog.ui.Control'], ['goog.array', 'goog.dom', 'goog.events.Event', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.events.KeyHandler', 'goog.string', 'goog.ui.Component', 'goog.ui.ControlContent', 'goog.ui.ControlRenderer', 'goog.ui.decorate', 'goog.ui.registry', 'goog.userAgent']);
goog.addDependency('ui/controlcontent.js', ['goog.ui.ControlContent'], []);
goog.addDependency('ui/controlrenderer.js', ['goog.ui.ControlRenderer'], ['goog.a11y.aria', 'goog.a11y.aria.State', 'goog.array', 'goog.asserts', 'goog.dom', 'goog.dom.classes', 'goog.object', 'goog.style', 'goog.ui.Component', 'goog.userAgent']);
goog.addDependency('ui/cookieeditor.js', ['goog.ui.CookieEditor'], ['goog.asserts', 'goog.dom', 'goog.dom.TagName', 'goog.events.EventType', 'goog.net.cookies', 'goog.string', 'goog.style', 'goog.ui.Component']);
goog.addDependency('ui/css3buttonrenderer.js', ['goog.ui.Css3ButtonRenderer'], ['goog.dom.TagName', 'goog.dom.classlist', 'goog.ui.Button', 'goog.ui.ButtonRenderer', 'goog.ui.Component', 'goog.ui.INLINE_BLOCK_CLASSNAME', 'goog.ui.registry']);
goog.addDependency('ui/css3menubuttonrenderer.js', ['goog.ui.Css3MenuButtonRenderer'], ['goog.dom', 'goog.dom.TagName', 'goog.ui.INLINE_BLOCK_CLASSNAME', 'goog.ui.MenuButton', 'goog.ui.MenuButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/cssnames.js', ['goog.ui.INLINE_BLOCK_CLASSNAME'], []);
goog.addDependency('ui/custombutton.js', ['goog.ui.CustomButton'], ['goog.ui.Button', 'goog.ui.CustomButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/custombuttonrenderer.js', ['goog.ui.CustomButtonRenderer'], ['goog.a11y.aria.Role', 'goog.dom.NodeType', 'goog.dom.classlist', 'goog.string', 'goog.ui.ButtonRenderer', 'goog.ui.INLINE_BLOCK_CLASSNAME']);
goog.addDependency('ui/customcolorpalette.js', ['goog.ui.CustomColorPalette'], ['goog.color', 'goog.dom', 'goog.dom.classlist', 'goog.ui.ColorPalette', 'goog.ui.Component']);
goog.addDependency('ui/datepicker.js', ['goog.ui.DatePicker', 'goog.ui.DatePicker.Events', 'goog.ui.DatePickerEvent'], ['goog.a11y.aria', 'goog.asserts', 'goog.date.Date', 'goog.date.DateRange', 'goog.date.Interval', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.classlist', 'goog.events.Event', 'goog.events.EventType', 'goog.events.KeyHandler', 'goog.i18n.DateTimeFormat', 'goog.i18n.DateTimePatterns', 'goog.i18n.DateTimeSymbols', 'goog.style', 'goog.ui.Component', 'goog.ui.DefaultDatePickerRenderer', 'goog.ui.IdGenerator']);
goog.addDependency('ui/datepickerrenderer.js', ['goog.ui.DatePickerRenderer'], []);
goog.addDependency('ui/decorate.js', ['goog.ui.decorate'], ['goog.ui.registry']);
goog.addDependency('ui/defaultdatepickerrenderer.js', ['goog.ui.DefaultDatePickerRenderer'], ['goog.dom', 'goog.dom.TagName', 'goog.ui.DatePickerRenderer']);
goog.addDependency('ui/dialog.js', ['goog.ui.Dialog', 'goog.ui.Dialog.ButtonSet', 'goog.ui.Dialog.ButtonSet.DefaultButtons', 'goog.ui.Dialog.DefaultButtonCaptions', 'goog.ui.Dialog.DefaultButtonKeys', 'goog.ui.Dialog.Event', 'goog.ui.Dialog.EventType'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.a11y.aria.State', 'goog.asserts', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.TagName', 'goog.dom.classlist', 'goog.dom.safe', 'goog.events', 'goog.events.Event', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.fx.Dragger', 'goog.html.SafeHtml', 'goog.html.legacyconversions', 'goog.math.Rect', 'goog.string', 'goog.structs', 'goog.structs.Map', 'goog.style', 'goog.ui.ModalPopup', 'goog.userAgent']);
goog.addDependency('ui/dimensionpicker.js', ['goog.ui.DimensionPicker'], ['goog.events.EventType', 'goog.events.KeyCodes', 'goog.math.Size', 'goog.ui.Component', 'goog.ui.Control', 'goog.ui.DimensionPickerRenderer', 'goog.ui.registry']);
goog.addDependency('ui/dimensionpickerrenderer.js', ['goog.ui.DimensionPickerRenderer'], ['goog.a11y.aria', 'goog.a11y.aria.State', 'goog.dom', 'goog.dom.TagName', 'goog.i18n.bidi', 'goog.style', 'goog.ui.ControlRenderer', 'goog.userAgent']);
goog.addDependency('ui/dragdropdetector.js', ['goog.ui.DragDropDetector', 'goog.ui.DragDropDetector.EventType', 'goog.ui.DragDropDetector.ImageDropEvent', 'goog.ui.DragDropDetector.LinkDropEvent'], ['goog.dom', 'goog.dom.TagName', 'goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.math.Coordinate', 'goog.string', 'goog.style', 'goog.userAgent']);
goog.addDependency('ui/drilldownrow.js', ['goog.ui.DrilldownRow'], ['goog.dom', 'goog.dom.classlist', 'goog.ui.Component']);
goog.addDependency('ui/editor/abstractdialog.js', ['goog.ui.editor.AbstractDialog', 'goog.ui.editor.AbstractDialog.Builder', 'goog.ui.editor.AbstractDialog.EventType'], ['goog.dom', 'goog.dom.classlist', 'goog.events.EventTarget', 'goog.string', 'goog.ui.Dialog']);
goog.addDependency('ui/editor/bubble.js', ['goog.ui.editor.Bubble'], ['goog.dom', 'goog.dom.TagName', 'goog.dom.ViewportSizeMonitor', 'goog.dom.classlist', 'goog.editor.style', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.log', 'goog.math.Box', 'goog.object', 'goog.positioning', 'goog.positioning.Corner', 'goog.positioning.Overflow', 'goog.positioning.OverflowStatus', 'goog.string', 'goog.style', 'goog.ui.Component', 'goog.ui.PopupBase', 'goog.userAgent']);
goog.addDependency('ui/editor/defaulttoolbar.js', ['goog.ui.editor.ButtonDescriptor', 'goog.ui.editor.DefaultToolbar'], ['goog.dom', 'goog.dom.TagName', 'goog.dom.classlist', 'goog.editor.Command', 'goog.style', 'goog.ui.editor.ToolbarFactory', 'goog.ui.editor.messages', 'goog.userAgent']);
goog.addDependency('ui/editor/equationeditordialog.js', ['goog.ui.editor.EquationEditorDialog'], ['goog.editor.Command', 'goog.ui.Dialog', 'goog.ui.editor.AbstractDialog', 'goog.ui.editor.EquationEditorOkEvent', 'goog.ui.equation.TexEditor']);
goog.addDependency('ui/editor/equationeditorokevent.js', ['goog.ui.editor.EquationEditorOkEvent'], ['goog.events.Event', 'goog.ui.editor.AbstractDialog']);
goog.addDependency('ui/editor/linkdialog.js', ['goog.ui.editor.LinkDialog', 'goog.ui.editor.LinkDialog.BeforeTestLinkEvent', 'goog.ui.editor.LinkDialog.EventType', 'goog.ui.editor.LinkDialog.OkEvent'], ['goog.dom', 'goog.dom.TagName', 'goog.editor.BrowserFeature', 'goog.editor.Link', 'goog.editor.focus', 'goog.editor.node', 'goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.events.InputHandler', 'goog.string', 'goog.style', 'goog.ui.Button', 'goog.ui.Component', 'goog.ui.LinkButtonRenderer', 'goog.ui.editor.AbstractDialog', 'goog.ui.editor.TabPane', 'goog.ui.editor.messages', 'goog.userAgent', 'goog.window']);
goog.addDependency('ui/editor/messages.js', ['goog.ui.editor.messages'], []);
goog.addDependency('ui/editor/tabpane.js', ['goog.ui.editor.TabPane'], ['goog.dom.TagName', 'goog.dom.classlist', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.style', 'goog.ui.Component', 'goog.ui.Control', 'goog.ui.Tab', 'goog.ui.TabBar']);
goog.addDependency('ui/editor/toolbarcontroller.js', ['goog.ui.editor.ToolbarController'], ['goog.editor.Field', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.ui.Component']);
goog.addDependency('ui/editor/toolbarfactory.js', ['goog.ui.editor.ToolbarFactory'], ['goog.array', 'goog.dom', 'goog.dom.TagName', 'goog.string', 'goog.string.Unicode', 'goog.style', 'goog.ui.Component', 'goog.ui.Container', 'goog.ui.Option', 'goog.ui.Toolbar', 'goog.ui.ToolbarButton', 'goog.ui.ToolbarColorMenuButton', 'goog.ui.ToolbarMenuButton', 'goog.ui.ToolbarRenderer', 'goog.ui.ToolbarSelect', 'goog.userAgent']);
goog.addDependency('ui/emoji/emoji.js', ['goog.ui.emoji.Emoji'], []);
goog.addDependency('ui/emoji/emojipalette.js', ['goog.ui.emoji.EmojiPalette'], ['goog.events.EventType', 'goog.net.ImageLoader', 'goog.ui.Palette', 'goog.ui.emoji.Emoji', 'goog.ui.emoji.EmojiPaletteRenderer']);
goog.addDependency('ui/emoji/emojipaletterenderer.js', ['goog.ui.emoji.EmojiPaletteRenderer'], ['goog.a11y.aria', 'goog.dom.NodeType', 'goog.dom.classlist', 'goog.style', 'goog.ui.PaletteRenderer', 'goog.ui.emoji.Emoji']);
goog.addDependency('ui/emoji/emojipicker.js', ['goog.ui.emoji.EmojiPicker'], ['goog.log', 'goog.style', 'goog.ui.Component', 'goog.ui.TabPane', 'goog.ui.emoji.Emoji', 'goog.ui.emoji.EmojiPalette', 'goog.ui.emoji.EmojiPaletteRenderer', 'goog.ui.emoji.ProgressiveEmojiPaletteRenderer']);
goog.addDependency('ui/emoji/popupemojipicker.js', ['goog.ui.emoji.PopupEmojiPicker'], ['goog.events.EventType', 'goog.positioning.AnchoredPosition', 'goog.positioning.Corner', 'goog.ui.Component', 'goog.ui.Popup', 'goog.ui.emoji.EmojiPicker']);
goog.addDependency('ui/emoji/progressiveemojipaletterenderer.js', ['goog.ui.emoji.ProgressiveEmojiPaletteRenderer'], ['goog.style', 'goog.ui.emoji.EmojiPaletteRenderer']);
goog.addDependency('ui/emoji/spriteinfo.js', ['goog.ui.emoji.SpriteInfo'], []);
goog.addDependency('ui/equation/arrowpalette.js', ['goog.ui.equation.ArrowPalette'], ['goog.math.Size', 'goog.ui.equation.Palette']);
goog.addDependency('ui/equation/changeevent.js', ['goog.ui.equation.ChangeEvent'], ['goog.events.Event']);
goog.addDependency('ui/equation/comparisonpalette.js', ['goog.ui.equation.ComparisonPalette'], ['goog.math.Size', 'goog.ui.equation.Palette']);
goog.addDependency('ui/equation/editorpane.js', ['goog.ui.equation.EditorPane'], ['goog.style', 'goog.ui.Component']);
goog.addDependency('ui/equation/equationeditor.js', ['goog.ui.equation.EquationEditor'], ['goog.events', 'goog.ui.Component', 'goog.ui.TabBar', 'goog.ui.equation.ImageRenderer', 'goog.ui.equation.TexPane']);
goog.addDependency('ui/equation/equationeditordialog.js', ['goog.ui.equation.EquationEditorDialog'], ['goog.dom', 'goog.dom.classlist', 'goog.ui.Dialog', 'goog.ui.equation.EquationEditor', 'goog.ui.equation.PaletteManager', 'goog.ui.equation.TexEditor']);
goog.addDependency('ui/equation/greekpalette.js', ['goog.ui.equation.GreekPalette'], ['goog.math.Size', 'goog.ui.equation.Palette']);
goog.addDependency('ui/equation/imagerenderer.js', ['goog.ui.equation.ImageRenderer'], ['goog.asserts', 'goog.dom.TagName', 'goog.dom.classlist', 'goog.string', 'goog.uri.utils']);
goog.addDependency('ui/equation/mathpalette.js', ['goog.ui.equation.MathPalette'], ['goog.math.Size', 'goog.ui.equation.Palette']);
goog.addDependency('ui/equation/menupalette.js', ['goog.ui.equation.MenuPalette', 'goog.ui.equation.MenuPaletteRenderer'], ['goog.math.Size', 'goog.ui.PaletteRenderer', 'goog.ui.equation.Palette', 'goog.ui.equation.PaletteRenderer']);
goog.addDependency('ui/equation/palette.js', ['goog.ui.equation.Palette', 'goog.ui.equation.PaletteEvent', 'goog.ui.equation.PaletteRenderer'], ['goog.dom', 'goog.dom.TagName', 'goog.events.Event', 'goog.ui.Palette', 'goog.ui.PaletteRenderer']);
goog.addDependency('ui/equation/palettemanager.js', ['goog.ui.equation.PaletteManager'], ['goog.Timer', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.ui.equation.ArrowPalette', 'goog.ui.equation.ComparisonPalette', 'goog.ui.equation.GreekPalette', 'goog.ui.equation.MathPalette', 'goog.ui.equation.MenuPalette', 'goog.ui.equation.Palette', 'goog.ui.equation.SymbolPalette']);
goog.addDependency('ui/equation/symbolpalette.js', ['goog.ui.equation.SymbolPalette'], ['goog.math.Size', 'goog.ui.equation.Palette']);
goog.addDependency('ui/equation/texeditor.js', ['goog.ui.equation.TexEditor'], ['goog.ui.Component', 'goog.ui.equation.ImageRenderer', 'goog.ui.equation.TexPane']);
goog.addDependency('ui/equation/texpane.js', ['goog.ui.equation.TexPane'], ['goog.Timer', 'goog.dom', 'goog.dom.TagName', 'goog.dom.selection', 'goog.events', 'goog.events.EventType', 'goog.events.InputHandler', 'goog.style', 'goog.ui.equation.ChangeEvent', 'goog.ui.equation.EditorPane', 'goog.ui.equation.ImageRenderer', 'goog.ui.equation.Palette', 'goog.ui.equation.PaletteEvent']);
goog.addDependency('ui/filteredmenu.js', ['goog.ui.FilteredMenu'], ['goog.dom', 'goog.events', 'goog.events.EventType', 'goog.events.InputHandler', 'goog.events.KeyCodes', 'goog.string', 'goog.style', 'goog.ui.Component', 'goog.ui.FilterObservingMenuItem', 'goog.ui.Menu', 'goog.userAgent']);
goog.addDependency('ui/filterobservingmenuitem.js', ['goog.ui.FilterObservingMenuItem'], ['goog.ui.FilterObservingMenuItemRenderer', 'goog.ui.MenuItem', 'goog.ui.registry']);
goog.addDependency('ui/filterobservingmenuitemrenderer.js', ['goog.ui.FilterObservingMenuItemRenderer'], ['goog.ui.MenuItemRenderer']);
goog.addDependency('ui/flatbuttonrenderer.js', ['goog.ui.FlatButtonRenderer'], ['goog.a11y.aria.Role', 'goog.dom.classlist', 'goog.ui.Button', 'goog.ui.ButtonRenderer', 'goog.ui.INLINE_BLOCK_CLASSNAME', 'goog.ui.registry']);
goog.addDependency('ui/flatmenubuttonrenderer.js', ['goog.ui.FlatMenuButtonRenderer'], ['goog.a11y.aria', 'goog.a11y.aria.State', 'goog.asserts', 'goog.dom', 'goog.string', 'goog.style', 'goog.ui.Component', 'goog.ui.FlatButtonRenderer', 'goog.ui.INLINE_BLOCK_CLASSNAME', 'goog.ui.Menu', 'goog.ui.MenuButton', 'goog.ui.MenuRenderer', 'goog.ui.registry']);
goog.addDependency('ui/formpost.js', ['goog.ui.FormPost'], ['goog.array', 'goog.dom.TagName', 'goog.string', 'goog.string.StringBuffer', 'goog.ui.Component']);
goog.addDependency('ui/gauge.js', ['goog.ui.Gauge', 'goog.ui.GaugeColoredRange'], ['goog.a11y.aria', 'goog.asserts', 'goog.events', 'goog.fx.Animation', 'goog.fx.Transition', 'goog.fx.easing', 'goog.graphics', 'goog.graphics.Font', 'goog.graphics.Path', 'goog.graphics.SolidFill', 'goog.math', 'goog.ui.Component', 'goog.ui.GaugeTheme']);
goog.addDependency('ui/gaugetheme.js', ['goog.ui.GaugeTheme'], ['goog.graphics.LinearGradient', 'goog.graphics.SolidFill', 'goog.graphics.Stroke']);
goog.addDependency('ui/gearsstatustype.js', ['goog.ui.GearsStatusType'], []);
goog.addDependency('ui/hovercard.js', ['goog.ui.HoverCard', 'goog.ui.HoverCard.EventType', 'goog.ui.HoverCard.TriggerEvent'], ['goog.array', 'goog.dom', 'goog.events', 'goog.events.Event', 'goog.events.EventType', 'goog.ui.AdvancedTooltip', 'goog.ui.PopupBase', 'goog.ui.Tooltip']);
goog.addDependency('ui/hsvapalette.js', ['goog.ui.HsvaPalette'], ['goog.array', 'goog.color.alpha', 'goog.dom', 'goog.dom.TagName', 'goog.events', 'goog.events.EventType', 'goog.style', 'goog.ui.Component', 'goog.ui.HsvPalette']);
goog.addDependency('ui/hsvpalette.js', ['goog.ui.HsvPalette'], ['goog.color', 'goog.dom.TagName', 'goog.events', 'goog.events.EventType', 'goog.events.InputHandler', 'goog.style', 'goog.style.bidi', 'goog.ui.Component', 'goog.userAgent']);
goog.addDependency('ui/idgenerator.js', ['goog.ui.IdGenerator'], []);
goog.addDependency('ui/idletimer.js', ['goog.ui.IdleTimer'], ['goog.Timer', 'goog.events', 'goog.events.EventTarget', 'goog.structs.Set', 'goog.ui.ActivityMonitor']);
goog.addDependency('ui/iframemask.js', ['goog.ui.IframeMask'], ['goog.Disposable', 'goog.Timer', 'goog.dom', 'goog.dom.iframe', 'goog.events.EventHandler', 'goog.style']);
goog.addDependency('ui/imagelessbuttonrenderer.js', ['goog.ui.ImagelessButtonRenderer'], ['goog.dom.classlist', 'goog.ui.Button', 'goog.ui.Component', 'goog.ui.CustomButtonRenderer', 'goog.ui.INLINE_BLOCK_CLASSNAME', 'goog.ui.registry']);
goog.addDependency('ui/imagelessmenubuttonrenderer.js', ['goog.ui.ImagelessMenuButtonRenderer'], ['goog.dom', 'goog.dom.TagName', 'goog.dom.classlist', 'goog.ui.INLINE_BLOCK_CLASSNAME', 'goog.ui.MenuButton', 'goog.ui.MenuButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/inputdatepicker.js', ['goog.ui.InputDatePicker'], ['goog.date.DateTime', 'goog.dom', 'goog.string', 'goog.ui.Component', 'goog.ui.DatePicker', 'goog.ui.PopupBase', 'goog.ui.PopupDatePicker']);
goog.addDependency('ui/itemevent.js', ['goog.ui.ItemEvent'], ['goog.events.Event']);
goog.addDependency('ui/keyboardshortcuthandler.js', ['goog.ui.KeyboardShortcutEvent', 'goog.ui.KeyboardShortcutHandler', 'goog.ui.KeyboardShortcutHandler.EventType'], ['goog.Timer', 'goog.events', 'goog.events.Event', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.events.KeyNames', 'goog.object', 'goog.userAgent']);
goog.addDependency('ui/labelinput.js', ['goog.ui.LabelInput'], ['goog.Timer', 'goog.a11y.aria', 'goog.a11y.aria.State', 'goog.asserts', 'goog.dom', 'goog.dom.classlist', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.ui.Component', 'goog.userAgent']);
goog.addDependency('ui/linkbuttonrenderer.js', ['goog.ui.LinkButtonRenderer'], ['goog.ui.Button', 'goog.ui.FlatButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/media/flashobject.js', ['goog.ui.media.FlashObject', 'goog.ui.media.FlashObject.ScriptAccessLevel', 'goog.ui.media.FlashObject.Wmodes'], ['goog.asserts', 'goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.log', 'goog.object', 'goog.string', 'goog.structs.Map', 'goog.style', 'goog.ui.Component', 'goog.userAgent', 'goog.userAgent.flash']);
goog.addDependency('ui/media/flickr.js', ['goog.ui.media.FlickrSet', 'goog.ui.media.FlickrSetModel'], ['goog.ui.media.FlashObject', 'goog.ui.media.Media', 'goog.ui.media.MediaModel', 'goog.ui.media.MediaRenderer']);
goog.addDependency('ui/media/googlevideo.js', ['goog.ui.media.GoogleVideo', 'goog.ui.media.GoogleVideoModel'], ['goog.string', 'goog.ui.media.FlashObject', 'goog.ui.media.Media', 'goog.ui.media.MediaModel', 'goog.ui.media.MediaRenderer']);
goog.addDependency('ui/media/media.js', ['goog.ui.media.Media', 'goog.ui.media.MediaRenderer'], ['goog.style', 'goog.ui.Component', 'goog.ui.Control', 'goog.ui.ControlRenderer']);
goog.addDependency('ui/media/mediamodel.js', ['goog.ui.media.MediaModel', 'goog.ui.media.MediaModel.Category', 'goog.ui.media.MediaModel.Credit', 'goog.ui.media.MediaModel.Credit.Role', 'goog.ui.media.MediaModel.Credit.Scheme', 'goog.ui.media.MediaModel.Medium', 'goog.ui.media.MediaModel.MimeType', 'goog.ui.media.MediaModel.Player', 'goog.ui.media.MediaModel.SubTitle', 'goog.ui.media.MediaModel.Thumbnail'], ['goog.array']);
goog.addDependency('ui/media/mp3.js', ['goog.ui.media.Mp3'], ['goog.string', 'goog.ui.media.FlashObject', 'goog.ui.media.Media', 'goog.ui.media.MediaRenderer']);
goog.addDependency('ui/media/photo.js', ['goog.ui.media.Photo'], ['goog.ui.media.Media', 'goog.ui.media.MediaRenderer']);
goog.addDependency('ui/media/picasa.js', ['goog.ui.media.PicasaAlbum', 'goog.ui.media.PicasaAlbumModel'], ['goog.ui.media.FlashObject', 'goog.ui.media.Media', 'goog.ui.media.MediaModel', 'goog.ui.media.MediaRenderer']);
goog.addDependency('ui/media/vimeo.js', ['goog.ui.media.Vimeo', 'goog.ui.media.VimeoModel'], ['goog.string', 'goog.ui.media.FlashObject', 'goog.ui.media.Media', 'goog.ui.media.MediaModel', 'goog.ui.media.MediaRenderer']);
goog.addDependency('ui/media/youtube.js', ['goog.ui.media.Youtube', 'goog.ui.media.YoutubeModel'], ['goog.string', 'goog.ui.Component', 'goog.ui.media.FlashObject', 'goog.ui.media.Media', 'goog.ui.media.MediaModel', 'goog.ui.media.MediaRenderer']);
goog.addDependency('ui/menu.js', ['goog.ui.Menu', 'goog.ui.Menu.EventType'], ['goog.math.Coordinate', 'goog.string', 'goog.style', 'goog.ui.Component.EventType', 'goog.ui.Component.State', 'goog.ui.Container', 'goog.ui.Container.Orientation', 'goog.ui.MenuHeader', 'goog.ui.MenuItem', 'goog.ui.MenuRenderer', 'goog.ui.MenuSeparator']);
goog.addDependency('ui/menubar.js', ['goog.ui.menuBar'], ['goog.ui.Container', 'goog.ui.MenuBarRenderer']);
goog.addDependency('ui/menubardecorator.js', ['goog.ui.menuBarDecorator'], ['goog.ui.MenuBarRenderer', 'goog.ui.menuBar', 'goog.ui.registry']);
goog.addDependency('ui/menubarrenderer.js', ['goog.ui.MenuBarRenderer'], ['goog.a11y.aria.Role', 'goog.ui.Container', 'goog.ui.ContainerRenderer']);
goog.addDependency('ui/menubase.js', ['goog.ui.MenuBase'], ['goog.events.EventHandler', 'goog.events.EventType', 'goog.events.KeyHandler', 'goog.ui.Popup']);
goog.addDependency('ui/menubutton.js', ['goog.ui.MenuButton'], ['goog.Timer', 'goog.a11y.aria', 'goog.a11y.aria.State', 'goog.asserts', 'goog.dom', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.events.KeyHandler', 'goog.math.Box', 'goog.math.Rect', 'goog.positioning', 'goog.positioning.Corner', 'goog.positioning.MenuAnchoredPosition', 'goog.positioning.Overflow', 'goog.style', 'goog.ui.Button', 'goog.ui.Component', 'goog.ui.Menu', 'goog.ui.MenuButtonRenderer', 'goog.ui.registry', 'goog.userAgent', 'goog.userAgent.product']);
goog.addDependency('ui/menubuttonrenderer.js', ['goog.ui.MenuButtonRenderer'], ['goog.a11y.aria', 'goog.a11y.aria.State', 'goog.asserts', 'goog.dom', 'goog.string', 'goog.style', 'goog.ui.Component', 'goog.ui.CustomButtonRenderer', 'goog.ui.INLINE_BLOCK_CLASSNAME', 'goog.ui.Menu', 'goog.ui.MenuRenderer', 'goog.userAgent']);
goog.addDependency('ui/menuheader.js', ['goog.ui.MenuHeader'], ['goog.ui.Component', 'goog.ui.Control', 'goog.ui.MenuHeaderRenderer', 'goog.ui.registry']);
goog.addDependency('ui/menuheaderrenderer.js', ['goog.ui.MenuHeaderRenderer'], ['goog.ui.ControlRenderer']);
goog.addDependency('ui/menuitem.js', ['goog.ui.MenuItem'], ['goog.array', 'goog.dom', 'goog.dom.classlist', 'goog.math.Coordinate', 'goog.string', 'goog.ui.Component', 'goog.ui.Control', 'goog.ui.MenuItemRenderer', 'goog.ui.registry']);
goog.addDependency('ui/menuitemrenderer.js', ['goog.ui.MenuItemRenderer'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.dom', 'goog.dom.classlist', 'goog.ui.Component', 'goog.ui.ControlRenderer']);
goog.addDependency('ui/menurenderer.js', ['goog.ui.MenuRenderer'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.a11y.aria.State', 'goog.asserts', 'goog.dom', 'goog.ui.ContainerRenderer', 'goog.ui.Separator']);
goog.addDependency('ui/menuseparator.js', ['goog.ui.MenuSeparator'], ['goog.ui.MenuSeparatorRenderer', 'goog.ui.Separator', 'goog.ui.registry']);
goog.addDependency('ui/menuseparatorrenderer.js', ['goog.ui.MenuSeparatorRenderer'], ['goog.dom', 'goog.dom.classlist', 'goog.ui.ControlContent', 'goog.ui.ControlRenderer']);
goog.addDependency('ui/mockactivitymonitor.js', ['goog.ui.MockActivityMonitor'], ['goog.events.EventType', 'goog.ui.ActivityMonitor']);
goog.addDependency('ui/mockactivitymonitor_test.js', ['goog.ui.MockActivityMonitorTest'], ['goog.events', 'goog.functions', 'goog.testing.jsunit', 'goog.testing.recordFunction', 'goog.ui.ActivityMonitor', 'goog.ui.MockActivityMonitor']);
goog.addDependency('ui/modalpopup.js', ['goog.ui.ModalPopup'], ['goog.Timer', 'goog.a11y.aria', 'goog.a11y.aria.State', 'goog.asserts', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.TagName', 'goog.dom.classlist', 'goog.dom.iframe', 'goog.events', 'goog.events.EventType', 'goog.events.FocusHandler', 'goog.fx.Transition', 'goog.string', 'goog.style', 'goog.ui.Component', 'goog.ui.PopupBase', 'goog.userAgent']);
goog.addDependency('ui/nativebuttonrenderer.js', ['goog.ui.NativeButtonRenderer'], ['goog.asserts', 'goog.dom.classlist', 'goog.events.EventType', 'goog.ui.ButtonRenderer', 'goog.ui.Component']);
goog.addDependency('ui/offlinestatuscard.js', ['goog.ui.OfflineStatusCard', 'goog.ui.OfflineStatusCard.EventType'], ['goog.dom', 'goog.events.EventType', 'goog.structs.Map', 'goog.style', 'goog.ui.Component', 'goog.ui.GearsStatusType', 'goog.ui.ProgressBar']);
goog.addDependency('ui/offlinestatuscomponent.js', ['goog.ui.OfflineStatusComponent', 'goog.ui.OfflineStatusComponent.StatusClassNames'], ['goog.dom.classlist', 'goog.events.EventType', 'goog.positioning.AnchoredPosition', 'goog.positioning.Corner', 'goog.positioning.Overflow', 'goog.ui.Component', 'goog.ui.GearsStatusType', 'goog.ui.OfflineStatusCard', 'goog.ui.Popup']);
goog.addDependency('ui/option.js', ['goog.ui.Option'], ['goog.ui.Component', 'goog.ui.MenuItem', 'goog.ui.registry']);
goog.addDependency('ui/palette.js', ['goog.ui.Palette'], ['goog.array', 'goog.dom', 'goog.events', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.math.Size', 'goog.ui.Component', 'goog.ui.Control', 'goog.ui.PaletteRenderer', 'goog.ui.SelectionModel']);
goog.addDependency('ui/paletterenderer.js', ['goog.ui.PaletteRenderer'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.a11y.aria.State', 'goog.array', 'goog.dom', 'goog.dom.NodeIterator', 'goog.dom.NodeType', 'goog.dom.TagName', 'goog.dom.classlist', 'goog.iter', 'goog.style', 'goog.ui.ControlRenderer', 'goog.userAgent']);
goog.addDependency('ui/plaintextspellchecker.js', ['goog.ui.PlainTextSpellChecker'], ['goog.Timer', 'goog.a11y.aria', 'goog.asserts', 'goog.dom', 'goog.events.EventHandler', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.events.KeyHandler', 'goog.spell.SpellCheck', 'goog.style', 'goog.ui.AbstractSpellChecker', 'goog.ui.Component', 'goog.userAgent']);
goog.addDependency('ui/popup.js', ['goog.ui.Popup', 'goog.ui.Popup.AbsolutePosition', 'goog.ui.Popup.AnchoredPosition', 'goog.ui.Popup.AnchoredViewPortPosition', 'goog.ui.Popup.ClientPosition', 'goog.ui.Popup.Corner', 'goog.ui.Popup.Overflow', 'goog.ui.Popup.ViewPortClientPosition', 'goog.ui.Popup.ViewPortPosition'], ['goog.math.Box', 'goog.positioning.AbsolutePosition', 'goog.positioning.AnchoredPosition', 'goog.positioning.AnchoredViewportPosition', 'goog.positioning.ClientPosition', 'goog.positioning.Corner', 'goog.positioning.Overflow', 'goog.positioning.ViewportClientPosition', 'goog.positioning.ViewportPosition', 'goog.style', 'goog.ui.PopupBase']);
goog.addDependency('ui/popupbase.js', ['goog.ui.PopupBase', 'goog.ui.PopupBase.EventType', 'goog.ui.PopupBase.Type'], ['goog.Timer', 'goog.dom', 'goog.events', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.fx.Transition', 'goog.style', 'goog.userAgent']);
goog.addDependency('ui/popupcolorpicker.js', ['goog.ui.PopupColorPicker'], ['goog.dom.classlist', 'goog.events.EventType', 'goog.positioning.AnchoredPosition', 'goog.positioning.Corner', 'goog.ui.ColorPicker', 'goog.ui.Component', 'goog.ui.Popup']);
goog.addDependency('ui/popupdatepicker.js', ['goog.ui.PopupDatePicker'], ['goog.events.EventType', 'goog.positioning.AnchoredPosition', 'goog.positioning.Corner', 'goog.style', 'goog.ui.Component', 'goog.ui.DatePicker', 'goog.ui.Popup', 'goog.ui.PopupBase']);
goog.addDependency('ui/popupmenu.js', ['goog.ui.PopupMenu'], ['goog.events.EventType', 'goog.positioning.AnchoredViewportPosition', 'goog.positioning.Corner', 'goog.positioning.MenuAnchoredPosition', 'goog.positioning.ViewportClientPosition', 'goog.structs', 'goog.structs.Map', 'goog.style', 'goog.ui.Component.EventType', 'goog.ui.Menu', 'goog.ui.PopupBase', 'goog.userAgent']);
goog.addDependency('ui/progressbar.js', ['goog.ui.ProgressBar', 'goog.ui.ProgressBar.Orientation'], ['goog.a11y.aria', 'goog.asserts', 'goog.dom', 'goog.dom.classlist', 'goog.events', 'goog.events.EventType', 'goog.ui.Component', 'goog.ui.RangeModel', 'goog.userAgent']);
goog.addDependency('ui/prompt.js', ['goog.ui.Prompt'], ['goog.Timer', 'goog.dom', 'goog.events', 'goog.events.EventType', 'goog.functions', 'goog.ui.Component', 'goog.ui.Dialog', 'goog.userAgent']);
goog.addDependency('ui/rangemodel.js', ['goog.ui.RangeModel'], ['goog.events.EventTarget', 'goog.ui.Component']);
goog.addDependency('ui/ratings.js', ['goog.ui.Ratings', 'goog.ui.Ratings.EventType'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.a11y.aria.State', 'goog.asserts', 'goog.dom.classlist', 'goog.events.EventType', 'goog.ui.Component']);
goog.addDependency('ui/registry.js', ['goog.ui.registry'], ['goog.dom.classlist']);
goog.addDependency('ui/richtextspellchecker.js', ['goog.ui.RichTextSpellChecker'], ['goog.Timer', 'goog.dom', 'goog.dom.NodeType', 'goog.events', 'goog.events.EventType', 'goog.spell.SpellCheck', 'goog.string.StringBuffer', 'goog.ui.AbstractSpellChecker']);
goog.addDependency('ui/roundedpanel.js', ['goog.ui.BaseRoundedPanel', 'goog.ui.CssRoundedPanel', 'goog.ui.GraphicsRoundedPanel', 'goog.ui.RoundedPanel', 'goog.ui.RoundedPanel.Corner'], ['goog.dom', 'goog.dom.classlist', 'goog.graphics', 'goog.graphics.Path', 'goog.graphics.SolidFill', 'goog.graphics.Stroke', 'goog.math', 'goog.math.Coordinate', 'goog.style', 'goog.ui.Component', 'goog.userAgent']);
goog.addDependency('ui/roundedtabrenderer.js', ['goog.ui.RoundedTabRenderer'], ['goog.dom', 'goog.ui.Tab', 'goog.ui.TabBar', 'goog.ui.TabRenderer', 'goog.ui.registry']);
goog.addDependency('ui/scrollfloater.js', ['goog.ui.ScrollFloater', 'goog.ui.ScrollFloater.EventType'], ['goog.array', 'goog.dom', 'goog.dom.classlist', 'goog.events.EventType', 'goog.style', 'goog.ui.Component', 'goog.userAgent']);
goog.addDependency('ui/select.js', ['goog.ui.Select'], ['goog.a11y.aria.Role', 'goog.events.EventType', 'goog.ui.Component', 'goog.ui.MenuButton', 'goog.ui.MenuItem', 'goog.ui.SelectionModel', 'goog.ui.registry']);
goog.addDependency('ui/selectionmenubutton.js', ['goog.ui.SelectionMenuButton', 'goog.ui.SelectionMenuButton.SelectionState'], ['goog.events.EventType', 'goog.style', 'goog.ui.Component', 'goog.ui.MenuButton', 'goog.ui.MenuItem', 'goog.ui.registry']);
goog.addDependency('ui/selectionmodel.js', ['goog.ui.SelectionModel'], ['goog.array', 'goog.events.EventTarget', 'goog.events.EventType']);
goog.addDependency('ui/separator.js', ['goog.ui.Separator'], ['goog.a11y.aria', 'goog.asserts', 'goog.ui.Component', 'goog.ui.Control', 'goog.ui.MenuSeparatorRenderer', 'goog.ui.registry']);
goog.addDependency('ui/serverchart.js', ['goog.ui.ServerChart', 'goog.ui.ServerChart.AxisDisplayType', 'goog.ui.ServerChart.ChartType', 'goog.ui.ServerChart.EncodingType', 'goog.ui.ServerChart.Event', 'goog.ui.ServerChart.LegendPosition', 'goog.ui.ServerChart.MaximumValue', 'goog.ui.ServerChart.MultiAxisAlignment', 'goog.ui.ServerChart.MultiAxisType', 'goog.ui.ServerChart.UriParam', 'goog.ui.ServerChart.UriTooLongEvent'], ['goog.Uri', 'goog.array', 'goog.asserts', 'goog.events.Event', 'goog.string', 'goog.ui.Component']);
goog.addDependency('ui/slider.js', ['goog.ui.Slider', 'goog.ui.Slider.Orientation'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.dom', 'goog.ui.SliderBase']);
goog.addDependency('ui/sliderbase.js', ['goog.ui.SliderBase', 'goog.ui.SliderBase.AnimationFactory', 'goog.ui.SliderBase.Orientation'], ['goog.Timer', 'goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.a11y.aria.State', 'goog.array', 'goog.asserts', 'goog.dom', 'goog.dom.classlist', 'goog.events', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.events.KeyHandler', 'goog.events.MouseWheelHandler', 'goog.fx.AnimationParallelQueue', 'goog.fx.Dragger', 'goog.fx.Transition', 'goog.fx.dom.ResizeHeight', 'goog.fx.dom.ResizeWidth', 'goog.fx.dom.Slide', 'goog.math', 'goog.math.Coordinate', 'goog.style', 'goog.style.bidi', 'goog.ui.Component', 'goog.ui.RangeModel']);
goog.addDependency('ui/splitbehavior.js', ['goog.ui.SplitBehavior', 'goog.ui.SplitBehavior.DefaultHandlers'], ['goog.Disposable', 'goog.dispose', 'goog.dom', 'goog.dom.NodeType', 'goog.dom.classlist', 'goog.events.EventHandler', 'goog.ui.ButtonSide', 'goog.ui.Component', 'goog.ui.decorate', 'goog.ui.registry']);
goog.addDependency('ui/splitpane.js', ['goog.ui.SplitPane', 'goog.ui.SplitPane.Orientation'], ['goog.asserts', 'goog.dom', 'goog.dom.classlist', 'goog.events.EventType', 'goog.fx.Dragger', 'goog.math.Rect', 'goog.math.Size', 'goog.style', 'goog.ui.Component', 'goog.userAgent']);
goog.addDependency('ui/style/app/buttonrenderer.js', ['goog.ui.style.app.ButtonRenderer'], ['goog.dom.classlist', 'goog.ui.Button', 'goog.ui.CustomButtonRenderer', 'goog.ui.INLINE_BLOCK_CLASSNAME', 'goog.ui.registry']);
goog.addDependency('ui/style/app/menubuttonrenderer.js', ['goog.ui.style.app.MenuButtonRenderer'], ['goog.a11y.aria.Role', 'goog.array', 'goog.dom', 'goog.style', 'goog.ui.Menu', 'goog.ui.MenuRenderer', 'goog.ui.style.app.ButtonRenderer']);
goog.addDependency('ui/style/app/primaryactionbuttonrenderer.js', ['goog.ui.style.app.PrimaryActionButtonRenderer'], ['goog.ui.Button', 'goog.ui.registry', 'goog.ui.style.app.ButtonRenderer']);
goog.addDependency('ui/submenu.js', ['goog.ui.SubMenu'], ['goog.Timer', 'goog.dom', 'goog.dom.classlist', 'goog.events.KeyCodes', 'goog.positioning.AnchoredViewportPosition', 'goog.positioning.Corner', 'goog.style', 'goog.ui.Component', 'goog.ui.Menu', 'goog.ui.MenuItem', 'goog.ui.SubMenuRenderer', 'goog.ui.registry']);
goog.addDependency('ui/submenurenderer.js', ['goog.ui.SubMenuRenderer'], ['goog.a11y.aria', 'goog.a11y.aria.State', 'goog.asserts', 'goog.dom', 'goog.dom.classlist', 'goog.style', 'goog.ui.Menu', 'goog.ui.MenuItemRenderer']);
goog.addDependency('ui/tab.js', ['goog.ui.Tab'], ['goog.ui.Component', 'goog.ui.Control', 'goog.ui.TabRenderer', 'goog.ui.registry']);
goog.addDependency('ui/tabbar.js', ['goog.ui.TabBar', 'goog.ui.TabBar.Location'], ['goog.ui.Component.EventType', 'goog.ui.Container', 'goog.ui.Container.Orientation', 'goog.ui.Tab', 'goog.ui.TabBarRenderer', 'goog.ui.registry']);
goog.addDependency('ui/tabbarrenderer.js', ['goog.ui.TabBarRenderer'], ['goog.a11y.aria.Role', 'goog.object', 'goog.ui.ContainerRenderer']);
goog.addDependency('ui/tablesorter.js', ['goog.ui.TableSorter', 'goog.ui.TableSorter.EventType'], ['goog.array', 'goog.dom', 'goog.dom.TagName', 'goog.dom.classlist', 'goog.events.EventType', 'goog.functions', 'goog.ui.Component']);
goog.addDependency('ui/tabpane.js', ['goog.ui.TabPane', 'goog.ui.TabPane.Events', 'goog.ui.TabPane.TabLocation', 'goog.ui.TabPane.TabPage', 'goog.ui.TabPaneEvent'], ['goog.dom', 'goog.dom.classlist', 'goog.events', 'goog.events.Event', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.style']);
goog.addDependency('ui/tabrenderer.js', ['goog.ui.TabRenderer'], ['goog.a11y.aria.Role', 'goog.ui.Component', 'goog.ui.ControlRenderer']);
goog.addDependency('ui/textarea.js', ['goog.ui.Textarea', 'goog.ui.Textarea.EventType'], ['goog.asserts', 'goog.dom', 'goog.dom.classlist', 'goog.events.EventType', 'goog.style', 'goog.ui.Control', 'goog.ui.TextareaRenderer', 'goog.userAgent']);
goog.addDependency('ui/textarearenderer.js', ['goog.ui.TextareaRenderer'], ['goog.dom.TagName', 'goog.ui.Component', 'goog.ui.ControlRenderer']);
goog.addDependency('ui/togglebutton.js', ['goog.ui.ToggleButton'], ['goog.ui.Button', 'goog.ui.Component', 'goog.ui.CustomButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/toolbar.js', ['goog.ui.Toolbar'], ['goog.ui.Container', 'goog.ui.ToolbarRenderer']);
goog.addDependency('ui/toolbarbutton.js', ['goog.ui.ToolbarButton'], ['goog.ui.Button', 'goog.ui.ToolbarButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/toolbarbuttonrenderer.js', ['goog.ui.ToolbarButtonRenderer'], ['goog.ui.CustomButtonRenderer']);
goog.addDependency('ui/toolbarcolormenubutton.js', ['goog.ui.ToolbarColorMenuButton'], ['goog.ui.ColorMenuButton', 'goog.ui.ToolbarColorMenuButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/toolbarcolormenubuttonrenderer.js', ['goog.ui.ToolbarColorMenuButtonRenderer'], ['goog.dom.classlist', 'goog.ui.ColorMenuButtonRenderer', 'goog.ui.MenuButtonRenderer', 'goog.ui.ToolbarMenuButtonRenderer']);
goog.addDependency('ui/toolbarmenubutton.js', ['goog.ui.ToolbarMenuButton'], ['goog.ui.MenuButton', 'goog.ui.ToolbarMenuButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/toolbarmenubuttonrenderer.js', ['goog.ui.ToolbarMenuButtonRenderer'], ['goog.ui.MenuButtonRenderer']);
goog.addDependency('ui/toolbarrenderer.js', ['goog.ui.ToolbarRenderer'], ['goog.a11y.aria.Role', 'goog.ui.Container', 'goog.ui.ContainerRenderer', 'goog.ui.Separator', 'goog.ui.ToolbarSeparatorRenderer']);
goog.addDependency('ui/toolbarselect.js', ['goog.ui.ToolbarSelect'], ['goog.ui.Select', 'goog.ui.ToolbarMenuButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/toolbarseparator.js', ['goog.ui.ToolbarSeparator'], ['goog.ui.Separator', 'goog.ui.ToolbarSeparatorRenderer', 'goog.ui.registry']);
goog.addDependency('ui/toolbarseparatorrenderer.js', ['goog.ui.ToolbarSeparatorRenderer'], ['goog.dom.classlist', 'goog.ui.INLINE_BLOCK_CLASSNAME', 'goog.ui.MenuSeparatorRenderer']);
goog.addDependency('ui/toolbartogglebutton.js', ['goog.ui.ToolbarToggleButton'], ['goog.ui.ToggleButton', 'goog.ui.ToolbarButtonRenderer', 'goog.ui.registry']);
goog.addDependency('ui/tooltip.js', ['goog.ui.Tooltip', 'goog.ui.Tooltip.CursorTooltipPosition', 'goog.ui.Tooltip.ElementTooltipPosition', 'goog.ui.Tooltip.State'], ['goog.Timer', 'goog.array', 'goog.dom', 'goog.events', 'goog.events.EventType', 'goog.math.Box', 'goog.math.Coordinate', 'goog.positioning', 'goog.positioning.AnchoredPosition', 'goog.positioning.Corner', 'goog.positioning.Overflow', 'goog.positioning.OverflowStatus', 'goog.positioning.ViewportPosition', 'goog.structs.Set', 'goog.style', 'goog.ui.Popup', 'goog.ui.PopupBase']);
goog.addDependency('ui/tree/basenode.js', ['goog.ui.tree.BaseNode', 'goog.ui.tree.BaseNode.EventType'], ['goog.Timer', 'goog.a11y.aria', 'goog.asserts', 'goog.events.KeyCodes', 'goog.string', 'goog.string.StringBuffer', 'goog.style', 'goog.ui.Component', 'goog.userAgent']);
goog.addDependency('ui/tree/treecontrol.js', ['goog.ui.tree.TreeControl'], ['goog.a11y.aria', 'goog.asserts', 'goog.dom.classlist', 'goog.events.EventType', 'goog.events.FocusHandler', 'goog.events.KeyHandler', 'goog.log', 'goog.ui.tree.BaseNode', 'goog.ui.tree.TreeNode', 'goog.ui.tree.TypeAhead', 'goog.userAgent']);
goog.addDependency('ui/tree/treenode.js', ['goog.ui.tree.TreeNode'], ['goog.ui.tree.BaseNode']);
goog.addDependency('ui/tree/typeahead.js', ['goog.ui.tree.TypeAhead', 'goog.ui.tree.TypeAhead.Offset'], ['goog.array', 'goog.events.KeyCodes', 'goog.string', 'goog.structs.Trie']);
goog.addDependency('ui/tristatemenuitem.js', ['goog.ui.TriStateMenuItem', 'goog.ui.TriStateMenuItem.State'], ['goog.dom.classlist', 'goog.ui.Component', 'goog.ui.MenuItem', 'goog.ui.TriStateMenuItemRenderer', 'goog.ui.registry']);
goog.addDependency('ui/tristatemenuitemrenderer.js', ['goog.ui.TriStateMenuItemRenderer'], ['goog.dom.classlist', 'goog.ui.MenuItemRenderer']);
goog.addDependency('ui/twothumbslider.js', ['goog.ui.TwoThumbSlider'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.dom', 'goog.ui.SliderBase']);
goog.addDependency('ui/zippy.js', ['goog.ui.Zippy', 'goog.ui.Zippy.Events', 'goog.ui.ZippyEvent'], ['goog.a11y.aria', 'goog.a11y.aria.Role', 'goog.a11y.aria.State', 'goog.dom', 'goog.dom.classlist', 'goog.events.Event', 'goog.events.EventHandler', 'goog.events.EventTarget', 'goog.events.EventType', 'goog.events.KeyCodes', 'goog.style']);
goog.addDependency('uri/uri.js', ['goog.Uri', 'goog.Uri.QueryData'], ['goog.array', 'goog.string', 'goog.structs', 'goog.structs.Map', 'goog.uri.utils', 'goog.uri.utils.ComponentIndex', 'goog.uri.utils.StandardQueryParam']);
goog.addDependency('uri/uri_test.js', ['goog.UriTest'], ['goog.Uri', 'goog.testing.jsunit']);
goog.addDependency('uri/utils.js', ['goog.uri.utils', 'goog.uri.utils.ComponentIndex', 'goog.uri.utils.QueryArray', 'goog.uri.utils.QueryValue', 'goog.uri.utils.StandardQueryParam'], ['goog.asserts', 'goog.string', 'goog.userAgent']);
goog.addDependency('useragent/adobereader.js', ['goog.userAgent.adobeReader'], ['goog.string', 'goog.userAgent']);
goog.addDependency('useragent/flash.js', ['goog.userAgent.flash'], ['goog.string']);
goog.addDependency('useragent/iphoto.js', ['goog.userAgent.iphoto'], ['goog.string', 'goog.userAgent']);
goog.addDependency('useragent/jscript.js', ['goog.userAgent.jscript'], ['goog.string']);
goog.addDependency('useragent/picasa.js', ['goog.userAgent.picasa'], ['goog.string', 'goog.userAgent']);
goog.addDependency('useragent/platform.js', ['goog.userAgent.platform'], ['goog.userAgent']);
goog.addDependency('useragent/product.js', ['goog.userAgent.product'], ['goog.userAgent']);
goog.addDependency('useragent/product_isversion.js', ['goog.userAgent.product.isVersion'], ['goog.userAgent.product']);
goog.addDependency('useragent/useragent.js', ['goog.userAgent'], ['goog.string']);
goog.addDependency('useragent/useragenttestutil.js', ['goog.userAgentTestUtil', 'goog.userAgentTestUtil.UserAgents'], ['goog.userAgent']);
goog.addDependency('vec/float32array.js', ['goog.vec.Float32Array'], []);
goog.addDependency('vec/float64array.js', ['goog.vec.Float64Array'], []);
goog.addDependency('vec/mat3.js', ['goog.vec.Mat3'], ['goog.vec']);
goog.addDependency('vec/mat3d.js', ['goog.vec.mat3d', 'goog.vec.mat3d.Type'], ['goog.vec']);
goog.addDependency('vec/mat3f.js', ['goog.vec.mat3f', 'goog.vec.mat3f.Type'], ['goog.vec']);
goog.addDependency('vec/mat4.js', ['goog.vec.Mat4'], ['goog.vec', 'goog.vec.Vec3', 'goog.vec.Vec4']);
goog.addDependency('vec/mat4d.js', ['goog.vec.mat4d', 'goog.vec.mat4d.Type'], ['goog.vec', 'goog.vec.vec3d', 'goog.vec.vec4d']);
goog.addDependency('vec/mat4f.js', ['goog.vec.mat4f', 'goog.vec.mat4f.Type'], ['goog.vec', 'goog.vec.vec3f', 'goog.vec.vec4f']);
goog.addDependency('vec/matrix3.js', ['goog.vec.Matrix3'], []);
goog.addDependency('vec/matrix4.js', ['goog.vec.Matrix4'], ['goog.vec', 'goog.vec.Vec3', 'goog.vec.Vec4']);
goog.addDependency('vec/quaternion.js', ['goog.vec.Quaternion'], ['goog.vec', 'goog.vec.Vec3', 'goog.vec.Vec4']);
goog.addDependency('vec/ray.js', ['goog.vec.Ray'], ['goog.vec.Vec3']);
goog.addDependency('vec/vec.js', ['goog.vec', 'goog.vec.AnyType', 'goog.vec.ArrayType', 'goog.vec.Float32', 'goog.vec.Float64', 'goog.vec.Number'], ['goog.vec.Float32Array', 'goog.vec.Float64Array']);
goog.addDependency('vec/vec2.js', ['goog.vec.Vec2'], ['goog.vec']);
goog.addDependency('vec/vec2d.js', ['goog.vec.vec2d', 'goog.vec.vec2d.Type'], ['goog.vec']);
goog.addDependency('vec/vec2f.js', ['goog.vec.vec2f', 'goog.vec.vec2f.Type'], ['goog.vec']);
goog.addDependency('vec/vec3.js', ['goog.vec.Vec3'], ['goog.vec']);
goog.addDependency('vec/vec3d.js', ['goog.vec.vec3d', 'goog.vec.vec3d.Type'], ['goog.vec']);
goog.addDependency('vec/vec3f.js', ['goog.vec.vec3f', 'goog.vec.vec3f.Type'], ['goog.vec']);
goog.addDependency('vec/vec4.js', ['goog.vec.Vec4'], ['goog.vec']);
goog.addDependency('vec/vec4d.js', ['goog.vec.vec4d', 'goog.vec.vec4d.Type'], ['goog.vec']);
goog.addDependency('vec/vec4f.js', ['goog.vec.vec4f', 'goog.vec.vec4f.Type'], ['goog.vec']);
goog.addDependency('webgl/webgl.js', ['goog.webgl'], []);
goog.addDependency('window/window.js', ['goog.window'], ['goog.string', 'goog.userAgent']);

//javascript/apps/drive/dataservice/sync/stat/requesttype.js
goog.provide('drive.ds.sync.stat.RequestType');


/**
 * A list of request types.
 * @enum {string}
 */
drive.ds.sync.stat.RequestType = {
  ABOUT: 'about',
  APPS: 'apps',
  CHANGE: 'change',
  MUTATE: 'mutate',
  PERMISSIONS: 'permissions',
  QUERY: 'query',
  REVISIONS: 'revisions'
};

//javascript/closure/disposable/idisposable.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the disposable interface.  A disposable object
 * has a dispose method to to clean up references and resources.
 * @author nnaze@google.com (Nathan Naze)
 */


goog.provide('goog.disposable.IDisposable');



/**
 * Interface for a disposable object.  If a instance requires cleanup
 * (references COM objects, DOM notes, or other disposable objects), it should
 * implement this interface (it may subclass goog.Disposable).
 * @interface
 */
goog.disposable.IDisposable = function() {};


/**
 * Disposes of the object and its resources.
 * @return {void} Nothing.
 */
goog.disposable.IDisposable.prototype.dispose;


/**
 * @return {boolean} Whether the object has been disposed of.
 */
goog.disposable.IDisposable.prototype.isDisposed;

//javascript/closure/disposable/disposable.js
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Implements the disposable interface. The dispose method is used
 * to clean up references and resources.
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.Disposable');
/** @suppress {extraProvide} */
goog.provide('goog.dispose');
/** @suppress {extraProvide} */
goog.provide('goog.disposeAll');

goog.require('goog.disposable.IDisposable');



/**
 * Class that provides the basic implementation for disposable objects. If your
 * class holds one or more references to COM objects, DOM nodes, or other
 * disposable objects, it should extend this class or implement the disposable
 * interface (defined in goog.disposable.IDisposable).
 * @constructor
 * @implements {goog.disposable.IDisposable}
 */
goog.Disposable = function() {
  if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
    if (goog.Disposable.INCLUDE_STACK_ON_CREATION) {
      this.creationStack = new Error().stack;
    }
    goog.Disposable.instances_[goog.getUid(this)] = this;
  }
};


/**
 * @enum {number} Different monitoring modes for Disposable.
 */
goog.Disposable.MonitoringMode = {
  /**
   * No monitoring.
   */
  OFF: 0,
  /**
   * Creating and disposing the goog.Disposable instances is monitored. All
   * disposable objects need to call the {@code goog.Disposable} base
   * constructor. The PERMANENT mode must be switched on before creating any
   * goog.Disposable instances.
   */
  PERMANENT: 1,
  /**
   * INTERACTIVE mode can be switched on and off on the fly without producing
   * errors. It also doesn't warn if the disposable objects don't call the
   * {@code goog.Disposable} base constructor.
   */
  INTERACTIVE: 2
};


/**
 * @define {number} The monitoring mode of the goog.Disposable
 *     instances. Default is OFF. Switching on the monitoring is only
 *     recommended for debugging because it has a significant impact on
 *     performance and memory usage. If switched off, the monitoring code
 *     compiles down to 0 bytes.
 */
goog.define('goog.Disposable.MONITORING_MODE', 0);


/**
 * @define {boolean} Whether to attach creation stack to each created disposable
 *     instance; This is only relevant for when MonitoringMode != OFF.
 */
goog.define('goog.Disposable.INCLUDE_STACK_ON_CREATION', true);


/**
 * Maps the unique ID of every undisposed {@code goog.Disposable} object to
 * the object itself.
 * @type {!Object.<number, !goog.Disposable>}
 * @private
 */
goog.Disposable.instances_ = {};


/**
 * @return {!Array.<!goog.Disposable>} All {@code goog.Disposable} objects that
 *     haven't been disposed of.
 */
goog.Disposable.getUndisposedObjects = function() {
  var ret = [];
  for (var id in goog.Disposable.instances_) {
    if (goog.Disposable.instances_.hasOwnProperty(id)) {
      ret.push(goog.Disposable.instances_[Number(id)]);
    }
  }
  return ret;
};


/**
 * Clears the registry of undisposed objects but doesn't dispose of them.
 */
goog.Disposable.clearUndisposedObjects = function() {
  goog.Disposable.instances_ = {};
};


/**
 * Whether the object has been disposed of.
 * @type {boolean}
 * @private
 */
goog.Disposable.prototype.disposed_ = false;


/**
 * Callbacks to invoke when this object is disposed.
 * @type {Array.<!Function>}
 * @private
 */
goog.Disposable.prototype.onDisposeCallbacks_;


/**
 * If monitoring the goog.Disposable instances is enabled, stores the creation
 * stack trace of the Disposable instance.
 * @type {string}
 */
goog.Disposable.prototype.creationStack;


/**
 * @return {boolean} Whether the object has been disposed of.
 * @override
 */
goog.Disposable.prototype.isDisposed = function() {
  return this.disposed_;
};


/**
 * @return {boolean} Whether the object has been disposed of.
 * @deprecated Use {@link #isDisposed} instead.
 */
goog.Disposable.prototype.getDisposed = goog.Disposable.prototype.isDisposed;


/**
 * Disposes of the object. If the object hasn't already been disposed of, calls
 * {@link #disposeInternal}. Classes that extend {@code goog.Disposable} should
 * override {@link #disposeInternal} in order to delete references to COM
 * objects, DOM nodes, and other disposable objects. Reentrant.
 *
 * @return {void} Nothing.
 * @override
 */
goog.Disposable.prototype.dispose = function() {
  if (!this.disposed_) {
    // Set disposed_ to true first, in case during the chain of disposal this
    // gets disposed recursively.
    this.disposed_ = true;
    this.disposeInternal();
    if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
      var uid = goog.getUid(this);
      if (goog.Disposable.MONITORING_MODE ==
          goog.Disposable.MonitoringMode.PERMANENT &&
          !goog.Disposable.instances_.hasOwnProperty(uid)) {
        throw Error(this + ' did not call the goog.Disposable base ' +
            'constructor or was disposed of after a clearUndisposedObjects ' +
            'call');
      }
      delete goog.Disposable.instances_[uid];
    }
  }
};


/**
 * Associates a disposable object with this object so that they will be disposed
 * together.
 * @param {goog.disposable.IDisposable} disposable that will be disposed when
 *     this object is disposed.
 */
goog.Disposable.prototype.registerDisposable = function(disposable) {
  this.addOnDisposeCallback(goog.partial(goog.dispose, disposable));
};


/**
 * Invokes a callback function when this object is disposed. Callbacks are
 * invoked in the order in which they were added.
 * @param {function(this:T):?} callback The callback function.
 * @param {T=} opt_scope An optional scope to call the callback in.
 * @template T
 */
goog.Disposable.prototype.addOnDisposeCallback = function(callback, opt_scope) {
  if (!this.onDisposeCallbacks_) {
    this.onDisposeCallbacks_ = [];
  }
  this.onDisposeCallbacks_.push(goog.bind(callback, opt_scope));
};


/**
 * Deletes or nulls out any references to COM objects, DOM nodes, or other
 * disposable objects. Classes that extend {@code goog.Disposable} should
 * override this method.
 * Not reentrant. To avoid calling it twice, it must only be called from the
 * subclass' {@code disposeInternal} method. Everywhere else the public
 * {@code dispose} method must be used.
 * For example:
 * <pre>
 *   mypackage.MyClass = function() {
 *     goog.base(this);
 *     // Constructor logic specific to MyClass.
 *     ...
 *   };
 *   goog.inherits(mypackage.MyClass, goog.Disposable);
 *
 *   mypackage.MyClass.prototype.disposeInternal = function() {
 *     // Dispose logic specific to MyClass.
 *     ...
 *     // Call superclass's disposeInternal at the end of the subclass's, like
 *     // in C++, to avoid hard-to-catch issues.
 *     goog.base(this, 'disposeInternal');
 *   };
 * </pre>
 * @protected
 */
goog.Disposable.prototype.disposeInternal = function() {
  if (this.onDisposeCallbacks_) {
    while (this.onDisposeCallbacks_.length) {
      this.onDisposeCallbacks_.shift()();
    }
  }
};


/**
 * Returns True if we can verify the object is disposed.
 * Calls {@code isDisposed} on the argument if it supports it.  If obj
 * is not an object with an isDisposed() method, return false.
 * @param {*} obj The object to investigate.
 * @return {boolean} True if we can verify the object is disposed.
 */
goog.Disposable.isDisposed = function(obj) {
  if (obj && typeof obj.isDisposed == 'function') {
    return obj.isDisposed();
  }
  return false;
};


/**
 * Calls {@code dispose} on the argument if it supports it. If obj is not an
 *     object with a dispose() method, this is a no-op.
 * @param {*} obj The object to dispose of.
 */
goog.dispose = function(obj) {
  if (obj && typeof obj.dispose == 'function') {
    obj.dispose();
  }
};


/**
 * Calls {@code dispose} on each member of the list that supports it. (If the
 * member is an ArrayLike, then {@code goog.disposeAll()} will be called
 * recursively on each of its members.) If the member is not an object with a
 * {@code dispose()} method, then it is ignored.
 * @param {...*} var_args The list.
 */
goog.disposeAll = function(var_args) {
  for (var i = 0, len = arguments.length; i < len; ++i) {
    var disposable = arguments[i];
    if (goog.isArrayLike(disposable)) {
      goog.disposeAll.apply(null, disposable);
    } else {
      goog.dispose(disposable);
    }
  }
};

//javascript/closure/debug/error.js
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides a base class for custom Error objects such that the
 * stack is correctly maintained.
 *
 * You should never need to throw goog.debug.Error(msg) directly, Error(msg) is
 * sufficient.
 *
 * @author pupius@google.com (Daniel Pupius)
 */

goog.provide('goog.debug.Error');



/**
 * Base class for custom error objects.
 * @param {*=} opt_msg The message associated with the error.
 * @constructor
 * @extends {Error}
 */
goog.debug.Error = function(opt_msg) {

  // Ensure there is a stack trace.
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, goog.debug.Error);
  } else {
    this.stack = new Error().stack || '';
  }

  if (opt_msg) {
    this.message = String(opt_msg);
  }
};
goog.inherits(goog.debug.Error, Error);


/** @override */
goog.debug.Error.prototype.name = 'CustomError';

//javascript/closure/dom/nodetype.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of goog.dom.NodeType.
 */

goog.provide('goog.dom.NodeType');


/**
 * Constants for the nodeType attribute in the Node interface.
 *
 * These constants match those specified in the Node interface. These are
 * usually present on the Node object in recent browsers, but not in older
 * browsers (specifically, early IEs) and thus are given here.
 *
 * In some browsers (early IEs), these are not defined on the Node object,
 * so they are provided here.
 *
 * See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
 * @enum {number}
 */
goog.dom.NodeType = {
  ELEMENT: 1,
  ATTRIBUTE: 2,
  TEXT: 3,
  CDATA_SECTION: 4,
  ENTITY_REFERENCE: 5,
  ENTITY: 6,
  PROCESSING_INSTRUCTION: 7,
  COMMENT: 8,
  DOCUMENT: 9,
  DOCUMENT_TYPE: 10,
  DOCUMENT_FRAGMENT: 11,
  NOTATION: 12
};

//javascript/closure/string/string.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for string manipulation.
 * @author pupius@google.com (Daniel Pupius)
 * @author arv@google.com (Erik Arvidsson)
 */


/**
 * Namespace for string utilities
 */
goog.provide('goog.string');
goog.provide('goog.string.Unicode');


/**
 * Common Unicode string characters.
 * @enum {string}
 */
goog.string.Unicode = {
  NBSP: '\xa0'
};


/**
 * Fast prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix A string to look for at the start of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix}.
 */
goog.string.startsWith = function(str, prefix) {
  return str.lastIndexOf(prefix, 0) == 0;
};


/**
 * Fast suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix}.
 */
goog.string.endsWith = function(str, suffix) {
  var l = str.length - suffix.length;
  return l >= 0 && str.indexOf(suffix, l) == l;
};


/**
 * Case-insensitive prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix  A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveStartsWith = function(str, prefix) {
  return goog.string.caseInsensitiveCompare(
      prefix, str.substr(0, prefix.length)) == 0;
};


/**
 * Case-insensitive suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveEndsWith = function(str, suffix) {
  return goog.string.caseInsensitiveCompare(
      suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;
};


/**
 * Case-insensitive equality checker.
 * @param {string} str1 First string to check.
 * @param {string} str2 Second string to check.
 * @return {boolean} True if {@code str1} and {@code str2} are the same string,
 *     ignoring case.
 */
goog.string.caseInsensitiveEquals = function(str1, str2) {
  return str1.toLowerCase() == str2.toLowerCase();
};


/**
 * Does simple python-style string substitution.
 * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
 * @param {string} str The string containing the pattern.
 * @param {...*} var_args The items to substitute into the pattern.
 * @return {string} A copy of {@code str} in which each occurrence of
 *     {@code %s} has been replaced an argument from {@code var_args}.
 */
goog.string.subs = function(str, var_args) {
  var splitParts = str.split('%s');
  var returnString = '';

  var subsArguments = Array.prototype.slice.call(arguments, 1);
  while (subsArguments.length &&
         // Replace up to the last split part. We are inserting in the
         // positions between split parts.
         splitParts.length > 1) {
    returnString += splitParts.shift() + subsArguments.shift();
  }

  return returnString + splitParts.join('%s'); // Join unused '%s'
};


/**
 * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines
 * and tabs) to a single space, and strips leading and trailing whitespace.
 * @param {string} str Input string.
 * @return {string} A copy of {@code str} with collapsed whitespace.
 */
goog.string.collapseWhitespace = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
};


/**
 * Checks if a string is empty or contains only whitespaces.
 * @param {string} str The string to check.
 * @return {boolean} True if {@code str} is empty or whitespace only.
 */
goog.string.isEmpty = function(str) {
  // testing length == 0 first is actually slower in all browsers (about the
  // same in Opera).
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return /^[\s\xa0]*$/.test(str);
};


/**
 * Checks if a string is null, undefined, empty or contains only whitespaces.
 * @param {*} str The string to check.
 * @return {boolean} True if{@code str} is null, undefined, empty, or
 *     whitespace only.
 */
goog.string.isEmptySafe = function(str) {
  return goog.string.isEmpty(goog.string.makeSafe(str));
};


/**
 * Checks if a string is all breaking whitespace.
 * @param {string} str The string to check.
 * @return {boolean} Whether the string is all breaking whitespace.
 */
goog.string.isBreakingWhitespace = function(str) {
  return !/[^\t\n\r ]/.test(str);
};


/**
 * Checks if a string contains all letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} consists entirely of letters.
 */
goog.string.isAlpha = function(str) {
  return !/[^a-zA-Z]/.test(str);
};


/**
 * Checks if a string contains only numbers.
 * @param {*} str string to check. If not a string, it will be
 *     casted to one.
 * @return {boolean} True if {@code str} is numeric.
 */
goog.string.isNumeric = function(str) {
  return !/[^0-9]/.test(str);
};


/**
 * Checks if a string contains only numbers or letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} is alphanumeric.
 */
goog.string.isAlphaNumeric = function(str) {
  return !/[^a-zA-Z0-9]/.test(str);
};


/**
 * Checks if a character is a space character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {code ch} is a space.
 */
goog.string.isSpace = function(ch) {
  return ch == ' ';
};


/**
 * Checks if a character is a valid unicode character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {code ch} is a valid unicode character.
 */
goog.string.isUnicodeChar = function(ch) {
  return ch.length == 1 && ch >= ' ' && ch <= '~' ||
         ch >= '\u0080' && ch <= '\uFFFD';
};


/**
 * Takes a string and replaces newlines with a space. Multiple lines are
 * replaced with a single space.
 * @param {string} str The string from which to strip newlines.
 * @return {string} A copy of {@code str} stripped of newlines.
 */
goog.string.stripNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)+/g, ' ');
};


/**
 * Replaces Windows and Mac new lines with unix style: \r or \r\n with \n.
 * @param {string} str The string to in which to canonicalize newlines.
 * @return {string} {@code str} A copy of {@code} with canonicalized newlines.
 */
goog.string.canonicalizeNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)/g, '\n');
};


/**
 * Normalizes whitespace in a string, replacing all whitespace chars with
 * a space.
 * @param {string} str The string in which to normalize whitespace.
 * @return {string} A copy of {@code str} with all whitespace normalized.
 */
goog.string.normalizeWhitespace = function(str) {
  return str.replace(/\xa0|\s/g, ' ');
};


/**
 * Normalizes spaces in a string, replacing all consecutive spaces and tabs
 * with a single space. Replaces non-breaking space with a space.
 * @param {string} str The string in which to normalize spaces.
 * @return {string} A copy of {@code str} with all consecutive spaces and tabs
 *    replaced with a single space.
 */
goog.string.normalizeSpaces = function(str) {
  return str.replace(/\xa0|[ \t]+/g, ' ');
};


/**
 * Removes the breaking spaces from the left and right of the string and
 * collapses the sequences of breaking spaces in the middle into single spaces.
 * The original and the result strings render the same way in HTML.
 * @param {string} str A string in which to collapse spaces.
 * @return {string} Copy of the string with normalized breaking spaces.
 */
goog.string.collapseBreakingSpaces = function(str) {
  return str.replace(/[\t\r\n ]+/g, ' ').replace(
      /^[\t\r\n ]+|[\t\r\n ]+$/g, '');
};


/**
 * Trims white spaces to the left and right of a string.
 * @param {string} str The string to trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trim = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
};


/**
 * Trims whitespaces at the left end of a string.
 * @param {string} str The string to left trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimLeft = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/^[\s\xa0]+/, '');
};


/**
 * Trims whitespaces at the right end of a string.
 * @param {string} str The string to right trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimRight = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+$/, '');
};


/**
 * A string comparator that ignores case.
 * -1 = str1 less than str2
 *  0 = str1 equals str2
 *  1 = str1 greater than str2
 *
 * @param {string} str1 The string to compare.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} The comparator result, as described above.
 */
goog.string.caseInsensitiveCompare = function(str1, str2) {
  var test1 = String(str1).toLowerCase();
  var test2 = String(str2).toLowerCase();

  if (test1 < test2) {
    return -1;
  } else if (test1 == test2) {
    return 0;
  } else {
    return 1;
  }
};


/**
 * Regular expression used for splitting a string into substrings of fractional
 * numbers, integers, and non-numeric characters.
 * @type {RegExp}
 * @private
 */
goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;


/**
 * String comparison function that handles numbers in a way humans might expect.
 * Using this function, the string "File 2.jpg" sorts before "File 10.jpg". The
 * comparison is mostly case-insensitive, though strings that are identical
 * except for case are sorted with the upper-case strings before lower-case.
 *
 * This comparison function is significantly slower (about 500x) than either
 * the default or the case-insensitive compare. It should not be used in
 * time-critical code, but should be fast enough to sort several hundred short
 * strings (like filenames) with a reasonable delay.
 *
 * @param {string} str1 The string to compare in a numerically sensitive way.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than
 *     0 if str1 > str2.
 */
goog.string.numerateCompare = function(str1, str2) {
  if (str1 == str2) {
    return 0;
  }
  if (!str1) {
    return -1;
  }
  if (!str2) {
    return 1;
  }

  // Using match to split the entire string ahead of time turns out to be faster
  // for most inputs than using RegExp.exec or iterating over each character.
  var tokens1 = str1.toLowerCase().match(goog.string.numerateCompareRegExp_);
  var tokens2 = str2.toLowerCase().match(goog.string.numerateCompareRegExp_);

  var count = Math.min(tokens1.length, tokens2.length);

  for (var i = 0; i < count; i++) {
    var a = tokens1[i];
    var b = tokens2[i];

    // Compare pairs of tokens, returning if one token sorts before the other.
    if (a != b) {

      // Only if both tokens are integers is a special comparison required.
      // Decimal numbers are sorted as strings (e.g., '.09' < '.1').
      var num1 = parseInt(a, 10);
      if (!isNaN(num1)) {
        var num2 = parseInt(b, 10);
        if (!isNaN(num2) && num1 - num2) {
          return num1 - num2;
        }
      }
      return a < b ? -1 : 1;
    }
  }

  // If one string is a substring of the other, the shorter string sorts first.
  if (tokens1.length != tokens2.length) {
    return tokens1.length - tokens2.length;
  }

  // The two strings must be equivalent except for case (perfect equality is
  // tested at the head of the function.) Revert to default ASCII-betical string
  // comparison to stablize the sort.
  return str1 < str2 ? -1 : 1;
};


/**
 * URL-encodes a string
 * @param {*} str The string to url-encode.
 * @return {string} An encoded copy of {@code str} that is safe for urls.
 *     Note that '#', ':', and other characters used to delimit portions
 *     of URLs *will* be encoded.
 */
goog.string.urlEncode = function(str) {
  return encodeURIComponent(String(str));
};


/**
 * URL-decodes the string. We need to specially handle '+'s because
 * the javascript library doesn't convert them to spaces.
 * @param {string} str The string to url decode.
 * @return {string} The decoded {@code str}.
 */
goog.string.urlDecode = function(str) {
  return decodeURIComponent(str.replace(/\+/g, ' '));
};


/**
 * Converts \n to <br>s or <br />s.
 * @param {string} str The string in which to convert newlines.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} A copy of {@code str} with converted newlines.
 */
goog.string.newLineToBr = function(str, opt_xml) {
  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? '<br />' : '<br>');
};


/**
 * Escape double quote '"' characters in addition to '&', '<', and '>' so that a
 * string can be included in an HTML tag attribute value within double quotes.
 *
 * It should be noted that > doesn't need to be escaped for the HTML or XML to
 * be valid, but it has been decided to escape it for consistency with other
 * implementations.
 *
 * NOTE(pupius):
 * HtmlEscape is often called during the generation of large blocks of HTML.
 * Using statics for the regular expressions and strings is an optimization
 * that can more than half the amount of time IE spends in this function for
 * large apps, since strings and regexes both contribute to GC allocations.
 *
 * Testing for the presence of a character before escaping increases the number
 * of function calls, but actually provides a speed increase for the average
 * case -- since the average case often doesn't require the escaping of all 4
 * characters and indexOf() is much cheaper than replace().
 * The worst case does suffer slightly from the additional calls, therefore the
 * opt_isLikelyToContainHtmlChars option has been included for situations
 * where all 4 HTML entities are very likely to be present and need escaping.
 *
 * Some benchmarks (times tended to fluctuate +-0.05ms):
 *                                     FireFox                     IE6
 * (no chars / average (mix of cases) / all 4 chars)
 * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
 * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
 * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
 *
 * An additional advantage of checking if replace actually needs to be called
 * is a reduction in the number of object allocations, so as the size of the
 * application grows the difference between the various methods would increase.
 *
 * @param {string} str string to be escaped.
 * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
 *     if the character needs replacing - use this option if you expect each of
 *     the characters to appear often. Leave false if you expect few html
 *     characters to occur in your strings, such as if you are escaping HTML.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {

  if (opt_isLikelyToContainHtmlChars) {
    return str.replace(goog.string.amperRe_, '&amp;')
          .replace(goog.string.ltRe_, '&lt;')
          .replace(goog.string.gtRe_, '&gt;')
          .replace(goog.string.quotRe_, '&quot;')
          .replace(goog.string.singleQuoteRe_, '&#39;');

  } else {
    // quick test helps in the case when there are no chars to replace, in
    // worst case this makes barely a difference to the time taken
    if (!goog.string.allRe_.test(str)) return str;

    // str.indexOf is faster than regex.test in this case
    if (str.indexOf('&') != -1) {
      str = str.replace(goog.string.amperRe_, '&amp;');
    }
    if (str.indexOf('<') != -1) {
      str = str.replace(goog.string.ltRe_, '&lt;');
    }
    if (str.indexOf('>') != -1) {
      str = str.replace(goog.string.gtRe_, '&gt;');
    }
    if (str.indexOf('"') != -1) {
      str = str.replace(goog.string.quotRe_, '&quot;');
    }
    if (str.indexOf('\'') != -1) {
      str = str.replace(goog.string.singleQuoteRe_, '&#39;');
    }
    return str;
  }
};


/**
 * Regular expression that matches an ampersand, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.amperRe_ = /&/g;


/**
 * Regular expression that matches a less than sign, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.ltRe_ = /</g;


/**
 * Regular expression that matches a greater than sign, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.gtRe_ = />/g;


/**
 * Regular expression that matches a double quote, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.quotRe_ = /"/g;


/**
 * Regular expression that matches a single quote, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.singleQuoteRe_ = /'/g;


/**
 * Regular expression that matches any character that needs to be escaped.
 * @type {RegExp}
 * @private
 */
goog.string.allRe_ = /[&<>"']/;


/**
 * Unescapes an HTML string.
 *
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapeEntities = function(str) {
  if (goog.string.contains(str, '&')) {
    // We are careful not to use a DOM if we do not have one. We use the []
    // notation so that the JSCompiler will not complain about these objects and
    // fields in the case where we have no DOM.
    if ('document' in goog.global) {
      return goog.string.unescapeEntitiesUsingDom_(str);
    } else {
      // Fall back on pure XML entities
      return goog.string.unescapePureXmlEntities_(str);
    }
  }
  return str;
};


/**
 * Unescapes a HTML string using the provided document.
 *
 * @param {string} str The string to unescape.
 * @param {!Document} document A document to use in escaping the string.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapeEntitiesWithDocument = function(str, document) {
  if (goog.string.contains(str, '&')) {
    return goog.string.unescapeEntitiesUsingDom_(str, document);
  }
  return str;
};


/**
 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
 * entities. This function is XSS-safe and whitespace-preserving.
 * @private
 * @param {string} str The string to unescape.
 * @param {Document=} opt_document An optional document to use for creating
 *     elements. If this is not specified then the default window.document
 *     will be used.
 * @return {string} The unescaped {@code str} string.
 */
goog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {
  var seen = {'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"'};
  var div;
  if (opt_document) {
    div = opt_document.createElement('div');
  } else {
    div = document.createElement('div');
  }
  // Match as many valid entity characters as possible. If the actual entity
  // happens to be shorter, it will still work as innerHTML will return the
  // trailing characters unchanged. Since the entity characters do not include
  // open angle bracket, there is no chance of XSS from the innerHTML use.
  // Since no whitespace is passed to innerHTML, whitespace is preserved.
  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {
    // Check for cached entity.
    var value = seen[s];
    if (value) {
      return value;
    }
    // Check for numeric entity.
    if (entity.charAt(0) == '#') {
      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
      var n = Number('0' + entity.substr(1));
      if (!isNaN(n)) {
        value = String.fromCharCode(n);
      }
    }
    // Fall back to innerHTML otherwise.
    if (!value) {
      // Append a non-entity character to avoid a bug in Webkit that parses
      // an invalid entity at the end of innerHTML text as the empty string.
      div.innerHTML = s + ' ';
      // Then remove the trailing character from the result.
      value = div.firstChild.nodeValue.slice(0, -1);
    }
    // Cache and return.
    return seen[s] = value;
  });
};


/**
 * Unescapes XML entities.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapePureXmlEntities_ = function(str) {
  return str.replace(/&([^;]+);/g, function(s, entity) {
    switch (entity) {
      case 'amp':
        return '&';
      case 'lt':
        return '<';
      case 'gt':
        return '>';
      case 'quot':
        return '"';
      default:
        if (entity.charAt(0) == '#') {
          // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.
          var n = Number('0' + entity.substr(1));
          if (!isNaN(n)) {
            return String.fromCharCode(n);
          }
        }
        // For invalid entities we just return the entity
        return s;
    }
  });
};


/**
 * Regular expression that matches an HTML entity.
 * See also HTML5: Tokenization / Tokenizing character references.
 * @private
 * @type {!RegExp}
 */
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;


/**
 * Do escaping of whitespace to preserve spatial formatting. We use character
 * entity #160 to make it safer for xml.
 * @param {string} str The string in which to escape whitespace.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.whitespaceEscape = function(str, opt_xml) {
  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);
};


/**
 * Strip quote characters around a string.  The second argument is a string of
 * characters to treat as quotes.  This can be a single character or a string of
 * multiple character and in that case each of those are treated as possible
 * quote characters. For example:
 *
 * <pre>
 * goog.string.stripQuotes('"abc"', '"`') --> 'abc'
 * goog.string.stripQuotes('`abc`', '"`') --> 'abc'
 * </pre>
 *
 * @param {string} str The string to strip.
 * @param {string} quoteChars The quote characters to strip.
 * @return {string} A copy of {@code str} without the quotes.
 */
goog.string.stripQuotes = function(str, quoteChars) {
  var length = quoteChars.length;
  for (var i = 0; i < length; i++) {
    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {
      return str.substring(1, str.length - 1);
    }
  }
  return str;
};


/**
 * Truncates a string to a certain length and adds '...' if necessary.  The
 * length also accounts for the ellipsis, so a maximum length of 10 and a string
 * 'Hello World!' produces 'Hello W...'.
 * @param {string} str The string to truncate.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cut off in the middle.
 * @return {string} The truncated {@code str} string.
 */
goog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (str.length > chars) {
    str = str.substring(0, chars - 3) + '...';
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Truncate a string in the middle, adding "..." if necessary,
 * and favoring the beginning of the string.
 * @param {string} str The string to truncate the middle of.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cutoff in the middle.
 * @param {number=} opt_trailingChars Optional number of trailing characters to
 *     leave at the end of the string, instead of truncating as close to the
 *     middle as possible.
 * @return {string} A truncated copy of {@code str}.
 */
goog.string.truncateMiddle = function(str, chars,
    opt_protectEscapedCharacters, opt_trailingChars) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (opt_trailingChars && str.length > chars) {
    if (opt_trailingChars > chars) {
      opt_trailingChars = chars;
    }
    var endPoint = str.length - opt_trailingChars;
    var startPoint = chars - opt_trailingChars;
    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);
  } else if (str.length > chars) {
    // Favor the beginning of the string:
    var half = Math.floor(chars / 2);
    var endPos = str.length - half;
    half += chars % 2;
    str = str.substring(0, half) + '...' + str.substring(endPos);
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Special chars that need to be escaped for goog.string.quote.
 * @private
 * @type {Object}
 */
goog.string.specialEscapeChars_ = {
  '\0': '\\0',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',
  '\x0B': '\\x0B', // '\v' is not supported in JScript
  '"': '\\"',
  '\\': '\\\\'
};


/**
 * Character mappings used internally for goog.string.escapeChar.
 * @private
 * @type {Object}
 */
goog.string.jsEscapeCache_ = {
  '\'': '\\\''
};


/**
 * Encloses a string in double quotes and escapes characters so that the
 * string is a valid JS string.
 * @param {string} s The string to quote.
 * @return {string} A copy of {@code s} surrounded by double quotes.
 */
goog.string.quote = function(s) {
  s = String(s);
  if (s.quote) {
    return s.quote();
  } else {
    var sb = ['"'];
    for (var i = 0; i < s.length; i++) {
      var ch = s.charAt(i);
      var cc = ch.charCodeAt(0);
      sb[i + 1] = goog.string.specialEscapeChars_[ch] ||
          ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));
    }
    sb.push('"');
    return sb.join('');
  }
};


/**
 * Takes a string and returns the escaped string for that character.
 * @param {string} str The string to escape.
 * @return {string} An escaped string representing {@code str}.
 */
goog.string.escapeString = function(str) {
  var sb = [];
  for (var i = 0; i < str.length; i++) {
    sb[i] = goog.string.escapeChar(str.charAt(i));
  }
  return sb.join('');
};


/**
 * Takes a character and returns the escaped string for that character. For
 * example escapeChar(String.fromCharCode(15)) -> "\\x0E".
 * @param {string} c The character to escape.
 * @return {string} An escaped string representing {@code c}.
 */
goog.string.escapeChar = function(c) {
  if (c in goog.string.jsEscapeCache_) {
    return goog.string.jsEscapeCache_[c];
  }

  if (c in goog.string.specialEscapeChars_) {
    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
  }

  var rv = c;
  var cc = c.charCodeAt(0);
  if (cc > 31 && cc < 127) {
    rv = c;
  } else {
    // tab is 9 but handled above
    if (cc < 256) {
      rv = '\\x';
      if (cc < 16 || cc > 256) {
        rv += '0';
      }
    } else {
      rv = '\\u';
      if (cc < 4096) { // \u1000
        rv += '0';
      }
    }
    rv += cc.toString(16).toUpperCase();
  }

  return goog.string.jsEscapeCache_[c] = rv;
};


/**
 * Takes a string and creates a map (Object) in which the keys are the
 * characters in the string. The value for the key is set to true. You can
 * then use goog.object.map or goog.array.map to change the values.
 * @param {string} s The string to build the map from.
 * @return {Object} The map of characters used.
 */
// TODO(arv): It seems like we should have a generic goog.array.toMap. But do
//            we want a dependency on goog.array in goog.string?
goog.string.toMap = function(s) {
  var rv = {};
  for (var i = 0; i < s.length; i++) {
    rv[s.charAt(i)] = true;
  }
  return rv;
};


/**
 * Checks whether a string contains a given substring.
 * @param {string} s The string to test.
 * @param {string} ss The substring to test for.
 * @return {boolean} True if {@code s} contains {@code ss}.
 */
goog.string.contains = function(s, ss) {
  return s.indexOf(ss) != -1;
};


/**
 * Returns the non-overlapping occurrences of ss in s.
 * If either s or ss evalutes to false, then returns zero.
 * @param {string} s The string to look in.
 * @param {string} ss The string to look for.
 * @return {number} Number of occurrences of ss in s.
 */
goog.string.countOf = function(s, ss) {
  return s && ss ? s.split(ss).length - 1 : 0;
};


/**
 * Removes a substring of a specified length at a specific
 * index in a string.
 * @param {string} s The base string from which to remove.
 * @param {number} index The index at which to remove the substring.
 * @param {number} stringLength The length of the substring to remove.
 * @return {string} A copy of {@code s} with the substring removed or the full
 *     string if nothing is removed or the input is invalid.
 */
goog.string.removeAt = function(s, index, stringLength) {
  var resultStr = s;
  // If the index is greater or equal to 0 then remove substring
  if (index >= 0 && index < s.length && stringLength > 0) {
    resultStr = s.substr(0, index) +
        s.substr(index + stringLength, s.length - index - stringLength);
  }
  return resultStr;
};


/**
 *  Removes the first occurrence of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.remove = function(s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), '');
  return s.replace(re, '');
};


/**
 *  Removes all occurrences of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.removeAll = function(s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), 'g');
  return s.replace(re, '');
};


/**
 * Escapes characters in the string that are not safe to use in a RegExp.
 * @param {*} s The string to escape. If not a string, it will be casted
 *     to one.
 * @return {string} A RegExp safe, escaped copy of {@code s}.
 */
goog.string.regExpEscape = function(s) {
  return String(s).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
      replace(/\x08/g, '\\x08');
};


/**
 * Repeats a string n times.
 * @param {string} string The string to repeat.
 * @param {number} length The number of times to repeat.
 * @return {string} A string containing {@code length} repetitions of
 *     {@code string}.
 */
goog.string.repeat = function(string, length) {
  return new Array(length + 1).join(string);
};


/**
 * Pads number to given length and optionally rounds it to a given precision.
 * For example:
 * <pre>padNumber(1.25, 2, 3) -> '01.250'
 * padNumber(1.25, 2) -> '01.25'
 * padNumber(1.25, 2, 1) -> '01.3'
 * padNumber(1.25, 0) -> '1.25'</pre>
 *
 * @param {number} num The number to pad.
 * @param {number} length The desired length.
 * @param {number=} opt_precision The desired precision.
 * @return {string} {@code num} as a string with the given options.
 */
goog.string.padNumber = function(num, length, opt_precision) {
  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
  var index = s.indexOf('.');
  if (index == -1) {
    index = s.length;
  }
  return goog.string.repeat('0', Math.max(0, length - index)) + s;
};


/**
 * Returns a string representation of the given object, with
 * null and undefined being returned as the empty string.
 *
 * @param {*} obj The object to convert.
 * @return {string} A string representation of the {@code obj}.
 */
goog.string.makeSafe = function(obj) {
  return obj == null ? '' : String(obj);
};


/**
 * Concatenates string expressions. This is useful
 * since some browsers are very inefficient when it comes to using plus to
 * concat strings. Be careful when using null and undefined here since
 * these will not be included in the result. If you need to represent these
 * be sure to cast the argument to a String first.
 * For example:
 * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'
 * buildString(null, undefined) -> ''
 * </pre>
 * @param {...*} var_args A list of strings to concatenate. If not a string,
 *     it will be casted to one.
 * @return {string} The concatenation of {@code var_args}.
 */
goog.string.buildString = function(var_args) {
  return Array.prototype.join.call(arguments, '');
};


/**
 * Returns a string with at least 64-bits of randomness.
 *
 * Doesn't trust Javascript's random function entirely. Uses a combination of
 * random and current timestamp, and then encodes the string in base-36 to
 * make it shorter.
 *
 * @return {string} A random string, e.g. sn1s7vb4gcic.
 */
goog.string.getRandomString = function() {
  var x = 2147483648;
  return Math.floor(Math.random() * x).toString(36) +
         Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
};


/**
 * Compares two version numbers.
 *
 * @param {string|number} version1 Version of first item.
 * @param {string|number} version2 Version of second item.
 *
 * @return {number}  1 if {@code version1} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code version2} is higher.
 */
goog.string.compareVersions = function(version1, version2) {
  var order = 0;
  // Trim leading and trailing whitespace and split the versions into
  // subversions.
  var v1Subs = goog.string.trim(String(version1)).split('.');
  var v2Subs = goog.string.trim(String(version2)).split('.');
  var subCount = Math.max(v1Subs.length, v2Subs.length);

  // Iterate over the subversions, as long as they appear to be equivalent.
  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
    var v1Sub = v1Subs[subIdx] || '';
    var v2Sub = v2Subs[subIdx] || '';

    // Split the subversions into pairs of numbers and qualifiers (like 'b').
    // Two different RegExp objects are needed because they are both using
    // the 'g' flag.
    var v1CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    var v2CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    do {
      var v1Comp = v1CompParser.exec(v1Sub) || ['', '', ''];
      var v2Comp = v2CompParser.exec(v2Sub) || ['', '', ''];
      // Break if there are no more matches.
      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
        break;
      }

      // Parse the numeric part of the subversion. A missing number is
      // equivalent to 0.
      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);

      // Compare the subversion components. The number has the highest
      // precedence. Next, if the numbers are equal, a subversion without any
      // qualifier is always higher than a subversion with any qualifier. Next,
      // the qualifiers are compared as strings.
      order = goog.string.compareElements_(v1CompNum, v2CompNum) ||
          goog.string.compareElements_(v1Comp[2].length == 0,
              v2Comp[2].length == 0) ||
          goog.string.compareElements_(v1Comp[2], v2Comp[2]);
      // Stop as soon as an inequality is discovered.
    } while (order == 0);
  }

  return order;
};


/**
 * Compares elements of a version number.
 *
 * @param {string|number|boolean} left An element from a version number.
 * @param {string|number|boolean} right An element from a version number.
 *
 * @return {number}  1 if {@code left} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code right} is higher.
 * @private
 */
goog.string.compareElements_ = function(left, right) {
  if (left < right) {
    return -1;
  } else if (left > right) {
    return 1;
  }
  return 0;
};


/**
 * Maximum value of #goog.string.hashCode, exclusive. 2^32.
 * @type {number}
 * @private
 */
goog.string.HASHCODE_MAX_ = 0x100000000;


/**
 * String hash function similar to java.lang.String.hashCode().
 * The hash code for a string is computed as
 * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
 * where s[i] is the ith character of the string and n is the length of
 * the string. We mod the result to make it between 0 (inclusive) and 2^32
 * (exclusive).
 * @param {string} str A string.
 * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32
 *  (exclusive). The empty string returns 0.
 */
goog.string.hashCode = function(str) {
  var result = 0;
  for (var i = 0; i < str.length; ++i) {
    result = 31 * result + str.charCodeAt(i);
    // Normalize to 4 byte range, 0 ... 2^32.
    result %= goog.string.HASHCODE_MAX_;
  }
  return result;
};


/**
 * The most recent unique ID. |0 is equivalent to Math.floor in this case.
 * @type {number}
 * @private
 */
goog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;


/**
 * Generates and returns a string which is unique in the current document.
 * This is useful, for example, to create unique IDs for DOM elements.
 * @return {string} A unique id.
 */
goog.string.createUniqueString = function() {
  return 'goog_' + goog.string.uniqueStringCounter_++;
};


/**
 * Converts the supplied string to a number, which may be Infinity or NaN.
 * This function strips whitespace: (toNumber(' 123') === 123)
 * This function accepts scientific notation: (toNumber('1e1') === 10)
 *
 * This is better than Javascript's built-in conversions because, sadly:
 *     (Number(' ') === 0) and (parseFloat('123a') === 123)
 *
 * @param {string} str The string to convert.
 * @return {number} The number the supplied string represents, or NaN.
 */
goog.string.toNumber = function(str) {
  var num = Number(str);
  if (num == 0 && goog.string.isEmpty(str)) {
    return NaN;
  }
  return num;
};


/**
 * Returns whether the given string is lower camel case (e.g. "isFooBar").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is lower camel case.
 */
goog.string.isLowerCamelCase = function(str) {
  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);
};


/**
 * Returns whether the given string is upper camel case (e.g. "FooBarBaz").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is upper camel case.
 */
goog.string.isUpperCamelCase = function(str) {
  return /^([A-Z][a-z]*)+$/.test(str);
};


/**
 * Converts a string from selector-case to camelCase (e.g. from
 * "multi-part-string" to "multiPartString"), useful for converting
 * CSS selectors and HTML dataset keys to their equivalent JS properties.
 * @param {string} str The string in selector-case form.
 * @return {string} The string in camelCase form.
 */
goog.string.toCamelCase = function(str) {
  return String(str).replace(/\-([a-z])/g, function(all, match) {
    return match.toUpperCase();
  });
};


/**
 * Converts a string from camelCase to selector-case (e.g. from
 * "multiPartString" to "multi-part-string"), useful for converting JS
 * style and dataset properties to equivalent CSS selectors and HTML keys.
 * @param {string} str The string in camelCase form.
 * @return {string} The string in selector-case form.
 */
goog.string.toSelectorCase = function(str) {
  return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();
};


/**
 * Converts a string into TitleCase. First character of the string is always
 * capitalized in addition to the first letter of every subsequent word.
 * Words are delimited by one or more whitespaces by default. Custom delimiters
 * can optionally be specified to replace the default, which doesn't preserve
 * whitespace delimiters and instead must be explicitly included if needed.
 *
 * Default delimiter => " ":
 *    goog.string.toTitleCase('oneTwoThree')    => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three')  => 'One Two Three'
 *    goog.string.toTitleCase('  one   two   ') => '  One   Two   '
 *    goog.string.toTitleCase('one_two_three')  => 'One_two_three'
 *    goog.string.toTitleCase('one-two-three')  => 'One-two-three'
 *
 * Custom delimiter => "_-.":
 *    goog.string.toTitleCase('oneTwoThree', '_-.')       => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three', '_-.')     => 'One two three'
 *    goog.string.toTitleCase('  one   two   ', '_-.')    => '  one   two   '
 *    goog.string.toTitleCase('one_two_three', '_-.')     => 'One_Two_Three'
 *    goog.string.toTitleCase('one-two-three', '_-.')     => 'One-Two-Three'
 *    goog.string.toTitleCase('one...two...three', '_-.') => 'One...Two...Three'
 *    goog.string.toTitleCase('one. two. three', '_-.')   => 'One. two. three'
 *    goog.string.toTitleCase('one-two.three', '_-.')     => 'One-Two.Three'
 *
 * @param {string} str String value in camelCase form.
 * @param {string=} opt_delimiters Custom delimiter character set used to
 *      distinguish words in the string value. Each character represents a
 *      single delimiter. When provided, default whitespace delimiter is
 *      overridden and must be explicitly included if needed.
 * @return {string} String value in TitleCase form.
 */
goog.string.toTitleCase = function(str, opt_delimiters) {
  var delimiters = goog.isString(opt_delimiters) ?
      goog.string.regExpEscape(opt_delimiters) : '\\s';

  // For IE8, we need to prevent using an empty character set. Otherwise,
  // incorrect matching will occur.
  delimiters = delimiters ? '|[' + delimiters + ']+' : '';

  var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');
  return str.replace(regexp, function(all, p1, p2) {
    return p1 + p2.toUpperCase();
  });
};


/**
 * Parse a string in decimal or hexidecimal ('0xFFFF') form.
 *
 * To parse a particular radix, please use parseInt(string, radix) directly. See
 * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt
 *
 * This is a wrapper for the built-in parseInt function that will only parse
 * numbers as base 10 or base 16.  Some JS implementations assume strings
 * starting with "0" are intended to be octal. ES3 allowed but discouraged
 * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.
 *
 * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj
 *
 * @param {string|number|null|undefined} value The value to be parsed.
 * @return {number} The number, parsed. If the string failed to parse, this
 *     will be NaN.
 */
goog.string.parseInt = function(value) {
  // Force finite numbers to strings.
  if (isFinite(value)) {
    value = String(value);
  }

  if (goog.isString(value)) {
    // If the string starts with '0x' or '-0x', parse as hex.
    return /^\s*-?0x/i.test(value) ?
        parseInt(value, 16) : parseInt(value, 10);
  }

  return NaN;
};


/**
 * Splits a string on a separator a limited number of times.
 *
 * This implementation is more similar to Python or Java, where the limit
 * parameter specifies the maximum number of splits rather than truncating
 * the number of results.
 *
 * See http://docs.python.org/2/library/stdtypes.html#str.split
 * See JavaDoc: http://goo.gl/F2AsY
 * See Mozilla reference: http://goo.gl/dZdZs
 *
 * @param {string} str String to split.
 * @param {string} separator The separator.
 * @param {number} limit The limit to the number of splits. The resulting array
 *     will have a maximum length of limit+1.  Negative numbers are the same
 *     as zero.
 * @return {!Array.<string>} The string, split.
 */

goog.string.splitLimit = function(str, separator, limit) {
  var parts = str.split(separator);
  var returnVal = [];

  // Only continue doing this while we haven't hit the limit and we have
  // parts left.
  while (limit > 0 && parts.length) {
    returnVal.push(parts.shift());
    limit--;
  }

  // If there are remaining parts, append them to the end.
  if (parts.length) {
    returnVal.push(parts.join(separator));
  }

  return returnVal;
};


//javascript/closure/asserts/asserts.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities to check the preconditions, postconditions and
 * invariants runtime.
 *
 * Methods in this package should be given special treatment by the compiler
 * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
 * will restrict <code>foo</code> to a truthy value.
 *
 * The compiler has an option to disable asserts. So code like:
 * <code>
 * var x = goog.asserts.assert(foo()); goog.asserts.assert(bar());
 * </code>
 * will be transformed into:
 * <code>
 * var x = foo();
 * </code>
 * The compiler will leave in foo() (because its return value is used),
 * but it will remove bar() because it assumes it does not have side-effects.
 *
 * @author pallosp@google.com (Peter Pallos)
 * @author agrieve@google.com (Andrew Grieve)
 */

goog.provide('goog.asserts');
goog.provide('goog.asserts.AssertionError');

goog.require('goog.debug.Error');
goog.require('goog.dom.NodeType');
goog.require('goog.string');


/**
 * @define {boolean} Whether to strip out asserts or to leave them in.
 */
goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);



/**
 * Error object for failed assertions.
 * @param {string} messagePattern The pattern that was used to form message.
 * @param {!Array.<*>} messageArgs The items to substitute into the pattern.
 * @constructor
 * @extends {goog.debug.Error}
 * @final
 */
goog.asserts.AssertionError = function(messagePattern, messageArgs) {
  messageArgs.unshift(messagePattern);
  goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
  // Remove the messagePattern afterwards to avoid permenantly modifying the
  // passed in array.
  messageArgs.shift();

  /**
   * The message pattern used to format the error message. Error handlers can
   * use this to uniquely identify the assertion.
   * @type {string}
   */
  this.messagePattern = messagePattern;
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);


/** @override */
goog.asserts.AssertionError.prototype.name = 'AssertionError';


/**
 * Throws an exception with the given message and "Assertion failed" prefixed
 * onto it.
 * @param {string} defaultMessage The message to use if givenMessage is empty.
 * @param {Array.<*>} defaultArgs The substitution arguments for defaultMessage.
 * @param {string|undefined} givenMessage Message supplied by the caller.
 * @param {Array.<*>} givenArgs The substitution arguments for givenMessage.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 * @private
 */
goog.asserts.doAssertFailure_ =
    function(defaultMessage, defaultArgs, givenMessage, givenArgs) {
  var message = 'Assertion failed';
  if (givenMessage) {
    message += ': ' + givenMessage;
    var args = givenArgs;
  } else if (defaultMessage) {
    message += ': ' + defaultMessage;
    args = defaultArgs;
  }
  // The '' + works around an Opera 10 bug in the unit tests. Without it,
  // a stack trace is added to var message above. With this, a stack trace is
  // not added until this line (it causes the extra garbage to be added after
  // the assertion message instead of in the middle of it).
  throw new goog.asserts.AssertionError('' + message, args || []);
};


/**
 * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
 * true.
 * @param {*} condition The condition to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {*} The value of the condition.
 * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
 */
goog.asserts.assert = function(condition, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !condition) {
    goog.asserts.doAssertFailure_('', null, opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return condition;
};


/**
 * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
 * when we want to add a check in the unreachable area like switch-case
 * statement:
 *
 * <pre>
 *  switch(type) {
 *    case FOO: doSomething(); break;
 *    case BAR: doSomethingElse(); break;
 *    default: goog.assert.fail('Unrecognized type: ' + type);
 *      // We have only 2 types - "default:" section is unreachable code.
 *  }
 * </pre>
 *
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} Failure.
 */
goog.asserts.fail = function(opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS) {
    throw new goog.asserts.AssertionError(
        'Failure' + (opt_message ? ': ' + opt_message : ''),
        Array.prototype.slice.call(arguments, 1));
  }
};


/**
 * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {number} The value, guaranteed to be a number when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 */
goog.asserts.assertNumber = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
    goog.asserts.doAssertFailure_('Expected number but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {number} */ (value);
};


/**
 * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {string} The value, guaranteed to be a string when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a string.
 */
goog.asserts.assertString = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
    goog.asserts.doAssertFailure_('Expected string but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {string} */ (value);
};


/**
 * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Function} The value, guaranteed to be a function when asserts
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a function.
 */
goog.asserts.assertFunction = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
    goog.asserts.doAssertFailure_('Expected function but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Function} */ (value);
};


/**
 * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Object} The value, guaranteed to be a non-null object.
 * @throws {goog.asserts.AssertionError} When the value is not an object.
 */
goog.asserts.assertObject = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
    goog.asserts.doAssertFailure_('Expected object but got %s: %s.',
        [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Object} */ (value);
};


/**
 * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Array} The value, guaranteed to be a non-null array.
 * @throws {goog.asserts.AssertionError} When the value is not an array.
 */
goog.asserts.assertArray = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
    goog.asserts.doAssertFailure_('Expected array but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Array} */ (value);
};


/**
 * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {boolean} The value, guaranteed to be a boolean when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
 */
goog.asserts.assertBoolean = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
    goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {boolean} */ (value);
};


/**
 * Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Element} The value, likely to be a DOM Element when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
 */
goog.asserts.assertElement = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && (!goog.isObject(value) ||
      value.nodeType != goog.dom.NodeType.ELEMENT)) {
    goog.asserts.doAssertFailure_('Expected Element but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Element} */ (value);
};


/**
 * Checks if the value is an instance of the user-defined type if
 * goog.asserts.ENABLE_ASSERTS is true.
 *
 * The compiler may tighten the type returned by this function.
 *
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} When the value is not an instance of
 *     type.
 * @return {!T}
 * @template T
 */
goog.asserts.assertInstanceof = function(value, type, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
    goog.asserts.doAssertFailure_('instanceof check failed.', null,
        opt_message, Array.prototype.slice.call(arguments, 3));
  }
  return value;
};


/**
 * Checks that no enumerable keys are present in Object.prototype. Such keys
 * would break most code that use {@code for (var ... in ...)} loops.
 */
goog.asserts.assertObjectPrototypeIsIntact = function() {
  for (var key in Object.prototype) {
    goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');
  }
};

//javascript/closure/array/array.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating arrays.
 *
 * @author pupius@google.com (Daniel Pupius)
 * @author arv@google.com (Erik Arvidsson)
 * @author pallosp@google.com (Peter Pallos)
 */


goog.provide('goog.array');
goog.provide('goog.array.ArrayLike');

goog.require('goog.asserts');


/**
 * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should
 * rely on Array.prototype functions, if available.
 *
 * The Array.prototype functions can be defined by external libraries like
 * Prototype and setting this flag to false forces closure to use its own
 * goog.array implementation.
 *
 * If your javascript can be loaded by a third party site and you are wary about
 * relying on the prototype functions, specify
 * "--define goog.NATIVE_ARRAY_PROTOTYPES=false" to the JSCompiler.
 *
 * Setting goog.TRUSTED_SITE to false will automatically set
 * NATIVE_ARRAY_PROTOTYPES to false.
 */
goog.define('goog.NATIVE_ARRAY_PROTOTYPES', goog.TRUSTED_SITE);


/**
 * @typedef {Array|NodeList|Arguments|{length: number}}
 */
goog.array.ArrayLike;


/**
 * Returns the last element in an array without removing it.
 * @param {Array.<T>|goog.array.ArrayLike} array The array.
 * @return {T} Last item in array.
 * @template T
 */
goog.array.peek = function(array) {
  return array[array.length - 1];
};


/**
 * Reference to the original {@code Array.prototype}.
 * @private
 */
goog.array.ARRAY_PROTOTYPE_ = Array.prototype;


// NOTE(arv): Since most of the array functions are generic it allows you to
// pass an array-like object. Strings have a length and are considered array-
// like. However, the 'in' operator does not work on strings so we cannot just
// use the array path even if the browser supports indexing into strings. We
// therefore end up splitting the string.


/**
 * Returns the index of the first element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at index 0.
 * @return {number} The index of the first matching array element.
 * @template T
 */
goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
                     goog.array.ARRAY_PROTOTYPE_.indexOf ?
    function(arr, obj, opt_fromIndex) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.indexOf.call(arr, obj, opt_fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      var fromIndex = opt_fromIndex == null ?
          0 : (opt_fromIndex < 0 ?
               Math.max(0, arr.length + opt_fromIndex) : opt_fromIndex);

      if (goog.isString(arr)) {
        // Array.prototype.indexOf uses === so only strings should be found.
        if (!goog.isString(obj) || obj.length != 1) {
          return -1;
        }
        return arr.indexOf(obj, fromIndex);
      }

      for (var i = fromIndex; i < arr.length; i++) {
        if (i in arr && arr[i] === obj)
          return i;
      }
      return -1;
    };


/**
 * Returns the index of the last element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}
 *
 * @param {!Array.<T>|!goog.array.ArrayLike} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {?number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at the end of the array.
 * @return {number} The index of the last matching array element.
 * @template T
 */
goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
                         goog.array.ARRAY_PROTOTYPE_.lastIndexOf ?
    function(arr, obj, opt_fromIndex) {
      goog.asserts.assert(arr.length != null);

      // Firefox treats undefined and null as 0 in the fromIndex argument which
      // leads it to always return -1
      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
      return goog.array.ARRAY_PROTOTYPE_.lastIndexOf.call(arr, obj, fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;

      if (fromIndex < 0) {
        fromIndex = Math.max(0, arr.length + fromIndex);
      }

      if (goog.isString(arr)) {
        // Array.prototype.lastIndexOf uses === so only strings should be found.
        if (!goog.isString(obj) || obj.length != 1) {
          return -1;
        }
        return arr.lastIndexOf(obj, fromIndex);
      }

      for (var i = fromIndex; i >= 0; i--) {
        if (i in arr && arr[i] === obj)
          return i;
      }
      return -1;
    };


/**
 * Calls a function for each element in an array. Skips holes in the array.
 * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array like object over
 *     which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function takes 3 arguments (the element, the index and the
 *     array). The return value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @template T,S
 */
goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES &&
                     goog.array.ARRAY_PROTOTYPE_.forEach ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      goog.array.ARRAY_PROTOTYPE_.forEach.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          f.call(opt_obj, arr2[i], i, arr);
        }
      }
    };


/**
 * Calls a function for each element in an array, starting from the last
 * element rather than the first.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function
 *     takes 3 arguments (the element, the index and the array). The return
 *     value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @template T,S
 */
goog.array.forEachRight = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = l - 1; i >= 0; --i) {
    if (i in arr2) {
      f.call(opt_obj, arr2[i], i, arr);
    }
  }
};


/**
 * Calls a function for each element in an array, and if the function returns
 * true adds the element to a new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?):boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a Boolean. If the return value is true the element is added to the
 *     result array. If it is false the element is not included.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array.<T>} a new array in which only elements that passed the test
 *     are present.
 * @template T,S
 */
goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES &&
                    goog.array.ARRAY_PROTOTYPE_.filter ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.filter.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = [];
      var resLength = 0;
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          var val = arr2[i];  // in case f mutates arr2
          if (f.call(opt_obj, val, i, arr)) {
            res[resLength++] = val;
          }
        }
      }
      return res;
    };


/**
 * Calls a function for each element in an array and inserts the result into a
 * new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-map}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?):?} f The function to call for every
 *     element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return something. The result will be inserted into a new array.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array} a new array with the results from f.
 * @template T,S
 */
goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES &&
                 goog.array.ARRAY_PROTOTYPE_.map ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.map.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = new Array(l);
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          res[i] = f.call(opt_obj, arr2[i], i, arr);
        }
      }
      return res;
    };


/**
 * Passes every element of an array into a function and accumulates the result.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}
 *
 * For example:
 * var a = [1, 2, 3, 4];
 * goog.array.reduce(a, function(r, v, i, arr) {return r + v;}, 0);
 * returns 10
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {R} Result of evaluating f repeatedly across the values of the array.
 * @template T,S,R
 */
goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES &&
                    goog.array.ARRAY_PROTOTYPE_.reduce ?
    function(arr, f, val, opt_obj) {
      goog.asserts.assert(arr.length != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return goog.array.ARRAY_PROTOTYPE_.reduce.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      var rval = val;
      goog.array.forEach(arr, function(val, index) {
        rval = f.call(opt_obj, rval, val, index, arr);
      });
      return rval;
    };


/**
 * Passes every element of an array into a function and accumulates the result,
 * starting from the last element and working towards the first.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}
 *
 * For example:
 * var a = ['a', 'b', 'c'];
 * goog.array.reduceRight(a, function(r, v, i, arr) {return r + v;}, '');
 * returns 'cba'
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {R} Object returned as a result of evaluating f repeatedly across the
 *     values of the array.
 * @template T,S,R
 */
goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES &&
                         goog.array.ARRAY_PROTOTYPE_.reduceRight ?
    function(arr, f, val, opt_obj) {
      goog.asserts.assert(arr.length != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return goog.array.ARRAY_PROTOTYPE_.reduceRight.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      var rval = val;
      goog.array.forEachRight(arr, function(val, index) {
        rval = f.call(opt_obj, rval, val, index, arr);
      });
      return rval;
    };


/**
 * Calls f for each element of an array. If any call returns true, some()
 * returns true (without checking the remaining elements). If all calls
 * return false, some() returns false.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-some}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} true if any element passes the test.
 * @template T,S
 */
goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES &&
                  goog.array.ARRAY_PROTOTYPE_.some ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.some.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
          return true;
        }
      }
      return false;
    };


/**
 * Call f for each element of an array. If all calls return true, every()
 * returns true. If any call returns false, every() returns false and
 * does not continue to check the remaining elements.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-every}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} false if any element fails the test.
 * @template T,S
 */
goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES &&
                   goog.array.ARRAY_PROTOTYPE_.every ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.every.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && !f.call(opt_obj, arr2[i], i, arr)) {
          return false;
        }
      }
      return true;
    };


/**
 * Counts the array elements that fulfill the predicate, i.e. for which the
 * callback function returns true. Skips holes in the array.
 *
 * @param {!(Array.<T>|goog.array.ArrayLike)} arr Array or array like object
 *     over which to iterate.
 * @param {function(this: S, T, number, ?): boolean} f The function to call for
 *     every element. Takes 3 arguments (the element, the index and the array).
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @return {number} The number of the matching elements.
 * @template T,S
 */
goog.array.count = function(arr, f, opt_obj) {
  var count = 0;
  goog.array.forEach(arr, function(element, index, arr) {
    if (f.call(opt_obj, element, index, arr)) {
      ++count;
    }
  }, opt_obj);
  return count;
};


/**
 * Search an array for the first element that satisfies a given condition and
 * return that element.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T} The first array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.find = function(arr, f, opt_obj) {
  var i = goog.array.findIndex(arr, f, opt_obj);
  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array for the first element that satisfies a given condition and
 * return its index.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the first array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndex = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = 0; i < l; i++) {
    if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return that element.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T} The last array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.findRight = function(arr, f, opt_obj) {
  var i = goog.array.findIndexRight(arr, f, opt_obj);
  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return its index.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {Object=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the last array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndexRight = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = l - 1; i >= 0; i--) {
    if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
};


/**
 * Whether the array contains the given object.
 * @param {goog.array.ArrayLike} arr The array to test for the presence of the
 *     element.
 * @param {*} obj The object for which to test.
 * @return {boolean} true if obj is present.
 */
goog.array.contains = function(arr, obj) {
  return goog.array.indexOf(arr, obj) >= 0;
};


/**
 * Whether the array is empty.
 * @param {goog.array.ArrayLike} arr The array to test.
 * @return {boolean} true if empty.
 */
goog.array.isEmpty = function(arr) {
  return arr.length == 0;
};


/**
 * Clears the array.
 * @param {goog.array.ArrayLike} arr Array or array like object to clear.
 */
goog.array.clear = function(arr) {
  // For non real arrays we don't have the magic length so we delete the
  // indices.
  if (!goog.isArray(arr)) {
    for (var i = arr.length - 1; i >= 0; i--) {
      delete arr[i];
    }
  }
  arr.length = 0;
};


/**
 * Pushes an item into an array, if it's not already in the array.
 * @param {Array.<T>} arr Array into which to insert the item.
 * @param {T} obj Value to add.
 * @template T
 */
goog.array.insert = function(arr, obj) {
  if (!goog.array.contains(arr, obj)) {
    arr.push(obj);
  }
};


/**
 * Inserts an object at the given index of the array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {*} obj The object to insert.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertAt = function(arr, obj, opt_i) {
  goog.array.splice(arr, opt_i, 0, obj);
};


/**
 * Inserts at the given index of the array, all elements of another array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {goog.array.ArrayLike} elementsToAdd The array of elements to add.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertArrayAt = function(arr, elementsToAdd, opt_i) {
  goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd);
};


/**
 * Inserts an object into an array before a specified object.
 * @param {Array.<T>} arr The array to modify.
 * @param {T} obj The object to insert.
 * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2
 *     is omitted or not found, obj is inserted at the end of the array.
 * @template T
 */
goog.array.insertBefore = function(arr, obj, opt_obj2) {
  var i;
  if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) < 0) {
    arr.push(obj);
  } else {
    goog.array.insertAt(arr, obj, i);
  }
};


/**
 * Removes the first occurrence of a particular value from an array.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array from which to remove
 *     value.
 * @param {T} obj Object to remove.
 * @return {boolean} True if an element was removed.
 * @template T
 */
goog.array.remove = function(arr, obj) {
  var i = goog.array.indexOf(arr, obj);
  var rv;
  if ((rv = i >= 0)) {
    goog.array.removeAt(arr, i);
  }
  return rv;
};


/**
 * Removes from an array the element at index i
 * @param {goog.array.ArrayLike} arr Array or array like object from which to
 *     remove value.
 * @param {number} i The index to remove.
 * @return {boolean} True if an element was removed.
 */
goog.array.removeAt = function(arr, i) {
  goog.asserts.assert(arr.length != null);

  // use generic form of splice
  // splice returns the removed items and if successful the length of that
  // will be 1
  return goog.array.ARRAY_PROTOTYPE_.splice.call(arr, i, 1).length == 1;
};


/**
 * Removes the first value that satisfies the given condition.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {boolean} True if an element was removed.
 * @template T,S
 */
goog.array.removeIf = function(arr, f, opt_obj) {
  var i = goog.array.findIndex(arr, f, opt_obj);
  if (i >= 0) {
    goog.array.removeAt(arr, i);
    return true;
  }
  return false;
};


/**
 * Returns a new array that is the result of joining the arguments.  If arrays
 * are passed then their items are added, however, if non-arrays are passed they
 * will be added to the return array as is.
 *
 * Note that ArrayLike objects will be added as is, rather than having their
 * items added.
 *
 * goog.array.concat([1, 2], [3, 4]) -> [1, 2, 3, 4]
 * goog.array.concat(0, [1, 2]) -> [0, 1, 2]
 * goog.array.concat([1, 2], null) -> [1, 2, null]
 *
 * There is bug in all current versions of IE (6, 7 and 8) where arrays created
 * in an iframe become corrupted soon (not immediately) after the iframe is
 * destroyed. This is common if loading data via goog.net.IframeIo, for example.
 * This corruption only affects the concat method which will start throwing
 * Catastrophic Errors (#-2147418113).
 *
 * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.
 *
 * Internally goog.array should use this, so that all methods will continue to
 * work on these broken array objects.
 *
 * @param {...*} var_args Items to concatenate.  Arrays will have each item
 *     added, while primitives and objects will be added as is.
 * @return {!Array} The new resultant array.
 */
goog.array.concat = function(var_args) {
  return goog.array.ARRAY_PROTOTYPE_.concat.apply(
      goog.array.ARRAY_PROTOTYPE_, arguments);
};


/**
 * Converts an object to an array.
 * @param {goog.array.ArrayLike} object  The object to convert to an array.
 * @return {!Array} The object converted into an array. If object has a
 *     length property, every property indexed with a non-negative number
 *     less than length will be included in the result. If object does not
 *     have a length property, an empty array will be returned.
 */
goog.array.toArray = function(object) {
  var length = object.length;

  // If length is not a number the following it false. This case is kept for
  // backwards compatibility since there are callers that pass objects that are
  // not array like.
  if (length > 0) {
    var rv = new Array(length);
    for (var i = 0; i < length; i++) {
      rv[i] = object[i];
    }
    return rv;
  }
  return [];
};


/**
 * Does a shallow copy of an array.
 * @param {goog.array.ArrayLike} arr  Array or array-like object to clone.
 * @return {!Array} Clone of the input array.
 */
goog.array.clone = goog.array.toArray;


/**
 * Extends an array with another array, element, or "array like" object.
 * This function operates 'in-place', it does not create a new Array.
 *
 * Example:
 * var a = [];
 * goog.array.extend(a, [0, 1]);
 * a; // [0, 1]
 * goog.array.extend(a, 2);
 * a; // [0, 1, 2]
 *
 * @param {Array} arr1  The array to modify.
 * @param {...*} var_args The elements or arrays of elements to add to arr1.
 */
goog.array.extend = function(arr1, var_args) {
  for (var i = 1; i < arguments.length; i++) {
    var arr2 = arguments[i];
    // If we have an Array or an Arguments object we can just call push
    // directly.
    var isArrayLike;
    if (goog.isArray(arr2) ||
        // Detect Arguments. ES5 says that the [[Class]] of an Arguments object
        // is "Arguments" but only V8 and JSC/Safari gets this right. We instead
        // detect Arguments by checking for array like and presence of "callee".
        (isArrayLike = goog.isArrayLike(arr2)) &&
            // The getter for callee throws an exception in strict mode
            // according to section 10.6 in ES5 so check for presence instead.
            Object.prototype.hasOwnProperty.call(arr2, 'callee')) {
      arr1.push.apply(arr1, arr2);
    } else if (isArrayLike) {
      // Otherwise loop over arr2 to prevent copying the object.
      var len1 = arr1.length;
      var len2 = arr2.length;
      for (var j = 0; j < len2; j++) {
        arr1[len1 + j] = arr2[j];
      }
    } else {
      arr1.push(arr2);
    }
  }
};


/**
 * Adds or removes elements from an array. This is a generic version of Array
 * splice. This means that it might work on other objects similar to arrays,
 * such as the arguments object.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array to modify.
 * @param {number|undefined} index The index at which to start changing the
 *     array. If not defined, treated as 0.
 * @param {number} howMany How many elements to remove (0 means no removal. A
 *     value below 0 is treated as zero and so is any other non number. Numbers
 *     are floored).
 * @param {...T} var_args Optional, additional elements to insert into the
 *     array.
 * @return {!Array.<T>} the removed elements.
 * @template T
 */
goog.array.splice = function(arr, index, howMany, var_args) {
  goog.asserts.assert(arr.length != null);

  return goog.array.ARRAY_PROTOTYPE_.splice.apply(
      arr, goog.array.slice(arguments, 1));
};


/**
 * Returns a new array from a segment of an array. This is a generic version of
 * Array slice. This means that it might work on other objects similar to
 * arrays, such as the arguments object.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array from
 * which to copy a segment.
 * @param {number} start The index of the first element to copy.
 * @param {number=} opt_end The index after the last element to copy.
 * @return {!Array.<T>} A new array containing the specified segment of the
 *     original array.
 * @template T
 */
goog.array.slice = function(arr, start, opt_end) {
  goog.asserts.assert(arr.length != null);

  // passing 1 arg to slice is not the same as passing 2 where the second is
  // null or undefined (in that case the second argument is treated as 0).
  // we could use slice on the arguments object and then use apply instead of
  // testing the length
  if (arguments.length <= 2) {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start);
  } else {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start, opt_end);
  }
};


/**
 * Removes all duplicates from an array (retaining only the first
 * occurrence of each array element).  This function modifies the
 * array in place and doesn't change the order of the non-duplicate items.
 *
 * For objects, duplicates are identified as having the same unique ID as
 * defined by {@link goog.getUid}.
 *
 * Alternatively you can specify a custom hash function that returns a unique
 * value for each item in the array it should consider unique.
 *
 * Runtime: N,
 * Worstcase space: 2N (no dupes)
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array from which to remove
 *     duplicates.
 * @param {Array=} opt_rv An optional array in which to return the results,
 *     instead of performing the removal inplace.  If specified, the original
 *     array will remain unchanged.
 * @param {function(T):string=} opt_hashFn An optional function to use to
 *     apply to every item in the array. This function should return a unique
 *     value for each item in the array it should consider unique.
 * @template T
 */
goog.array.removeDuplicates = function(arr, opt_rv, opt_hashFn) {
  var returnArray = opt_rv || arr;
  var defaultHashFn = function(item) {
    // Prefix each type with a single character representing the type to
    // prevent conflicting keys (e.g. true and 'true').
    return goog.isObject(current) ? 'o' + goog.getUid(current) :
        (typeof current).charAt(0) + current;
  };
  var hashFn = opt_hashFn || defaultHashFn;

  var seen = {}, cursorInsert = 0, cursorRead = 0;
  while (cursorRead < arr.length) {
    var current = arr[cursorRead++];
    var key = hashFn(current);
    if (!Object.prototype.hasOwnProperty.call(seen, key)) {
      seen[key] = true;
      returnArray[cursorInsert++] = current;
    }
  }
  returnArray.length = cursorInsert;
};


/**
 * Searches the specified array for the specified target using the binary
 * search algorithm.  If no opt_compareFn is specified, elements are compared
 * using <code>goog.array.defaultCompare</code>, which compares the elements
 * using the built in < and > operators.  This will produce the expected
 * behavior for homogeneous arrays of String(s) and Number(s). The array
 * specified <b>must</b> be sorted in ascending order (as defined by the
 * comparison function).  If the array is not sorted, results are undefined.
 * If the array contains multiple instances of the specified target value, any
 * of these instances may be found.
 *
 * Runtime: O(log n)
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {*} target The sought value.
 * @param {Function=} opt_compareFn Optional comparison function by which the
 *     array is ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 */
goog.array.binarySearch = function(arr, target, opt_compareFn) {
  return goog.array.binarySearch_(arr,
      opt_compareFn || goog.array.defaultCompare, false /* isEvaluator */,
      target);
};


/**
 * Selects an index in the specified array using the binary search algorithm.
 * The evaluator receives an element and determines whether the desired index
 * is before, at, or after it.  The evaluator must be consistent (formally,
 * goog.array.map(goog.array.map(arr, evaluator, opt_obj), goog.math.sign)
 * must be monotonically non-increasing).
 *
 * Runtime: O(log n)
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {Function} evaluator Evaluator function that receives 3 arguments
 *     (the element, the index and the array). Should return a negative number,
 *     zero, or a positive number depending on whether the desired index is
 *     before, at, or after the element passed to it.
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within evaluator.
 * @return {number} Index of the leftmost element matched by the evaluator, if
 *     such exists; otherwise (-(insertion point) - 1). The insertion point is
 *     the index of the first element for which the evaluator returns negative,
 *     or arr.length if no such element exists. The return value is non-negative
 *     iff a match is found.
 */
goog.array.binarySelect = function(arr, evaluator, opt_obj) {
  return goog.array.binarySearch_(arr, evaluator, true /* isEvaluator */,
      undefined /* opt_target */, opt_obj);
};


/**
 * Implementation of a binary search algorithm which knows how to use both
 * comparison functions and evaluators. If an evaluator is provided, will call
 * the evaluator with the given optional data object, conforming to the
 * interface defined in binarySelect. Otherwise, if a comparison function is
 * provided, will call the comparison function against the given data object.
 *
 * This implementation purposefully does not use goog.bind or goog.partial for
 * performance reasons.
 *
 * Runtime: O(log n)
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {Function} compareFn Either an evaluator or a comparison function,
 *     as defined by binarySearch and binarySelect above.
 * @param {boolean} isEvaluator Whether the function is an evaluator or a
 *     comparison function.
 * @param {*=} opt_target If the function is a comparison function, then this is
 *     the target to binary search for.
 * @param {Object=} opt_selfObj If the function is an evaluator, this is an
  *    optional this object for the evaluator.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @private
 */
goog.array.binarySearch_ = function(arr, compareFn, isEvaluator, opt_target,
    opt_selfObj) {
  var left = 0;  // inclusive
  var right = arr.length;  // exclusive
  var found;
  while (left < right) {
    var middle = (left + right) >> 1;
    var compareResult;
    if (isEvaluator) {
      compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);
    } else {
      compareResult = compareFn(opt_target, arr[middle]);
    }
    if (compareResult > 0) {
      left = middle + 1;
    } else {
      right = middle;
      // We are looking for the lowest index so we can't return immediately.
      found = !compareResult;
    }
  }
  // left is the index if found, or the insertion point otherwise.
  // ~left is a shorthand for -left - 1.
  return found ? left : ~left;
};


/**
 * Sorts the specified array into ascending order.  If no opt_compareFn is
 * specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s), unlike the native sort,
 * but will give unpredictable results for heterogenous lists of strings and
 * numbers with different numbers of digits.
 *
 * This sort is not guaranteed to be stable.
 *
 * Runtime: Same as <code>Array.prototype.sort</code>
 *
 * @param {Array.<T>} arr The array to be sorted.
 * @param {?function(T,T):number=} opt_compareFn Optional comparison
 *     function by which the
 *     array is to be ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @template T
 */
goog.array.sort = function(arr, opt_compareFn) {
  // TODO(arv): Update type annotation since null is not accepted.
  goog.asserts.assert(arr.length != null);

  goog.array.ARRAY_PROTOTYPE_.sort.call(
      arr, opt_compareFn || goog.array.defaultCompare);
};


/**
 * Sorts the specified array into ascending order in a stable way.  If no
 * opt_compareFn is specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s).
 *
 * Runtime: Same as <code>Array.prototype.sort</code>, plus an additional
 * O(n) overhead of copying the array twice.
 *
 * @param {Array.<T>} arr The array to be sorted.
 * @param {?function(T, T): number=} opt_compareFn Optional comparison function
 *     by which the array is to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template T
 */
goog.array.stableSort = function(arr, opt_compareFn) {
  for (var i = 0; i < arr.length; i++) {
    arr[i] = {index: i, value: arr[i]};
  }
  var valueCompareFn = opt_compareFn || goog.array.defaultCompare;
  function stableCompareFn(obj1, obj2) {
    return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;
  };
  goog.array.sort(arr, stableCompareFn);
  for (var i = 0; i < arr.length; i++) {
    arr[i] = arr[i].value;
  }
};


/**
 * Sorts an array of objects by the specified object key and compare
 * function. If no compare function is provided, the key values are
 * compared in ascending order using <code>goog.array.defaultCompare</code>.
 * This won't work for keys that get renamed by the compiler. So use
 * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.
 * @param {Array.<Object>} arr An array of objects to sort.
 * @param {string} key The object key to sort by.
 * @param {Function=} opt_compareFn The function to use to compare key
 *     values.
 */
goog.array.sortObjectsByKey = function(arr, key, opt_compareFn) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  goog.array.sort(arr, function(a, b) {
    return compare(a[key], b[key]);
  });
};


/**
 * Tells if the array is sorted.
 * @param {!Array.<T>} arr The array.
 * @param {?function(T,T):number=} opt_compareFn Function to compare the
 *     array elements.
 *     Should take 2 arguments to compare, and return a negative number, zero,
 *     or a positive number depending on whether the first argument is less
 *     than, equal to, or greater than the second.
 * @param {boolean=} opt_strict If true no equal elements are allowed.
 * @return {boolean} Whether the array is sorted.
 * @template T
 */
goog.array.isSorted = function(arr, opt_compareFn, opt_strict) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  for (var i = 1; i < arr.length; i++) {
    var compareResult = compare(arr[i - 1], arr[i]);
    if (compareResult > 0 || compareResult == 0 && opt_strict) {
      return false;
    }
  }
  return true;
};


/**
 * Compares two arrays for equality. Two arrays are considered equal if they
 * have the same length and their corresponding elements are equal according to
 * the comparison function.
 *
 * @param {goog.array.ArrayLike} arr1 The first array to compare.
 * @param {goog.array.ArrayLike} arr2 The second array to compare.
 * @param {Function=} opt_equalsFn Optional comparison function.
 *     Should take 2 arguments to compare, and return true if the arguments
 *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
 *     compares the elements using the built-in '===' operator.
 * @return {boolean} Whether the two arrays are equal.
 */
goog.array.equals = function(arr1, arr2, opt_equalsFn) {
  if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||
      arr1.length != arr2.length) {
    return false;
  }
  var l = arr1.length;
  var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
  for (var i = 0; i < l; i++) {
    if (!equalsFn(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
};


/**
 * @deprecated Use {@link goog.array.equals}.
 * @param {goog.array.ArrayLike} arr1 See {@link goog.array.equals}.
 * @param {goog.array.ArrayLike} arr2 See {@link goog.array.equals}.
 * @param {Function=} opt_equalsFn See {@link goog.array.equals}.
 * @return {boolean} See {@link goog.array.equals}.
 */
goog.array.compare = function(arr1, arr2, opt_equalsFn) {
  return goog.array.equals(arr1, arr2, opt_equalsFn);
};


/**
 * 3-way array compare function.
 * @param {!goog.array.ArrayLike} arr1 The first array to compare.
 * @param {!goog.array.ArrayLike} arr2 The second array to compare.
 * @param {?function(?, ?): number=} opt_compareFn Optional comparison function
 *     by which the array is to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @return {number} Negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 */
goog.array.compare3 = function(arr1, arr2, opt_compareFn) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  var l = Math.min(arr1.length, arr2.length);
  for (var i = 0; i < l; i++) {
    var result = compare(arr1[i], arr2[i]);
    if (result != 0) {
      return result;
    }
  }
  return goog.array.defaultCompare(arr1.length, arr2.length);
};


/**
 * Compares its two arguments for order, using the built in < and >
 * operators.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
goog.array.defaultCompare = function(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};


/**
 * Compares its two arguments for equality, using the built in === operator.
 * @param {*} a The first object to compare.
 * @param {*} b The second object to compare.
 * @return {boolean} True if the two arguments are equal, false otherwise.
 */
goog.array.defaultCompareEquality = function(a, b) {
  return a === b;
};


/**
 * Inserts a value into a sorted array. The array is not modified if the
 * value is already present.
 * @param {Array.<T>} array The array to modify.
 * @param {T} value The object to insert.
 * @param {?function(T,T):number=} opt_compareFn Optional comparison function by
 *     which the
 *     array is ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @return {boolean} True if an element was inserted.
 * @template T
 */
goog.array.binaryInsert = function(array, value, opt_compareFn) {
  var index = goog.array.binarySearch(array, value, opt_compareFn);
  if (index < 0) {
    goog.array.insertAt(array, value, -(index + 1));
    return true;
  }
  return false;
};


/**
 * Removes a value from a sorted array.
 * @param {Array} array The array to modify.
 * @param {*} value The object to remove.
 * @param {Function=} opt_compareFn Optional comparison function by which the
 *     array is ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @return {boolean} True if an element was removed.
 */
goog.array.binaryRemove = function(array, value, opt_compareFn) {
  var index = goog.array.binarySearch(array, value, opt_compareFn);
  return (index >= 0) ? goog.array.removeAt(array, index) : false;
};


/**
 * Splits an array into disjoint buckets according to a splitting function.
 * @param {Array.<T>} array The array.
 * @param {function(this:S, T,number,Array.<T>):?} sorter Function to call for
 *     every element.  This takes 3 arguments (the element, the index and the
 *     array) and must return a valid object key (a string, number, etc), or
 *     undefined, if that object should not be placed in a bucket.
 * @param {S=} opt_obj The object to be used as the value of 'this' within
 *     sorter.
 * @return {!Object} An object, with keys being all of the unique return values
 *     of sorter, and values being arrays containing the items for
 *     which the splitter returned that key.
 * @template T,S
 */
goog.array.bucket = function(array, sorter, opt_obj) {
  var buckets = {};

  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    var key = sorter.call(opt_obj, value, i, array);
    if (goog.isDef(key)) {
      // Push the value to the right bucket, creating it if necessary.
      var bucket = buckets[key] || (buckets[key] = []);
      bucket.push(value);
    }
  }

  return buckets;
};


/**
 * Creates a new object built from the provided array and the key-generation
 * function.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array like object over
 *     which to iterate whose elements will be the values in the new object.
 * @param {?function(this:S, T, number, ?) : string} keyFunc The function to
 *     call for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a string that will be used as the
 *     key for the element in the new object. If the function returns the same
 *     key for more than one element, the value for that key is
 *     implementation-defined.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within keyFunc.
 * @return {!Object.<T>} The new object.
 * @template T,S
 */
goog.array.toObject = function(arr, keyFunc, opt_obj) {
  var ret = {};
  goog.array.forEach(arr, function(element, index) {
    ret[keyFunc.call(opt_obj, element, index, arr)] = element;
  });
  return ret;
};


/**
 * Creates a range of numbers in an arithmetic progression.
 *
 * Range takes 1, 2, or 3 arguments:
 * <pre>
 * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]
 * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]
 * range(-2, -5, -1) produces [-2, -3, -4]
 * range(-2, -5, 1) produces [], since stepping by 1 wouldn't ever reach -5.
 * </pre>
 *
 * @param {number} startOrEnd The starting value of the range if an end argument
 *     is provided. Otherwise, the start value is 0, and this is the end value.
 * @param {number=} opt_end The optional end value of the range.
 * @param {number=} opt_step The step size between range values. Defaults to 1
 *     if opt_step is undefined or 0.
 * @return {!Array.<number>} An array of numbers for the requested range. May be
 *     an empty array if adding the step would not converge toward the end
 *     value.
 */
goog.array.range = function(startOrEnd, opt_end, opt_step) {
  var array = [];
  var start = 0;
  var end = startOrEnd;
  var step = opt_step || 1;
  if (opt_end !== undefined) {
    start = startOrEnd;
    end = opt_end;
  }

  if (step * (end - start) < 0) {
    // Sign mismatch: start + step will never reach the end value.
    return [];
  }

  if (step > 0) {
    for (var i = start; i < end; i += step) {
      array.push(i);
    }
  } else {
    for (var i = start; i > end; i += step) {
      array.push(i);
    }
  }
  return array;
};


/**
 * Returns an array consisting of the given value repeated N times.
 *
 * @param {*} value The value to repeat.
 * @param {number} n The repeat count.
 * @return {!Array} An array with the repeated value.
 */
goog.array.repeat = function(value, n) {
  var array = [];
  for (var i = 0; i < n; i++) {
    array[i] = value;
  }
  return array;
};


/**
 * Returns an array consisting of every argument with all arrays
 * expanded in-place recursively.
 *
 * @param {...*} var_args The values to flatten.
 * @return {!Array} An array containing the flattened values.
 */
goog.array.flatten = function(var_args) {
  var result = [];
  for (var i = 0; i < arguments.length; i++) {
    var element = arguments[i];
    if (goog.isArray(element)) {
      result.push.apply(result, goog.array.flatten.apply(null, element));
    } else {
      result.push(element);
    }
  }
  return result;
};


/**
 * Rotates an array in-place. After calling this method, the element at
 * index i will be the element previously at index (i - n) %
 * array.length, for all values of i between 0 and array.length - 1,
 * inclusive.
 *
 * For example, suppose list comprises [t, a, n, k, s]. After invoking
 * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].
 *
 * @param {!Array.<T>} array The array to rotate.
 * @param {number} n The amount to rotate.
 * @return {!Array.<T>} The array.
 * @template T
 */
goog.array.rotate = function(array, n) {
  goog.asserts.assert(array.length != null);

  if (array.length) {
    n %= array.length;
    if (n > 0) {
      goog.array.ARRAY_PROTOTYPE_.unshift.apply(array, array.splice(-n, n));
    } else if (n < 0) {
      goog.array.ARRAY_PROTOTYPE_.push.apply(array, array.splice(0, -n));
    }
  }
  return array;
};


/**
 * Moves one item of an array to a new position keeping the order of the rest
 * of the items. Example use case: keeping a list of JavaScript objects
 * synchronized with the corresponding list of DOM elements after one of the
 * elements has been dragged to a new position.
 * @param {!(Array|Arguments|{length:number})} arr The array to modify.
 * @param {number} fromIndex Index of the item to move between 0 and
 *     {@code arr.length - 1}.
 * @param {number} toIndex Target index between 0 and {@code arr.length - 1}.
 */
goog.array.moveItem = function(arr, fromIndex, toIndex) {
  goog.asserts.assert(fromIndex >= 0 && fromIndex < arr.length);
  goog.asserts.assert(toIndex >= 0 && toIndex < arr.length);
  // Remove 1 item at fromIndex.
  var removedItems = goog.array.ARRAY_PROTOTYPE_.splice.call(arr, fromIndex, 1);
  // Insert the removed item at toIndex.
  goog.array.ARRAY_PROTOTYPE_.splice.call(arr, toIndex, 0, removedItems[0]);
  // We don't use goog.array.insertAt and goog.array.removeAt, because they're
  // significantly slower than splice.
};


/**
 * Creates a new array for which the element at position i is an array of the
 * ith element of the provided arrays.  The returned array will only be as long
 * as the shortest array provided; additional values are ignored.  For example,
 * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].
 *
 * This is similar to the zip() function in Python.  See {@link
 * http://docs.python.org/library/functions.html#zip}
 *
 * @param {...!goog.array.ArrayLike} var_args Arrays to be combined.
 * @return {!Array.<!Array>} A new array of arrays created from provided arrays.
 */
goog.array.zip = function(var_args) {
  if (!arguments.length) {
    return [];
  }
  var result = [];
  for (var i = 0; true; i++) {
    var value = [];
    for (var j = 0; j < arguments.length; j++) {
      var arr = arguments[j];
      // If i is larger than the array length, this is the shortest array.
      if (i >= arr.length) {
        return result;
      }
      value.push(arr[i]);
    }
    result.push(value);
  }
};


/**
 * Shuffles the values in the specified array using the Fisher-Yates in-place
 * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()
 * and so resets the state of that random number generator. Similarly, may reset
 * the state of the any other specified random number generator.
 *
 * Runtime: O(n)
 *
 * @param {!Array} arr The array to be shuffled.
 * @param {function():number=} opt_randFn Optional random function to use for
 *     shuffling.
 *     Takes no arguments, and returns a random number on the interval [0, 1).
 *     Defaults to Math.random() using JavaScript's built-in Math library.
 */
goog.array.shuffle = function(arr, opt_randFn) {
  var randFn = opt_randFn || Math.random;

  for (var i = arr.length - 1; i > 0; i--) {
    // Choose a random array index in [0, i] (inclusive with i).
    var j = Math.floor(randFn() * (i + 1));

    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
};

//javascript/closure/structs/queue.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Datastructure: Queue.
 *
 * @author ozgur@google.com (Ozgur D. Sahin)
 *
 * This file provides the implementation of a FIFO Queue structure.
 * API is similar to that of com.google.common.collect.IntQueue
 */

goog.provide('goog.structs.Queue');

goog.require('goog.array');



/**
 * Class for FIFO Queue data structure.
 *
 * @constructor
 * @template T
 */
goog.structs.Queue = function() {
  /**
   * The index of the next element to be removed from the queue.
   * @private {number}
   */
  this.head_ = 0;

  /**
   * The index at which the next element would be added to the queue.
   * @private {number}
   */
  this.tail_ = 0;

  /**
   * @const
   * @private {!Array.<T>}
   */
  this.elements_ = [];
};


/**
 * Puts the specified element on this queue.
 * @param {T} element The element to be added to the queue.
 */
goog.structs.Queue.prototype.enqueue = function(element) {
  this.elements_[this.tail_++] = element;
};


/**
 * Retrieves and removes the head of this queue.
 * @return {T} The element at the head of this queue. Returns undefined if the
 *     queue is empty.
 */
goog.structs.Queue.prototype.dequeue = function() {
  if (this.head_ == this.tail_) {
    return undefined;
  }
  var result = this.elements_[this.head_];
  delete this.elements_[this.head_];
  this.head_++;
  return result;
};


/**
 * Retrieves but does not remove the head of this queue.
 * @return {T} The element at the head of this queue. Returns undefined if the
 *     queue is empty.
 */
goog.structs.Queue.prototype.peek = function() {
  if (this.head_ == this.tail_) {
    return undefined;
  }
  return this.elements_[this.head_];
};


/**
 * Returns the number of elements in this queue.
 * @return {number} The number of elements in this queue.
 */
goog.structs.Queue.prototype.getCount = function() {
  return this.tail_ - this.head_;
};


/**
 * Returns true if this queue contains no elements.
 * @return {boolean} true if this queue contains no elements.
 */
goog.structs.Queue.prototype.isEmpty = function() {
  return this.tail_ - this.head_ == 0;
};


/**
 * Removes all elements from the queue.
 */
goog.structs.Queue.prototype.clear = function() {
  this.elements_.length = 0;
  this.head_ = 0;
  this.tail_ = 0;
};


/**
 * Returns true if the given value is in the queue.
 * @param {T} obj The value to look for.
 * @return {boolean} Whether the object is in the queue.
 */
goog.structs.Queue.prototype.contains = function(obj) {
  return goog.array.contains(this.elements_, obj);
};


/**
 * Removes the first occurrence of a particular value from the queue.
 * @param {T} obj Object to remove.
 * @return {boolean} True if an element was removed.
 */
goog.structs.Queue.prototype.remove = function(obj) {
  var index = goog.array.indexOf(this.elements_, obj);
  if (index < 0) {
    return false;
  }
  if (index == this.head_) {
    this.dequeue();
  } else {
    goog.array.removeAt(this.elements_, index);
    this.tail_--;
  }
  return true;
};


/**
 * Returns all the values in the queue.
 * @return {Array.<T>} An array of the values in the queue.
 */
goog.structs.Queue.prototype.getValues = function() {
  return this.elements_.slice(this.head_, this.tail_);
};

//javascript/closure/testing/watchers.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Simple notifiers for the Closure testing framework.
 *
 * @author johnlenz@google.com (John Lenz)
 */

goog.provide('goog.testing.watchers');


/** @private {!Array.<function()>} */
goog.testing.watchers.resetWatchers_ = [];


/**
 * Fires clock reset watching functions.
 */
goog.testing.watchers.signalClockReset = function() {
  var watchers = goog.testing.watchers.resetWatchers_;
  for (var i = 0; i < watchers.length; i++) {
    goog.testing.watchers.resetWatchers_[i]();
  }
};


/**
 * Enqueues a function to be called when the clock used for setTimeout is reset.
 * @param {function()} fn
 */
goog.testing.watchers.watchClockReset = function(fn) {
  goog.testing.watchers.resetWatchers_.push(fn);
};


//javascript/closure/debug/entrypointregistry.js
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A global registry for entry points into a program,
 * so that they can be instrumented. Each module should register their
 * entry points with this registry. Designed to be compiled out
 * if no instrumentation is requested.
 *
 * Entry points may be registered before or after a call to
 * goog.debug.entryPointRegistry.monitorAll. If an entry point is registered
 * later, the existing monitor will instrument the new entry point.
 *
 * @author nicksantos@google.com (Nick Santos)
 */

goog.provide('goog.debug.EntryPointMonitor');
goog.provide('goog.debug.entryPointRegistry');

goog.require('goog.asserts');



/**
 * @interface
 */
goog.debug.EntryPointMonitor = function() {};


/**
 * Instruments a function.
 *
 * @param {!Function} fn A function to instrument.
 * @return {!Function} The instrumented function.
 */
goog.debug.EntryPointMonitor.prototype.wrap;


/**
 * Try to remove an instrumentation wrapper created by this monitor.
 * If the function passed to unwrap is not a wrapper created by this
 * monitor, then we will do nothing.
 *
 * Notice that some wrappers may not be unwrappable. For example, if other
 * monitors have applied their own wrappers, then it will be impossible to
 * unwrap them because their wrappers will have captured our wrapper.
 *
 * So it is important that entry points are unwrapped in the reverse
 * order that they were wrapped.
 *
 * @param {!Function} fn A function to unwrap.
 * @return {!Function} The unwrapped function, or {@code fn} if it was not
 *     a wrapped function created by this monitor.
 */
goog.debug.EntryPointMonitor.prototype.unwrap;


/**
 * An array of entry point callbacks.
 * @type {!Array.<function(!Function)>}
 * @private
 */
goog.debug.entryPointRegistry.refList_ = [];


/**
 * Monitors that should wrap all the entry points.
 * @type {!Array.<!goog.debug.EntryPointMonitor>}
 * @private
 */
goog.debug.entryPointRegistry.monitors_ = [];


/**
 * Whether goog.debug.entryPointRegistry.monitorAll has ever been called.
 * Checking this allows the compiler to optimize out the registrations.
 * @type {boolean}
 * @private
 */
goog.debug.entryPointRegistry.monitorsMayExist_ = false;


/**
 * Register an entry point with this module.
 *
 * The entry point will be instrumented when a monitor is passed to
 * goog.debug.entryPointRegistry.monitorAll. If this has already occurred, the
 * entry point is instrumented immediately.
 *
 * @param {function(!Function)} callback A callback function which is called
 *     with a transforming function to instrument the entry point. The callback
 *     is responsible for wrapping the relevant entry point with the
 *     transforming function.
 */
goog.debug.entryPointRegistry.register = function(callback) {
  // Don't use push(), so that this can be compiled out.
  goog.debug.entryPointRegistry.refList_[
      goog.debug.entryPointRegistry.refList_.length] = callback;
  // If no one calls monitorAll, this can be compiled out.
  if (goog.debug.entryPointRegistry.monitorsMayExist_) {
    var monitors = goog.debug.entryPointRegistry.monitors_;
    for (var i = 0; i < monitors.length; i++) {
      callback(goog.bind(monitors[i].wrap, monitors[i]));
    }
  }
};


/**
 * Configures a monitor to wrap all entry points.
 *
 * Entry points that have already been registered are immediately wrapped by
 * the monitor. When an entry point is registered in the future, it will also
 * be wrapped by the monitor when it is registered.
 *
 * @param {!goog.debug.EntryPointMonitor} monitor An entry point monitor.
 */
goog.debug.entryPointRegistry.monitorAll = function(monitor) {
  goog.debug.entryPointRegistry.monitorsMayExist_ = true;
  var transformer = goog.bind(monitor.wrap, monitor);
  for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) {
    goog.debug.entryPointRegistry.refList_[i](transformer);
  }
  goog.debug.entryPointRegistry.monitors_.push(monitor);
};


/**
 * Try to unmonitor all the entry points that have already been registered. If
 * an entry point is registered in the future, it will not be wrapped by the
 * monitor when it is registered. Note that this may fail if the entry points
 * have additional wrapping.
 *
 * @param {!goog.debug.EntryPointMonitor} monitor The last monitor to wrap
 *     the entry points.
 * @throws {Error} If the monitor is not the most recently configured monitor.
 */
goog.debug.entryPointRegistry.unmonitorAllIfPossible = function(monitor) {
  var monitors = goog.debug.entryPointRegistry.monitors_;
  goog.asserts.assert(monitor == monitors[monitors.length - 1],
      'Only the most recent monitor can be unwrapped.');
  var transformer = goog.bind(monitor.unwrap, monitor);
  for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) {
    goog.debug.entryPointRegistry.refList_[i](transformer);
  }
  monitors.length--;
};

//javascript/closure/functions/functions.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for creating functions. Loosely inspired by the
 * java classes: http://goo.gl/GM0Hmu and http://goo.gl/6k7nI8.
 *
 * @author nicksantos@google.com (Nick Santos)
 */


goog.provide('goog.functions');


/**
 * Creates a function that always returns the same value.
 * @param {T} retValue The value to return.
 * @return {function():T} The new function.
 * @template T
 */
goog.functions.constant = function(retValue) {
  return function() {
    return retValue;
  };
};


/**
 * Always returns false.
 * @type {function(...): boolean}
 */
goog.functions.FALSE = goog.functions.constant(false);


/**
 * Always returns true.
 * @type {function(...): boolean}
 */
goog.functions.TRUE = goog.functions.constant(true);


/**
 * Always returns NULL.
 * @type {function(...): null}
 */
goog.functions.NULL = goog.functions.constant(null);


/**
 * A simple function that returns the first argument of whatever is passed
 * into it.
 * @param {T=} opt_returnValue The single value that will be returned.
 * @param {...*} var_args Optional trailing arguments. These are ignored.
 * @return {T} The first argument passed in, or undefined if nothing was passed.
 * @template T
 */
goog.functions.identity = function(opt_returnValue, var_args) {
  return opt_returnValue;
};


/**
 * Creates a function that always throws an error with the given message.
 * @param {string} message The error message.
 * @return {!Function} The error-throwing function.
 */
goog.functions.error = function(message) {
  return function() {
    throw Error(message);
  };
};


/**
 * Creates a function that throws the given object.
 * @param {*} err An object to be thrown.
 * @return {!Function} The error-throwing function.
 */
goog.functions.fail = function(err) {
  return function() {
    throw err;
  }
};


/**
 * Given a function, create a function that keeps opt_numArgs arguments and
 * silently discards all additional arguments.
 * @param {Function} f The original function.
 * @param {number=} opt_numArgs The number of arguments to keep. Defaults to 0.
 * @return {!Function} A version of f that only keeps the first opt_numArgs
 *     arguments.
 */
goog.functions.lock = function(f, opt_numArgs) {
  opt_numArgs = opt_numArgs || 0;
  return function() {
    return f.apply(this, Array.prototype.slice.call(arguments, 0, opt_numArgs));
  };
};


/**
 * Creates a function that returns its nth argument.
 * @param {number} n The position of the return argument.
 * @return {!Function} A new function.
 */
goog.functions.nth = function(n) {
  return function() {
    return arguments[n];
  };
};


/**
 * Given a function, create a new function that swallows its return value
 * and replaces it with a new one.
 * @param {Function} f A function.
 * @param {T} retValue A new return value.
 * @return {function(...[?]):T} A new function.
 * @template T
 */
goog.functions.withReturnValue = function(f, retValue) {
  return goog.functions.sequence(f, goog.functions.constant(retValue));
};


/**
 * Creates the composition of the functions passed in.
 * For example, (goog.functions.compose(f, g))(a) is equivalent to f(g(a)).
 * @param {function(...[?]):T} fn The final function.
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):T} The composition of all inputs.
 * @template T
 */
goog.functions.compose = function(fn, var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    var result;
    if (length) {
      result = functions[length - 1].apply(this, arguments);
    }

    for (var i = length - 2; i >= 0; i--) {
      result = functions[i].call(this, result);
    }
    return result;
  };
};


/**
 * Creates a function that calls the functions passed in in sequence, and
 * returns the value of the last function. For example,
 * (goog.functions.sequence(f, g))(x) is equivalent to f(x),g(x).
 * @param {...Function} var_args A list of functions.
 * @return {!Function} A function that calls all inputs in sequence.
 */
goog.functions.sequence = function(var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    var result;
    for (var i = 0; i < length; i++) {
      result = functions[i].apply(this, arguments);
    }
    return result;
  };
};


/**
 * Creates a function that returns true if each of its components evaluates
 * to true. The components are evaluated in order, and the evaluation will be
 * short-circuited as soon as a function returns false.
 * For example, (goog.functions.and(f, g))(x) is equivalent to f(x) && g(x).
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):boolean} A function that ANDs its component
 *      functions.
 */
goog.functions.and = function(var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    for (var i = 0; i < length; i++) {
      if (!functions[i].apply(this, arguments)) {
        return false;
      }
    }
    return true;
  };
};


/**
 * Creates a function that returns true if any of its components evaluates
 * to true. The components are evaluated in order, and the evaluation will be
 * short-circuited as soon as a function returns true.
 * For example, (goog.functions.or(f, g))(x) is equivalent to f(x) || g(x).
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):boolean} A function that ORs its component
 *    functions.
 */
goog.functions.or = function(var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    for (var i = 0; i < length; i++) {
      if (functions[i].apply(this, arguments)) {
        return true;
      }
    }
    return false;
  };
};


/**
 * Creates a function that returns the Boolean opposite of a provided function.
 * For example, (goog.functions.not(f))(x) is equivalent to !f(x).
 * @param {!Function} f The original function.
 * @return {function(...[?]):boolean} A function that delegates to f and returns
 * opposite.
 */
goog.functions.not = function(f) {
  return function() {
    return !f.apply(this, arguments);
  };
};


/**
 * Generic factory function to construct an object given the constructor
 * and the arguments. Intended to be bound to create object factories.
 *
 * Callers should cast the result to the appropriate type for proper type
 * checking by the compiler.
 * @param {!Function} constructor The constructor for the Object.
 * @param {...*} var_args The arguments to be passed to the constructor.
 * @return {!Object} A new instance of the class given in {@code constructor}.
 */
goog.functions.create = function(constructor, var_args) {
  /**
 * @constructor
 * @final
 */
  var temp = function() {};
  temp.prototype = constructor.prototype;

  // obj will have constructor's prototype in its chain and
  // 'obj instanceof constructor' will be true.
  var obj = new temp();

  // obj is initialized by constructor.
  // arguments is only array-like so lacks shift(), but can be used with
  // the Array prototype function.
  constructor.apply(obj, Array.prototype.slice.call(arguments, 1));
  return obj;
};


/**
 * @define {boolean} Whether the return value cache should be used.
 *    This should only be used to disable caches when testing.
 */
goog.define('goog.functions.CACHE_RETURN_VALUE', true);


/**
 * Gives a wrapper function that caches the return value of a parameterless
 * function when first called.
 *
 * When called for the first time, the given function is called and its
 * return value is cached (thus this is only appropriate for idempotent
 * functions).  Subsequent calls will return the cached return value. This
 * allows the evaluation of expensive functions to be delayed until first used.
 *
 * To cache the return values of functions with parameters, see goog.memoize.
 *
 * @param {!function():T} fn A function to lazily evaluate.
 * @return {!function():T} A wrapped version the function.
 * @template T
 */
goog.functions.cacheReturnValue = function(fn) {
  var called = false;
  var value;

  return function() {
    if (!goog.functions.CACHE_RETURN_VALUE) {
      return fn();
    }

    if (!called) {
      value = fn();
      called = true;
    }

    return value;
  }
};

//javascript/closure/async/nexttick.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides a function to schedule running a function as soon
 * as possible after the current JS execution stops and yields to the event
 * loop.
 *
 * @author malteubl@google.com (Malte Ubl)
 */

goog.provide('goog.async.nextTick');

goog.require('goog.debug.entryPointRegistry');
goog.require('goog.functions');


/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(���, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
goog.async.nextTick = function(callback, opt_context) {
  var cb = callback;
  if (opt_context) {
    cb = goog.bind(callback, opt_context);
  }
  cb = goog.async.nextTick.wrapCallback_(cb);
  // Introduced and currently only supported by IE10.
  if (goog.isFunction(goog.global.setImmediate)) {
    goog.global.setImmediate(cb);
    return;
  }
  // Look for and cache the custom fallback version of setImmediate.
  if (!goog.async.nextTick.setImmediate_) {
    goog.async.nextTick.setImmediate_ =
        goog.async.nextTick.getSetImmediateEmulator_();
  }
  goog.async.nextTick.setImmediate_(cb);
};


/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
goog.async.nextTick.setImmediate_;


/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
goog.async.nextTick.getSetImmediateEmulator_ = function() {
  // Create a private message channel and use it to postMessage empty messages
  // to ourselves.
  var Channel = goog.global['MessageChannel'];
  // If MessageChannel is not available and we are in a browser, implement
  // an iframe based polyfill in browsers that have postMessage and
  // document.addEventListener. The latter excludes IE8 because it has a
  // synchronous postMessage implementation.
  if (typeof Channel === 'undefined' && typeof window !== 'undefined' &&
      window.postMessage && window.addEventListener) {
    /** @constructor */
    Channel = function() {
      // Make an empty, invisible iframe.
      var iframe = document.createElement('iframe');
      iframe.style.display = 'none';
      iframe.src = '';
      document.documentElement.appendChild(iframe);
      var win = iframe.contentWindow;
      var doc = win.document;
      doc.open();
      doc.write('');
      doc.close();
      var message = 'callImmediate' + Math.random();
      var origin = win.location.protocol + '//' + win.location.host;
      var onmessage = goog.bind(function(e) {
        // Validate origin and message to make sure that this message was
        // intended for us.
        if (e.origin != origin && e.data != message) {
          return;
        }
        this['port1'].onmessage();
      }, this);
      win.addEventListener('message', onmessage, false);
      this['port1'] = {};
      this['port2'] = {
        postMessage: function() {
          win.postMessage(message, origin);
        }
      };
    };
  }
  if (typeof Channel !== 'undefined') {
    var channel = new Channel();
    // Use a fifo linked list to call callbacks in the right order.
    var head = {};
    var tail = head;
    channel['port1'].onmessage = function() {
      head = head.next;
      var cb = head.cb;
      head.cb = null;
      cb();
    };
    return function(cb) {
      tail.next = {
        cb: cb
      };
      tail = tail.next;
      channel['port2'].postMessage(0);
    };
  }
  // Implementation for IE6-8: Script elements fire an asynchronous
  // onreadystatechange event when inserted into the DOM.
  if (typeof document !== 'undefined' && 'onreadystatechange' in
      document.createElement('script')) {
    return function(cb) {
      var script = document.createElement('script');
      script.onreadystatechange = function() {
        // Clean up and call the callback.
        script.onreadystatechange = null;
        script.parentNode.removeChild(script);
        script = null;
        cb();
        cb = null;
      };
      document.documentElement.appendChild(script);
    };
  }
  // Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
  // or more.
  return function(cb) {
    goog.global.setTimeout(cb, 0);
  };
};


/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
goog.async.nextTick.wrapCallback_ = goog.functions.identity;


// Register the callback function as an entry point, so that it can be
// monitored for exception handling, etc. This has to be done in this file
// since it requires special code to handle all browsers.
goog.debug.entryPointRegistry.register(
    /**
     * @param {function(!Function): !Function} transformer The transforming
     *     function.
     */
    function(transformer) {
      goog.async.nextTick.wrapCallback_ = transformer;
    });

//javascript/closure/async/run.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.provide('goog.async.run');
goog.provide('goog.async.throwException');

goog.require('goog.async.nextTick');
goog.require('goog.testing.watchers');


/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
goog.async.throwException = function(exception) {
  // Each throw needs to be in its own context.
  goog.async.nextTick(function() { throw exception; });
};


/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
goog.async.run = function(callback, opt_context) {
  if (!goog.async.run.workQueueScheduled_) {
    // Nothing is currently scheduled, schedule it now.
    goog.async.nextTick(goog.async.run.processWorkQueue);
    goog.async.run.workQueueScheduled_ = true;
  }

  goog.async.run.workQueue_.push(
      new goog.async.run.WorkItem_(callback, opt_context));
};


/** @private {boolean} */
goog.async.run.workQueueScheduled_ = false;


/** @private {!Array.<!goog.async.run.WorkItem_>} */
goog.async.run.workQueue_ = [];


if (goog.DEBUG) {
  /**
   * Reset the event queue.
   * @private
   */
  goog.async.run.resetQueue_ = function() {
    goog.async.run.workQueueScheduled_ = false;
    goog.async.run.workQueue_ = [];
  };

  // If there is a clock implemenation in use for testing
  // and it is reset, reset the queue.
  goog.testing.watchers.watchClockReset(goog.async.run.resetQueue_);
}


/**
 * Run any pending goog.async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * goog.async.nextTick.
 */
goog.async.run.processWorkQueue = function() {
  // NOTE: additional work queue items may be pushed while processing.
  while (goog.async.run.workQueue_.length) {
    // Don't let the work queue grow indefinitely.
    var workItems = goog.async.run.workQueue_;
    goog.async.run.workQueue_ = [];
    for (var i = 0; i < workItems.length; i++) {
      var workItem = workItems[i];
      try {
        workItem.fn.call(workItem.scope);
      } catch (e) {
        goog.async.throwException(e);
      }
    }
  }

  // There are no more work items, reset the work queue.
  goog.async.run.workQueueScheduled_ = false;
};



/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
goog.async.run.WorkItem_ = function(fn, scope) {
  /** @const */ this.fn = fn;
  /** @const */ this.scope = scope;
};

//javascript/closure/labs/promise/thenable.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.provide('goog.labs.Thenable');



/**
 * Provides a more strict interface for Thenables in terms of
 * http://promisesaplus.com for interop with {@see goog.labs.Promise}.
 *
 * @interface
 * @template TYPE
 */
goog.labs.Thenable = function() {};


/**
 * Adds callbacks that will operate on the result of the Thenable, returning a
 * new child Promise.
 *
 * If the Thenable is fulfilled, the {@code onFulfilled} callback will be
 * invoked with the fulfillment value as argument, and the child Promise will
 * be fulfilled with the return value of the callback. If the callback throws
 * an exception, the child Promise will be rejected with the thrown value
 * instead.
 *
 * If the Thenable is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value of the callback or thrown value.
 *
 * @param {(function(this:THIS, TYPE):
 *          (RESULT|goog.labs.Thenable.<RESULT>|Thenable))=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fullfilled.
 * @param {(function(*): *)=} opt_onRejected A function that will be invoked
 *     with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 * @return {!goog.labs.Promise.<RESULT>} A new Promise that will receive the
 *     result of the fulfillment or rejection callback.
 * @template RESULT,THIS
 */
goog.labs.Thenable.prototype.then = function(opt_onFulfilled, opt_onRejected,
    opt_context) {};


/**
 * An expando property to indicate that an object implements
 * goog.labs.Thenable.
 *
 * {@see addImplementation}.
 *
 * @const
 */
goog.labs.Thenable.IMPLEMENTED_BY_PROP =
    '$goog_labs_Thenable';


/**
 * Marks a given class (constructor) as an implementation of Thenable, so
 * that we can query that fact at runtime. The class must have already
 * implemented the interface.
 * Exports a 'then' method on the constructor prototype, so that the objects
 * also implement the extern {@see Thenable} interface for interop with
 * other Promise implementations.
 * @param {function(new:goog.labs.Thenable,...[?])} ctor The class constructor.
 *     The corresponding class must have already implemented the interface.
 */
goog.labs.Thenable.addImplementation = function(ctor) {
  goog.exportProperty(ctor.prototype, 'then', ctor.prototype.then);
  if (COMPILED) {
    ctor.prototype[goog.labs.Thenable.IMPLEMENTED_BY_PROP] = true;
  } else {
    // Avoids dictionary access in uncompiled mode.
    ctor.prototype.$goog_labs_Thenable = true;
  }
};


/**
 * @param {*} object
 * @return {boolean} Whether a given instance implements
 *     {@code goog.labs.Thenable}. The class/superclass of the instance must
 *     call {@code addImplementation}.
 */
goog.labs.Thenable.isImplementedBy = function(object) {
  if (!object) {
    return false;
  }
  try {
    if (COMPILED) {
      return !!object[goog.labs.Thenable.IMPLEMENTED_BY_PROP];
    }
    return !!object.$goog_labs_Thenable;
  } catch (e) {
    // Property access seems to be forbidden.
    return false;
  }
};

//javascript/closure/labs/promise/promise.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.provide('goog.labs.Promise');

goog.require('goog.asserts');
goog.require('goog.async.run');
goog.require('goog.async.throwException');
goog.require('goog.debug.Error');
goog.require('goog.labs.Thenable');



/**
 * Promises provide a result that may be resolved asynchronously. A Promise may
 * be resolved by being fulfilled or rejected with a value, which will be known
 * as the fulfillment value or the rejection reason. Whether fulfilled or
 * rejected, the Promise result is immutable once it is set.
 *
 * Promises may represent results of any type, including undefined. Rejection
 * reasons are typically Errors, but may also be of any type. Closure Promises
 * allow for optional type annotations that enforce that fulfillment values are
 * of the appropriate types at compile time.
 *
 * The result of a Promise is accessible by calling {@code then} and registering
 * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise
 * resolves, the relevant callbacks are invoked with the fulfillment value or
 * rejection reason as argument. Callbacks are always invoked in the order they
 * were registered, even when additional {@code then} calls are made from inside
 * another callback. A callback is always run asynchronously sometime after the
 * scope containing the registering {@code then} invocation has returned.
 *
 * If a Promise is resolved with another Promise, the first Promise will block
 * until the second is resolved, and then assumes the same result as the second
 * Promise. This allows Promises to depend on the results of other Promises,
 * linking together multiple asynchronous operations.
 *
 * This implementation is compatible with the Promises/A+ specification and
 * passes that specification's conformance test suite. A Closure Promise may be
 * resolved with a Promise instance (or sufficiently compatible Promise-like
 * object) created by other Promise implementations. From the specification,
 * Promise-like objects are known as "Thenables".
 *
 * @see http://promisesaplus.com/
 *
 * @param {function(
 *             this:THIS,
 *             function((TYPE|goog.labs.Promise.<TYPE>|Thenable)),
 *             function(*)): void} resolver
 *     Initialization function that is invoked immediately with {@code resolve}
 *     and {@code reject} functions as arguments. The Promise is resolved or
 *     rejected with the first argument passed to either function.
 * @param {THIS=} opt_context An optional context for executing the resolver
 *     function. If unspecified, the resolver function will be executed in the
 *     default scope.
 * @constructor
 * @struct
 * @final
 * @implements {goog.labs.Thenable.<TYPE>}
 * @template TYPE,THIS
 */
goog.labs.Promise = function(resolver, opt_context) {
  /**
   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or
   * BLOCKED.
   * @private {goog.labs.Promise.State_}
   */
  this.state_ = goog.labs.Promise.State_.PENDING;

  /**
   * The resolved result of the Promise. Immutable once set with either a
   * fulfillment value or rejection reason.
   * @private {*}
   */
  this.result_ = undefined;

  /**
   * For Promises created by calling {@code then()}, the originating parent.
   * @private {goog.labs.Promise}
   */
  this.parent_ = null;

  /**
   * The list of {@code onFulfilled} and {@code onRejected} callbacks added to
   * this Promise by calls to {@code then()}.
   * @private {!Array.<goog.labs.Promise.CallbackEntry_>}
   */
  this.callbackEntries_ = [];

  /**
   * Whether the Promise is in the queue of Promises to execute.
   * @private {boolean}
   */
  this.executing_ = false;

  if (goog.labs.Promise.UNHANDLED_REJECTION_DELAY > 0) {
    /**
     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater
     * than 0 milliseconds. The ID is set when the Promise is rejected, and
     * cleared only if an {@code onRejected} callback is invoked for the
     * Promise (or one of its descendants) before the delay is exceeded.
     *
     * If the rejection is not handled before the timeout completes, the
     * rejection reason is passed to the unhandled rejection handler.
     * @private {number}
     */
    this.unhandledRejectionId_ = 0;
  } else if (goog.labs.Promise.UNHANDLED_REJECTION_DELAY == 0) {
    /**
     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a
     * boolean that is set if the Promise is rejected, and reset to false if an
     * {@code onRejected} callback is invoked for the Promise (or one of its
     * descendants). If the rejection is not handled before the next timestep,
     * the rejection reason is passed to the unhandled rejection handler.
     * @private {boolean}
     */
    this.hadUnhandledRejection_ = false;
  }

  if (goog.labs.Promise.LONG_STACK_TRACES) {
    /**
     * A list of stack trace frames pointing to the locations where this Promise
     * was created or had callbacks added to it. Saved to add additional context
     * to stack traces when an exception is thrown.
     * @private {!Array.<string>}
     */
    this.stack_ = [];
    this.addStackTrace_(new Error('created'));

    /**
     * Index of the most recently executed stack frame entry.
     * @private {number}
     */
    this.currentStep_ = 0;
  }

  try {
    var self = this;
    resolver.call(
        opt_context,
        function(value) {
          self.resolve_(goog.labs.Promise.State_.FULFILLED, value);
        },
        function(reason) {
          self.resolve_(goog.labs.Promise.State_.REJECTED, reason);
        });
  } catch (e) {
    this.resolve_(goog.labs.Promise.State_.REJECTED, e);
  }
};


/**
 * @define {boolean} Whether traces of {@code then} calls should be included in
 * exceptions thrown
 */
goog.define('goog.labs.Promise.LONG_STACK_TRACES', goog.DEBUG);


/**
 * @define {number} The delay in milliseconds before a rejected Promise's reason
 * is passed to the rejection handler. By default, the rejection handler
 * rethrows the rejection reason so that it appears in the developer console or
 * {@code window.onerror} handler.
 *
 * Rejections are rethrown as quickly as possible by default. A negative value
 * disables rejection handling entirely.
 */
goog.define('goog.labs.Promise.UNHANDLED_REJECTION_DELAY', 0);


/**
 * The possible internal states for a Promise. These states are not directly
 * observable to external callers.
 * @enum {number}
 * @private
 */
goog.labs.Promise.State_ = {
  /** The Promise is waiting for resolution. */
  PENDING: 0,

  /** The Promise is blocked waiting for the result of another Thenable. */
  BLOCKED: 1,

  /** The Promise has been resolved with a fulfillment value. */
  FULFILLED: 2,

  /** The Promise has been resolved with a rejection reason. */
  REJECTED: 3
};


/**
 * Typedef for entries in the callback chain. Each call to {@code then},
 * {@code thenCatch}, or {@code thenAlways} creates an entry containing the
 * functions that may be invoked once the Promise is resolved.
 *
 * @typedef {{
 *   child: goog.labs.Promise,
 *   onFulfilled: function(*),
 *   onRejected: function(*)
 * }}
 * @private
 */
goog.labs.Promise.CallbackEntry_;


/**
 * @param {(TYPE|goog.labs.Thenable.<TYPE>|Thenable)=} opt_value
 * @return {!goog.labs.Promise.<TYPE>} A new Promise that is immediately
 *     resolved with the given value.
 * @template TYPE
 */
goog.labs.Promise.resolve = function(opt_value) {
  return new goog.labs.Promise(function(resolve, reject) {
    resolve(opt_value);
  });
};


/**
 * @param {*=} opt_reason
 * @return {!goog.labs.Promise} A new Promise that is immediately rejected with
 *     the given reason.
 */
goog.labs.Promise.reject = function(opt_reason) {
  return new goog.labs.Promise(function(resolve, reject) {
    reject(opt_reason);
  });
};


/**
 * @param {!Array.<!(goog.labs.Thenable.<TYPE>|Thenable)>} promises
 * @return {!goog.labs.Promise.<TYPE>} A Promise that receives the result of the
 *     first Promise (or Promise-like) input to complete.
 * @template TYPE
 */
goog.labs.Promise.race = function(promises) {
  return new goog.labs.Promise(function(resolve, reject) {
    if (!promises.length) {
      resolve(undefined);
    }
    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(resolve, reject);
    }
  });
};


/**
 * @param {!Array.<!(goog.labs.Thenable.<TYPE>|Thenable)>} promises
 * @return {!goog.labs.Promise.<!Array.<TYPE>>} A Promise that receives a list
 *     of every fulfilled value once every input Promise (or Promise-like) is
 *     successfully fulfilled, or is rejected by the first rejection result.
 * @template TYPE
 */
goog.labs.Promise.all = function(promises) {
  return new goog.labs.Promise(function(resolve, reject) {
    var toFulfill = promises.length;
    var values = [];

    if (!toFulfill) {
      resolve(values);
      return;
    }

    var onFulfill = function(index, value) {
      toFulfill--;
      values[index] = value;
      if (toFulfill == 0) {
        resolve(values);
      }
    };

    var onReject = function(reason) {
      reject(reason);
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(goog.partial(onFulfill, i), onReject);
    }
  });
};


/**
 * @param {!Array.<!(goog.labs.Thenable.<TYPE>|Thenable)>} promises
 * @return {!goog.labs.Promise.<TYPE>} A Promise that receives the value of the
 *     first input to be fulfilled, or is rejected with a list of every
 *     rejection reason if all inputs are rejected.
 * @template TYPE
 */
goog.labs.Promise.firstFulfilled = function(promises) {
  return new goog.labs.Promise(function(resolve, reject) {
    var toReject = promises.length;
    var reasons = [];

    if (!toReject) {
      resolve(undefined);
      return;
    }

    var onFulfill = function(value) {
      resolve(value);
    };

    var onReject = function(index, reason) {
      toReject--;
      reasons[index] = reason;
      if (toReject == 0) {
        reject(reasons);
      }
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(onFulfill, goog.partial(onReject, i));
    }
  });
};


/**
 * Adds callbacks that will operate on the result of the Promise, returning a
 * new child Promise.
 *
 * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked
 * with the fulfillment value as argument, and the child Promise will be
 * fulfilled with the return value of the callback. If the callback throws an
 * exception, the child Promise will be rejected with the thrown value instead.
 *
 * If the Promise is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value (or thrown value) of the callback.
 *
 * @param {(function(this:THIS, TYPE):
 *          (RESULT|goog.labs.Thenable.<RESULT>|Thenable))=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fullfilled.
 * @param {(function(this:THIS, *): *)=} opt_onRejected A function that will be
 *     invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the default calling context.
 * @return {!goog.labs.Promise.<RESULT>} A new Promise that will receive the
 *     result of the fulfillment or rejection callback.
 * @template RESULT,THIS
 * @override
 */
goog.labs.Promise.prototype.then = function(
    opt_onFulfilled, opt_onRejected, opt_context) {
  this.addStackTrace_(new Error('then'));

  return this.addChildPromise_(
      goog.isFunction(opt_onFulfilled) ? opt_onFulfilled : null,
      goog.isFunction(opt_onRejected) ? opt_onRejected : null,
      opt_context);
};
goog.labs.Thenable.addImplementation(goog.labs.Promise);


/**
 * Adds a callback that will be invoked whether the Promise is fulfilled or
 * rejected. The callback receives no argument, and no new child Promise is
 * created. This is useful for ensuring that cleanup takes place after certain
 * asynchronous operations. Callbacks added with {@code thenAlways} will be
 * executed in the same order with other calls to {@code then},
 * {@code thenAlways}, or {@code thenCatch}.
 *
 * Since it does not produce a new child Promise, cancellation propagation is
 * not prevented by adding callbacks with {@code thenAlways}. A Promise that has
 * a cleanup handler added with {@code thenAlways} will be canceled if all of
 * its children created by {@code then} (or {@code thenCatch}) are canceled.
 *
 * @param {function(this:THIS): void} onResolved A function that will be invoked
 *     when the Promise is resolved.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!goog.labs.Promise.<TYPE>} This Promise, for chaining additional
 *     calls.
 * @template THIS
 */
goog.labs.Promise.prototype.thenAlways = function(onResolved, opt_context) {
  this.addStackTrace_(new Error('thenAlways'));

  var callback = function() {
    try {
      // Ensure that no arguments are passed to onResolved.
      onResolved.call(opt_context);
    } catch (err) {
      goog.labs.Promise.handleRejection_.call(null, err);
    }
  };

  this.addCallbackEntry_({
    child: null,
    onRejected: callback,
    onFulfilled: callback
  });
  return this;
};


/**
 * Adds a callback that will be invoked only if the Promise is rejected. This
 * is equivalent to {@code then(null, onRejected)}.
 *
 * @param {!function(this:THIS, *): *} onRejected A function that will be
 *     invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!goog.labs.Promise} A new Promise that will receive the
 *     result of the callback.
 * @template THIS
 */
goog.labs.Promise.prototype.thenCatch = function(onRejected, opt_context) {
  this.addStackTrace_(new Error('thenCatch'));
  return this.addChildPromise_(null, onRejected, opt_context);
};


/**
 * Cancels the Promise if it is still pending by rejecting it with a cancel
 * Error. No action is performed if the Promise is already resolved.
 *
 * All child Promises of the canceled Promise will be rejected with the same
 * cancel error, as with normal Promise rejection. If the Promise to be canceled
 * is the only child of a pending Promise, the parent Promise will also be
 * canceled. Cancellation may propagate upward through multiple generations.
 *
 * @param {string=} opt_message An optional debugging message for describing the
 *     cancellation reason.
 */
goog.labs.Promise.prototype.cancel = function(opt_message) {
  if (this.state_ == goog.labs.Promise.State_.PENDING) {
    goog.async.run(function() {
      var err = new goog.labs.Promise.CancellationError(opt_message);
      this.cancelInternal_(err);
    }, this);
  }
};


/**
 * Cancels this Promise with the given error.
 *
 * @param {!Error} err The cancellation error.
 * @private
 */
goog.labs.Promise.prototype.cancelInternal_ = function(err) {
  if (this.state_ == goog.labs.Promise.State_.PENDING) {
    if (this.parent_) {
      // Cancel the Promise and remove it from the parent's child list.
      this.parent_.cancelChild_(this, err);
    } else {
      this.resolve_(goog.labs.Promise.State_.REJECTED, err);
    }
  }
};


/**
 * Cancels a child Promise from the list of callback entries. If the Promise has
 * not already been resolved, reject it with a cancel error. If there are no
 * other children in the list of callback entries, propagate the cancellation
 * by canceling this Promise as well.
 *
 * @param {!goog.labs.Promise} childPromise The Promise to cancel.
 * @param {!Error} err The cancel error to use for rejecting the Promise.
 * @private
 */
goog.labs.Promise.prototype.cancelChild_ = function(childPromise, err) {
  var childCount = 0;
  var childIndex = -1;

  // Find the callback entry for the childPromise, and count whether there are
  // additional child Promises.
  for (var i = 0, entry; entry = this.callbackEntries_[i]; i++) {
    var child = entry.child;
    if (child) {
      childCount++;
      if (child == childPromise) {
        childIndex = i;
      }
      if (childIndex >= 0 && childCount > 1) {
        break;
      }
    }
  }

  // If the child Promise was the only child, cancel this Promise as well.
  // Otherwise, reject only the child Promise with the cancel error.
  if (childIndex >= 0) {
    if (this.state_ == goog.labs.Promise.State_.PENDING && childCount == 1) {
      this.cancelInternal_(err);
    } else {
      var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];
      this.executeCallback_(
          callbackEntry, goog.labs.Promise.State_.REJECTED, err);
    }
  }
};


/**
 * Adds a callback entry to the current Promise, and schedules callback
 * execution if the Promise has already been resolved.
 *
 * @param {goog.labs.Promise.CallbackEntry_} callbackEntry Record containing
 *     {@code onFulfilled} and {@code onRejected} callbacks to execute after
 *     the Promise is resolved.
 * @private
 */
goog.labs.Promise.prototype.addCallbackEntry_ = function(callbackEntry) {
  if (!this.callbackEntries_.length &&
      (this.state_ == goog.labs.Promise.State_.FULFILLED ||
       this.state_ == goog.labs.Promise.State_.REJECTED)) {
    this.scheduleCallbacks_();
  }
  this.callbackEntries_.push(callbackEntry);
};


/**
 * Creates a child Promise and adds it to the callback entry list. The result of
 * the child Promise is determined by the state of the parent Promise and the
 * result of the {@code onFulfilled} or {@code onRejected} callbacks as
 * specified in the Promise resolution procedure.
 *
 * @see http://promisesaplus.com/#the__method
 *
 * @param {?function(this:THIS, TYPE):
 *          (RESULT|goog.labs.Promise.<RESULT>|Thenable)} onFulfilled A
 *     callback that will be invoked if the Promise is fullfilled, or null.
 * @param {?function(this:THIS, *): *} onRejected A callback that will be
 *     invoked if the Promise is rejected, or null.
 * @param {THIS=} opt_context An optional execution context for the callbacks.
 *     in the default calling context.
 * @return {!goog.labs.Promise} The child Promise.
 * @template RESULT,THIS
 * @private
 */
goog.labs.Promise.prototype.addChildPromise_ = function(
    onFulfilled, onRejected, opt_context) {

  var callbackEntry = {
    child: null,
    onFulfilled: null,
    onRejected: null
  };

  callbackEntry.child = new goog.labs.Promise(function(resolve, reject) {
    // Invoke onFulfilled, or resolve with the parent's value if absent.
    callbackEntry.onFulfilled = onFulfilled ? function(value) {
      try {
        var result = onFulfilled.call(opt_context, value);
        resolve(result);
      } catch (err) {
        reject(err);
      }
    } : resolve;

    // Invoke onRejected, or reject with the parent's reason if absent.
    callbackEntry.onRejected = onRejected ? function(reason) {
      try {
        var result = onRejected.call(opt_context, reason);
        if (!goog.isDef(result) &&
            reason instanceof goog.labs.Promise.CancellationError) {
          // Propagate cancellation to children if no other result is returned.
          reject(reason);
        } else {
          resolve(result);
        }
      } catch (err) {
        reject(err);
      }
    } : reject;
  });

  callbackEntry.child.parent_ = this;
  this.addCallbackEntry_(
      /** @type {goog.labs.Promise.CallbackEntry_} */ (callbackEntry));
  return callbackEntry.child;
};


/**
 * Unblocks the Promise and fulfills it with the given value.
 *
 * @param {TYPE} value
 * @private
 */
goog.labs.Promise.prototype.unblockAndFulfill_ = function(value) {
  goog.asserts.assert(this.state_ == goog.labs.Promise.State_.BLOCKED);
  this.state_ = goog.labs.Promise.State_.PENDING;
  this.resolve_(goog.labs.Promise.State_.FULFILLED, value);
};


/**
 * Unblocks the Promise and rejects it with the given rejection reason.
 *
 * @param {*} reason
 * @private
 */
goog.labs.Promise.prototype.unblockAndReject_ = function(reason) {
  goog.asserts.assert(this.state_ == goog.labs.Promise.State_.BLOCKED);
  this.state_ = goog.labs.Promise.State_.PENDING;
  this.resolve_(goog.labs.Promise.State_.REJECTED, reason);
};


/**
 * Attempts to resolve a Promise with a given resolution state and value. This
 * is a no-op if the given Promise has already been resolved.
 *
 * If the given result is a Thenable (such as another Promise), the Promise will
 * be resolved with the same state and result as the Thenable once it is itself
 * resolved.
 *
 * If the given result is not a Thenable, the Promise will be fulfilled or
 * rejected with that result based on the given state.
 *
 * @see http://promisesaplus.com/#the_promise_resolution_procedure
 *
 * @param {goog.labs.Promise.State_} state
 * @param {*} x The result to apply to the Promise.
 * @private
 */
goog.labs.Promise.prototype.resolve_ = function(state, x) {
  if (this.state_ != goog.labs.Promise.State_.PENDING) {
    return;
  }

  if (this == x) {
    state = goog.labs.Promise.State_.REJECTED;
    x = new TypeError('Promise cannot resolve to itself');

  } else if (goog.labs.Thenable.isImplementedBy(x)) {
    x = /** @type {!goog.labs.Thenable} */ (x);
    this.state_ = goog.labs.Promise.State_.BLOCKED;
    x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);
    return;

  } else if (goog.isObject(x)) {
    try {
      var then = x['then'];
      if (goog.isFunction(then)) {
        this.tryThen_(x, then);
        return;
      }
    } catch (e) {
      state = goog.labs.Promise.State_.REJECTED;
      x = e;
    }
  }

  this.result_ = x;
  this.state_ = state;
  this.scheduleCallbacks_();

  if (state == goog.labs.Promise.State_.REJECTED &&
      !(x instanceof goog.labs.Promise.CancellationError)) {
    goog.labs.Promise.addUnhandledRejection_(this, x);
  }
};


/**
 * Attempts to call the {@code then} method on an object in the hopes that it is
 * a Promise-compatible instance. This allows interoperation between different
 * Promise implementations, however a non-compliant object may cause a Promise
 * to hang indefinitely. If the {@code then} method throws an exception, the
 * dependent Promise will be rejected with the thrown value.
 *
 * @see http://promisesaplus.com/#point-70
 *
 * @param {Thenable} thenable An object with a {@code then} method that may be
 *     compatible with the Promise/A+ specification.
 * @param {!Function} then The {@code then} method of the Thenable object.
 * @private
 */
goog.labs.Promise.prototype.tryThen_ = function(thenable, then) {
  this.state_ = goog.labs.Promise.State_.BLOCKED;
  var promise = this;
  var called = false;

  var resolve = function(value) {
    if (!called) {
      called = true;
      promise.unblockAndFulfill_(value);
    }
  };

  var reject = function(reason) {
    if (!called) {
      called = true;
      promise.unblockAndReject_(reason);
    }
  };

  try {
    then.call(thenable, resolve, reject);
  } catch (e) {
    reject(e);
  }
};


/**
 * Executes the pending callbacks of a resolved Promise after a timeout.
 *
 * Section 2.2.4 of the Promises/A+ specification requires that Promise
 * callbacks must only be invoked from a call stack that only contains Promise
 * implementation code, which we accomplish by invoking callback execution after
 * a timeout. If {@code startExecution_} is called multiple times for the same
 * Promise, the callback chain will be evaluated only once. Additional callbacks
 * may be added during the evaluation phase, and will be executed in the same
 * event loop.
 *
 * All Promises added to the waiting list during the same browser event loop
 * will be executed in one batch to avoid using a separate timeout per Promise.
 *
 * @private
 */
goog.labs.Promise.prototype.scheduleCallbacks_ = function() {
  if (!this.executing_) {
    this.executing_ = true;
    goog.async.run(this.executeCallbacks_, this);
  }
};


/**
 * Executes all pending callbacks for this Promise.
 *
 * @private
 */
goog.labs.Promise.prototype.executeCallbacks_ = function() {
  while (this.callbackEntries_.length) {
    var entries = this.callbackEntries_;
    this.callbackEntries_ = [];

    for (var i = 0; i < entries.length; i++) {
      if (goog.labs.Promise.LONG_STACK_TRACES) {
        this.currentStep_++;
      }
      this.executeCallback_(entries[i], this.state_, this.result_);
    }
  }
  this.executing_ = false;
};


/**
 * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}
 * or {@code onRejected} callback based on the resolved state of the Promise.
 *
 * @param {!goog.labs.Promise.CallbackEntry_} callbackEntry An entry containing
 *     the onFulfilled and/or onRejected callbacks for this step.
 * @param {goog.labs.Promise.State_} state The resolution status of the
 *     Promise, either FULFILLED or REJECTED.
 * @param {*} result The resolved result of the Promise.
 * @private
 */
goog.labs.Promise.prototype.executeCallback_ = function(
    callbackEntry, state, result) {
  if (state == goog.labs.Promise.State_.FULFILLED) {
    callbackEntry.onFulfilled(result);
  } else {
    this.removeUnhandledRejection_();
    callbackEntry.onRejected(result);
  }
};


/**
 * Records a stack trace entry for functions that call {@code then} or the
 * Promise constructor. May be disabled by unsetting {@code LONG_STACK_TRACES}.
 *
 * @param {!Error} err An Error object created by the calling function for
 *     providing a stack trace.
 * @private
 */
goog.labs.Promise.prototype.addStackTrace_ = function(err) {
  if (goog.labs.Promise.LONG_STACK_TRACES && err.stack) {
    // Extract the third line of the stack trace, which is the entry for the
    // user function that called into Promise code.
    var trace = err.stack.split('\n', 4)[3];
    var message = err.message;

    // Pad the message to align the traces.
    message += Array(11 - message.length).join(' ');
    this.stack_.push(message + trace);
  }
};


/**
 * Adds extra stack trace information to an exception for the list of
 * asynchronous {@code then} calls that have been run for this Promise. Stack
 * trace information is recorded in {@see #addStackTrace_}, and appended to
 * rethrown errors when {@code LONG_STACK_TRACES} is enabled.
 *
 * @param {*} err An unhandled exception captured during callback execution.
 * @private
 */
goog.labs.Promise.prototype.appendLongStack_ = function(err) {
  if (goog.labs.Promise.LONG_STACK_TRACES &&
      err && err.stack && this.stack_.length) {
    var longTrace = ['Promise trace:'];

    for (var promise = this; promise; promise = promise.parent_) {
      for (var i = this.currentStep_; i >= 0; i--) {
        longTrace.push(promise.stack_[i]);
      }
      longTrace.push('Value: ' +
          '[' + (promise.state_ == goog.labs.Promise.State_.REJECTED ?
              'REJECTED' : 'FULFILLED') + '] ' +
          '<' + String(promise.result_) + '>');
    }
    err.stack += '\n\n' + longTrace.join('\n');
  }
};


/**
 * Marks this rejected Promise as having being handled. Also marks any parent
 * Promises in the rejected state as handled. The rejection handler will no
 * longer be invoked for this Promise (if it has not been called already).
 *
 * @private
 */
goog.labs.Promise.prototype.removeUnhandledRejection_ = function() {
  if (goog.labs.Promise.UNHANDLED_REJECTION_DELAY > 0) {
    for (var p = this; p && p.unhandledRejectionId_; p = p.parent_) {
      goog.global.clearTimeout(p.unhandledRejectionId_);
      p.unhandledRejectionId_ = 0;
    }
  } else if (goog.labs.Promise.UNHANDLED_REJECTION_DELAY == 0) {
    for (var p = this; p && p.hadUnhandledRejection_; p = p.parent_) {
      p.hadUnhandledRejection_ = false;
    }
  }
};


/**
 * Marks this rejected Promise as unhandled. If no {@code onRejected} callback
 * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}
 * expires, the reason will be passed to the unhandled rejection handler. The
 * handler typically rethrows the rejection reason so that it becomes visible in
 * the developer console.
 *
 * @param {!goog.labs.Promise} promise The rejected Promise.
 * @param {*} reason The Promise rejection reason.
 * @private
 */
goog.labs.Promise.addUnhandledRejection_ = function(promise, reason) {
  if (goog.labs.Promise.UNHANDLED_REJECTION_DELAY > 0) {
    promise.unhandledRejectionId_ = goog.global.setTimeout(function() {
      promise.appendLongStack_(reason);
      goog.labs.Promise.handleRejection_.call(null, reason);
    }, goog.labs.Promise.UNHANDLED_REJECTION_DELAY);

  } else if (goog.labs.Promise.UNHANDLED_REJECTION_DELAY == 0) {
    promise.hadUnhandledRejection_ = true;
    goog.async.run(function() {
      if (promise.hadUnhandledRejection_) {
        promise.appendLongStack_(reason);
        goog.labs.Promise.handleRejection_.call(null, reason);
      }
    });
  }
};


/**
 * A method that is invoked with the rejection reasons for Promises that are
 * rejected but have no {@code onRejected} callbacks registered yet.
 * @type {function(*)}
 * @private
 */
goog.labs.Promise.handleRejection_ = goog.async.throwException;


/**
 * Sets a handler that will be called with reasons from unhandled rejected
 * Promises. If the rejected Promise (or one of its descendants) has an
 * {@code onRejected} callback registered, the rejection will be considered
 * handled, and the rejection handler will not be called.
 *
 * By default, unhandled rejections are rethrown so that the error may be
 * captured by the developer console or a {@code window.onerror} handler.
 *
 * @param {function(*)} handler A function that will be called with reasons from
 *     rejected Promises. Defaults to {@code goog.async.throwException}.
 */
goog.labs.Promise.setUnhandledRejectionHandler = function(handler) {
  goog.labs.Promise.handleRejection_ = handler;
};



/**
 * Error used as a rejection reason for canceled Promises.
 *
 * @param {string=} opt_message
 * @constructor
 * @extends {goog.debug.Error}
 * @final
 */
goog.labs.Promise.CancellationError = function(opt_message) {
  goog.base(this, opt_message);
};
goog.inherits(goog.labs.Promise.CancellationError, goog.debug.Error);


/** @override */
goog.labs.Promise.CancellationError.prototype.name = 'cancel';

//third_party/javascript/closure/mochikit/async/deferred.js
// Copyright 2007 Bob Ippolito. All Rights Reserved.
// Modifications Copyright 2009 The Closure Library Authors. All Rights
// Reserved.

/**
 * @license Portions of this code are from MochiKit, received by
 * The Closure Authors under the MIT license. All other code is Copyright
 * 2005-2009 The Closure Authors. All Rights Reserved.
 */

/**
 * @fileoverview Classes for tracking asynchronous operations and handling the
 * results. The Deferred object here is patterned after the Deferred object in
 * the Twisted python networking framework.
 *
 * See: http://twistedmatrix.com/projects/core/documentation/howto/defer.html
 *
 * Based on the Dojo code which in turn is based on the MochiKit code.
 *
 * @author abefettig@google.com (Abe Fettig)
 * @author arv@google.com (Erik Arvidsson)
 * @author brenneman@google.com (Shawn Brenneman)
 */

goog.provide('goog.async.Deferred');
goog.provide('goog.async.Deferred.AlreadyCalledError');
goog.provide('goog.async.Deferred.CanceledError');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug.Error');
goog.require('goog.labs.Promise');
goog.require('goog.labs.Thenable');



/**
 * A Deferred represents the result of an asynchronous operation. A Deferred
 * instance has no result when it is created, and is "fired" (given an initial
 * result) by calling {@code callback} or {@code errback}.
 *
 * Once fired, the result is passed through a sequence of callback functions
 * registered with {@code addCallback} or {@code addErrback}. The functions may
 * mutate the result before it is passed to the next function in the sequence.
 *
 * Callbacks and errbacks may be added at any time, including after the Deferred
 * has been "fired". If there are no pending actions in the execution sequence
 * of a fired Deferred, any new callback functions will be called with the last
 * computed result. Adding a callback function is the only way to access the
 * result of the Deferred.
 *
 * If a Deferred operation is canceled, an optional user-provided cancellation
 * function is invoked which may perform any special cleanup, followed by firing
 * the Deferred's errback sequence with a {@code CanceledError}. If the
 * Deferred has already fired, cancellation is ignored.
 *
 * Deferreds may be templated to a specific type they produce using generics
 * with syntax such as:
 * <code>
 *   /** @type {goog.async.Deferred.<string>} *&#47;
 *   var d = new goog.async.Deferred();
 *   // Compiler can infer that foo is a string.
 *   d.addCallback(function(foo) {...});
 *   d.callback('string');  // Checked to be passed a string
 * </code>
 * Since deferreds are often used to produce different values across a chain,
 * the type information is not propagated across chains, but rather only
 * associated with specifically cast objects.
 *
 * @param {Function=} opt_onCancelFunction A function that will be called if the
 *     Deferred is canceled. If provided, this function runs before the
 *     Deferred is fired with a {@code CanceledError}.
 * @param {Object=} opt_defaultScope The default object context to call
 *     callbacks and errbacks in.
 * @constructor
 * @implements {goog.labs.Thenable.<VALUE>}
 * @template VALUE
 */
goog.async.Deferred = function(opt_onCancelFunction, opt_defaultScope) {
  /**
   * Entries in the sequence are arrays containing a callback, an errback, and
   * an optional scope. The callback or errback in an entry may be null.
   * @type {!Array.<!Array>}
   * @private
   */
  this.sequence_ = [];

  /**
   * Optional function that will be called if the Deferred is canceled.
   * @type {Function|undefined}
   * @private
   */
  this.onCancelFunction_ = opt_onCancelFunction;

  /**
   * The default scope to execute callbacks and errbacks in.
   * @type {Object}
   * @private
   */
  this.defaultScope_ = opt_defaultScope || null;

  /**
   * Whether the Deferred has been fired.
   * @type {boolean}
   * @private
   */
  this.fired_ = false;

  /**
   * Whether the last result in the execution sequence was an error.
   * @type {boolean}
   * @private
   */
  this.hadError_ = false;

  /**
   * The current Deferred result, updated as callbacks and errbacks are
   * executed.
   * @type {*}
   * @private
   */
  this.result_ = undefined;

  /**
   * Whether the Deferred is blocked waiting on another Deferred to fire. If a
   * callback or errback returns a Deferred as a result, the execution sequence
   * is blocked until that Deferred result becomes available.
   * @type {boolean}
   * @private
   */
  this.blocked_ = false;

  /**
   * Whether this Deferred is blocking execution of another Deferred. If this
   * instance was returned as a result in another Deferred's execution
   * sequence,that other Deferred becomes blocked until this instance's
   * execution sequence completes. No additional callbacks may be added to a
   * Deferred once it is blocking another instance.
   * @type {boolean}
   * @private
   */
  this.blocking_ = false;

  /**
   * Whether the Deferred has been canceled without having a custom cancel
   * function.
   * @type {boolean}
   * @private
   */
  this.silentlyCanceled_ = false;

  /**
   * If an error is thrown during Deferred execution with no errback to catch
   * it, the error is rethrown after a timeout. Reporting the error after a
   * timeout allows execution to continue in the calling context (empty when
   * no error is scheduled).
   * @type {number}
   * @private
   */
  this.unhandledErrorId_ = 0;

  /**
   * If this Deferred was created by branch(), this will be the "parent"
   * Deferred.
   * @type {goog.async.Deferred}
   * @private
   */
  this.parent_ = null;

  /**
   * The number of Deferred objects that have been branched off this one. This
   * will be decremented whenever a branch is fired or canceled.
   * @type {number}
   * @private
   */
  this.branches_ = 0;

  if (goog.async.Deferred.LONG_STACK_TRACES) {
    /**
     * Holds the stack trace at time of deferred creation if the JS engine
     * provides the Error.captureStackTrace API.
     * @private {?string}
     */
    this.constructorStack_ = null;
    if (Error.captureStackTrace) {
      var target = { stack: '' };
      Error.captureStackTrace(target, goog.async.Deferred);
      // Check if Error.captureStackTrace worked. It fails in gjstest.
      if (typeof target.stack == 'string') {
        // Remove first line and force stringify to prevent memory leak due to
        // holding on to actual stack frames.
        this.constructorStack_ = target.stack.replace(/^[^\n]*\n/, '');
      }
    }
  }
};


/**
 * @define {boolean} Whether unhandled errors should always get rethrown to the
 * global scope. Defaults to the value of goog.DEBUG.
 */
goog.define('goog.async.Deferred.STRICT_ERRORS', false);


/**
 * @define {boolean} Whether to attempt to make stack traces long.  Defaults to
 * the value of goog.DEBUG.
 */
goog.define('goog.async.Deferred.LONG_STACK_TRACES', goog.DEBUG);


/**
 * Cancels a Deferred that has not yet been fired, or is blocked on another
 * deferred operation. If this Deferred is waiting for a blocking Deferred to
 * fire, the blocking Deferred will also be canceled.
 *
 * If this Deferred was created by calling branch() on a parent Deferred with
 * opt_propagateCancel set to true, the parent may also be canceled. If
 * opt_deepCancel is set, cancel() will be called on the parent (as well as any
 * other ancestors if the parent is also a branch). If one or more branches were
 * created with opt_propagateCancel set to true, the parent will be canceled if
 * cancel() is called on all of those branches.
 *
 * @param {boolean=} opt_deepCancel If true, cancels this Deferred's parent even
 *     if cancel() hasn't been called on some of the parent's branches. Has no
 *     effect on a branch without opt_propagateCancel set to true.
 */
goog.async.Deferred.prototype.cancel = function(opt_deepCancel) {
  if (!this.hasFired()) {
    if (this.parent_) {
      // Get rid of the parent reference before potentially running the parent's
      // canceler function to ensure that this cancellation isn't
      // double-counted.
      var parent = this.parent_;
      delete this.parent_;
      if (opt_deepCancel) {
        parent.cancel(opt_deepCancel);
      } else {
        parent.branchCancel_();
      }
    }

    if (this.onCancelFunction_) {
      // Call in user-specified scope.
      this.onCancelFunction_.call(this.defaultScope_, this);
    } else {
      this.silentlyCanceled_ = true;
    }
    if (!this.hasFired()) {
      this.errback(new goog.async.Deferred.CanceledError(this));
    }
  } else if (this.result_ instanceof goog.async.Deferred) {
    this.result_.cancel();
  }
};


/**
 * Handle a single branch being canceled. Once all branches are canceled, this
 * Deferred will be canceled as well.
 *
 * @private
 */
goog.async.Deferred.prototype.branchCancel_ = function() {
  this.branches_--;
  if (this.branches_ <= 0) {
    this.cancel();
  }
};


/**
 * Called after a blocking Deferred fires. Unblocks this Deferred and resumes
 * its execution sequence.
 *
 * @param {boolean} isSuccess Whether the result is a success or an error.
 * @param {*} res The result of the blocking Deferred.
 * @private
 */
goog.async.Deferred.prototype.continue_ = function(isSuccess, res) {
  this.blocked_ = false;
  this.updateResult_(isSuccess, res);
};


/**
 * Updates the current result based on the success or failure of the last action
 * in the execution sequence.
 *
 * @param {boolean} isSuccess Whether the new result is a success or an error.
 * @param {*} res The result.
 * @private
 */
goog.async.Deferred.prototype.updateResult_ = function(isSuccess, res) {
  this.fired_ = true;
  this.result_ = res;
  this.hadError_ = !isSuccess;
  this.fire_();
};


/**
 * Verifies that the Deferred has not yet been fired.
 *
 * @private
 * @throws {Error} If this has already been fired.
 */
goog.async.Deferred.prototype.check_ = function() {
  if (this.hasFired()) {
    if (!this.silentlyCanceled_) {
      throw new goog.async.Deferred.AlreadyCalledError(this);
    }
    this.silentlyCanceled_ = false;
  }
};


/**
 * Fire the execution sequence for this Deferred by passing the starting result
 * to the first registered callback.
 * @param {VALUE=} opt_result The starting result.
 */
goog.async.Deferred.prototype.callback = function(opt_result) {
  this.check_();
  this.assertNotDeferred_(opt_result);
  this.updateResult_(true /* isSuccess */, opt_result);
};


/**
 * Fire the execution sequence for this Deferred by passing the starting error
 * result to the first registered errback.
 * @param {*=} opt_result The starting error.
 */
goog.async.Deferred.prototype.errback = function(opt_result) {
  this.check_();
  this.assertNotDeferred_(opt_result);
  this.makeStackTraceLong_(opt_result);
  this.updateResult_(false /* isSuccess */, opt_result);
};


/**
 * Attempt to make the error's stack trace be long in that it contains the
 * stack trace from the point where the deferred was created on top of the
 * current stack trace to give additional context.
 * @param {*} error
 * @private
 */
goog.async.Deferred.prototype.makeStackTraceLong_ = function(error) {
  if (!goog.async.Deferred.LONG_STACK_TRACES) {
    return;
  }
  if (this.constructorStack_ && goog.isObject(error) && error.stack &&
      // Stack looks like it was system generated. See
      // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
      (/^[^\n]+(\n   [^\n]+)+/).test(error.stack)) {
    error.stack = error.stack + '\nDEFERRED OPERATION:\n' +
        this.constructorStack_;
  }
};


/**
 * Asserts that an object is not a Deferred.
 * @param {*} obj The object to test.
 * @throws {Error} Throws an exception if the object is a Deferred.
 * @private
 */
goog.async.Deferred.prototype.assertNotDeferred_ = function(obj) {
  goog.asserts.assert(
      !(obj instanceof goog.async.Deferred),
      'An execution sequence may not be initiated with a blocking Deferred.');
};


/**
 * Register a callback function to be called with a successful result. If no
 * value is returned by the callback function, the result value is unchanged. If
 * a new value is returned, it becomes the Deferred result and will be passed to
 * the next callback in the execution sequence.
 *
 * If the function throws an error, the error becomes the new result and will be
 * passed to the next errback in the execution chain.
 *
 * If the function returns a Deferred, the execution sequence will be blocked
 * until that Deferred fires. Its result will be passed to the next callback (or
 * errback if it is an error result) in this Deferred's execution sequence.
 *
 * @param {!function(this:T,VALUE):?} cb The function to be called with a
 *     successful result.
 * @param {T=} opt_scope An optional scope to call the callback in.
 * @return {!goog.async.Deferred} This Deferred.
 * @template T
 */
goog.async.Deferred.prototype.addCallback = function(cb, opt_scope) {
  return this.addCallbacks(cb, null, opt_scope);
};


/**
 * Register a callback function to be called with an error result. If no value
 * is returned by the function, the error result is unchanged. If a new error
 * value is returned or thrown, that error becomes the Deferred result and will
 * be passed to the next errback in the execution sequence.
 *
 * If the errback function handles the error by returning a non-error value,
 * that result will be passed to the next normal callback in the sequence.
 *
 * If the function returns a Deferred, the execution sequence will be blocked
 * until that Deferred fires. Its result will be passed to the next callback (or
 * errback if it is an error result) in this Deferred's execution sequence.
 *
 * @param {!function(this:T,?):?} eb The function to be called on an
 *     unsuccessful result.
 * @param {T=} opt_scope An optional scope to call the errback in.
 * @return {!goog.async.Deferred.<VALUE>} This Deferred.
 * @template T
 */
goog.async.Deferred.prototype.addErrback = function(eb, opt_scope) {
  return this.addCallbacks(null, eb, opt_scope);
};


/**
 * Registers one function as both a callback and errback.
 *
 * @param {!function(this:T,?):?} f The function to be called on any result.
 * @param {T=} opt_scope An optional scope to call the function in.
 * @return {!goog.async.Deferred} This Deferred.
 * @template T
 */
goog.async.Deferred.prototype.addBoth = function(f, opt_scope) {
  return this.addCallbacks(f, f, opt_scope);
};


/**
 * Registers a callback function and an errback function at the same position
 * in the execution sequence. Only one of these functions will execute,
 * depending on the error state during the execution sequence.
 *
 * NOTE: This is not equivalent to {@code def.addCallback().addErrback()}! If
 * the callback is invoked, the errback will be skipped, and vice versa.
 *
 * @param {(function(this:T,VALUE):?)|null} cb The function to be called on a
 *     successful result.
 * @param {(function(this:T,?):?)|null} eb The function to be called on an
 *     unsuccessful result.
 * @param {T=} opt_scope An optional scope to call the functions in.
 * @return {!goog.async.Deferred} This Deferred.
 * @template T
 */
goog.async.Deferred.prototype.addCallbacks = function(cb, eb, opt_scope) {
  goog.asserts.assert(!this.blocking_, 'Blocking Deferreds can not be re-used');
  this.sequence_.push([cb, eb, opt_scope]);
  if (this.hasFired()) {
    this.fire_();
  }
  return this;
};


/**
 * ATTENTION: This is labs code.
 *
 * Implements {@see goog.labs.Thenable} for seamless integration with
 * {@see goog.labs.Promise}.
 * Deferred results are mutable and may represent multiple values over
 * their lifetime. Calling {@code then} on a Deferred returns a Promise
 * with the result of the Deferred at that point in its callback chain.
 * Note that if the Deferred result is never mutated, and only
 * {@code then} calls are made, the Deferred will behave like a Promise.
 *
 * @param {(function(this:THIS, VALUE):
 *          (RESULT|goog.labs.Thenable.<RESULT>|Thenable))=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fullfilled.
 * @param {(function(*): *)=} opt_onRejected A function that will be invoked
 *     with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 * @return {!goog.labs.Promise.<RESULT>} A new Promise that will receive the
 *     result of the fulfillment or rejection callback.
 * @template RESULT,THIS
 * @override
 */
goog.async.Deferred.prototype.then = function(opt_onFulfilled, opt_onRejected,
    opt_context) {
  var resolve, reject;
  var promise = new goog.labs.Promise(function(res, rej) {
    // Copying resolvers to outer scope, so that they are available when the
    // deferred callback fires (which may be synchronous).
    resolve = res;
    reject = rej;
  });
  this.addCallbacks(resolve, function(reason) {
    if (reason instanceof goog.async.Deferred.CanceledError) {
      promise.cancel();
    } else {
      reject(reason);
    }
  });
  return promise.then(opt_onFulfilled, opt_onRejected, opt_context);
};
goog.labs.Thenable.addImplementation(goog.async.Deferred);


/**
 * Links another Deferred to the end of this Deferred's execution sequence. The
 * result of this execution sequence will be passed as the starting result for
 * the chained Deferred, invoking either its first callback or errback.
 *
 * @param {!goog.async.Deferred} otherDeferred The Deferred to chain.
 * @return {!goog.async.Deferred} This Deferred.
 */
goog.async.Deferred.prototype.chainDeferred = function(otherDeferred) {
  this.addCallbacks(
      otherDeferred.callback, otherDeferred.errback, otherDeferred);
  return this;
};


/**
 * Makes this Deferred wait for another Deferred's execution sequence to
 * complete before continuing.
 *
 * This is equivalent to adding a callback that returns {@code otherDeferred},
 * but doesn't prevent additional callbacks from being added to
 * {@code otherDeferred}.
 *
 * @param {!goog.async.Deferred} otherDeferred The Deferred to wait for.
 * @return {!goog.async.Deferred} This Deferred.
 */
goog.async.Deferred.prototype.awaitDeferred = function(otherDeferred) {
  return this.addCallback(goog.bind(otherDeferred.branch, otherDeferred));
};


/**
 * Creates a branch off this Deferred's execution sequence, and returns it as a
 * new Deferred. The branched Deferred's starting result will be shared with the
 * parent at the point of the branch, even if further callbacks are added to the
 * parent.
 *
 * All branches at the same stage in the execution sequence will receive the
 * same starting value.
 *
 * @param {boolean=} opt_propagateCancel If cancel() is called on every child
 *     branch created with opt_propagateCancel, the parent will be canceled as
 *     well.
 * @return {!goog.async.Deferred.<VALUE>} A Deferred that will be started with
 *     the computed result from this stage in the execution sequence.
 */
goog.async.Deferred.prototype.branch = function(opt_propagateCancel) {
  var d = new goog.async.Deferred();
  this.chainDeferred(d);
  if (opt_propagateCancel) {
    d.parent_ = this;
    this.branches_++;
  }
  return d;
};


/**
 * @return {boolean} Whether the execution sequence has been started on this
 *     Deferred by invoking {@code callback} or {@code errback}.
 */
goog.async.Deferred.prototype.hasFired = function() {
  return this.fired_;
};


/**
 * @param {*} res The latest result in the execution sequence.
 * @return {boolean} Whether the current result is an error that should cause
 *     the next errback to fire. May be overridden by subclasses to handle
 *     special error types.
 * @protected
 */
goog.async.Deferred.prototype.isError = function(res) {
  return res instanceof Error;
};


/**
 * @return {boolean} Whether an errback exists in the remaining sequence.
 * @private
 */
goog.async.Deferred.prototype.hasErrback_ = function() {
  return goog.array.some(this.sequence_, function(sequenceRow) {
    // The errback is the second element in the array.
    return goog.isFunction(sequenceRow[1]);
  });
};


/**
 * Exhausts the execution sequence while a result is available. The result may
 * be modified by callbacks or errbacks, and execution will block if the
 * returned result is an incomplete Deferred.
 *
 * @private
 */
goog.async.Deferred.prototype.fire_ = function() {
  if (this.unhandledErrorId_ && this.hasFired() && this.hasErrback_()) {
    // It is possible to add errbacks after the Deferred has fired. If a new
    // errback is added immediately after the Deferred encountered an unhandled
    // error, but before that error is rethrown, the error is unscheduled.
    goog.async.Deferred.unscheduleError_(this.unhandledErrorId_);
    this.unhandledErrorId_ = 0;
  }

  if (this.parent_) {
    this.parent_.branches_--;
    delete this.parent_;
  }

  var res = this.result_;
  var unhandledException = false;
  var isNewlyBlocked = false;

  while (this.sequence_.length && !this.blocked_) {
    var sequenceEntry = this.sequence_.shift();

    var callback = sequenceEntry[0];
    var errback = sequenceEntry[1];
    var scope = sequenceEntry[2];

    var f = this.hadError_ ? errback : callback;
    if (f) {
      /** @preserveTry */
      try {
        var ret = f.call(scope || this.defaultScope_, res);

        // If no result, then use previous result.
        if (goog.isDef(ret)) {
          // Bubble up the error as long as the return value hasn't changed.
          this.hadError_ = this.hadError_ && (ret == res || this.isError(ret));
          this.result_ = res = ret;
        }

        if (goog.labs.Thenable.isImplementedBy(res)) {
          isNewlyBlocked = true;
          this.blocked_ = true;
        }

      } catch (ex) {
        res = ex;
        this.hadError_ = true;
        this.makeStackTraceLong_(res);

        if (!this.hasErrback_()) {
          // If an error is thrown with no additional errbacks in the queue,
          // prepare to rethrow the error.
          unhandledException = true;
        }
      }
    }
  }

  this.result_ = res;

  if (isNewlyBlocked) {
    var onCallback = goog.bind(this.continue_, this, true /* isSuccess */);
    var onErrback = goog.bind(this.continue_, this, false /* isSuccess */);

    if (res instanceof goog.async.Deferred) {
      res.addCallbacks(onCallback, onErrback);
      res.blocking_ = true;
    } else {
      res.then(onCallback, onErrback);
    }
  } else if (goog.async.Deferred.STRICT_ERRORS && this.isError(res) &&
      !(res instanceof goog.async.Deferred.CanceledError)) {
    this.hadError_ = true;
    unhandledException = true;
  }

  if (unhandledException) {
    // Rethrow the unhandled error after a timeout. Execution will continue, but
    // the error will be seen by global handlers and the user. The throw will
    // be canceled if another errback is appended before the timeout executes.
    // The error's original stack trace is preserved where available.
    this.unhandledErrorId_ = goog.async.Deferred.scheduleError_(res);
  }
};


/**
 * Creates a Deferred that has an initial result.
 *
 * @param {*=} opt_result The result.
 * @return {!goog.async.Deferred} The new Deferred.
 */
goog.async.Deferred.succeed = function(opt_result) {
  var d = new goog.async.Deferred();
  d.callback(opt_result);
  return d;
};


/**
 * Creates a Deferred that has an initial error result.
 *
 * @param {*} res The error result.
 * @return {!goog.async.Deferred} The new Deferred.
 */
goog.async.Deferred.fail = function(res) {
  var d = new goog.async.Deferred();
  d.errback(res);
  return d;
};


/**
 * Creates a Deferred that has already been canceled.
 *
 * @return {!goog.async.Deferred} The new Deferred.
 */
goog.async.Deferred.canceled = function() {
  var d = new goog.async.Deferred();
  d.cancel();
  return d;
};


/**
 * Normalizes values that may or may not be Deferreds.
 *
 * If the input value is a Deferred, the Deferred is branched (so the original
 * execution sequence is not modified) and the input callback added to the new
 * branch. The branch is returned to the caller.
 *
 * If the input value is not a Deferred, the callback will be executed
 * immediately and an already firing Deferred will be returned to the caller.
 *
 * In the following (contrived) example, if <code>isImmediate</code> is true
 * then 3 is alerted immediately, otherwise 6 is alerted after a 2-second delay.
 *
 * <pre>
 * var value;
 * if (isImmediate) {
 *   value = 3;
 * } else {
 *   value = new goog.async.Deferred();
 *   setTimeout(function() { value.callback(6); }, 2000);
 * }
 *
 * var d = goog.async.Deferred.when(value, alert);
 * </pre>
 *
 * @param {*} value Deferred or normal value to pass to the callback.
 * @param {!function(this:T, ?):?} callback The callback to execute.
 * @param {T=} opt_scope An optional scope to call the callback in.
 * @return {!goog.async.Deferred} A new Deferred that will call the input
 *     callback with the input value.
 * @template T
 */
goog.async.Deferred.when = function(value, callback, opt_scope) {
  if (value instanceof goog.async.Deferred) {
    return value.branch(true).addCallback(callback, opt_scope);
  } else {
    return goog.async.Deferred.succeed(value).addCallback(callback, opt_scope);
  }
};



/**
 * An error sub class that is used when a Deferred has already been called.
 * @param {!goog.async.Deferred} deferred The Deferred.
 *
 * @constructor
 * @extends {goog.debug.Error}
 */
goog.async.Deferred.AlreadyCalledError = function(deferred) {
  goog.debug.Error.call(this);

  /**
   * The Deferred that raised this error.
   * @type {goog.async.Deferred}
   */
  this.deferred = deferred;
};
goog.inherits(goog.async.Deferred.AlreadyCalledError, goog.debug.Error);


/** @override */
goog.async.Deferred.AlreadyCalledError.prototype.message =
    'Deferred has already fired';


/** @override */
goog.async.Deferred.AlreadyCalledError.prototype.name = 'AlreadyCalledError';



/**
 * An error sub class that is used when a Deferred is canceled.
 *
 * @param {!goog.async.Deferred} deferred The Deferred object.
 * @constructor
 * @extends {goog.debug.Error}
 */
goog.async.Deferred.CanceledError = function(deferred) {
  goog.debug.Error.call(this);

  /**
   * The Deferred that raised this error.
   * @type {goog.async.Deferred}
   */
  this.deferred = deferred;
};
goog.inherits(goog.async.Deferred.CanceledError, goog.debug.Error);


/** @override */
goog.async.Deferred.CanceledError.prototype.message = 'Deferred was canceled';


/** @override */
goog.async.Deferred.CanceledError.prototype.name = 'CanceledError';



/**
 * Wrapper around errors that are scheduled to be thrown by failing deferreds
 * after a timeout.
 * @param {number} id Id of this error.
 * @param {*} error Error from a failing deferred.
 *
 * @constructor
 * @final
 * @private
 * @struct
 */
goog.async.Deferred.Error_ = function(id, error) {
  /**
   * @const
   * @private
   */
  this.id_ = id;

  /**
   * @const
   * @private
   */
  this.error_ = error;

  /** @private {number} */
  this.timeoutId_ = goog.global.setTimeout(goog.bind(this.throwError, this), 0);
};


/**
 * Actually throws the error and removes it from the list of pending
 * deferred errors.
 */
goog.async.Deferred.Error_.prototype.throwError = function() {
  goog.asserts.assert(goog.async.Deferred.errorMap_[this.id_],
      'Cannot throw an error that is not scheduled.');
  delete goog.async.Deferred.errorMap_[this.id_];
  throw this.error_;
};


/**
 * Resets the error throw timer.
 */
goog.async.Deferred.Error_.prototype.resetTimer = function() {
  goog.global.clearTimeout(this.timeoutId_);
};


/**
 * @type {!Object.<string|goog.async.Deferred.Error_>}
 * @private
 */
goog.async.Deferred.errorMap_ = {};


/**
 * @type {number}
 * @private
 */
goog.async.Deferred.errorCounter_ = 0;


/**
 * Schedules an error to be thrown after a delay.
 * @param {*} error Error from a failing deferred.
 * @return {number} Id of the error.
 * @private
 */
goog.async.Deferred.scheduleError_ = function(error) {
  var id = ++goog.async.Deferred.errorCounter_;
  goog.async.Deferred.errorMap_[id] = new goog.async.Deferred.Error_(id, error);
  return id;
};


/**
 * Unschedules an error from being thrown.
 * @param {number} id Id of the deferred error to unschedule.
 * @private
 */
goog.async.Deferred.unscheduleError_ = function(id) {
  var error = goog.async.Deferred.errorMap_[id];
  if (error) {
    error.resetTimer();
    delete goog.async.Deferred.errorMap_[id];
  }
};


/**
 * Asserts that there are no pending deferred errors. If there are any
 * scheduled errors, one will be thrown immediately to make this function fail.
 */
goog.async.Deferred.assertNoErrors = function() {
  var map = goog.async.Deferred.errorMap_;
  for (var key in map) {
    var error = map[key];
    error.resetTimer();
    error.throwError();
  }
};

//javascript/apps/drive/dataservice/sync/commandmanager.js
goog.provide('drive.ds.sync.CommandManager');

goog.require('goog.Disposable');
goog.require('goog.async.Deferred');
goog.require('goog.structs.Queue');



/**
 * A command manager responsible for maintaining a queue of pending commands
 * that need to be executed.
 * @extends {goog.Disposable}
 * @constructor
 * @template T
 */
drive.ds.sync.CommandManager = function() {
  /**
   * @private {!goog.structs.Queue.<T>} A FIFO queue of commands to process.
   */
  this.commands_ = new goog.structs.Queue();

  /** @private {boolean} Whether dependencies have been initialized. */
  this.initialized_ = false;
};
goog.inherits(drive.ds.sync.CommandManager, goog.Disposable);


/**
 * Perform initialization. By default this calls markInitialized, if this
 * method is overrided, be sure to call markInitialized once initialization
 * is complete.
 */
drive.ds.sync.CommandManager.prototype.initialize = function() {
  this.markInitialized();
};


/**
 * Marks dependencies as initialized and begins processing requests.
 * @protected
 */
drive.ds.sync.CommandManager.prototype.markInitialized = function() {
  this.initialized_ = true;
  this.process_();
};


/**
 * Processes the command queue if dependencies are initialized.
 * @private
 */
drive.ds.sync.CommandManager.prototype.process_ = function() {
  if (this.initialized_) {
    var command;
    while (command = this.commands_.dequeue()) {
      this.processCommand(command);
    }
  }
};


/**
 * Processes a particular command.
 * @param {!drive.ds.sync.CommandManager.CommandWrapper} commandWrapper The
 *     command wrapper.
 * @protected
 */
drive.ds.sync.CommandManager.prototype.processCommand = goog.abstractMethod;


/**
 * Queues up a command.
 * @param {!T} command The command request.
 * @return {!goog.async.Deferred} deferred The deferred to call once the command
 *     has been executed.
 */
drive.ds.sync.CommandManager.prototype.enqueue = function(command) {
  var deferred = new goog.async.Deferred();

  var commandWrapper =
      new drive.ds.sync.CommandManager.CommandWrapper(command, deferred);
  this.commands_.enqueue(commandWrapper);
  this.process_();

  return deferred;
};



/**
 * A command wrapper object that holds the command and deferred object that
 * accepts a command success or failure.
 * @param {!T} command The command to be executed.
 * @param {!goog.async.Deferred} deferred The deferred to call once the command
 *     has been executed.
 * @constructor
 * @template T
 */
drive.ds.sync.CommandManager.CommandWrapper = function(command, deferred) {
  /** @private {T} The commmand to be executed. */
  this.command_ = command;

  /**
   * The deferred to call once the command has been executed.
   * @private {!goog.async.Deferred}
   */
  this.deferred_ = deferred;
};


/**
 * @return {!T} command The command to be executed.
 */
drive.ds.sync.CommandManager.CommandWrapper.prototype.getCommand =
    function() {
  return this.command_;
};


/**
 * @return {!goog.async.Deferred} The deferred to call once the command
 *     has been executed.
 */
drive.ds.sync.CommandManager.CommandWrapper.prototype.getDeferred =
    function() {
  return this.deferred_;
};

//javascript/closure/structs/collection.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines the collection interface.
 *
 * @author nnaze@google.com (Nathan Naze)
 */

goog.provide('goog.structs.Collection');



/**
 * An interface for a collection of values.
 * @interface
 * @template T
 */
goog.structs.Collection = function() {};


/**
 * @param {T} value Value to add to the collection.
 */
goog.structs.Collection.prototype.add;


/**
 * @param {T} value Value to remove from the collection.
 */
goog.structs.Collection.prototype.remove;


/**
 * @param {T} value Value to find in the collection.
 * @return {boolean} Whether the collection contains the specified value.
 */
goog.structs.Collection.prototype.contains;


/**
 * @return {number} The number of values stored in the collection.
 */
goog.structs.Collection.prototype.getCount;


//javascript/closure/math/math.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Additional mathematical functions.
 * @author pupius@google.com (Daniel Pupius)
 */

goog.provide('goog.math');

goog.require('goog.array');
goog.require('goog.asserts');


/**
 * Returns a random integer greater than or equal to 0 and less than {@code a}.
 * @param {number} a  The upper bound for the random integer (exclusive).
 * @return {number} A random integer N such that 0 <= N < a.
 */
goog.math.randomInt = function(a) {
  return Math.floor(Math.random() * a);
};


/**
 * Returns a random number greater than or equal to {@code a} and less than
 * {@code b}.
 * @param {number} a  The lower bound for the random number (inclusive).
 * @param {number} b  The upper bound for the random number (exclusive).
 * @return {number} A random number N such that a <= N < b.
 */
goog.math.uniformRandom = function(a, b) {
  return a + Math.random() * (b - a);
};


/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
goog.math.clamp = function(value, min, max) {
  return Math.min(Math.max(value, min), max);
};


/**
 * The % operator in JavaScript returns the remainder of a / b, but differs from
 * some other languages in that the result will have the same sign as the
 * dividend. For example, -1 % 8 == -1, whereas in some other languages
 * (such as Python) the result would be 7. This function emulates the more
 * correct modulo behavior, which is useful for certain applications such as
 * calculating an offset index in a circular list.
 *
 * @param {number} a The dividend.
 * @param {number} b The divisor.
 * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
 *     or b < x <= 0, depending on the sign of b).
 */
goog.math.modulo = function(a, b) {
  var r = a % b;
  // If r and b differ in sign, add b to wrap the result to the correct sign.
  return (r * b < 0) ? r + b : r;
};


/**
 * Performs linear interpolation between values a and b. Returns the value
 * between a and b proportional to x (when x is between 0 and 1. When x is
 * outside this range, the return value is a linear extrapolation).
 * @param {number} a A number.
 * @param {number} b A number.
 * @param {number} x The proportion between a and b.
 * @return {number} The interpolated value between a and b.
 */
goog.math.lerp = function(a, b, x) {
  return a + x * (b - a);
};


/**
 * Tests whether the two values are equal to each other, within a certain
 * tolerance to adjust for floating point errors.
 * @param {number} a A number.
 * @param {number} b A number.
 * @param {number=} opt_tolerance Optional tolerance range. Defaults
 *     to 0.000001. If specified, should be greater than 0.
 * @return {boolean} Whether {@code a} and {@code b} are nearly equal.
 */
goog.math.nearlyEquals = function(a, b, opt_tolerance) {
  return Math.abs(a - b) <= (opt_tolerance || 0.000001);
};


/**
 * Standardizes an angle to be in range [0-360). Negative angles become
 * positive, and values greater than 360 are returned modulo 360.
 * @param {number} angle Angle in degrees.
 * @return {number} Standardized angle.
 */
goog.math.standardAngle = function(angle) {
  return goog.math.modulo(angle, 360);
};


/**
 * Converts degrees to radians.
 * @param {number} angleDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
goog.math.toRadians = function(angleDegrees) {
  return angleDegrees * Math.PI / 180;
};


/**
 * Converts radians to degrees.
 * @param {number} angleRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
goog.math.toDegrees = function(angleRadians) {
  return angleRadians * 180 / Math.PI;
};


/**
 * For a given angle and radius, finds the X portion of the offset.
 * @param {number} degrees Angle in degrees (zero points in +X direction).
 * @param {number} radius Radius.
 * @return {number} The x-distance for the angle and radius.
 */
goog.math.angleDx = function(degrees, radius) {
  return radius * Math.cos(goog.math.toRadians(degrees));
};


/**
 * For a given angle and radius, finds the Y portion of the offset.
 * @param {number} degrees Angle in degrees (zero points in +X direction).
 * @param {number} radius Radius.
 * @return {number} The y-distance for the angle and radius.
 */
goog.math.angleDy = function(degrees, radius) {
  return radius * Math.sin(goog.math.toRadians(degrees));
};


/**
 * Computes the angle between two points (x1,y1) and (x2,y2).
 * Angle zero points in the +X direction, 90 degrees points in the +Y
 * direction (down) and from there we grow clockwise towards 360 degrees.
 * @param {number} x1 x of first point.
 * @param {number} y1 y of first point.
 * @param {number} x2 x of second point.
 * @param {number} y2 y of second point.
 * @return {number} Standardized angle in degrees of the vector from
 *     x1,y1 to x2,y2.
 */
goog.math.angle = function(x1, y1, x2, y2) {
  return goog.math.standardAngle(goog.math.toDegrees(Math.atan2(y2 - y1,
                                                                x2 - x1)));
};


/**
 * Computes the difference between startAngle and endAngle (angles in degrees).
 * @param {number} startAngle  Start angle in degrees.
 * @param {number} endAngle  End angle in degrees.
 * @return {number} The number of degrees that when added to
 *     startAngle will result in endAngle. Positive numbers mean that the
 *     direction is clockwise. Negative numbers indicate a counter-clockwise
 *     direction.
 *     The shortest route (clockwise vs counter-clockwise) between the angles
 *     is used.
 *     When the difference is 180 degrees, the function returns 180 (not -180)
 *     angleDifference(30, 40) is 10, and angleDifference(40, 30) is -10.
 *     angleDifference(350, 10) is 20, and angleDifference(10, 350) is -20.
 */
goog.math.angleDifference = function(startAngle, endAngle) {
  var d = goog.math.standardAngle(endAngle) -
          goog.math.standardAngle(startAngle);
  if (d > 180) {
    d = d - 360;
  } else if (d <= -180) {
    d = 360 + d;
  }
  return d;
};


/**
 * Returns the sign of a number as per the "sign" or "signum" function.
 * @param {number} x The number to take the sign of.
 * @return {number} -1 when negative, 1 when positive, 0 when 0.
 */
goog.math.sign = function(x) {
  return x == 0 ? 0 : (x < 0 ? -1 : 1);
};


/**
 * JavaScript implementation of Longest Common Subsequence problem.
 * http://en.wikipedia.org/wiki/Longest_common_subsequence
 *
 * Returns the longest possible array that is subarray of both of given arrays.
 *
 * @param {Array.<Object>} array1 First array of objects.
 * @param {Array.<Object>} array2 Second array of objects.
 * @param {Function=} opt_compareFn Function that acts as a custom comparator
 *     for the array ojects. Function should return true if objects are equal,
 *     otherwise false.
 * @param {Function=} opt_collectorFn Function used to decide what to return
 *     as a result subsequence. It accepts 2 arguments: index of common element
 *     in the first array and index in the second. The default function returns
 *     element from the first array.
 * @return {Array.<Object>} A list of objects that are common to both arrays
 *     such that there is no common subsequence with size greater than the
 *     length of the list.
 */
goog.math.longestCommonSubsequence = function(
    array1, array2, opt_compareFn, opt_collectorFn) {

  var compare = opt_compareFn || function(a, b) {
    return a == b;
  };

  var collect = opt_collectorFn || function(i1, i2) {
    return array1[i1];
  };

  var length1 = array1.length;
  var length2 = array2.length;

  var arr = [];
  for (var i = 0; i < length1 + 1; i++) {
    arr[i] = [];
    arr[i][0] = 0;
  }

  for (var j = 0; j < length2 + 1; j++) {
    arr[0][j] = 0;
  }

  for (i = 1; i <= length1; i++) {
    for (j = 1; j <= length2; j++) {
      if (compare(array1[i - 1], array2[j - 1])) {
        arr[i][j] = arr[i - 1][j - 1] + 1;
      } else {
        arr[i][j] = Math.max(arr[i - 1][j], arr[i][j - 1]);
      }
    }
  }

  // Backtracking
  var result = [];
  var i = length1, j = length2;
  while (i > 0 && j > 0) {
    if (compare(array1[i - 1], array2[j - 1])) {
      result.unshift(collect(i - 1, j - 1));
      i--;
      j--;
    } else {
      if (arr[i - 1][j] > arr[i][j - 1]) {
        i--;
      } else {
        j--;
      }
    }
  }

  return result;
};


/**
 * Returns the sum of the arguments.
 * @param {...number} var_args Numbers to add.
 * @return {number} The sum of the arguments (0 if no arguments were provided,
 *     {@code NaN} if any of the arguments is not a valid number).
 */
goog.math.sum = function(var_args) {
  return /** @type {number} */ (goog.array.reduce(arguments,
      function(sum, value) {
        return sum + value;
      }, 0));
};


/**
 * Returns the arithmetic mean of the arguments.
 * @param {...number} var_args Numbers to average.
 * @return {number} The average of the arguments ({@code NaN} if no arguments
 *     were provided or any of the arguments is not a valid number).
 */
goog.math.average = function(var_args) {
  return goog.math.sum.apply(null, arguments) / arguments.length;
};


/**
 * Returns the unbiased sample variance of the arguments. For a definition,
 * see e.g. http://en.wikipedia.org/wiki/Variance
 * @param {...number} var_args Number samples to analyze.
 * @return {number} The unbiased sample variance of the arguments (0 if fewer
 *     than two samples were provided, or {@code NaN} if any of the samples is
 *     not a valid number).
 */
goog.math.sampleVariance = function(var_args) {
  var sampleSize = arguments.length;
  if (sampleSize < 2) {
    return 0;
  }

  var mean = goog.math.average.apply(null, arguments);
  var variance = goog.math.sum.apply(null, goog.array.map(arguments,
      function(val) {
        return Math.pow(val - mean, 2);
      })) / (sampleSize - 1);

  return variance;
};


/**
 * Returns the sample standard deviation of the arguments.  For a definition of
 * sample standard deviation, see e.g.
 * http://en.wikipedia.org/wiki/Standard_deviation
 * @param {...number} var_args Number samples to analyze.
 * @return {number} The sample standard deviation of the arguments (0 if fewer
 *     than two samples were provided, or {@code NaN} if any of the samples is
 *     not a valid number).
 */
goog.math.standardDeviation = function(var_args) {
  return Math.sqrt(goog.math.sampleVariance.apply(null, arguments));
};


/**
 * Returns whether the supplied number represents an integer, i.e. that is has
 * no fractional component.  No range-checking is performed on the number.
 * @param {number} num The number to test.
 * @return {boolean} Whether {@code num} is an integer.
 */
goog.math.isInt = function(num) {
  return isFinite(num) && num % 1 == 0;
};


/**
 * Returns whether the supplied number is finite and not NaN.
 * @param {number} num The number to test.
 * @return {boolean} Whether {@code num} is a finite number.
 */
goog.math.isFiniteNumber = function(num) {
  return isFinite(num) && !isNaN(num);
};


/**
 * A tweaked variant of {@code Math.floor} which tolerates if the passed number
 * is infinitesimally smaller than the closest integer. It often happens with
 * the results of floating point calculations because of the finite precision
 * of the intermediate results. For example {@code Math.floor(Math.log(1000) /
 * Math.LN10) == 2}, not 3 as one would expect.
 * @param {number} num A number.
 * @param {number=} opt_epsilon An infinitesimally small positive number, the
 *     rounding error to tolerate.
 * @return {number} The largest integer less than or equal to {@code num}.
 */
goog.math.safeFloor = function(num, opt_epsilon) {
  goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
  return Math.floor(num + (opt_epsilon || 2e-15));
};


/**
 * A tweaked variant of {@code Math.ceil}. See {@code goog.math.safeFloor} for
 * details.
 * @param {number} num A number.
 * @param {number=} opt_epsilon An infinitesimally small positive number, the
 *     rounding error to tolerate.
 * @return {number} The smallest integer greater than or equal to {@code num}.
 */
goog.math.safeCeil = function(num, opt_epsilon) {
  goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
  return Math.ceil(num - (opt_epsilon || 2e-15));
};

//javascript/closure/iter/iter.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Python style iteration utilities.
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.iter');
goog.provide('goog.iter.Iterable');
goog.provide('goog.iter.Iterator');
goog.provide('goog.iter.StopIteration');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.functions');
goog.require('goog.math');


// TODO(nnaze): Add more functions from Python's itertools.
// http://docs.python.org/library/itertools.html


/**
 * @typedef {goog.iter.Iterator|{length:number}|{__iterator__}}
 */
goog.iter.Iterable;


// For script engines that already support iterators.
if ('StopIteration' in goog.global) {
  /**
   * Singleton Error object that is used to terminate iterations.
   * @type {Error}
   */
  goog.iter.StopIteration = goog.global['StopIteration'];
} else {
  /**
   * Singleton Error object that is used to terminate iterations.
   * @type {Error}
   * @suppress {duplicate}
   */
  goog.iter.StopIteration = Error('StopIteration');
}



/**
 * Class/interface for iterators.  An iterator needs to implement a {@code next}
 * method and it needs to throw a {@code goog.iter.StopIteration} when the
 * iteration passes beyond the end.  Iterators have no {@code hasNext} method.
 * It is recommended to always use the helper functions to iterate over the
 * iterator or in case you are only targeting JavaScript 1.7 for in loops.
 * @constructor
 */
goog.iter.Iterator = function() {};


/**
 * Returns the next value of the iteration.  This will throw the object
 * {@see goog.iter#StopIteration} when the iteration passes the end.
 * @return {*} Any object or value.
 */
goog.iter.Iterator.prototype.next = function() {
  throw goog.iter.StopIteration;
};


/**
 * Returns the {@code Iterator} object itself.  This is used to implement
 * the iterator protocol in JavaScript 1.7
 * @param {boolean=} opt_keys  Whether to return the keys or values. Default is
 *     to only return the values.  This is being used by the for-in loop (true)
 *     and the for-each-in loop (false).  Even though the param gives a hint
 *     about what the iterator will return there is no guarantee that it will
 *     return the keys when true is passed.
 * @return {!goog.iter.Iterator} The object itself.
 */
goog.iter.Iterator.prototype.__iterator__ = function(opt_keys) {
  return this;
};


/**
 * Returns an iterator that knows how to iterate over the values in the object.
 * @param {goog.iter.Iterable} iterable  If the object is an iterator it
 *     will be returned as is.  If the object has a {@code __iterator__} method
 *     that will be called to get the value iterator.  If the object is an
 *     array-like object we create an iterator for that.
 * @return {!goog.iter.Iterator} An iterator that knows how to iterate over the
 *     values in {@code iterable}.
 */
goog.iter.toIterator = function(iterable) {
  if (iterable instanceof goog.iter.Iterator) {
    return iterable;
  }
  if (typeof iterable.__iterator__ == 'function') {
    return iterable.__iterator__(false);
  }
  if (goog.isArrayLike(iterable)) {
    var i = 0;
    var newIter = new goog.iter.Iterator;
    newIter.next = function() {
      while (true) {
        if (i >= iterable.length) {
          throw goog.iter.StopIteration;
        }
        // Don't include deleted elements.
        if (!(i in iterable)) {
          i++;
          continue;
        }
        return iterable[i++];
      }
    };
    return newIter;
  }


  // TODO(arv): Should we fall back on goog.structs.getValues()?
  throw Error('Not implemented');
};


/**
 * Calls a function for each element in the iterator with the element of the
 * iterator passed as argument.
 *
 * @param {goog.iter.Iterable} iterable  The iterator to iterate
 *     over.  If the iterable is an object {@code toIterator} will be called on
 *     it.
* @param {function(this:T,?,?,?):?} f  The function to call for every
 *     element.  This function
 *     takes 3 arguments (the element, undefined, and the iterator) and the
 *     return value is irrelevant.  The reason for passing undefined as the
 *     second argument is so that the same function can be used in
 *     {@see goog.array#forEach} as well as others.
 * @param {T=} opt_obj  The object to be used as the value of 'this' within
 *     {@code f}.
 * @template T
 */
goog.iter.forEach = function(iterable, f, opt_obj) {
  if (goog.isArrayLike(iterable)) {
    /** @preserveTry */
    try {
      // NOTES: this passes the index number to the second parameter
      // of the callback contrary to the documentation above.
      goog.array.forEach(/** @type {goog.array.ArrayLike} */(iterable), f,
                         opt_obj);
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  } else {
    iterable = goog.iter.toIterator(iterable);
    /** @preserveTry */
    try {
      while (true) {
        f.call(opt_obj, iterable.next(), undefined, iterable);
      }
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  }
};


/**
 * Calls a function for every element in the iterator, and if the function
 * returns true adds the element to a new iterator.
 *
 * @param {goog.iter.Iterable} iterable The iterator to iterate over.
 * @param {function(this:T,?,undefined,?):boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, undefined, and the iterator) and should
 *     return a boolean.  If the return value is true the element will be
 *     included  in the returned iteror.  If it is false the element is not
 *     included.
 * @param {T=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator} A new iterator in which only elements that
 *     passed the test are present.
 * @template T
 */
goog.iter.filter = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (true) {
      var val = iterator.next();
      if (f.call(opt_obj, val, undefined, iterator)) {
        return val;
      }
    }
  };
  return newIter;
};


/**
 * Creates a new iterator that returns the values in a range.  This function
 * can take 1, 2 or 3 arguments:
 * <pre>
 * range(5) same as range(0, 5, 1)
 * range(2, 5) same as range(2, 5, 1)
 * </pre>
 *
 * @param {number} startOrStop  The stop value if only one argument is provided.
 *     The start value if 2 or more arguments are provided.  If only one
 *     argument is used the start value is 0.
 * @param {number=} opt_stop  The stop value.  If left out then the first
 *     argument is used as the stop value.
 * @param {number=} opt_step  The number to increment with between each call to
 *     next.  This can be negative.
 * @return {!goog.iter.Iterator} A new iterator that returns the values in the
 *     range.
 */
goog.iter.range = function(startOrStop, opt_stop, opt_step) {
  var start = 0;
  var stop = startOrStop;
  var step = opt_step || 1;
  if (arguments.length > 1) {
    start = startOrStop;
    stop = opt_stop;
  }
  if (step == 0) {
    throw Error('Range step argument must not be zero');
  }

  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    if (step > 0 && start >= stop || step < 0 && start <= stop) {
      throw goog.iter.StopIteration;
    }
    var rv = start;
    start += step;
    return rv;
  };
  return newIter;
};


/**
 * Joins the values in a iterator with a delimiter.
 * @param {goog.iter.Iterable} iterable  The iterator to get the values from.
 * @param {string} deliminator  The text to put between the values.
 * @return {string} The joined value string.
 */
goog.iter.join = function(iterable, deliminator) {
  return goog.iter.toArray(iterable).join(deliminator);
};


/**
 * For every element in the iterator call a function and return a new iterator
 * with that value.
 *
 * @param {goog.iter.Iterable} iterable The iterator to iterate over.
 * @param {function(this:T,?,undefined,?):?} f The function to call for every
 *     element.  This function
 *     takes 3 arguments (the element, undefined, and the iterator) and should
 *     return a new value.
 * @param {T=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator} A new iterator that returns the results of
 *     applying the function to each element in the original iterator.
 * @template T
 */
goog.iter.map = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (true) {
      var val = iterator.next();
      return f.call(opt_obj, val, undefined, iterator);
    }
  };
  return newIter;
};


/**
 * Passes every element of an iterator into a function and accumulates the
 * result.
 *
 * @param {goog.iter.Iterable} iterable The iterator to iterate over.
 * @param {function(this:T,V,?):V} f The function to call for every
 *     element. This function takes 2 arguments (the function's previous result
 *     or the initial value, and the value of the current element).
 *     function(previousValue, currentElement) : newValue.
 * @param {V} val The initial value to pass into the function on the first call.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {V} Result of evaluating f repeatedly across the values of
 *     the iterator.
 * @template T,V
 */
goog.iter.reduce = function(iterable, f, val, opt_obj) {
  var rval = val;
  goog.iter.forEach(iterable, function(val) {
    rval = f.call(opt_obj, rval, val);
  });
  return rval;
};


/**
 * Goes through the values in the iterator. Calls f for each these and if any of
 * them returns true, this returns true (without checking the rest). If all
 * return false this will return false.
 *
 * @param {goog.iter.Iterable} iterable  The iterator object.
 * @param {function(this:T,?,undefined,?):boolean} f  The function to call for
 *     every value. This function
 *     takes 3 arguments (the value, undefined, and the iterator) and should
 *     return a boolean.
 * @param {T=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {boolean} true if any value passes the test.
 * @template T
 */
goog.iter.some = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  /** @preserveTry */
  try {
    while (true) {
      if (f.call(opt_obj, iterable.next(), undefined, iterable)) {
        return true;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return false;
};


/**
 * Goes through the values in the iterator. Calls f for each these and if any of
 * them returns false this returns false (without checking the rest). If all
 * return true this will return true.
 *
 * @param {goog.iter.Iterable} iterable  The iterator object.
 * @param {function(this:T,?,undefined,?):boolean} f  The function to call for
 *     every value. This function
 *     takes 3 arguments (the value, undefined, and the iterator) and should
 *     return a boolean.
 * @param {T=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {boolean} true if every value passes the test.
 * @template T
 */
goog.iter.every = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  /** @preserveTry */
  try {
    while (true) {
      if (!f.call(opt_obj, iterable.next(), undefined, iterable)) {
        return false;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return true;
};


/**
 * Takes zero or more iterables and returns one iterator that will iterate over
 * them in the order chained.
 * @param {...!goog.iter.Iterable} var_args Any number of iterable objects.
 * @return {!goog.iter.Iterator} Returns a new iterator that will iterate over
 *     all the given iterables' contents.
 */
goog.iter.chain = function(var_args) {
  var iterator = goog.iter.toIterator(arguments);
  var iter = new goog.iter.Iterator();
  var current = null;

  iter.next = function() {
    while (true) {
      if (current == null) {
        var it = /** @type {!goog.iter.Iterable} */ (iterator.next());
        current = goog.iter.toIterator(it);
      }
      try {
        return current.next();
      } catch (ex) {
        if (ex !== goog.iter.StopIteration) {
          throw ex;
        }
        current = null;
      }
    }
  };

  return iter;
};


/**
 * Takes a single iterable containing zero or more iterables and returns one
 * iterator that will iterate over each one in the order given.
 * @see http://docs.python.org/2/library/itertools.html#itertools.chain.from_iterable
 * @param {!goog.iter.Iterable.<!goog.iter.Iterable>} iterable The iterable of
 *     iterables to chain.
 * @return {!goog.iter.Iterator} Returns a new iterator that will iterate over
 *     all the contents of the iterables contained within {@code iterable}.
 */
goog.iter.chainFromIterable = function(iterable) {
  return goog.iter.chain.apply(undefined, iterable);
};


/**
 * Builds a new iterator that iterates over the original, but skips elements as
 * long as a supplied function returns true.
 * @param {goog.iter.Iterable} iterable  The iterator object.
 * @param {function(this:T,?,undefined,?):boolean} f  The function to call for
 *     every value. This function
 *     takes 3 arguments (the value, undefined, and the iterator) and should
 *     return a boolean.
 * @param {T=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator} A new iterator that drops elements from the
 *     original iterator as long as {@code f} is true.
 * @template T
 */
goog.iter.dropWhile = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  var dropping = true;
  newIter.next = function() {
    while (true) {
      var val = iterator.next();
      if (dropping && f.call(opt_obj, val, undefined, iterator)) {
        continue;
      } else {
        dropping = false;
      }
      return val;
    }
  };
  return newIter;
};


/**
 * Builds a new iterator that iterates over the original, but only as long as a
 * supplied function returns true.
 * @param {goog.iter.Iterable} iterable  The iterator object.
 * @param {function(this:T,?,undefined,?):boolean} f  The function to call for
 *     every value. This function
 *     takes 3 arguments (the value, undefined, and the iterator) and should
 *     return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object in f when called.
 * @return {!goog.iter.Iterator} A new iterator that keeps elements in the
 *     original iterator as long as the function is true.
 * @template T
 */
goog.iter.takeWhile = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  var taking = true;
  newIter.next = function() {
    while (true) {
      if (taking) {
        var val = iterator.next();
        if (f.call(opt_obj, val, undefined, iterator)) {
          return val;
        } else {
          taking = false;
        }
      } else {
        throw goog.iter.StopIteration;
      }
    }
  };
  return newIter;
};


/**
 * Converts the iterator to an array
 * @param {goog.iter.Iterable} iterable  The iterator to convert to an array.
 * @return {!Array} An array of the elements the iterator iterates over.
 */
goog.iter.toArray = function(iterable) {
  // Fast path for array-like.
  if (goog.isArrayLike(iterable)) {
    return goog.array.toArray(/** @type {!goog.array.ArrayLike} */(iterable));
  }
  iterable = goog.iter.toIterator(iterable);
  var array = [];
  goog.iter.forEach(iterable, function(val) {
    array.push(val);
  });
  return array;
};


/**
 * Iterates over two iterables and returns true if they contain the same
 * sequence of elements and have the same length.
 * @param {!goog.iter.Iterable} iterable1 The first iterable object.
 * @param {!goog.iter.Iterable} iterable2 The second iterable object.
 * @return {boolean} true if the iterables contain the same sequence of
 *     elements and have the same length.
 */
goog.iter.equals = function(iterable1, iterable2) {
  var fillValue = {};
  var pairs = goog.iter.zipLongest(fillValue, iterable1, iterable2);
  return goog.iter.every(pairs, function(pair) {
    return pair[0] == pair[1];
  });
};


/**
 * Advances the iterator to the next position, returning the given default value
 * instead of throwing an exception if the iterator has no more entries.
 * @param {goog.iter.Iterable} iterable The iterable object.
 * @param {*} defaultValue The value to return if the iterator is empty.
 * @return {*} The next item in the iteration, or defaultValue if the iterator
 *     was empty.
 */
goog.iter.nextOrValue = function(iterable, defaultValue) {
  try {
    return goog.iter.toIterator(iterable).next();
  } catch (e) {
    if (e != goog.iter.StopIteration) {
      throw e;
    }
    return defaultValue;
  }
};


/**
 * Cartesian product of zero or more sets.  Gives an iterator that gives every
 * combination of one element chosen from each set.  For example,
 * ([1, 2], [3, 4]) gives ([1, 3], [1, 4], [2, 3], [2, 4]).
 * @see http://docs.python.org/library/itertools.html#itertools.product
 * @param {...!goog.array.ArrayLike.<*>} var_args Zero or more sets, as arrays.
 * @return {!goog.iter.Iterator} An iterator that gives each n-tuple (as an
 *     array).
 */
goog.iter.product = function(var_args) {
  var someArrayEmpty = goog.array.some(arguments, function(arr) {
    return !arr.length;
  });

  // An empty set in a cartesian product gives an empty set.
  if (someArrayEmpty || !arguments.length) {
    return new goog.iter.Iterator();
  }

  var iter = new goog.iter.Iterator();
  var arrays = arguments;

  // The first indicies are [0, 0, ...]
  var indicies = goog.array.repeat(0, arrays.length);

  iter.next = function() {

    if (indicies) {
      var retVal = goog.array.map(indicies, function(valueIndex, arrayIndex) {
        return arrays[arrayIndex][valueIndex];
      });

      // Generate the next-largest indicies for the next call.
      // Increase the rightmost index. If it goes over, increase the next
      // rightmost (like carry-over addition).
      for (var i = indicies.length - 1; i >= 0; i--) {
        // Assertion prevents compiler warning below.
        goog.asserts.assert(indicies);
        if (indicies[i] < arrays[i].length - 1) {
          indicies[i]++;
          break;
        }

        // We're at the last indicies (the last element of every array), so
        // the iteration is over on the next call.
        if (i == 0) {
          indicies = null;
          break;
        }
        // Reset the index in this column and loop back to increment the
        // next one.
        indicies[i] = 0;
      }
      return retVal;
    }

    throw goog.iter.StopIteration;
  };

  return iter;
};


/**
 * Create an iterator to cycle over the iterable's elements indefinitely.
 * For example, ([1, 2, 3]) would return : 1, 2, 3, 1, 2, 3, ...
 * @see: http://docs.python.org/library/itertools.html#itertools.cycle.
 * @param {!goog.iter.Iterable} iterable The iterable object.
 * @return {!goog.iter.Iterator} An iterator that iterates indefinitely over
 * the values in {@code iterable}.
 */
goog.iter.cycle = function(iterable) {

  var baseIterator = goog.iter.toIterator(iterable);

  // We maintain a cache to store the iterable elements as we iterate
  // over them. The cache is used to return elements once we have
  // iterated over the iterable once.
  var cache = [];
  var cacheIndex = 0;

  var iter = new goog.iter.Iterator();

  // This flag is set after the iterable is iterated over once
  var useCache = false;

  iter.next = function() {
    var returnElement = null;

    // Pull elements off the original iterator if not using cache
    if (!useCache) {
      try {
        // Return the element from the iterable
        returnElement = baseIterator.next();
        cache.push(returnElement);
        return returnElement;
      } catch (e) {
        // If an exception other than StopIteration is thrown
        // or if there are no elements to iterate over (the iterable was empty)
        // throw an exception
        if (e != goog.iter.StopIteration || goog.array.isEmpty(cache)) {
          throw e;
        }
        // set useCache to true after we know that a 'StopIteration' exception
        // was thrown and the cache is not empty (to handle the 'empty iterable'
        // use case)
        useCache = true;
      }
    }

    returnElement = cache[cacheIndex];
    cacheIndex = (cacheIndex + 1) % cache.length;

    return returnElement;
  };

  return iter;
};


/**
 * Creates an iterator that counts indefinitely from a starting value.
 * @see http://docs.python.org/2/library/itertools.html#itertools.count
 * @param {number=} opt_start The starting value. Default is 0.
 * @param {number=} opt_step The number to increment with between each call to
 *     next. Negative and floating point numbers are allowed. Default is 1.
 * @return {!goog.iter.Iterator} A new iterator that returns the values in the
 *     series.
 */
goog.iter.count = function(opt_start, opt_step) {
  var counter = opt_start || 0;
  var step = goog.isDef(opt_step) ? opt_step : 1;
  var iter = new goog.iter.Iterator();

  iter.next = function() {
    var returnValue = counter;
    counter += step;
    return returnValue;
  };

  return iter;
};


/**
 * Creates an iterator that returns the same object or value repeatedly.
 * @param {*} value Any object or value to repeat.
 * @return {!goog.iter.Iterator} A new iterator that returns the repeated value.
 */
goog.iter.repeat = function(value) {
  var iter = new goog.iter.Iterator();

  iter.next = goog.functions.constant(value);

  return iter;
};


/**
 * Creates an iterator that returns running totals from the numbers in
 * {@code iterable}. For example, the array {@code [1, 2, 3, 4, 5]} yields
 * {@code 1 -> 3 -> 6 -> 10 -> 15}.
 * @see http://docs.python.org/3.2/library/itertools.html#itertools.accumulate
 * @param {!goog.iter.Iterable.<number>} iterable The iterable of numbers to
 *     accumulate.
 * @return {!goog.iter.Iterator.<number>} A new iterator that returns the
 *     numbers in the series.
 */
goog.iter.accumulate = function(iterable) {
  var iterator = goog.iter.toIterator(iterable);
  var total = 0;
  var iter = new goog.iter.Iterator();

  iter.next = function() {
    total += iterator.next();
    return total;
  };

  return iter;
};


/**
 * Creates an iterator that returns arrays containing the ith elements from the
 * provided iterables. The returned arrays will be the same size as the number
 * of iterables given in {@code var_args}. Once the shortest iterable is
 * exhausted, subsequent calls to {@code next()} will throw
 * {@code goog.iter.StopIteration}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.izip
 * @param {...!goog.iter.Iterable} var_args Any number of iterable objects.
 * @return {!goog.iter.Iterator} A new iterator that returns arrays of elements
 *     from the provided iterables.
 */
goog.iter.zip = function(var_args) {
  var args = arguments;
  var iter = new goog.iter.Iterator();

  if (args.length > 0) {
    var iterators = goog.array.map(args, goog.iter.toIterator);
    iter.next = function() {
      var arr = goog.array.map(iterators, function(it) {
        return it.next();
      });
      return arr;
    };
  }

  return iter;
};


/**
 * Creates an iterator that returns arrays containing the ith elements from the
 * provided iterables. The returned arrays will be the same size as the number
 * of iterables given in {@code var_args}. Shorter iterables will be extended
 * with {@code fillValue}. Once the longest iterable is exhausted, subsequent
 * calls to {@code next()} will throw {@code goog.iter.StopIteration}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.izip_longest
 * @param {*} fillValue The object or value used to fill shorter iterables.
 * @param {...!goog.iter.Iterable} var_args Any number of iterable objects.
 * @return {!goog.iter.Iterator} A new iterator that returns arrays of elements
 *     from the provided iterables.
 */
goog.iter.zipLongest = function(fillValue, var_args) {
  var args = goog.array.slice(arguments, 1);
  var iter = new goog.iter.Iterator();

  if (args.length > 0) {
    var iterators = goog.array.map(args, goog.iter.toIterator);

    iter.next = function() {
      var iteratorsHaveValues = false;  // false when all iterators are empty.
      var arr = goog.array.map(iterators, function(it) {
        var returnValue;
        try {
          returnValue = it.next();
          // Iterator had a value, so we've not exhausted the iterators.
          // Set flag accordingly.
          iteratorsHaveValues = true;
        } catch (ex) {
          if (ex !== goog.iter.StopIteration) {
            throw ex;
          }
          returnValue = fillValue;
        }
        return returnValue;
      });

      if (!iteratorsHaveValues) {
        throw goog.iter.StopIteration;
      }
      return arr;
    };
  }

  return iter;
};


/**
 * Creates an iterator that filters {@code iterable} based on a series of
 * {@code selectors}. On each call to {@code next()}, one item is taken from
 * both the {@code iterable} and {@code selectors} iterators. If the item from
 * {@code selectors} evaluates to true, the item from {@code iterable} is given.
 * Otherwise, it is skipped. Once either {@code iterable} or {@code selectors}
 * is exhausted, subsequent calls to {@code next()} will throw
 * {@code goog.iter.StopIteration}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.compress
 * @param {!goog.iter.Iterable.<T>} iterable The iterable to filter.
 * @param {!goog.iter.Iterable} selectors An iterable of items to be evaluated
 *     in a boolean context to determine if the corresponding element in
 *     {@code iterable} should be included in the result.
 * @return {!goog.iter.Iterable.<T>} A new iterator that returns the filtered
 *    values.
 * @template T
 */
goog.iter.compress = function(iterable, selectors) {
  var selectorIterator = goog.iter.toIterator(selectors);

  return goog.iter.filter(iterable, function() {
    return !!selectorIterator.next();
  });
};



/**
 * Implements the {@code goog.iter.groupBy} iterator.
 * @param {!goog.iter.Iterable} iterable  The iterable to group.
 * @param {Function=} opt_keyFunc  Optional function for determining the key
 *     value for each group in the {@code iterable}. Default is the identity
 *     function.
 * @constructor
 * @extends {goog.iter.Iterator}
 * @private
 */
goog.iter.GroupByIterator_ = function(iterable, opt_keyFunc) {

  /**
   * The iterable to group, coerced to an iterator.
   * @type {!goog.iter.Iterator}
   */
  this.iterator = goog.iter.toIterator(iterable);

  /**
   * A function for determining the key value for each element in the iterable.
   * If no function is provided, the idenity function is used and returns the
   * element unchanged.
   * @type {function(...[*]): *}
   */
  this.keyFunc = opt_keyFunc || goog.functions.identity;

  /**
   * The target key for determining the start of a group.
   * @type {*}
   */
  this.targetKey;

  /**
   * The current key visited during iteration.
   * @type {*}
   */
  this.currentKey;

  /**
   * The current value being added to the group.
   * @type {*}
   */
  this.currentValue;
};
goog.inherits(goog.iter.GroupByIterator_, goog.iter.Iterator);


/** @override */
goog.iter.GroupByIterator_.prototype.next = function() {
  while (this.currentKey == this.targetKey) {
    this.currentValue = this.iterator.next();  // Exits on StopIteration
    this.currentKey = this.keyFunc(this.currentValue);
  }
  this.targetKey = this.currentKey;
  return [this.currentKey, this.groupItems_(this.targetKey)];
};


/**
 * Performs the grouping of objects using the given key.
 * @param {*} targetKey  The target key object for the group.
 * @return {!Array} An array of grouped objects.
 * @private
 */
goog.iter.GroupByIterator_.prototype.groupItems_ = function(targetKey) {
  var arr = [];
  while (this.currentKey == targetKey) {
    arr.push(this.currentValue);
    try {
      this.currentValue = this.iterator.next();
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
      break;
    }
    this.currentKey = this.keyFunc(this.currentValue);
  }
  return arr;
};


/**
 * Creates an iterator that returns arrays containing elements from the
 * {@code iterable} grouped by a key value. For iterables with repeated
 * elements (i.e. sorted according to a particular key function), this function
 * has a {@code uniq}-like effect. For example, grouping the array:
 * {@code [A, B, B, C, C, A]} produces
 * {@code [A, [A]], [B, [B, B]], [C, [C, C]], [A, [A]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.groupby
 * @param {!goog.iter.Iterable} iterable  The iterable to group.
 * @param {Function=} opt_keyFunc  Optional function for determining the key
 *     value for each group in the {@code iterable}. Default is the identity
 *     function.
 * @return {!goog.iter.Iterator} A new iterator that returns arrays of
 *     consecutive key and groups.
 */
goog.iter.groupBy = function(iterable, opt_keyFunc) {
  return new goog.iter.GroupByIterator_(iterable, opt_keyFunc);
};


/**
 * Returns an array of iterators each of which can iterate over the values in
 * {@code iterable} without advancing the others.
 * @see http://docs.python.org/2/library/itertools.html#itertools.tee
 * @param {!goog.iter.Iterable} iterable  The iterable to tee.
 * @param {number=} opt_num  The number of iterators to create. Default is 2.
 * @return {!Array.<goog.iter.Iterator>} An array of iterators.
 */
goog.iter.tee = function(iterable, opt_num) {
  var iterator = goog.iter.toIterator(iterable);
  var num = goog.isNumber(opt_num) ? opt_num : 2;
  var buffers = goog.array.map(goog.array.range(num), function() {
    return [];
  });

  var addNextIteratorValueToBuffers = function() {
    var val = iterator.next();
    goog.array.forEach(buffers, function(buffer) {
      buffer.push(val);
    });
  };

  var createIterator = function(buffer) {
    // Each tee'd iterator has an associated buffer (initially empty). When a
    // tee'd iterator's buffer is empty, it calls
    // addNextIteratorValueToBuffers(), adding the next value to all tee'd
    // iterators' buffers, and then returns that value. This allows each
    // iterator to be advanced independently.
    var iter = new goog.iter.Iterator();

    iter.next = function() {
      if (goog.array.isEmpty(buffer)) {
        addNextIteratorValueToBuffers();
      }
      goog.asserts.assert(!goog.array.isEmpty(buffer));
      return buffer.shift();
    };

    return iter;
  };

  return goog.array.map(buffers, createIterator);
};


/**
 * Creates an iterator that returns arrays containing a count and an element
 * obtained from the given {@code iterable}.
 * @see http://docs.python.org/2/library/functions.html#enumerate
 * @param {!goog.iter.Iterable} iterable  The iterable to enumerate.
 * @param {number=} opt_start  Optional starting value. Default is 0.
 * @return {!goog.iter.Iterator} A new iterator containing count/item pairs.
 */
goog.iter.enumerate = function(iterable, opt_start) {
  return goog.iter.zip(goog.iter.count(opt_start), iterable);
};


/**
 * Creates an iterator that returns the first {@code limitSize} elements from an
 * iterable. If this number is greater than the number of elements in the
 * iterable, all the elements are returned.
 * @see http://goo.gl/V0sihp Inspired by the limit iterator in Guava.
 * @param {!goog.iter.Iterable} iterable  The iterable to limit.
 * @param {number} limitSize  The maximum number of elements to return.
 * @return {!goog.iter.Iterator} A new iterator containing {@code limitSize}
 *     elements.
 */
goog.iter.limit = function(iterable, limitSize) {
  goog.asserts.assert(goog.math.isInt(limitSize) && limitSize >= 0);

  var iterator = goog.iter.toIterator(iterable);

  var iter = new goog.iter.Iterator();
  var remaining = limitSize;

  iter.next = function() {
    if (remaining-- > 0) {
      return iterator.next();
    }
    throw goog.iter.StopIteration;
  };

  return iter;
};


/**
 * Creates an iterator that is advanced {@code count} steps ahead. Consumed
 * values are silently discarded. If {@code count} is greater than the number
 * of elements in {@code iterable}, an empty iterator is returned. Subsequent
 * calls to {@code next()} will throw {@code goog.iter.StopIteration}.
 * @param {!goog.iter.Iterable} iterable  The iterable to consume.
 * @param {number} count  The number of elements to consume from the iterator.
 * @return {!goog.iter.Iterator}  An iterator advanced zero or more steps ahead.
 */
goog.iter.consume = function(iterable, count) {
  goog.asserts.assert(goog.math.isInt(count) && count >= 0);

  var iterator = goog.iter.toIterator(iterable);

  while (count-- > 0) {
    goog.iter.nextOrValue(iterator, null);
  }

  return iterator;
};


/**
 * Creates an iterator that returns a range of elements from an iterable.
 * Similar to {@see goog.array#slice} but does not support negative indexes.
 * @param {!goog.iter.Iterable} iterable  The iterable to slice.
 * @param {number} start  The index of the first element to return.
 * @param {number=} opt_end  The index after the last element to return. If
 *     defined, must be greater than or equal to {@code start}.
 * @return {!goog.iter.Iterator}  A new iterator containing a slice of the
 *     original.
 */
goog.iter.slice = function(iterable, start, opt_end) {
  goog.asserts.assert(goog.math.isInt(start) && start >= 0);

  var iterator = goog.iter.consume(iterable, start);

  if (goog.isNumber(opt_end)) {
    goog.asserts.assert(
        goog.math.isInt(/** @type {number} */ (opt_end)) && opt_end >= start);
    iterator = goog.iter.limit(iterator, opt_end - start /* limitSize */);
  }

  return iterator;
};


/**
 * Checks an array for duplicate elements.
 * @param {Array.<T>|goog.array.ArrayLike} arr The array to check for
 *     duplicates.
 * @return {boolean} True, if the array contains duplicates, false otherwise.
 * @private
 * @template T
 */
// TODO(dlindquist): Consider moving this into goog.array as a public function.
goog.iter.hasDuplicates_ = function(arr) {
  var deduped = [];
  goog.array.removeDuplicates(arr, deduped);
  return arr.length != deduped.length;
};


/**
 * Creates an iterator that returns permutations of elements in
 * {@code iterable}.
 *
 * Permutations are obtained by taking the Cartesian product of
 * {@code opt_length} iterables and filtering out those with repeated
 * elements. For example, the permutations of {@code [1,2,3]} are
 * {@code [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.permutations
 * @param {!goog.iter.Iterable} iterable The iterable from which to generate
 *    permutations.
 * @param {number=} opt_length Length of each permutation. If omitted, defaults
 *     to the length of {@code iterable}.
 * @return {!goog.iter.Iterator} A new iterator containing the permutations of
 *     {@code iterable}.
 */
goog.iter.permutations = function(iterable, opt_length) {
  var elements = goog.iter.toArray(iterable);
  var length = goog.isNumber(opt_length) ? opt_length : elements.length;

  var sets = goog.array.repeat(elements, length);
  var product = goog.iter.product.apply(undefined, sets);

  return goog.iter.filter(product, function(arr) {
    return !goog.iter.hasDuplicates_(arr);
  });
};


/**
 * Creates an iterator that returns combinations of elements from
 * {@code iterable}.
 *
 * Combinations are obtained by taking the {@see goog.iter#permutations} of
 * {@code iterable} and filtering those whose elements appear in the order they
 * are encountered in {@code iterable}. For example, the 3-length combinations
 * of {@code [0,1,2,3]} are {@code [[0,1,2], [0,1,3], [0,2,3], [1,2,3]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.combinations
 * @param {!goog.iter.Iterable} iterable The iterable from which to generate
 *     combinations.
 * @param {number} length The length of each combination.
 * @return {!goog.iter.Iterator} A new iterator containing combinations from
 *     the {@code iterable}.
 */
goog.iter.combinations = function(iterable, length) {
  var elements = goog.iter.toArray(iterable);
  var indexes = goog.iter.range(elements.length);
  var indexIterator = goog.iter.permutations(indexes, length);
  // sortedIndexIterator will now give arrays of with the given length that
  // indicate what indexes into "elements" should be returned on each iteration.
  var sortedIndexIterator = goog.iter.filter(indexIterator, function(arr) {
    return goog.array.isSorted(arr);
  });

  var iter = new goog.iter.Iterator();

  function getIndexFromElements(index) {
    return elements[index];
  }

  iter.next = function() {
    return goog.array.map(
        /** @type {!Array.<number>} */
        (sortedIndexIterator.next()), getIndexFromElements);
  };

  return iter;
};


/**
 * Creates an iterator that returns combinations of elements from
 * {@code iterable}, with repeated elements possible.
 *
 * Combinations are obtained by taking the Cartesian product of {@code length}
 * iterables and filtering those whose elements appear in the order they are
 * encountered in {@code iterable}. For example, the 2-length combinations of
 * {@code [1,2,3]} are {@code [[1,1], [1,2], [1,3], [2,2], [2,3], [3,3]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.combinations_with_replacement
 * @see http://en.wikipedia.org/wiki/Combination#Number_of_combinations_with_repetition
 * @param {!goog.iter.Iterable} iterable The iterable to combine.
 * @param {number} length The length of each combination.
 * @return {!goog.iter.Iterator} A new iterator containing combinations from
 *     the {@code iterable}.
 */
goog.iter.combinationsWithReplacement = function(iterable, length) {
  var elements = goog.iter.toArray(iterable);
  var indexes = goog.array.range(elements.length);
  var sets = goog.array.repeat(indexes, length);
  var indexIterator = goog.iter.product.apply(undefined, sets);
  // sortedIndexIterator will now give arrays of with the given length that
  // indicate what indexes into "elements" should be returned on each iteration.
  var sortedIndexIterator = goog.iter.filter(indexIterator, function(arr) {
    return goog.array.isSorted(arr);
  });

  var iter = new goog.iter.Iterator();

  function getIndexFromElements(index) {
    return elements[index];
  }

  iter.next = function() {
    return goog.array.map(
        /** @type {!Array.<number>} */
        (sortedIndexIterator.next()), getIndexFromElements);
  };

  return iter;
};

//javascript/closure/object/object.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating objects/maps/hashes.
 * @author pupius@google.com (Daniel Pupius)
 * @author arv@google.com (Erik Arvidsson)
 * @author pallosp@google.com (Peter Pallos)
 */

goog.provide('goog.object');


/**
 * Calls a function for each element in an object/map/hash.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):?} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the object) and the return value is ignored.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @template T,K,V
 */
goog.object.forEach = function(obj, f, opt_obj) {
  for (var key in obj) {
    f.call(opt_obj, obj[key], key, obj);
  }
};


/**
 * Calls a function for each element in an object/map/hash. If that call returns
 * true, adds the element to a new object.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):boolean} f The function to call
 *     for every element. This
 *     function takes 3 arguments (the element, the index and the object)
 *     and should return a boolean. If the return value is true the
 *     element is added to the result object. If it is false the
 *     element is not included.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object.<K,V>} a new object in which only elements that passed the
 *     test are present.
 * @template T,K,V
 */
goog.object.filter = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    if (f.call(opt_obj, obj[key], key, obj)) {
      res[key] = obj[key];
    }
  }
  return res;
};


/**
 * For every element in an object/map/hash calls a function and inserts the
 * result into a new object.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):R} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the object)
 *     and should return something. The result will be inserted
 *     into a new object.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object.<K,R>} a new object with the results from f.
 * @template T,K,V,R
 */
goog.object.map = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    res[key] = f.call(opt_obj, obj[key], key, obj);
  }
  return res;
};


/**
 * Calls a function for each element in an object/map/hash. If any
 * call returns true, returns true (without checking the rest). If
 * all calls return false, returns false.
 *
 * @param {Object.<K,V>} obj The object to check.
 * @param {function(this:T,V,?,Object.<K,V>):boolean} f The function to
 *     call for every element. This function
 *     takes 3 arguments (the element, the index and the object) and should
 *     return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} true if any element passes the test.
 * @template T,K,V
 */
goog.object.some = function(obj, f, opt_obj) {
  for (var key in obj) {
    if (f.call(opt_obj, obj[key], key, obj)) {
      return true;
    }
  }
  return false;
};


/**
 * Calls a function for each element in an object/map/hash. If
 * all calls return true, returns true. If any call returns false, returns
 * false at this point and does not continue to check the remaining elements.
 *
 * @param {Object.<K,V>} obj The object to check.
 * @param {?function(this:T,V,?,Object.<K,V>):boolean} f The function to
 *     call for every element. This function
 *     takes 3 arguments (the element, the index and the object) and should
 *     return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} false if any element fails the test.
 * @template T,K,V
 */
goog.object.every = function(obj, f, opt_obj) {
  for (var key in obj) {
    if (!f.call(opt_obj, obj[key], key, obj)) {
      return false;
    }
  }
  return true;
};


/**
 * Returns the number of key-value pairs in the object map.
 *
 * @param {Object} obj The object for which to get the number of key-value
 *     pairs.
 * @return {number} The number of key-value pairs in the object map.
 */
goog.object.getCount = function(obj) {
  // JS1.5 has __count__ but it has been deprecated so it raises a warning...
  // in other words do not use. Also __count__ only includes the fields on the
  // actual object and not in the prototype chain.
  var rv = 0;
  for (var key in obj) {
    rv++;
  }
  return rv;
};


/**
 * Returns one key from the object map, if any exists.
 * For map literals the returned key will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object} obj The object to pick a key from.
 * @return {string|undefined} The key or undefined if the object is empty.
 */
goog.object.getAnyKey = function(obj) {
  for (var key in obj) {
    return key;
  }
};


/**
 * Returns one value from the object map, if any exists.
 * For map literals the returned value will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object.<K,V>} obj The object to pick a value from.
 * @return {V|undefined} The value or undefined if the object is empty.
 * @template K,V
 */
goog.object.getAnyValue = function(obj) {
  for (var key in obj) {
    return obj[key];
  }
};


/**
 * Whether the object/hash/map contains the given object as a value.
 * An alias for goog.object.containsValue(obj, val).
 *
 * @param {Object.<K,V>} obj The object in which to look for val.
 * @param {V} val The object for which to check.
 * @return {boolean} true if val is present.
 * @template K,V
 */
goog.object.contains = function(obj, val) {
  return goog.object.containsValue(obj, val);
};


/**
 * Returns the values of the object/map/hash.
 *
 * @param {Object.<K,V>} obj The object from which to get the values.
 * @return {!Array.<V>} The values in the object/map/hash.
 * @template K,V
 */
goog.object.getValues = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = obj[key];
  }
  return res;
};


/**
 * Returns the keys of the object/map/hash.
 *
 * @param {Object} obj The object from which to get the keys.
 * @return {!Array.<string>} Array of property keys.
 */
goog.object.getKeys = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = key;
  }
  return res;
};


/**
 * Get a value from an object multiple levels deep.  This is useful for
 * pulling values from deeply nested objects, such as JSON responses.
 * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)
 *
 * @param {!Object} obj An object to get the value from.  Can be array-like.
 * @param {...(string|number|!Array.<number|string>)} var_args A number of keys
 *     (as strings, or numbers, for array-like objects).  Can also be
 *     specified as a single array of keys.
 * @return {*} The resulting value.  If, at any point, the value for a key
 *     is undefined, returns undefined.
 */
goog.object.getValueByKeys = function(obj, var_args) {
  var isArrayLike = goog.isArrayLike(var_args);
  var keys = isArrayLike ? var_args : arguments;

  // Start with the 2nd parameter for the variable parameters syntax.
  for (var i = isArrayLike ? 0 : 1; i < keys.length; i++) {
    obj = obj[keys[i]];
    if (!goog.isDef(obj)) {
      break;
    }
  }

  return obj;
};


/**
 * Whether the object/map/hash contains the given key.
 *
 * @param {Object} obj The object in which to look for key.
 * @param {*} key The key for which to check.
 * @return {boolean} true If the map contains the key.
 */
goog.object.containsKey = function(obj, key) {
  return key in obj;
};


/**
 * Whether the object/map/hash contains the given value. This is O(n).
 *
 * @param {Object.<K,V>} obj The object in which to look for val.
 * @param {V} val The value for which to check.
 * @return {boolean} true If the map contains the value.
 * @template K,V
 */
goog.object.containsValue = function(obj, val) {
  for (var key in obj) {
    if (obj[key] == val) {
      return true;
    }
  }
  return false;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its key.
 * @param {Object.<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,Object.<K,V>):boolean} f The
 *      function to call for every element. Takes 3 arguments (the value,
 *     the key and the object) and should return a boolean.
 * @param {T=} opt_this An optional "this" context for the function.
 * @return {string|undefined} The key of an element for which the function
 *     returns true or undefined if no such element is found.
 * @template T,K,V
 */
goog.object.findKey = function(obj, f, opt_this) {
  for (var key in obj) {
    if (f.call(opt_this, obj[key], key, obj)) {
      return key;
    }
  }
  return undefined;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its value.
 * @param {Object.<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,Object.<K,V>):boolean} f The function
 *     to call for every element. Takes 3 arguments (the value, the key
 *     and the object) and should return a boolean.
 * @param {T=} opt_this An optional "this" context for the function.
 * @return {V} The value of an element for which the function returns true or
 *     undefined if no such element is found.
 * @template T,K,V
 */
goog.object.findValue = function(obj, f, opt_this) {
  var key = goog.object.findKey(obj, f, opt_this);
  return key && obj[key];
};


/**
 * Whether the object/map/hash is empty.
 *
 * @param {Object} obj The object to test.
 * @return {boolean} true if obj is empty.
 */
goog.object.isEmpty = function(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
};


/**
 * Removes all key value pairs from the object/map/hash.
 *
 * @param {Object} obj The object to clear.
 */
goog.object.clear = function(obj) {
  for (var i in obj) {
    delete obj[i];
  }
};


/**
 * Removes a key-value pair based on the key.
 *
 * @param {Object} obj The object from which to remove the key.
 * @param {*} key The key to remove.
 * @return {boolean} Whether an element was removed.
 */
goog.object.remove = function(obj, key) {
  var rv;
  if ((rv = key in obj)) {
    delete obj[key];
  }
  return rv;
};


/**
 * Adds a key-value pair to the object. Throws an exception if the key is
 * already in use. Use set if you want to change an existing pair.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} val The value to add.
 * @template K,V
 */
goog.object.add = function(obj, key, val) {
  if (key in obj) {
    throw Error('The object already contains the key "' + key + '"');
  }
  goog.object.set(obj, key, val);
};


/**
 * Returns the value for the given key.
 *
 * @param {Object.<K,V>} obj The object from which to get the value.
 * @param {string} key The key for which to get the value.
 * @param {R=} opt_val The value to return if no item is found for the given
 *     key (default is undefined).
 * @return {V|R|undefined} The value for the given key.
 * @template K,V,R
 */
goog.object.get = function(obj, key, opt_val) {
  if (key in obj) {
    return obj[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the object/map/hash.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add.
 * @template K,V
 */
goog.object.set = function(obj, key, value) {
  obj[key] = value;
};


/**
 * Adds a key-value pair to the object/map/hash if it doesn't exist yet.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
goog.object.setIfUndefined = function(obj, key, value) {
  return key in obj ? obj[key] : (obj[key] = value);
};


/**
 * Does a flat clone of the object.
 *
 * @param {Object.<K,V>} obj Object to clone.
 * @return {!Object.<K,V>} Clone of the input object.
 * @template K,V
 */
goog.object.clone = function(obj) {
  // We cannot use the prototype trick because a lot of methods depend on where
  // the actual key is set.

  var res = {};
  for (var key in obj) {
    res[key] = obj[key];
  }
  return res;
  // We could also use goog.mixin but I wanted this to be independent from that.
};


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.object.unsafeClone</code> does not detect reference loops. Objects
 * that refer to themselves will cause infinite recursion.
 *
 * <code>goog.object.unsafeClone</code> is unaware of unique identifiers, and
 * copies UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 */
goog.object.unsafeClone = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.object.unsafeClone(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * Returns a new object in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 *
 * @param {Object} obj The object to transpose.
 * @return {!Object} The transposed object.
 */
goog.object.transpose = function(obj) {
  var transposed = {};
  for (var key in obj) {
    transposed[obj[key]] = key;
  }
  return transposed;
};


/**
 * The names of the fields that are defined on Object.prototype.
 * @type {Array.<string>}
 * @private
 */
goog.object.PROTOTYPE_FIELDS_ = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/**
 * Extends an object with another object.
 * This operates 'in-place'; it does not create a new Object.
 *
 * Example:
 * var o = {};
 * goog.object.extend(o, {a: 0, b: 1});
 * o; // {a: 0, b: 1}
 * goog.object.extend(o, {c: 2});
 * o; // {a: 0, b: 1, c: 2}
 *
 * @param {Object} target  The object to modify.
 * @param {...Object} var_args The objects from which values will be copied.
 */
goog.object.extend = function(target, var_args) {
  var key, source;
  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    for (key in source) {
      target[key] = source[key];
    }

    // For IE the for-in-loop does not contain any properties that are not
    // enumerable on the prototype object (for example isPrototypeOf from
    // Object.prototype) and it will also not include 'replace' on objects that
    // extend String and change 'replace' (not that it is common for anyone to
    // extend anything except Object).

    for (var j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {
      key = goog.object.PROTOTYPE_FIELDS_[j];
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
};


/**
 * Creates a new object built from the key-value pairs provided as arguments.
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise even arguments are used as
 *     the property names and odd arguments are used as the property values.
 * @return {!Object} The new object.
 * @throws {Error} If there are uneven number of arguments or there is only one
 *     non array argument.
 */
goog.object.create = function(var_args) {
  var argLength = arguments.length;
  if (argLength == 1 && goog.isArray(arguments[0])) {
    return goog.object.create.apply(null, arguments[0]);
  }

  if (argLength % 2) {
    throw Error('Uneven number of arguments');
  }

  var rv = {};
  for (var i = 0; i < argLength; i += 2) {
    rv[arguments[i]] = arguments[i + 1];
  }
  return rv;
};


/**
 * Creates a new object where the property names come from the arguments but
 * the value is always set to true
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise the arguments are used
 *     as the property names.
 * @return {!Object} The new object.
 */
goog.object.createSet = function(var_args) {
  var argLength = arguments.length;
  if (argLength == 1 && goog.isArray(arguments[0])) {
    return goog.object.createSet.apply(null, arguments[0]);
  }

  var rv = {};
  for (var i = 0; i < argLength; i++) {
    rv[arguments[i]] = true;
  }
  return rv;
};


/**
 * Creates an immutable view of the underlying object, if the browser
 * supports immutable objects.
 *
 * In default mode, writes to this view will fail silently. In strict mode,
 * they will throw an error.
 *
 * @param {!Object.<K,V>} obj An object.
 * @return {!Object.<K,V>} An immutable view of that object, or the
 *     original object if this browser does not support immutables.
 * @template K,V
 */
goog.object.createImmutableView = function(obj) {
  var result = obj;
  if (Object.isFrozen && !Object.isFrozen(obj)) {
    result = Object.create(obj);
    Object.freeze(result);
  }
  return result;
};


/**
 * @param {!Object} obj An object.
 * @return {boolean} Whether this is an immutable view of the object.
 */
goog.object.isImmutableView = function(obj) {
  return !!Object.isFrozen && Object.isFrozen(obj);
};

//javascript/closure/structs/map.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Datastructure: Hash Map.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author jonp@google.com (Jon Perlow) Optimized for IE6
 *
 * This file contains an implementation of a Map structure. It implements a lot
 * of the methods used in goog.structs so those functions work on hashes. This
 * is best suited for complex key types. For simple keys such as numbers and
 * strings, and where special names like __proto__ are not a concern, consider
 * using the lighter-weight utilities in goog.object.
 * MOE:begin_intracomment_strip
 *
 * NOTE(flan): Internally, key types are NOT actually cast to
 * strings. Some people actually rely on this behavior even though it
 * is incorrect. For more information, see http://b/5622311.
 *
 * NOTE(flan): Erik Corry (erikcorry) from the V8 team went over this
 * class with me to help look for simplifications and
 * optimizations. In the end, he didn't come up with very much. Erik
 * explained that "for (k in o)" is not optimized in Crankshaft
 * because it needs to look up properties in the whole prototype
 * chain. It also needs to return the keys in order. Thus keeping an
 * array of keys is actually much more efficient.
 *
 * Likewise, one option to iterate safely with "for (k in o)" is to
 * prefix the keys with some character, like ':'. This can create a
 * lot of strings that didn't exist before. In Closure Labs,
 * goog.labs.structs.Map uses extra arrays to store non-safe keys and
 * values.
 *
 * Thus, there are not a lot of reasonable simplifications that can be
 * done here without impacting performance.
 *
 * TODO(chrishenry): Create some performance benchmarks for common
 * operations.
 * MOE:end_intracomment_strip
 */


goog.provide('goog.structs.Map');

goog.require('goog.iter.Iterator');
goog.require('goog.iter.StopIteration');
goog.require('goog.object');



/**
 * Class for Hash Map datastructure.
 * @param {*=} opt_map Map or Object to initialize the map with.
 * @param {...*} var_args If 2 or more arguments are present then they
 *     will be used as key-value pairs.
 * @constructor
 * @template K, V
 */
goog.structs.Map = function(opt_map, var_args) {

  /**
   * Underlying JS object used to implement the map.
   * @private {!Object}
   */
  this.map_ = {};

  /**
   * An array of keys. This is necessary for two reasons:
   *   1. Iterating the keys using for (var key in this.map_) allocates an
   *      object for every key in IE which is really bad for IE6 GC perf.
   *   2. Without a side data structure, we would need to escape all the keys
   *      as that would be the only way we could tell during iteration if the
   *      key was an internal key or a property of the object.
   *
   * This array can contain deleted keys so it's necessary to check the map
   * as well to see if the key is still in the map (this doesn't require a
   * memory allocation in IE).
   * @private {!Array.<string>}
   */
  this.keys_ = [];

  /**
   * The number of key value pairs in the map.
   * @private {number}
   */
  this.count_ = 0;

  /**
   * Version used to detect changes while iterating.
   * @private {number}
   */
  this.version_ = 0;

  var argLength = arguments.length;

  if (argLength > 1) {
    if (argLength % 2) {
      throw Error('Uneven number of arguments');
    }
    for (var i = 0; i < argLength; i += 2) {
      this.set(arguments[i], arguments[i + 1]);
    }
  } else if (opt_map) {
    this.addAll(/** @type {Object} */ (opt_map));
  }
};


/**
 * @return {number} The number of key-value pairs in the map.
 */
goog.structs.Map.prototype.getCount = function() {
  return this.count_;
};


/**
 * Returns the values of the map.
 * @return {!Array.<V>} The values in the map.
 */
goog.structs.Map.prototype.getValues = function() {
  this.cleanupKeysArray_();

  var rv = [];
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    rv.push(this.map_[key]);
  }
  return rv;
};


/**
 * Returns the keys of the map.
 * @return {!Array.<string>} Array of string values.
 */
goog.structs.Map.prototype.getKeys = function() {
  this.cleanupKeysArray_();
  return /** @type {!Array.<string>} */ (this.keys_.concat());
};


/**
 * Whether the map contains the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the map contains the key.
 */
goog.structs.Map.prototype.containsKey = function(key) {
  return goog.structs.Map.hasKey_(this.map_, key);
};


/**
 * Whether the map contains the given value. This is O(n).
 * @param {V} val The value to check for.
 * @return {boolean} Whether the map contains the value.
 */
goog.structs.Map.prototype.containsValue = function(val) {
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {
      return true;
    }
  }
  return false;
};


/**
 * Whether this map is equal to the argument map.
 * @param {goog.structs.Map} otherMap The map against which to test equality.
 * @param {function(V, V): boolean=} opt_equalityFn Optional equality function
 *     to test equality of values. If not specified, this will test whether
 *     the values contained in each map are identical objects.
 * @return {boolean} Whether the maps are equal.
 */
goog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {
  if (this === otherMap) {
    return true;
  }

  if (this.count_ != otherMap.getCount()) {
    return false;
  }

  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;

  this.cleanupKeysArray_();
  for (var key, i = 0; key = this.keys_[i]; i++) {
    if (!equalityFn(this.get(key), otherMap.get(key))) {
      return false;
    }
  }

  return true;
};


/**
 * Default equality test for values.
 * @param {*} a The first value.
 * @param {*} b The second value.
 * @return {boolean} Whether a and b reference the same object.
 */
goog.structs.Map.defaultEquals = function(a, b) {
  return a === b;
};


/**
 * @return {boolean} Whether the map is empty.
 */
goog.structs.Map.prototype.isEmpty = function() {
  return this.count_ == 0;
};


/**
 * Removes all key-value pairs from the map.
 */
goog.structs.Map.prototype.clear = function() {
  this.map_ = {};
  this.keys_.length = 0;
  this.count_ = 0;
  this.version_ = 0;
};


/**
 * Removes a key-value pair based on the key. This is O(logN) amortized due to
 * updating the keys array whenever the count becomes half the size of the keys
 * in the keys array.
 * @param {*} key  The key to remove.
 * @return {boolean} Whether object was removed.
 */
goog.structs.Map.prototype.remove = function(key) {
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    delete this.map_[key];
    this.count_--;
    this.version_++;

    // clean up the keys array if the threshhold is hit
    if (this.keys_.length > 2 * this.count_) {
      this.cleanupKeysArray_();
    }

    return true;
  }
  return false;
};


/**
 * Cleans up the temp keys array by removing entries that are no longer in the
 * map.
 * @private
 */
goog.structs.Map.prototype.cleanupKeysArray_ = function() {
  if (this.count_ != this.keys_.length) {
    // First remove keys that are no longer in the map.
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (goog.structs.Map.hasKey_(this.map_, key)) {
        this.keys_[destIndex++] = key;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }

  if (this.count_ != this.keys_.length) {
    // If the count still isn't correct, that means we have duplicates. This can
    // happen when the same key is added and removed multiple times. Now we have
    // to allocate one extra Object to remove the duplicates. This could have
    // been done in the first pass, but in the common case, we can avoid
    // allocating an extra object by only doing this when necessary.
    var seen = {};
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (!(goog.structs.Map.hasKey_(seen, key))) {
        this.keys_[destIndex++] = key;
        seen[key] = 1;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }
};


/**
 * Returns the value for the given key.  If the key is not found and the default
 * value is not given this will return {@code undefined}.
 * @param {*} key The key to get the value for.
 * @param {DEFAULT=} opt_val The value to return if no item is found for the
 *     given key, defaults to undefined.
 * @return {V|DEFAULT} The value for the given key.
 * @template DEFAULT
 */
goog.structs.Map.prototype.get = function(key, opt_val) {
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    return this.map_[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the map.
 * @param {*} key The key.
 * @param {V} value The value to add.
 * @return {*} Some subclasses return a value.
 */
goog.structs.Map.prototype.set = function(key, value) {
  if (!(goog.structs.Map.hasKey_(this.map_, key))) {
    this.count_++;
    this.keys_.push(key);
    // Only change the version if we add a new key.
    this.version_++;
  }
  this.map_[key] = value;
};


/**
 * Adds multiple key-value pairs from another goog.structs.Map or Object.
 * @param {Object} map  Object containing the data to add.
 */
goog.structs.Map.prototype.addAll = function(map) {
  var keys, values;
  if (map instanceof goog.structs.Map) {
    keys = map.getKeys();
    values = map.getValues();
  } else {
    keys = goog.object.getKeys(map);
    values = goog.object.getValues(map);
  }
  // we could use goog.array.forEach here but I don't want to introduce that
  // dependency just for this.
  for (var i = 0; i < keys.length; i++) {
    this.set(keys[i], values[i]);
  }
};


/**
 * Clones a map and returns a new map.
 * @return {!goog.structs.Map} A new map with the same key-value pairs.
 */
goog.structs.Map.prototype.clone = function() {
  return new goog.structs.Map(this);
};


/**
 * Returns a new map in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 *
 * It acts very similarly to {goog.object.transpose(Object)}.
 *
 * @return {!goog.structs.Map} The transposed map.
 */
goog.structs.Map.prototype.transpose = function() {
  var transposed = new goog.structs.Map();
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    var value = this.map_[key];
    transposed.set(value, key);
  }

  return transposed;
};


/**
 * @return {!Object} Object representation of the map.
 */
goog.structs.Map.prototype.toObject = function() {
  this.cleanupKeysArray_();
  var obj = {};
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    obj[key] = this.map_[key];
  }
  return obj;
};


/**
 * Returns an iterator that iterates over the keys in the map.  Removal of keys
 * while iterating might have undesired side effects.
 * @return {!goog.iter.Iterator} An iterator over the keys in the map.
 */
goog.structs.Map.prototype.getKeyIterator = function() {
  return this.__iterator__(true);
};


/**
 * Returns an iterator that iterates over the values in the map.  Removal of
 * keys while iterating might have undesired side effects.
 * @return {!goog.iter.Iterator} An iterator over the values in the map.
 */
goog.structs.Map.prototype.getValueIterator = function() {
  return this.__iterator__(false);
};


/**
 * Returns an iterator that iterates over the values or the keys in the map.
 * This throws an exception if the map was mutated since the iterator was
 * created.
 * @param {boolean=} opt_keys True to iterate over the keys. False to iterate
 *     over the values.  The default value is false.
 * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.
 */
goog.structs.Map.prototype.__iterator__ = function(opt_keys) {
  // Clean up keys to minimize the risk of iterating over dead keys.
  this.cleanupKeysArray_();

  var i = 0;
  var keys = this.keys_;
  var map = this.map_;
  var version = this.version_;
  var selfObj = this;

  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (true) {
      if (version != selfObj.version_) {
        throw Error('The map has changed since the iterator was created');
      }
      if (i >= keys.length) {
        throw goog.iter.StopIteration;
      }
      var key = keys[i++];
      return opt_keys ? key : map[key];
    }
  };
  return newIter;
};


/**
 * Safe way to test for hasOwnProperty.  It even allows testing for
 * 'hasOwnProperty'.
 * @param {Object} obj The object to test for presence of the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the object has the key.
 * @private
 */
goog.structs.Map.hasKey_ = function(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

//javascript/closure/structs/structs.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Generics method for collection-like classes and objects.
 *
 * @author arv@google.com (Erik Arvidsson)
 *
 * This file contains functions to work with collections. It supports using
 * Map, Set, Array and Object and other classes that implement collection-like
 * methods.
 */


goog.provide('goog.structs');

goog.require('goog.array');
goog.require('goog.object');


// We treat an object as a dictionary if it has getKeys or it is an object that
// isn't arrayLike.


/**
 * Returns the number of values in the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {number} The number of values in the collection-like object.
 */
goog.structs.getCount = function(col) {
  if (typeof col.getCount == 'function') {
    return col.getCount();
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return col.length;
  }
  return goog.object.getCount(col);
};


/**
 * Returns the values of the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {!Array} The values in the collection-like object.
 */
goog.structs.getValues = function(col) {
  if (typeof col.getValues == 'function') {
    return col.getValues();
  }
  if (goog.isString(col)) {
    return col.split('');
  }
  if (goog.isArrayLike(col)) {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(col[i]);
    }
    return rv;
  }
  return goog.object.getValues(col);
};


/**
 * Returns the keys of the collection. Some collections have no notion of
 * keys/indexes and this function will return undefined in those cases.
 * @param {Object} col The collection-like object.
 * @return {!Array|undefined} The keys in the collection.
 */
goog.structs.getKeys = function(col) {
  if (typeof col.getKeys == 'function') {
    return col.getKeys();
  }
  // if we have getValues but no getKeys we know this is a key-less collection
  if (typeof col.getValues == 'function') {
    return undefined;
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(i);
    }
    return rv;
  }

  return goog.object.getKeys(col);
};


/**
 * Whether the collection contains the given value. This is O(n) and uses
 * equals (==) to test the existence.
 * @param {Object} col The collection-like object.
 * @param {*} val The value to check for.
 * @return {boolean} True if the map contains the value.
 */
goog.structs.contains = function(col, val) {
  if (typeof col.contains == 'function') {
    return col.contains(val);
  }
  if (typeof col.containsValue == 'function') {
    return col.containsValue(val);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.contains(/** @type {Array} */ (col), val);
  }
  return goog.object.containsValue(col, val);
};


/**
 * Whether the collection is empty.
 * @param {Object} col The collection-like object.
 * @return {boolean} True if empty.
 */
goog.structs.isEmpty = function(col) {
  if (typeof col.isEmpty == 'function') {
    return col.isEmpty();
  }

  // We do not use goog.string.isEmpty because here we treat the string as
  // collection and as such even whitespace matters

  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.isEmpty(/** @type {Array} */ (col));
  }
  return goog.object.isEmpty(col);
};


/**
 * Removes all the elements from the collection.
 * @param {Object} col The collection-like object.
 */
goog.structs.clear = function(col) {
  // NOTE(arv): This should not contain strings because strings are immutable
  if (typeof col.clear == 'function') {
    col.clear();
  } else if (goog.isArrayLike(col)) {
    goog.array.clear(/** @type {goog.array.ArrayLike} */ (col));
  } else {
    goog.object.clear(col);
  }
};


/**
 * Calls a function for each value in a collection. The function takes
 * three arguments; the value, the key and the collection.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):?} f The function to call for every value.
 *     This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and the return value is irrelevant.
 * @param {T=} opt_obj The object to be used as the value of 'this'
 *     within {@code f}.
 * @template T,S
 */
goog.structs.forEach = function(col, f, opt_obj) {
  if (typeof col.forEach == 'function') {
    col.forEach(f, opt_obj);
  } else if (goog.isArrayLike(col) || goog.isString(col)) {
    goog.array.forEach(/** @type {Array} */ (col), f, opt_obj);
  } else {
    var keys = goog.structs.getKeys(col);
    var values = goog.structs.getValues(col);
    var l = values.length;
    for (var i = 0; i < l; i++) {
      f.call(opt_obj, values[i], keys && keys[i], col);
    }
  }
};


/**
 * Calls a function for every value in the collection. When a call returns true,
 * adds the value to a new collection (Array is returned by default).
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and should return a Boolean. If the
 *     return value is true the value is added to the result collection. If it
 *     is false the value is not included.
 * @param {T=} opt_obj The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {!Object|!Array} A new collection where the passed values are
 *     present. If col is a key-less collection an array is returned.  If col
 *     has keys and values a plain old JS object is returned.
 * @template T,S
 */
goog.structs.filter = function(col, f, opt_obj) {
  if (typeof col.filter == 'function') {
    return col.filter(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.filter(/** @type {!Array} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      if (f.call(opt_obj, values[i], keys[i], col)) {
        rv[keys[i]] = values[i];
      }
    }
  } else {
    // We should not use goog.array.filter here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      if (f.call(opt_obj, values[i], undefined, col)) {
        rv.push(values[i]);
      }
    }
  }
  return rv;
};


/**
 * Calls a function for every value in the collection and adds the result into a
 * new collection (defaults to creating a new Array).
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):V} f The function to call for every value.
 *     This function takes 3 arguments (the value, the key or undefined if the
 *     collection has no notion of keys, and the collection) and should return
 *     something. The result will be used as the value in the new collection.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {!Object.<V>|!Array.<V>} A new collection with the new values.  If
 *     col is a key-less collection an array is returned.  If col has keys and
 *     values a plain old JS object is returned.
 * @template T,S,V
 */
goog.structs.map = function(col, f, opt_obj) {
  if (typeof col.map == 'function') {
    return col.map(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.map(/** @type {!Array} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      rv[keys[i]] = f.call(opt_obj, values[i], keys[i], col);
    }
  } else {
    // We should not use goog.array.map here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      rv[i] = f.call(opt_obj, values[i], undefined, col);
    }
  }
  return rv;
};


/**
 * Calls f for each value in a collection. If any call returns true this returns
 * true (without checking the rest). If all returns false this returns false.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes 3 arguments (the value, the key or undefined
 *     if the collection has no notion of keys, and the collection) and should
 *     return a boolean.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {boolean} True if any value passes the test.
 * @template T,S
 */
goog.structs.some = function(col, f, opt_obj) {
  if (typeof col.some == 'function') {
    return col.some(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.some(/** @type {!Array} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (f.call(opt_obj, values[i], keys && keys[i], col)) {
      return true;
    }
  }
  return false;
};


/**
 * Calls f for each value in a collection. If all calls return true this return
 * true this returns true. If any returns false this returns false at this point
 *  and does not continue to check the remaining values.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes 3 arguments (the value, the key or
 *     undefined if the collection has no notion of keys, and the collection)
 *     and should return a boolean.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {boolean} True if all key-value pairs pass the test.
 * @template T,S
 */
goog.structs.every = function(col, f, opt_obj) {
  if (typeof col.every == 'function') {
    return col.every(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.every(/** @type {!Array} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (!f.call(opt_obj, values[i], keys && keys[i], col)) {
      return false;
    }
  }
  return true;
};

//javascript/closure/structs/set.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Datastructure: Set.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author pallosp@google.com (Peter Pallos)
 *
 * This class implements a set data structure. Adding and removing is O(1). It
 * supports both object and primitive values. Be careful because you can add
 * both 1 and new Number(1), because these are not the same. You can even add
 * multiple new Number(1) because these are not equal.
 */


goog.provide('goog.structs.Set');

goog.require('goog.structs');
goog.require('goog.structs.Collection');
goog.require('goog.structs.Map');



/**
 * A set that can contain both primitives and objects.  Adding and removing
 * elements is O(1).  Primitives are treated as identical if they have the same
 * type and convert to the same string.  Objects are treated as identical only
 * if they are references to the same object.  WARNING: A goog.structs.Set can
 * contain both 1 and (new Number(1)), because they are not the same.  WARNING:
 * Adding (new Number(1)) twice will yield two distinct elements, because they
 * are two different objects.  WARNING: Any object that is added to a
 * goog.structs.Set will be modified!  Because goog.getUid() is used to
 * identify objects, every object in the set will be mutated.
 * @param {Array.<T>|Object.<?,T>=} opt_values Initial values to start with.
 * @constructor
 * @implements {goog.structs.Collection.<T>}
 * @final
 * @template T
 */
goog.structs.Set = function(opt_values) {
  this.map_ = new goog.structs.Map;
  if (opt_values) {
    this.addAll(opt_values);
  }
};


/**
 * Obtains a unique key for an element of the set.  Primitives will yield the
 * same key if they have the same type and convert to the same string.  Object
 * references will yield the same key only if they refer to the same object.
 * @param {*} val Object or primitive value to get a key for.
 * @return {string} A unique key for this value/object.
 * @private
 */
goog.structs.Set.getKey_ = function(val) {
  var type = typeof val;
  if (type == 'object' && val || type == 'function') {
    return 'o' + goog.getUid(/** @type {Object} */ (val));
  } else {
    return type.substr(0, 1) + val;
  }
};


/**
 * @return {number} The number of elements in the set.
 * @override
 */
goog.structs.Set.prototype.getCount = function() {
  return this.map_.getCount();
};


/**
 * Add a primitive or an object to the set.
 * @param {T} element The primitive or object to add.
 * @override
 */
goog.structs.Set.prototype.add = function(element) {
  this.map_.set(goog.structs.Set.getKey_(element), element);
};


/**
 * Adds all the values in the given collection to this set.
 * @param {Array.<T>|Object.<?,T>} col A collection containing the elements to
 *     add.
 */
goog.structs.Set.prototype.addAll = function(col) {
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    this.add(values[i]);
  }
};


/**
 * Removes all values in the given collection from this set.
 * @param {Array.<T>|Object.<?,T>} col A collection containing the elements to
 *     remove.
 */
goog.structs.Set.prototype.removeAll = function(col) {
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    this.remove(values[i]);
  }
};


/**
 * Removes the given element from this set.
 * @param {T} element The primitive or object to remove.
 * @return {boolean} Whether the element was found and removed.
 * @override
 */
goog.structs.Set.prototype.remove = function(element) {
  return this.map_.remove(goog.structs.Set.getKey_(element));
};


/**
 * Removes all elements from this set.
 */
goog.structs.Set.prototype.clear = function() {
  this.map_.clear();
};


/**
 * Tests whether this set is empty.
 * @return {boolean} True if there are no elements in this set.
 */
goog.structs.Set.prototype.isEmpty = function() {
  return this.map_.isEmpty();
};


/**
 * Tests whether this set contains the given element.
 * @param {T} element The primitive or object to test for.
 * @return {boolean} True if this set contains the given element.
 * @override
 */
goog.structs.Set.prototype.contains = function(element) {
  return this.map_.containsKey(goog.structs.Set.getKey_(element));
};


/**
 * Tests whether this set contains all the values in a given collection.
 * Repeated elements in the collection are ignored, e.g.  (new
 * goog.structs.Set([1, 2])).containsAll([1, 1]) is True.
 * @param {Object} col A collection-like object.
 * @return {boolean} True if the set contains all elements.
 */
goog.structs.Set.prototype.containsAll = function(col) {
  return goog.structs.every(col, this.contains, this);
};


/**
 * Finds all values that are present in both this set and the given collection.
 * @param {Array.<S>|Object.<?,S>} col A collection.
 * @return {!goog.structs.Set.<T|S>} A new set containing all the values
 *     (primitives or objects) present in both this set and the given
 *     collection.
 * @template S
 */
goog.structs.Set.prototype.intersection = function(col) {
  var result = new goog.structs.Set();

  var values = goog.structs.getValues(col);
  for (var i = 0; i < values.length; i++) {
    var value = values[i];
    if (this.contains(value)) {
      result.add(value);
    }
  }

  return result;
};


/**
 * Finds all values that are present in this set and not in the given
 * collection.
 * @param {Array.<T>|Object.<?,T>} col A collection.
 * @return {!goog.structs.Set} A new set containing all the values
 *     (primitives or objects) present in this set but not in the given
 *     collection.
 */
goog.structs.Set.prototype.difference = function(col) {
  var result = this.clone();
  result.removeAll(col);
  return result;
};


/**
 * Returns an array containing all the elements in this set.
 * @return {!Array.<T>} An array containing all the elements in this set.
 */
goog.structs.Set.prototype.getValues = function() {
  return this.map_.getValues();
};


/**
 * Creates a shallow clone of this set.
 * @return {!goog.structs.Set.<T>} A new set containing all the same elements as
 *     this set.
 */
goog.structs.Set.prototype.clone = function() {
  return new goog.structs.Set(this);
};


/**
 * Tests whether the given collection consists of the same elements as this set,
 * regardless of order, without repetition.  Primitives are treated as equal if
 * they have the same type and convert to the same string; objects are treated
 * as equal if they are references to the same object.  This operation is O(n).
 * @param {Object} col A collection.
 * @return {boolean} True if the given collection consists of the same elements
 *     as this set, regardless of order, without repetition.
 */
goog.structs.Set.prototype.equals = function(col) {
  return this.getCount() == goog.structs.getCount(col) && this.isSubsetOf(col);
};


/**
 * Tests whether the given collection contains all the elements in this set.
 * Primitives are treated as equal if they have the same type and convert to the
 * same string; objects are treated as equal if they are references to the same
 * object.  This operation is O(n).
 * @param {Object} col A collection.
 * @return {boolean} True if this set is a subset of the given collection.
 */
goog.structs.Set.prototype.isSubsetOf = function(col) {
  var colCount = goog.structs.getCount(col);
  if (this.getCount() > colCount) {
    return false;
  }
  // TODO(pallosp) Find the minimal collection size where the conversion makes
  // the contains() method faster.
  if (!(col instanceof goog.structs.Set) && colCount > 5) {
    // Convert to a goog.structs.Set so that goog.structs.contains runs in
    // O(1) time instead of O(n) time.
    col = new goog.structs.Set(col);
  }
  return goog.structs.every(this, function(value) {
    return goog.structs.contains(col, value);
  });
};


/**
 * Returns an iterator that iterates over the elements in this set.
 * @param {boolean=} opt_keys This argument is ignored.
 * @return {!goog.iter.Iterator} An iterator over the elements in this set.
 */
goog.structs.Set.prototype.__iterator__ = function(opt_keys) {
  return this.map_.__iterator__(false);
};

//javascript/closure/useragent/useragent.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Rendering engine detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For information on the browser brand (such as Safari versus Chrome), see
 * goog.userAgent.product.
 * @author pupius@google.com (Daniel Pupius)
 * @author arv@google.com (Erik Arvidsson)
 * @see ../demos/useragent.html
 */

goog.provide('goog.userAgent');

goog.require('goog.string');


/**
 * @define {boolean} Whether we know at compile-time that the browser is IE.
 */
goog.define('goog.userAgent.ASSUME_IE', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is GECKO.
 */
goog.define('goog.userAgent.ASSUME_GECKO', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.
 */
goog.define('goog.userAgent.ASSUME_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is a
 *     mobile device running WebKit e.g. iPhone or Android.
 */
goog.define('goog.userAgent.ASSUME_MOBILE_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is OPERA.
 */
goog.define('goog.userAgent.ASSUME_OPERA', false);


/**
 * @define {boolean} Whether the
 *     {@code goog.userAgent.isVersionOrHigher}
 *     function will return true for any version.
 */
goog.define('goog.userAgent.ASSUME_ANY_VERSION', false);


/**
 * Whether we know the browser engine at compile-time.
 * @type {boolean}
 * @private
 */
goog.userAgent.BROWSER_KNOWN_ =
    goog.userAgent.ASSUME_IE ||
    goog.userAgent.ASSUME_GECKO ||
    goog.userAgent.ASSUME_MOBILE_WEBKIT ||
    goog.userAgent.ASSUME_WEBKIT ||
    goog.userAgent.ASSUME_OPERA;


/**
 * Returns the userAgent string for the current browser.
 * Some user agents (I'm thinking of you, Gears WorkerPool) do not expose a
 * navigator object off the global scope.  In that case we return null.
 *
 * @return {?string} The userAgent string or null if there is none.
 */
goog.userAgent.getUserAgentString = function() {
  return goog.global['navigator'] ? goog.global['navigator'].userAgent : null;
};


/**
 * @return {Object} The native navigator object.
 */
goog.userAgent.getNavigator = function() {
  // Need a local navigator reference instead of using the global one,
  // to avoid the rare case where they reference different objects.
  // (in a WorkerPool, for example).
  return goog.global['navigator'];
};


/**
 * Initializer for goog.userAgent.
 *
 * This is a named function so that it can be stripped via the jscompiler
 * option for stripping types.
 * @private
 */
goog.userAgent.init_ = function() {
  /**
   * Whether the user agent string denotes Opera.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedOpera_ = false;

  /**
   * Whether the user agent string denotes Internet Explorer. This includes
   * other browsers using Trident as its rendering engine. For example AOL
   * and Netscape 8
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedIe_ = false;

  /**
   * Whether the user agent string denotes WebKit. WebKit is the rendering
   * engine that Safari, Android and others use.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedWebkit_ = false;

  /**
   * Whether the user agent string denotes a mobile device.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedMobile_ = false;

  /**
   * Whether the user agent string denotes Gecko. Gecko is the rendering
   * engine used by Mozilla, Mozilla Firefox, Camino and many more.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedGecko_ = false;

  var ua;
  if (!goog.userAgent.BROWSER_KNOWN_ &&
      (ua = goog.userAgent.getUserAgentString())) {
    var navigator = goog.userAgent.getNavigator();
    goog.userAgent.detectedOpera_ = goog.string.startsWith(ua, 'Opera');
    goog.userAgent.detectedIe_ = !goog.userAgent.detectedOpera_ &&
        (goog.string.contains(ua, 'MSIE') ||
         goog.string.contains(ua, 'Trident'));
    goog.userAgent.detectedWebkit_ = !goog.userAgent.detectedOpera_ &&
        goog.string.contains(ua, 'WebKit');
    // WebKit also gives navigator.product string equal to 'Gecko'.
    goog.userAgent.detectedMobile_ = goog.userAgent.detectedWebkit_ &&
        goog.string.contains(ua, 'Mobile');
    goog.userAgent.detectedGecko_ = !goog.userAgent.detectedOpera_ &&
        !goog.userAgent.detectedWebkit_ && !goog.userAgent.detectedIe_ &&
        navigator.product == 'Gecko';
  }
};


if (!goog.userAgent.BROWSER_KNOWN_) {
  goog.userAgent.init_();
}


/**
 * Whether the user agent is Opera.
 * @type {boolean}
 */
goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_OPERA : goog.userAgent.detectedOpera_;


/**
 * Whether the user agent is Internet Explorer. This includes other browsers
 * using Trident as its rendering engine. For example AOL and Netscape 8
 * @type {boolean}
 */
goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_IE : goog.userAgent.detectedIe_;


/**
 * Whether the user agent is Gecko. Gecko is the rendering engine used by
 * Mozilla, Mozilla Firefox, Camino and many more.
 * @type {boolean}
 */
goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_GECKO :
    goog.userAgent.detectedGecko_;


/**
 * Whether the user agent is WebKit. WebKit is the rendering engine that
 * Safari, Android and others use.
 * @type {boolean}
 */
goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT :
    goog.userAgent.detectedWebkit_;


/**
 * Whether the user agent is running on a mobile device.
 * @type {boolean}
 */
goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT ||
                        goog.userAgent.detectedMobile_;


/**
 * Used while transitioning code to use WEBKIT instead.
 * @type {boolean}
 * @deprecated Use {@link goog.userAgent.product.SAFARI} instead.
 * TODO(nicksantos): Delete this from goog.userAgent.
 */
goog.userAgent.SAFARI = goog.userAgent.WEBKIT;


/**
 * @return {string} the platform (operating system) the user agent is running
 *     on. Default to empty string because navigator.platform may not be defined
 *     (on Rhino, for example).
 * @private
 */
goog.userAgent.determinePlatform_ = function() {
  var navigator = goog.userAgent.getNavigator();
  return navigator && navigator.platform || '';
};


/**
 * The platform (operating system) the user agent is running on. Default to
 * empty string because navigator.platform may not be defined (on Rhino, for
 * example).
 * @type {string}
 */
goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();


/**
 * @define {boolean} Whether the user agent is running on a Macintosh operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_MAC', false);


/**
 * @define {boolean} Whether the user agent is running on a Windows operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_WINDOWS', false);


/**
 * @define {boolean} Whether the user agent is running on a Linux operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_LINUX', false);


/**
 * @define {boolean} Whether the user agent is running on a X11 windowing
 *     system.
 */
goog.define('goog.userAgent.ASSUME_X11', false);


/**
 * @define {boolean} Whether the user agent is running on Android.
 */
goog.define('goog.userAgent.ASSUME_ANDROID', false);


/**
 * @define {boolean} Whether the user agent is running on an iPhone.
 */
goog.define('goog.userAgent.ASSUME_IPHONE', false);


/**
 * @define {boolean} Whether the user agent is running on an iPad.
 */
goog.define('goog.userAgent.ASSUME_IPAD', false);


/**
 * @type {boolean}
 * @private
 */
goog.userAgent.PLATFORM_KNOWN_ =
    goog.userAgent.ASSUME_MAC ||
    goog.userAgent.ASSUME_WINDOWS ||
    goog.userAgent.ASSUME_LINUX ||
    goog.userAgent.ASSUME_X11 ||
    goog.userAgent.ASSUME_ANDROID ||
    goog.userAgent.ASSUME_IPHONE ||
    goog.userAgent.ASSUME_IPAD;


/**
 * Initialize the goog.userAgent constants that define which platform the user
 * agent is running on.
 * @private
 */
goog.userAgent.initPlatform_ = function() {
  /**
   * Whether the user agent is running on a Macintosh operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedMac_ = goog.string.contains(goog.userAgent.PLATFORM,
      'Mac');

  /**
   * Whether the user agent is running on a Windows operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedWindows_ = goog.string.contains(
      goog.userAgent.PLATFORM, 'Win');

  /**
   * Whether the user agent is running on a Linux operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedLinux_ = goog.string.contains(goog.userAgent.PLATFORM,
      'Linux');

  /**
   * Whether the user agent is running on a X11 windowing system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedX11_ = !!goog.userAgent.getNavigator() &&
      goog.string.contains(goog.userAgent.getNavigator()['appVersion'] || '',
          'X11');

  // Need user agent string for Android/IOS detection
  var ua = goog.userAgent.getUserAgentString();

  /**
   * Whether the user agent is running on Android.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedAndroid_ = !!ua &&
      goog.string.contains(ua, 'Android');

  /**
   * Whether the user agent is running on an iPhone.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedIPhone_ = !!ua && goog.string.contains(ua, 'iPhone');

  /**
   * Whether the user agent is running on an iPad.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedIPad_ = !!ua && goog.string.contains(ua, 'iPad');
};


if (!goog.userAgent.PLATFORM_KNOWN_) {
  goog.userAgent.initPlatform_();
}


/**
 * Whether the user agent is running on a Macintosh operating system.
 * @type {boolean}
 */
goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_MAC : goog.userAgent.detectedMac_;


/**
 * Whether the user agent is running on a Windows operating system.
 * @type {boolean}
 */
goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_WINDOWS : goog.userAgent.detectedWindows_;


/**
 * Whether the user agent is running on a Linux operating system.
 * @type {boolean}
 */
goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_LINUX : goog.userAgent.detectedLinux_;


/**
 * Whether the user agent is running on a X11 windowing system.
 * @type {boolean}
 */
goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_X11 : goog.userAgent.detectedX11_;


/**
 * Whether the user agent is running on Android.
 * @type {boolean}
 */
goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_ANDROID : goog.userAgent.detectedAndroid_;


/**
 * Whether the user agent is running on an iPhone.
 * @type {boolean}
 */
goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPHONE : goog.userAgent.detectedIPhone_;


/**
 * Whether the user agent is running on an iPad.
 * @type {boolean}
 */
goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPAD : goog.userAgent.detectedIPad_;


/**
 * @return {string} The string that describes the version number of the user
 *     agent.
 * @private
 */
goog.userAgent.determineVersion_ = function() {
  // All browsers have different ways to detect the version and they all have
  // different naming schemes.

  // version is a string rather than a number because it may contain 'b', 'a',
  // and so on.
  var version = '', re;

  if (goog.userAgent.OPERA && goog.global['opera']) {
    var operaVersion = goog.global['opera'].version;
    version = typeof operaVersion == 'function' ? operaVersion() : operaVersion;
  } else {
    if (goog.userAgent.GECKO) {
      re = /rv\:([^\);]+)(\)|;)/;
    } else if (goog.userAgent.IE) {
      re = /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/;
    } else if (goog.userAgent.WEBKIT) {
      // WebKit/125.4
      re = /WebKit\/(\S+)/;
    }
    if (re) {
      var arr = re.exec(goog.userAgent.getUserAgentString());
      version = arr ? arr[1] : '';
    }
  }
  if (goog.userAgent.IE) {
    // IE9 can be in document mode 9 but be reporting an inconsistent user agent
    // version.  If it is identifying as a version lower than 9 we take the
    // documentMode as the version instead.  IE8 has similar behavior.
    // It is recommended to set the X-UA-Compatible header to ensure that IE9
    // uses documentMode 9.
    var docMode = goog.userAgent.getDocumentMode_();
    if (docMode > parseFloat(version)) {
      return String(docMode);
    }
  }
  return version;
};


/**
 * @return {number|undefined} Returns the document mode (for testing).
 * @private
 */
goog.userAgent.getDocumentMode_ = function() {
  // NOTE(pupius): goog.userAgent may be used in context where there is no DOM.
  var doc = goog.global['document'];
  return doc ? doc['documentMode'] : undefined;
};


/**
 * The version of the user agent. This is a string because it might contain
 * 'b' (as in beta) as well as multiple dots.
 * @type {string}
 */
goog.userAgent.VERSION = goog.userAgent.determineVersion_();


/**
 * Compares two version numbers.
 *
 * @param {string} v1 Version of first item.
 * @param {string} v2 Version of second item.
 *
 * @return {number}  1 if first argument is higher
 *                   0 if arguments are equal
 *                  -1 if second argument is higher.
 * @deprecated Use goog.string.compareVersions.
 */
goog.userAgent.compare = function(v1, v2) {
  return goog.string.compareVersions(v1, v2);
};


/**
 * Cache for {@link goog.userAgent.isVersionOrHigher}.
 * Calls to compareVersions are surprisingly expensive and, as a browser's
 * version number is unlikely to change during a session, we cache the results.
 * @const
 * @private
 */
goog.userAgent.isVersionOrHigherCache_ = {};


/**
 * Whether the user agent version is higher or the same as the given version.
 * NOTE: When checking the version numbers for Firefox and Safari, be sure to
 * use the engine's version, not the browser's version number.  For example,
 * Firefox 3.0 corresponds to Gecko 1.9 and Safari 3.0 to Webkit 522.11.
 * Opera and Internet Explorer versions match the product release number.<br>
 * @see <a href="http://en.wikipedia.org/wiki/Safari_version_history">
 *     Webkit</a>
 * @see <a href="http://en.wikipedia.org/wiki/Gecko_engine">Gecko</a>
 *
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 */
goog.userAgent.isVersionOrHigher = function(version) {
  return goog.userAgent.ASSUME_ANY_VERSION ||
      goog.userAgent.isVersionOrHigherCache_[version] ||
      (goog.userAgent.isVersionOrHigherCache_[version] =
          goog.string.compareVersions(goog.userAgent.VERSION, version) >= 0);
};


/**
 * Deprecated alias to {@code goog.userAgent.isVersionOrHigher}.
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 * @deprecated Use goog.userAgent.isVersionOrHigher().
 */
goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher;


/**
 * Whether the IE effective document mode is higher or the same as the given
 * document mode version.
 * NOTE: Only for IE, return false for another browser.
 *
 * @param {number} documentMode The document mode version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *     same as the given version.
 */
goog.userAgent.isDocumentModeOrHigher = function(documentMode) {
  return goog.userAgent.IE && goog.userAgent.DOCUMENT_MODE >= documentMode;
};


/**
 * Deprecated alias to {@code goog.userAgent.isDocumentModeOrHigher}.
 * @param {number} version The version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *      same as the given version.
 * @deprecated Use goog.userAgent.isDocumentModeOrHigher().
 */
goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;


/**
 * For IE version < 7, documentMode is undefined, so attempt to use the
 * CSS1Compat property to see if we are in standards mode. If we are in
 * standards mode, treat the browser version as the document mode. Otherwise,
 * IE is emulating version 5.
 * @type {number|undefined}
 * @const
 */
goog.userAgent.DOCUMENT_MODE = (function() {
  var doc = goog.global['document'];
  if (!doc || !goog.userAgent.IE) {
    return undefined;
  }
  var mode = goog.userAgent.getDocumentMode_();
  return mode || (doc['compatMode'] == 'CSS1Compat' ?
      parseInt(goog.userAgent.VERSION, 10) : 5);
})();

//javascript/closure/debug/debug.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Logging and debugging utilities.
 *
 * @author pupius@google.com (Daniel Pupius)
 * @see ../demos/debug.html
 */

goog.provide('goog.debug');

goog.require('goog.array');
goog.require('goog.string');
goog.require('goog.structs.Set');
goog.require('goog.userAgent');


/** @define {boolean} Whether logging should be enabled. */
goog.define('goog.debug.LOGGING_ENABLED', goog.DEBUG);


/**
 * Catches onerror events fired by windows and similar objects.
 * @param {function(Object)} logFunc The function to call with the error
 *    information.
 * @param {boolean=} opt_cancel Whether to stop the error from reaching the
 *    browser.
 * @param {Object=} opt_target Object that fires onerror events.
 */
goog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {
  var target = opt_target || goog.global;
  var oldErrorHandler = target.onerror;
  var retVal = !!opt_cancel;

  // Chrome interprets onerror return value backwards (http://crbug.com/92062)
  // until it was fixed in webkit revision r94061 (Webkit 535.3). This
  // workaround still needs to be skipped in Safari after the webkit change
  // gets pushed out in Safari.
  // See https://bugs.webkit.org/show_bug.cgi?id=67119
  if (goog.userAgent.WEBKIT &&
      !goog.userAgent.isVersionOrHigher('535.3')) {
    retVal = !retVal;
  }

  /**
   * New onerror handler for this target. This onerror handler follows the spec
   * according to
   * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors
   * The spec was changed in August 2013 to support receiving column information
   * and an error object for all scripts on the same origin or cross origin
   * scripts with the proper headers. See
   * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
   *
   * @param {string} message The error message. For cross-origin errors, this
   *     will be scrubbed to just "Script error.". For new browsers that have
   *     updated to follow the latest spec, errors that come from origins that
   *     have proper cross origin headers will not be scrubbed.
   * @param {string} url The URL of the script that caused the error. The URL
   *     will be scrubbed to "" for cross origin scripts unless the script has
   *     proper cross origin headers and the browser has updated to the latest
   *     spec.
   * @param {number} line The line number in the script that the error
   *     occurred on.
   * @param {number=} opt_col The optional column number that the error
   *     occurred on. Only browsers that have updated to the latest spec will
   *     include this.
   * @param {Error=} opt_error The optional actual error object for this
   *     error that should include the stack. Only browsers that have updated
   *     to the latest spec will inlude this parameter.
   * @return {boolean} Whether to prevent the error from reaching the browser.
   */
  target.onerror = function(message, url, line, opt_col, opt_error) {
    if (oldErrorHandler) {
      oldErrorHandler(message, url, line, opt_col, opt_error);
    }
    logFunc({
      message: message,
      fileName: url,
      line: line,
      col: opt_col,
      error: opt_error
    });
    return retVal;
  };
};


/**
 * Creates a string representing an object and all its properties.
 * @param {Object|null|undefined} obj Object to expose.
 * @param {boolean=} opt_showFn Show the functions as well as the properties,
 *     default is false.
 * @return {string} The string representation of {@code obj}.
 */
goog.debug.expose = function(obj, opt_showFn) {
  if (typeof obj == 'undefined') {
    return 'undefined';
  }
  if (obj == null) {
    return 'NULL';
  }
  var str = [];

  for (var x in obj) {
    if (!opt_showFn && goog.isFunction(obj[x])) {
      continue;
    }
    var s = x + ' = ';
    /** @preserveTry */
    try {
      s += obj[x];
    } catch (e) {
      s += '*** ' + e + ' ***';
    }
    str.push(s);
  }
  return str.join('\n');
};


/**
 * Creates a string representing a given primitive or object, and for an
 * object, all its properties and nested objects.  WARNING: If an object is
 * given, it and all its nested objects will be modified.  To detect reference
 * cycles, this method identifies objects using goog.getUid() which mutates the
 * object.
 * @param {*} obj Object to expose.
 * @param {boolean=} opt_showFn Also show properties that are functions (by
 *     default, functions are omitted).
 * @return {string} A string representation of {@code obj}.
 */
goog.debug.deepExpose = function(obj, opt_showFn) {
  var previous = new goog.structs.Set();
  var str = [];

  var helper = function(obj, space) {
    var nestspace = space + '  ';

    var indentMultiline = function(str) {
      return str.replace(/\n/g, '\n' + space);
    };

    /** @preserveTry */
    try {
      if (!goog.isDef(obj)) {
        str.push('undefined');
      } else if (goog.isNull(obj)) {
        str.push('NULL');
      } else if (goog.isString(obj)) {
        str.push('"' + indentMultiline(obj) + '"');
      } else if (goog.isFunction(obj)) {
        str.push(indentMultiline(String(obj)));
      } else if (goog.isObject(obj)) {
        if (previous.contains(obj)) {
          // TODO(kpy): This is a bug; it falsely detects non-loops as loops
          // when the reference tree contains two references to the same object.
          str.push('*** reference loop detected ***');
        } else {
          previous.add(obj);
          str.push('{');
          for (var x in obj) {
            if (!opt_showFn && goog.isFunction(obj[x])) {
              continue;
            }
            str.push('\n');
            str.push(nestspace);
            str.push(x + ' = ');
            helper(obj[x], nestspace);
          }
          str.push('\n' + space + '}');
        }
      } else {
        str.push(obj);
      }
    } catch (e) {
      str.push('*** ' + e + ' ***');
    }
  };

  helper(obj, '');
  return str.join('');
};


/**
 * Recursively outputs a nested array as a string.
 * @param {Array} arr The array.
 * @return {string} String representing nested array.
 */
goog.debug.exposeArray = function(arr) {
  var str = [];
  for (var i = 0; i < arr.length; i++) {
    if (goog.isArray(arr[i])) {
      str.push(goog.debug.exposeArray(arr[i]));
    } else {
      str.push(arr[i]);
    }
  }
  return '[ ' + str.join(', ') + ' ]';
};


/**
 * Exposes an exception that has been caught by a try...catch and outputs the
 * error with a stack trace.
 * @param {Object} err Error object or string.
 * @param {Function=} opt_fn Optional function to start stack trace from.
 * @return {string} Details of exception.
 */
goog.debug.exposeException = function(err, opt_fn) {
  /** @preserveTry */
  try {
    var e = goog.debug.normalizeErrorObject(err);

    // Create the error message
    var error = 'Message: ' + goog.string.htmlEscape(e.message) +
        '\nUrl: <a href="view-source:' + e.fileName + '" target="_new">' +
        e.fileName + '</a>\nLine: ' + e.lineNumber + '\n\nBrowser stack:\n' +
        goog.string.htmlEscape(e.stack + '-> ') +
        '[end]\n\nJS stack traversal:\n' + goog.string.htmlEscape(
            goog.debug.getStacktrace(opt_fn) + '-> ');
    return error;
  } catch (e2) {
    return 'Exception trying to expose exception! You win, we lose. ' + e2;
  }
};


/**
 * Normalizes the error/exception object between browsers.
 * @param {Object} err Raw error object.
 * @return {Object} Normalized error object.
 */
goog.debug.normalizeErrorObject = function(err) {
  var href = goog.getObjectByName('window.location.href');
  if (goog.isString(err)) {
    return {
      'message': err,
      'name': 'Unknown error',
      'lineNumber': 'Not available',
      'fileName': href,
      'stack': 'Not available'
    };
  }

  var lineNumber, fileName;
  var threwError = false;

  try {
    lineNumber = err.lineNumber || err.line || 'Not available';
  } catch (e) {
    // Firefox 2 sometimes throws an error when accessing 'lineNumber':
    // Message: Permission denied to get property UnnamedClass.lineNumber
    lineNumber = 'Not available';
    threwError = true;
  }

  try {
    fileName = err.fileName || err.filename || err.sourceURL ||
        // $googDebugFname may be set before a call to eval to set the filename
        // that the eval is supposed to present.
        goog.global['$googDebugFname'] || href;
  } catch (e) {
    // Firefox 2 may also throw an error when accessing 'filename'.
    fileName = 'Not available';
    threwError = true;
  }

  // The IE Error object contains only the name and the message.
  // The Safari Error object uses the line and sourceURL fields.
  if (threwError || !err.lineNumber || !err.fileName || !err.stack ||
      !err.message || !err.name) {
    return {
      'message': err.message || 'Not available',
      'name': err.name || 'UnknownError',
      'lineNumber': lineNumber,
      'fileName': fileName,
      'stack': err.stack || 'Not available'
    };
  }

  // Standards error object
  return err;
};


/**
 * Converts an object to an Error if it's a String,
 * adds a stacktrace if there isn't one,
 * and optionally adds an extra message.
 * @param {Error|string} err  the original thrown object or string.
 * @param {string=} opt_message  optional additional message to add to the
 *     error.
 * @return {Error} If err is a string, it is used to create a new Error,
 *     which is enhanced and returned.  Otherwise err itself is enhanced
 *     and returned.
 */
goog.debug.enhanceError = function(err, opt_message) {
  var error = typeof err == 'string' ? Error(err) : err;
  if (!error.stack) {
    error.stack = goog.debug.getStacktrace(arguments.callee.caller);
  }
  if (opt_message) {
    // find the first unoccupied 'messageX' property
    var x = 0;
    while (error['message' + x]) {
      ++x;
    }
    error['message' + x] = String(opt_message);
  }
  return error;
};


/**
 * Gets the current stack trace. Simple and iterative - doesn't worry about
 * catching circular references or getting the args.
 * @param {number=} opt_depth Optional maximum depth to trace back to.
 * @return {string} A string with the function names of all functions in the
 *     stack, separated by \n.
 */
goog.debug.getStacktraceSimple = function(opt_depth) {
  var sb = [];
  var fn = arguments.callee.caller;
  var depth = 0;

  while (fn && (!opt_depth || depth < opt_depth)) {
    sb.push(goog.debug.getFunctionName(fn));
    sb.push('()\n');
    /** @preserveTry */
    try {
      fn = fn.caller;
    } catch (e) {
      sb.push('[exception trying to get caller]\n');
      break;
    }
    depth++;
    if (depth >= goog.debug.MAX_STACK_DEPTH) {
      sb.push('[...long stack...]');
      break;
    }
  }
  if (opt_depth && depth >= opt_depth) {
    sb.push('[...reached max depth limit...]');
  } else {
    sb.push('[end]');
  }

  return sb.join('');
};


/**
 * Max length of stack to try and output
 * @type {number}
 */
goog.debug.MAX_STACK_DEPTH = 50;


/**
 * Gets the current stack trace, either starting from the caller or starting
 * from a specified function that's currently on the call stack.
 * @param {Function=} opt_fn Optional function to start getting the trace from.
 *     If not provided, defaults to the function that called this.
 * @return {string} Stack trace.
 */
goog.debug.getStacktrace = function(opt_fn) {
  return goog.debug.getStacktraceHelper_(opt_fn || arguments.callee.caller, []);
};


/**
 * Private helper for getStacktrace().
 * @param {Function} fn Function to start getting the trace from.
 * @param {Array} visited List of functions visited so far.
 * @return {string} Stack trace starting from function fn.
 * @private
 */
goog.debug.getStacktraceHelper_ = function(fn, visited) {
  var sb = [];

  // Circular reference, certain functions like bind seem to cause a recursive
  // loop so we need to catch circular references
  if (goog.array.contains(visited, fn)) {
    sb.push('[...circular reference...]');

  // Traverse the call stack until function not found or max depth is reached
  } else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {
    sb.push(goog.debug.getFunctionName(fn) + '(');
    var args = fn.arguments;
    for (var i = 0; i < args.length; i++) {
      if (i > 0) {
        sb.push(', ');
      }
      var argDesc;
      var arg = args[i];
      switch (typeof arg) {
        case 'object':
          argDesc = arg ? 'object' : 'null';
          break;

        case 'string':
          argDesc = arg;
          break;

        case 'number':
          argDesc = String(arg);
          break;

        case 'boolean':
          argDesc = arg ? 'true' : 'false';
          break;

        case 'function':
          argDesc = goog.debug.getFunctionName(arg);
          argDesc = argDesc ? argDesc : '[fn]';
          break;

        case 'undefined':
        default:
          argDesc = typeof arg;
          break;
      }

      if (argDesc.length > 40) {
        argDesc = argDesc.substr(0, 40) + '...';
      }
      sb.push(argDesc);
    }
    visited.push(fn);
    sb.push(')\n');
    /** @preserveTry */
    try {
      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));
    } catch (e) {
      sb.push('[exception trying to get caller]\n');
    }

  } else if (fn) {
    sb.push('[...long stack...]');
  } else {
    sb.push('[end]');
  }
  return sb.join('');
};


/**
 * Set a custom function name resolver.
 * @param {function(Function): string} resolver Resolves functions to their
 *     names.
 */
goog.debug.setFunctionResolver = function(resolver) {
  goog.debug.fnNameResolver_ = resolver;
};


/**
 * Gets a function name
 * @param {Function} fn Function to get name of.
 * @return {string} Function's name.
 */
goog.debug.getFunctionName = function(fn) {
  if (goog.debug.fnNameCache_[fn]) {
    return goog.debug.fnNameCache_[fn];
  }
  if (goog.debug.fnNameResolver_) {
    var name = goog.debug.fnNameResolver_(fn);
    if (name) {
      goog.debug.fnNameCache_[fn] = name;
      return name;
    }
  }

  // Heuristically determine function name based on code.
  var functionSource = String(fn);
  if (!goog.debug.fnNameCache_[functionSource]) {
    var matches = /function ([^\(]+)/.exec(functionSource);
    if (matches) {
      var method = matches[1];
      goog.debug.fnNameCache_[functionSource] = method;
    } else {
      goog.debug.fnNameCache_[functionSource] = '[Anonymous]';
    }
  }

  return goog.debug.fnNameCache_[functionSource];
};


/**
 * Makes whitespace visible by replacing it with printable characters.
 * This is useful in finding diffrences between the expected and the actual
 * output strings of a testcase.
 * @param {string} string whose whitespace needs to be made visible.
 * @return {string} string whose whitespace is made visible.
 */
goog.debug.makeWhitespaceVisible = function(string) {
  return string.replace(/ /g, '[_]')
      .replace(/\f/g, '[f]')
      .replace(/\n/g, '[n]\n')
      .replace(/\r/g, '[r]')
      .replace(/\t/g, '[t]');
};


/**
 * Hash map for storing function names that have already been looked up.
 * @type {Object}
 * @private
 */
goog.debug.fnNameCache_ = {};


/**
 * Resolves functions to their names.  Resolved function names will be cached.
 * @type {function(Function):string}
 * @private
 */
goog.debug.fnNameResolver_;

//javascript/closure/debug/logrecord.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the LogRecord class. Please minimize
 * dependencies this file has on other closure classes as any dependency it
 * takes won't be able to use the logging infrastructure.
 *
 * @author jonp@google.com (Jon Perlow)
 */

goog.provide('goog.debug.LogRecord');



/**
 * LogRecord objects are used to pass logging requests between
 * the logging framework and individual log Handlers.
 * @constructor
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {string} loggerName The name of the source logger.
 * @param {number=} opt_time Time this log record was created if other than now.
 *     If 0, we use #goog.now.
 * @param {number=} opt_sequenceNumber Sequence number of this log record. This
 *     should only be passed in when restoring a log record from persistence.
 */
goog.debug.LogRecord = function(level, msg, loggerName,
    opt_time, opt_sequenceNumber) {
  this.reset(level, msg, loggerName, opt_time, opt_sequenceNumber);
};


/**
 * Time the LogRecord was created.
 * @type {number}
 * @private
 */
goog.debug.LogRecord.prototype.time_;


/**
 * Level of the LogRecord
 * @type {goog.debug.Logger.Level}
 * @private
 */
goog.debug.LogRecord.prototype.level_;


/**
 * Message associated with the record
 * @type {string}
 * @private
 */
goog.debug.LogRecord.prototype.msg_;


/**
 * Name of the logger that created the record.
 * @type {string}
 * @private
 */
goog.debug.LogRecord.prototype.loggerName_;


/**
 * Sequence number for the LogRecord. Each record has a unique sequence number
 * that is greater than all log records created before it.
 * @type {number}
 * @private
 */
goog.debug.LogRecord.prototype.sequenceNumber_ = 0;


/**
 * Exception associated with the record
 * @type {Object}
 * @private
 */
goog.debug.LogRecord.prototype.exception_ = null;


/**
 * Exception text associated with the record
 * @type {?string}
 * @private
 */
goog.debug.LogRecord.prototype.exceptionText_ = null;


/**
 * @define {boolean} Whether to enable log sequence numbers.
 */
goog.define('goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS', true);


/**
 * A sequence counter for assigning increasing sequence numbers to LogRecord
 * objects.
 * @type {number}
 * @private
 */
goog.debug.LogRecord.nextSequenceNumber_ = 0;


/**
 * Sets all fields of the log record.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {string} loggerName The name of the source logger.
 * @param {number=} opt_time Time this log record was created if other than now.
 *     If 0, we use #goog.now.
 * @param {number=} opt_sequenceNumber Sequence number of this log record. This
 *     should only be passed in when restoring a log record from persistence.
 */
goog.debug.LogRecord.prototype.reset = function(level, msg, loggerName,
    opt_time, opt_sequenceNumber) {
  if (goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS) {
    this.sequenceNumber_ = typeof opt_sequenceNumber == 'number' ?
        opt_sequenceNumber : goog.debug.LogRecord.nextSequenceNumber_++;
  }

  this.time_ = opt_time || goog.now();
  this.level_ = level;
  this.msg_ = msg;
  this.loggerName_ = loggerName;
  delete this.exception_;
  delete this.exceptionText_;
};


/**
 * Get the source Logger's name.
 *
 * @return {string} source logger name (may be null).
 */
goog.debug.LogRecord.prototype.getLoggerName = function() {
  return this.loggerName_;
};


/**
 * Get the exception that is part of the log record.
 *
 * @return {Object} the exception.
 */
goog.debug.LogRecord.prototype.getException = function() {
  return this.exception_;
};


/**
 * Set the exception that is part of the log record.
 *
 * @param {Object} exception the exception.
 */
goog.debug.LogRecord.prototype.setException = function(exception) {
  this.exception_ = exception;
};


/**
 * Get the exception text that is part of the log record.
 *
 * @return {?string} Exception text.
 */
goog.debug.LogRecord.prototype.getExceptionText = function() {
  return this.exceptionText_;
};


/**
 * Set the exception text that is part of the log record.
 *
 * @param {string} text The exception text.
 */
goog.debug.LogRecord.prototype.setExceptionText = function(text) {
  this.exceptionText_ = text;
};


/**
 * Get the source Logger's name.
 *
 * @param {string} loggerName source logger name (may be null).
 */
goog.debug.LogRecord.prototype.setLoggerName = function(loggerName) {
  this.loggerName_ = loggerName;
};


/**
 * Get the logging message level, for example Level.SEVERE.
 * @return {goog.debug.Logger.Level} the logging message level.
 */
goog.debug.LogRecord.prototype.getLevel = function() {
  return this.level_;
};


/**
 * Set the logging message level, for example Level.SEVERE.
 * @param {goog.debug.Logger.Level} level the logging message level.
 */
goog.debug.LogRecord.prototype.setLevel = function(level) {
  this.level_ = level;
};


/**
 * Get the "raw" log message, before localization or formatting.
 *
 * @return {string} the raw message string.
 */
goog.debug.LogRecord.prototype.getMessage = function() {
  return this.msg_;
};


/**
 * Set the "raw" log message, before localization or formatting.
 *
 * @param {string} msg the raw message string.
 */
goog.debug.LogRecord.prototype.setMessage = function(msg) {
  this.msg_ = msg;
};


/**
 * Get event time in milliseconds since 1970.
 *
 * @return {number} event time in millis since 1970.
 */
goog.debug.LogRecord.prototype.getMillis = function() {
  return this.time_;
};


/**
 * Set event time in milliseconds since 1970.
 *
 * @param {number} time event time in millis since 1970.
 */
goog.debug.LogRecord.prototype.setMillis = function(time) {
  this.time_ = time;
};


/**
 * Get the sequence number.
 * <p>
 * Sequence numbers are normally assigned in the LogRecord
 * constructor, which assigns unique sequence numbers to
 * each new LogRecord in increasing order.
 * @return {number} the sequence number.
 */
goog.debug.LogRecord.prototype.getSequenceNumber = function() {
  return this.sequenceNumber_;
};


//javascript/closure/debug/logbuffer.js
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A buffer for log records. The purpose of this is to improve
 * logging performance by re-using old objects when the buffer becomes full and
 * to eliminate the need for each app to implement their own log buffer. The
 * disadvantage to doing this is that log handlers cannot maintain references to
 * log records and expect that they are not overwriten at a later point.
 *
 * @author agrieve@google.com (Andrew Grieve)
 */

goog.provide('goog.debug.LogBuffer');

goog.require('goog.asserts');
goog.require('goog.debug.LogRecord');



/**
 * Creates the log buffer.
 * @constructor
 * @final
 */
goog.debug.LogBuffer = function() {
  goog.asserts.assert(goog.debug.LogBuffer.isBufferingEnabled(),
      'Cannot use goog.debug.LogBuffer without defining ' +
      'goog.debug.LogBuffer.CAPACITY.');
  this.clear();
};


/**
 * A static method that always returns the same instance of LogBuffer.
 * @return {!goog.debug.LogBuffer} The LogBuffer singleton instance.
 */
goog.debug.LogBuffer.getInstance = function() {
  if (!goog.debug.LogBuffer.instance_) {
    // This function is written with the return statement after the assignment
    // to avoid the jscompiler StripCode bug described in http://b/2608064.
    // After that bug is fixed this can be refactored.
    goog.debug.LogBuffer.instance_ = new goog.debug.LogBuffer();
  }
  return goog.debug.LogBuffer.instance_;
};


/**
 * @define {number} The number of log records to buffer. 0 means disable
 * buffering.
 */
goog.define('goog.debug.LogBuffer.CAPACITY', 0);


/**
 * The array to store the records.
 * @type {!Array.<!goog.debug.LogRecord|undefined>}
 * @private
 */
goog.debug.LogBuffer.prototype.buffer_;


/**
 * The index of the most recently added record or -1 if there are no records.
 * @type {number}
 * @private
 */
goog.debug.LogBuffer.prototype.curIndex_;


/**
 * Whether the buffer is at capacity.
 * @type {boolean}
 * @private
 */
goog.debug.LogBuffer.prototype.isFull_;


/**
 * Adds a log record to the buffer, possibly overwriting the oldest record.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {string} loggerName The name of the source logger.
 * @return {!goog.debug.LogRecord} The log record.
 */
goog.debug.LogBuffer.prototype.addRecord = function(level, msg, loggerName) {
  var curIndex = (this.curIndex_ + 1) % goog.debug.LogBuffer.CAPACITY;
  this.curIndex_ = curIndex;
  if (this.isFull_) {
    var ret = this.buffer_[curIndex];
    ret.reset(level, msg, loggerName);
    return ret;
  }
  this.isFull_ = curIndex == goog.debug.LogBuffer.CAPACITY - 1;
  return this.buffer_[curIndex] =
      new goog.debug.LogRecord(level, msg, loggerName);
};


/**
 * @return {boolean} Whether the log buffer is enabled.
 */
goog.debug.LogBuffer.isBufferingEnabled = function() {
  return goog.debug.LogBuffer.CAPACITY > 0;
};


/**
 * Removes all buffered log records.
 */
goog.debug.LogBuffer.prototype.clear = function() {
  this.buffer_ = new Array(goog.debug.LogBuffer.CAPACITY);
  this.curIndex_ = -1;
  this.isFull_ = false;
};


/**
 * Calls the given function for each buffered log record, starting with the
 * oldest one.
 * @param {function(!goog.debug.LogRecord)} func The function to call.
 */
goog.debug.LogBuffer.prototype.forEachRecord = function(func) {
  var buffer = this.buffer_;
  // Corner case: no records.
  if (!buffer[0]) {
    return;
  }
  var curIndex = this.curIndex_;
  var i = this.isFull_ ? curIndex : -1;
  do {
    i = (i + 1) % goog.debug.LogBuffer.CAPACITY;
    func(/** @type {!goog.debug.LogRecord} */ (buffer[i]));
  } while (i != curIndex);
};


//javascript/closure/debug/logger.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the Logger class. Please minimize dependencies
 * this file has on other closure classes as any dependency it takes won't be
 * able to use the logging infrastructure.
 *
 * @author jonp@google.com (Jon Perlow)
 * @see ../demos/debug.html
 */

goog.provide('goog.debug.LogManager');
goog.provide('goog.debug.Loggable');
goog.provide('goog.debug.Logger');
goog.provide('goog.debug.Logger.Level');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug');
goog.require('goog.debug.LogBuffer');
goog.require('goog.debug.LogRecord');


/**
 * A message value that can be handled by a Logger.
 *
 * Functions are treated like callbacks, but are only called when the event's
 * log level is enabled. This is useful for logging messages that are expensive
 * to construct.
 *
 * @typedef {string|function(): string}
 */
goog.debug.Loggable;



/**
 * The Logger is an object used for logging debug messages. Loggers are
 * normally named, using a hierarchical dot-separated namespace. Logger names
 * can be arbitrary strings, but they should normally be based on the package
 * name or class name of the logged component, such as goog.net.BrowserChannel.
 *
 * The Logger object is loosely based on the java class
 * java.util.logging.Logger. It supports different levels of filtering for
 * different loggers.
 *
 * The logger object should never be instantiated by application code. It
 * should always use the goog.debug.Logger.getLogger function.
 *
 * @constructor
 * @param {string} name The name of the Logger.
 * @final
 */
goog.debug.Logger = function(name) {
  /**
   * Name of the Logger. Generally a dot-separated namespace
   * @type {string}
   * @private
   */
  this.name_ = name;
};


/**
 * Parent Logger.
 * @type {goog.debug.Logger}
 * @private
 */
goog.debug.Logger.prototype.parent_ = null;


/**
 * Level that this logger only filters above. Null indicates it should
 * inherit from the parent.
 * @type {goog.debug.Logger.Level}
 * @private
 */
goog.debug.Logger.prototype.level_ = null;


/**
 * Map of children loggers. The keys are the leaf names of the children and
 * the values are the child loggers.
 * @type {Object}
 * @private
 */
goog.debug.Logger.prototype.children_ = null;


/**
 * Handlers that are listening to this logger.
 * @type {Array.<Function>}
 * @private
 */
goog.debug.Logger.prototype.handlers_ = null;


/**
 * @define {boolean} Toggles whether loggers other than the root logger can have
 *     log handlers attached to them and whether they can have their log level
 *     set. Logging is a bit faster when this is set to false.
 */
goog.define('goog.debug.Logger.ENABLE_HIERARCHY', true);


if (!goog.debug.Logger.ENABLE_HIERARCHY) {
  /**
   * @type {!Array.<Function>}
   * @private
   */
  goog.debug.Logger.rootHandlers_ = [];


  /**
   * @type {goog.debug.Logger.Level}
   * @private
   */
  goog.debug.Logger.rootLevel_;
}



/**
 * The Level class defines a set of standard logging levels that
 * can be used to control logging output.  The logging Level objects
 * are ordered and are specified by ordered integers.  Enabling logging
 * at a given level also enables logging at all higher levels.
 * <p>
 * Clients should normally use the predefined Level constants such
 * as Level.SEVERE.
 * <p>
 * The levels in descending order are:
 * <ul>
 * <li>SEVERE (highest value)
 * <li>WARNING
 * <li>INFO
 * <li>CONFIG
 * <li>FINE
 * <li>FINER
 * <li>FINEST  (lowest value)
 * </ul>
 * In addition there is a level OFF that can be used to turn
 * off logging, and a level ALL that can be used to enable
 * logging of all messages.
 *
 * @param {string} name The name of the level.
 * @param {number} value The numeric value of the level.
 * @constructor
 * @final
 */
goog.debug.Logger.Level = function(name, value) {
  /**
   * The name of the level
   * @type {string}
   */
  this.name = name;

  /**
   * The numeric value of the level
   * @type {number}
   */
  this.value = value;
};


/**
 * @return {string} String representation of the logger level.
 * @override
 */
goog.debug.Logger.Level.prototype.toString = function() {
  return this.name;
};


/**
 * OFF is a special level that can be used to turn off logging.
 * This level is initialized to <CODE>Infinity</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.OFF =
    new goog.debug.Logger.Level('OFF', Infinity);


/**
 * SHOUT is a message level for extra debugging loudness.
 * This level is initialized to <CODE>1200</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.SHOUT = new goog.debug.Logger.Level('SHOUT', 1200);


/**
 * SEVERE is a message level indicating a serious failure.
 * This level is initialized to <CODE>1000</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.SEVERE = new goog.debug.Logger.Level('SEVERE', 1000);


/**
 * WARNING is a message level indicating a potential problem.
 * This level is initialized to <CODE>900</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.WARNING = new goog.debug.Logger.Level('WARNING', 900);


/**
 * INFO is a message level for informational messages.
 * This level is initialized to <CODE>800</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.INFO = new goog.debug.Logger.Level('INFO', 800);


/**
 * CONFIG is a message level for static configuration messages.
 * This level is initialized to <CODE>700</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.CONFIG = new goog.debug.Logger.Level('CONFIG', 700);


/**
 * FINE is a message level providing tracing information.
 * This level is initialized to <CODE>500</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.FINE = new goog.debug.Logger.Level('FINE', 500);


/**
 * FINER indicates a fairly detailed tracing message.
 * This level is initialized to <CODE>400</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.FINER = new goog.debug.Logger.Level('FINER', 400);

/**
 * FINEST indicates a highly detailed tracing message.
 * This level is initialized to <CODE>300</CODE>.
 * @type {!goog.debug.Logger.Level}
 */

goog.debug.Logger.Level.FINEST = new goog.debug.Logger.Level('FINEST', 300);


/**
 * ALL indicates that all messages should be logged.
 * This level is initialized to <CODE>0</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.ALL = new goog.debug.Logger.Level('ALL', 0);


/**
 * The predefined levels.
 * @type {!Array.<!goog.debug.Logger.Level>}
 * @final
 */
goog.debug.Logger.Level.PREDEFINED_LEVELS = [
  goog.debug.Logger.Level.OFF,
  goog.debug.Logger.Level.SHOUT,
  goog.debug.Logger.Level.SEVERE,
  goog.debug.Logger.Level.WARNING,
  goog.debug.Logger.Level.INFO,
  goog.debug.Logger.Level.CONFIG,
  goog.debug.Logger.Level.FINE,
  goog.debug.Logger.Level.FINER,
  goog.debug.Logger.Level.FINEST,
  goog.debug.Logger.Level.ALL];


/**
 * A lookup map used to find the level object based on the name or value of
 * the level object.
 * @type {Object}
 * @private
 */
goog.debug.Logger.Level.predefinedLevelsCache_ = null;


/**
 * Creates the predefined levels cache and populates it.
 * @private
 */
goog.debug.Logger.Level.createPredefinedLevelsCache_ = function() {
  goog.debug.Logger.Level.predefinedLevelsCache_ = {};
  for (var i = 0, level; level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];
       i++) {
    goog.debug.Logger.Level.predefinedLevelsCache_[level.value] = level;
    goog.debug.Logger.Level.predefinedLevelsCache_[level.name] = level;
  }
};


/**
 * Gets the predefined level with the given name.
 * @param {string} name The name of the level.
 * @return {goog.debug.Logger.Level} The level, or null if none found.
 */
goog.debug.Logger.Level.getPredefinedLevel = function(name) {
  if (!goog.debug.Logger.Level.predefinedLevelsCache_) {
    goog.debug.Logger.Level.createPredefinedLevelsCache_();
  }

  return goog.debug.Logger.Level.predefinedLevelsCache_[name] || null;
};


/**
 * Gets the highest predefined level <= #value.
 * @param {number} value Level value.
 * @return {goog.debug.Logger.Level} The level, or null if none found.
 */
goog.debug.Logger.Level.getPredefinedLevelByValue = function(value) {
  if (!goog.debug.Logger.Level.predefinedLevelsCache_) {
    goog.debug.Logger.Level.createPredefinedLevelsCache_();
  }

  if (value in goog.debug.Logger.Level.predefinedLevelsCache_) {
    return goog.debug.Logger.Level.predefinedLevelsCache_[value];
  }

  for (var i = 0; i < goog.debug.Logger.Level.PREDEFINED_LEVELS.length; ++i) {
    var level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];
    if (level.value <= value) {
      return level;
    }
  }
  return null;
};


/**
 * Finds or creates a logger for a named subsystem. If a logger has already been
 * created with the given name it is returned. Otherwise a new logger is
 * created. If a new logger is created its log level will be configured based
 * on the LogManager configuration and it will configured to also send logging
 * output to its parent's handlers. It will be registered in the LogManager
 * global namespace.
 *
 * @param {string} name A name for the logger. This should be a dot-separated
 * name and should normally be based on the package name or class name of the
 * subsystem, such as goog.net.BrowserChannel.
 * @return {!goog.debug.Logger} The named logger.
 */
goog.debug.Logger.getLogger = function(name) {
  return goog.debug.LogManager.getLogger(name);
};


/**
 * Logs a message to profiling tools, if available.
 * {@see http://code.google.com/webtoolkit/speedtracer/logging-api.html}
 * {@see http://msdn.microsoft.com/en-us/library/dd433074(VS.85).aspx}
 * @param {string} msg The message to log.
 */
goog.debug.Logger.logToProfilers = function(msg) {
  // Using goog.global, as loggers might be used in window-less contexts.
  if (goog.global['console']) {
    if (goog.global['console']['timeStamp']) {
      // Logs a message to Firebug, Web Inspector, SpeedTracer, etc.
      goog.global['console']['timeStamp'](msg);
    } else if (goog.global['console']['markTimeline']) {
      // TODO(mkwst): markTimeline is deprecated. Drop this else clause entirely
      // after Chrome M14 hits stable.
      goog.global['console']['markTimeline'](msg);
    }
  }

  if (goog.global['msWriteProfilerMark']) {
    // Logs a message to the Microsoft profiler
    goog.global['msWriteProfilerMark'](msg);
  }
};


/**
 * Gets the name of this logger.
 * @return {string} The name of this logger.
 */
goog.debug.Logger.prototype.getName = function() {
  return this.name_;
};


/**
 * Adds a handler to the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {Function} handler Handler function to add.
 */
goog.debug.Logger.prototype.addHandler = function(handler) {
  if (goog.debug.LOGGING_ENABLED) {
    if (goog.debug.Logger.ENABLE_HIERARCHY) {
      if (!this.handlers_) {
        this.handlers_ = [];
      }
      this.handlers_.push(handler);
    } else {
      goog.asserts.assert(!this.name_,
          'Cannot call addHandler on a non-root logger when ' +
          'goog.debug.Logger.ENABLE_HIERARCHY is false.');
      goog.debug.Logger.rootHandlers_.push(handler);
    }
  }
};


/**
 * Removes a handler from the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {Function} handler Handler function to remove.
 * @return {boolean} Whether the handler was removed.
 */
goog.debug.Logger.prototype.removeHandler = function(handler) {
  if (goog.debug.LOGGING_ENABLED) {
    var handlers = goog.debug.Logger.ENABLE_HIERARCHY ? this.handlers_ :
        goog.debug.Logger.rootHandlers_;
    return !!handlers && goog.array.remove(handlers, handler);
  } else {
    return false;
  }
};


/**
 * Returns the parent of this logger.
 * @return {goog.debug.Logger} The parent logger or null if this is the root.
 */
goog.debug.Logger.prototype.getParent = function() {
  return this.parent_;
};


/**
 * Returns the children of this logger as a map of the child name to the logger.
 * @return {!Object} The map where the keys are the child leaf names and the
 *     values are the Logger objects.
 */
goog.debug.Logger.prototype.getChildren = function() {
  if (!this.children_) {
    this.children_ = {};
  }
  return this.children_;
};


/**
 * Set the log level specifying which message levels will be logged by this
 * logger. Message levels lower than this value will be discarded.
 * The level value Level.OFF can be used to turn off logging. If the new level
 * is null, it means that this node should inherit its level from its nearest
 * ancestor with a specific (non-null) level value.
 *
 * @param {goog.debug.Logger.Level} level The new level.
 */
goog.debug.Logger.prototype.setLevel = function(level) {
  if (goog.debug.LOGGING_ENABLED) {
    if (goog.debug.Logger.ENABLE_HIERARCHY) {
      this.level_ = level;
    } else {
      goog.asserts.assert(!this.name_,
          'Cannot call setLevel() on a non-root logger when ' +
          'goog.debug.Logger.ENABLE_HIERARCHY is false.');
      goog.debug.Logger.rootLevel_ = level;
    }
  }
};


/**
 * Gets the log level specifying which message levels will be logged by this
 * logger. Message levels lower than this value will be discarded.
 * The level value Level.OFF can be used to turn off logging. If the level
 * is null, it means that this node should inherit its level from its nearest
 * ancestor with a specific (non-null) level value.
 *
 * @return {goog.debug.Logger.Level} The level.
 */
goog.debug.Logger.prototype.getLevel = function() {
  return goog.debug.LOGGING_ENABLED ?
      this.level_ : goog.debug.Logger.Level.OFF;
};


/**
 * Returns the effective level of the logger based on its ancestors' levels.
 * @return {goog.debug.Logger.Level} The level.
 */
goog.debug.Logger.prototype.getEffectiveLevel = function() {
  if (!goog.debug.LOGGING_ENABLED) {
    return goog.debug.Logger.Level.OFF;
  }

  if (!goog.debug.Logger.ENABLE_HIERARCHY) {
    return goog.debug.Logger.rootLevel_;
  }
  if (this.level_) {
    return this.level_;
  }
  if (this.parent_) {
    return this.parent_.getEffectiveLevel();
  }
  goog.asserts.fail('Root logger has no level set.');
  return null;
};


/**
 * Checks if a message of the given level would actually be logged by this
 * logger. This check is based on the Loggers effective level, which may be
 * inherited from its parent.
 * @param {goog.debug.Logger.Level} level The level to check.
 * @return {boolean} Whether the message would be logged.
 */
goog.debug.Logger.prototype.isLoggable = function(level) {
  return goog.debug.LOGGING_ENABLED &&
      level.value >= this.getEffectiveLevel().value;
};


/**
 * Logs a message. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error|Object=} opt_exception An exception associated with the
 *     message.
 */
goog.debug.Logger.prototype.log = function(level, msg, opt_exception) {
  // java caches the effective level, not sure it's necessary here
  if (goog.debug.LOGGING_ENABLED && this.isLoggable(level)) {
    // Message callbacks can be useful when a log message is expensive to build.
    if (goog.isFunction(msg)) {
      msg = msg();
    }

    this.doLogRecord_(this.getLogRecord(level, msg, opt_exception));
  }
};


/**
 * Creates a new log record and adds the exception (if present) to it.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {Error|Object=} opt_exception An exception associated with the
 *     message.
 * @return {!goog.debug.LogRecord} A log record.
 */
goog.debug.Logger.prototype.getLogRecord = function(level, msg, opt_exception) {
  if (goog.debug.LogBuffer.isBufferingEnabled()) {
    var logRecord =
        goog.debug.LogBuffer.getInstance().addRecord(level, msg, this.name_);
  } else {
    logRecord = new goog.debug.LogRecord(level, String(msg), this.name_);
  }
  if (opt_exception) {
    logRecord.setException(opt_exception);
    logRecord.setExceptionText(
        goog.debug.exposeException(opt_exception, arguments.callee.caller));
  }
  return logRecord;
};


/**
 * Logs a message at the Logger.Level.SHOUT level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.shout = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.SHOUT, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.SEVERE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.severe = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.SEVERE, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.WARNING level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.warning = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.WARNING, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.INFO level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.info = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.INFO, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.CONFIG level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.config = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.CONFIG, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.FINE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.fine = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.FINE, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.FINER level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.finer = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.FINER, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.FINEST level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.finest = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.FINEST, msg, opt_exception);
  }
};


/**
 * Logs a LogRecord. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * @param {goog.debug.LogRecord} logRecord A log record to log.
 */
goog.debug.Logger.prototype.logRecord = function(logRecord) {
  if (goog.debug.LOGGING_ENABLED && this.isLoggable(logRecord.getLevel())) {
    this.doLogRecord_(logRecord);
  }
};


/**
 * Logs a LogRecord.
 * @param {goog.debug.LogRecord} logRecord A log record to log.
 * @private
 */
goog.debug.Logger.prototype.doLogRecord_ = function(logRecord) {
  goog.debug.Logger.logToProfilers('log:' + logRecord.getMessage());
  if (goog.debug.Logger.ENABLE_HIERARCHY) {
    var target = this;
    while (target) {
      target.callPublish_(logRecord);
      target = target.getParent();
    }
  } else {
    for (var i = 0, handler; handler = goog.debug.Logger.rootHandlers_[i++]; ) {
      handler(logRecord);
    }
  }
};


/**
 * Calls the handlers for publish.
 * @param {goog.debug.LogRecord} logRecord The log record to publish.
 * @private
 */
goog.debug.Logger.prototype.callPublish_ = function(logRecord) {
  if (this.handlers_) {
    for (var i = 0, handler; handler = this.handlers_[i]; i++) {
      handler(logRecord);
    }
  }
};


/**
 * Sets the parent of this logger. This is used for setting up the logger tree.
 * @param {goog.debug.Logger} parent The parent logger.
 * @private
 */
goog.debug.Logger.prototype.setParent_ = function(parent) {
  this.parent_ = parent;
};


/**
 * Adds a child to this logger. This is used for setting up the logger tree.
 * @param {string} name The leaf name of the child.
 * @param {goog.debug.Logger} logger The child logger.
 * @private
 */
goog.debug.Logger.prototype.addChild_ = function(name, logger) {
  this.getChildren()[name] = logger;
};


/**
 * There is a single global LogManager object that is used to maintain a set of
 * shared state about Loggers and log services. This is loosely based on the
 * java class java.util.logging.LogManager.
 */
goog.debug.LogManager = {};


/**
 * Map of logger names to logger objects.
 *
 * @type {!Object}
 * @private
 */
goog.debug.LogManager.loggers_ = {};


/**
 * The root logger which is the root of the logger tree.
 * @type {goog.debug.Logger}
 * @private
 */
goog.debug.LogManager.rootLogger_ = null;


/**
 * Initializes the LogManager if not already initialized.
 */
goog.debug.LogManager.initialize = function() {
  if (!goog.debug.LogManager.rootLogger_) {
    goog.debug.LogManager.rootLogger_ = new goog.debug.Logger('');
    goog.debug.LogManager.loggers_[''] = goog.debug.LogManager.rootLogger_;
    goog.debug.LogManager.rootLogger_.setLevel(goog.debug.Logger.Level.CONFIG);
  }
};


/**
 * Returns all the loggers.
 * @return {!Object} Map of logger names to logger objects.
 */
goog.debug.LogManager.getLoggers = function() {
  return goog.debug.LogManager.loggers_;
};


/**
 * Returns the root of the logger tree namespace, the logger with the empty
 * string as its name.
 *
 * @return {!goog.debug.Logger} The root logger.
 */
goog.debug.LogManager.getRoot = function() {
  goog.debug.LogManager.initialize();
  return /** @type {!goog.debug.Logger} */ (goog.debug.LogManager.rootLogger_);
};


/**
 * Finds a named logger.
 *
 * @param {string} name A name for the logger. This should be a dot-separated
 * name and should normally be based on the package name or class name of the
 * subsystem, such as goog.net.BrowserChannel.
 * @return {!goog.debug.Logger} The named logger.
 */
goog.debug.LogManager.getLogger = function(name) {
  goog.debug.LogManager.initialize();
  var ret = goog.debug.LogManager.loggers_[name];
  return ret || goog.debug.LogManager.createLogger_(name);
};


/**
 * Creates a function that can be passed to goog.debug.catchErrors. The function
 * will log all reported errors using the given logger.
 * @param {goog.debug.Logger=} opt_logger The logger to log the errors to.
 *     Defaults to the root logger.
 * @return {function(Object)} The created function.
 */
goog.debug.LogManager.createFunctionForCatchErrors = function(opt_logger) {
  return function(info) {
    var logger = opt_logger || goog.debug.LogManager.getRoot();
    logger.severe('Error: ' + info.message + ' (' + info.fileName +
                  ' @ Line: ' + info.line + ')');
  };
};


/**
 * Creates the named logger. Will also create the parents of the named logger
 * if they don't yet exist.
 * @param {string} name The name of the logger.
 * @return {!goog.debug.Logger} The named logger.
 * @private
 */
goog.debug.LogManager.createLogger_ = function(name) {
  // find parent logger
  var logger = new goog.debug.Logger(name);
  if (goog.debug.Logger.ENABLE_HIERARCHY) {
    var lastDotIndex = name.lastIndexOf('.');
    var parentName = name.substr(0, lastDotIndex);
    var leafName = name.substr(lastDotIndex + 1);
    var parentLogger = goog.debug.LogManager.getLogger(parentName);

    // tell the parent about the child and the child about the parent
    parentLogger.addChild_(leafName, logger);
    logger.setParent_(parentLogger);
  }

  goog.debug.LogManager.loggers_[name] = logger;
  return logger;
};

//javascript/apps/drive/dataservice/sync/stat/requeststat.js
goog.provide('drive.ds.sync.stat.RequestStat');



/**
 * An object storing request stats.
 * @param {number} bytes The size of the response in bytes.
 * @param {number} time The time it took for the request to run in milliseconds.
 * @constructor
 */
drive.ds.sync.stat.RequestStat = function(bytes, time) {
  /**
   * The size of the response in bytes.
   * @private {number}
   */
  this.bytes_ = bytes;

  /**
   * The time it took for the request to run in milliseconds.
   * @private {number}
   */
  this.time_ = time;
};


/**
 * @return {number} The size of the response for the request in bytes.
 */
drive.ds.sync.stat.RequestStat.prototype.getBytes = function() {
  return this.bytes_;
};


/**
 * @return {number} The time it took for the request to run in milliseconds.
 */
drive.ds.sync.stat.RequestStat.prototype.getTime = function() {
  return this.time_;
};

//javascript/apps/drive/dataservice/sync/stat/statmonitor.js
goog.provide('drive.ds.sync.stat.StatMonitor');

goog.require('drive.ds.sync.stat.RequestStat');
goog.require('goog.array');
goog.require('goog.debug.Logger');
goog.require('goog.object');
goog.require('goog.structs.Map');
goog.require('goog.structs.Queue');



/**
 * A performance monitor that logs stats on a regular basis.
 * TODO(towong): Send stats to some backend server.
 * TODO(towong): Add unit testing.
 * @constructor
 */
drive.ds.sync.stat.StatMonitor = function() {
  /**
   * A map of map name to map of items to monitor.
   * @private {goog.structs.Map.<string, !Object.<*, *>>}
   */
  this.maps_ = new goog.structs.Map();

  /**
   * A map of request types to request stats, tracking up to the last
   * MAX_REQUESTS_ number of requests for each request type.
   * @private {goog.structs.Map.<string,
   *     goog.structs.Queue.<!drive.ds.sync.stat.RequestStat>>}
   */
  this.requestStats_ = new goog.structs.Map();

  /**
   * @private {!goog.debug.Logger}
   */
  this.logger_ = goog.debug.Logger.getLogger(
      'drive.ds.sync.stat.StatMonitor');

  /**
   * Whether this performance monitor is enabled.
   * @private {boolean}
   */
  this.enabled_ = false;
};
goog.addSingletonGetter(drive.ds.sync.stat.StatMonitor);


/**
 * Maximum number of requets to include in rolling average.
 * @private {number}
 */
drive.ds.sync.stat.StatMonitor.MAX_REQUESTS_ = 100;


/**
 * Number of milliseconds between rechecking.
 * @private {number}
 */
drive.ds.sync.stat.StatMonitor.prototype.INTERVAL_MS_ = 30000;


/**
 * Whether this performance monitor is enabled.
 * @param {boolean} enabled Whether this performance monitor is enabled.
 */
drive.ds.sync.stat.StatMonitor.prototype.setEnabled = function(enabled) {
  this.enabled_ = enabled;

  if (this.enabled_) {
    this.log_();
  }
};


/**
 * Registers a map for monitoring.
 * @param {string} name A name to identify this map.
 * @param {!Object.<*, *>} map A map to monitor.
 */
drive.ds.sync.stat.StatMonitor.prototype.registerMap =
    function(name, map) {
  this.maps_.set(name, map);
};


/**
 * Passes in the amount of time it took to process the particular request.
 * @param {!Object} response The response from the Genoa API.
 * @param {number} time The time it took to process the request in milliseconds.
 * @param {!drive.ds.sync.stat.RequestType} type The request type.
 */
drive.ds.sync.stat.StatMonitor.prototype.addRequestStat =
    function(response, time, type) {
  if (this.enabled_) {
    var queue = this.requestStats_.get(type);
    if (!queue) {
      queue = new goog.structs.Queue();
      this.requestStats_.set(type, queue);
    }

    var stat = new drive.ds.sync.stat.RequestStat(
        this.getSizeOf_(response, 0, {}), time);
    queue.enqueue(stat);

    if (queue.getCount() > drive.ds.sync.stat.StatMonitor.MAX_REQUESTS_) {
      queue.dequeue();
    }
  }
};


/**
 * Calculate and log the latest set of stat.
 * @private
 */
drive.ds.sync.stat.StatMonitor.prototype.log_ = function() {
  // Calculate and log for maps.
  var keys = this.maps_.getKeys();
  for (var i = 0; i < keys.length; i++) {
    this.statForMap_(keys[i],
        /** @type {!Object.<*, *>} */ (this.maps_.get(keys[i])));
  }

  // Calculate and log Genoa request times and response sizes.
  this.statsForRequests_();

  if (this.enabled_) {
    goog.global.setTimeout(goog.bind(this.log_, this),
        drive.ds.sync.stat.StatMonitor.prototype.INTERVAL_MS_);
  }
};


/**
 * Calculates size stats for a particular map.
 * @param {string} name A name to identify this map.
 * @param {!Object.<*, *>} map The map to print stats for.
 * @private
 */
drive.ds.sync.stat.StatMonitor.prototype.statForMap_ = function(name, map) {
  var totalBytes = 0;

  goog.object.forEach(map, function(item) {
    totalBytes += this.getSizeOf_(item, 0, {});
  }, this);

  var totalItems = goog.object.getCount(map);
  this.logger_.info('Map Stats for: ' + name + ' | ' +
      'Items: ' + totalItems + ' | ' +
      'Bytes: ' + totalBytes + ' | ' +
      'Average Bytes: ' + Math.round(totalBytes / totalItems));
};


/**
 * Calculates stats for requests.
 * @private
 */
drive.ds.sync.stat.StatMonitor.prototype.statsForRequests_ = function() {
  // Time and payload size stats.
  var keys = this.requestStats_.getKeys();
  for (var i = 0; i < keys.length; i++) {
    var totalBytes = 0;
    var totalTime = 0;
    goog.array.forEach(this.requestStats_.get(keys[i]).getValues(),
        function(stat) {
          totalBytes += stat.getBytes();
          totalTime += stat.getTime();
        });

    var requestCount = this.requestStats_.get(keys[i]).getCount();
    this.logger_.info('Request Stats for: ' + keys[i] + ' | ' +
        'Request Count: ' + requestCount + ' | ' +
        'Average Time (ms): ' + Math.round(totalTime / requestCount) + ' | ' +
        'Average Bytes: ' + Math.round(totalBytes / requestCount));
  }
};


/**
 * Computes the size of the current object. Numbers are approximations
 * based on current implementations on most computers. Could be off on
 * different platforms.
 * Note: Based on {@code fava.data.DataSpy}
 * @param {*} object The object to measure.
 * @param {number} depth The depth of the call, to control excessive recursions.
 * @param {Object} objectsSeen Objects seen so far.
 * @return {number} The number of bytes in object.
 * @throws {string} An overflow or other error condition occurred.
 * @private
 */
drive.ds.sync.stat.StatMonitor.prototype.getSizeOf_ =
    function(object, depth, objectsSeen) {
  var bytes = 0;
  if (typeof object === 'boolean') {
    bytes = 4;
  } else if (typeof object === 'string') {
    bytes = object.length * 2;
  } else if (typeof object === 'number') {
    bytes = 8;
  } else if (typeof object === 'object') {
    if (depth > 10) {
      this.logger_.warning('Aborted internalGetSizeOf: too much recursion!');
      throw '[too much recursion]';
    }
    if (!object || object.length === 0 || object === this)
      return 0;
    if (!objectsSeen[object]) {
      objectsSeen[object] = true;
      for (var i in object) {
        bytes += 8;  // object overhead.
        bytes += this.getSizeOf_(object[i], depth + 1, objectsSeen);
      }
    }
  }

  return bytes;
};

//javascript/apps/drive/dataservice/sync/stat/stopwatch.js
goog.provide('drive.ds.sync.stat.Stopwatch');



/**
 * A stopwatch for timing events.
 * @constructor
 */
drive.ds.sync.stat.Stopwatch = function() {
  /**
   * The time when start was last called.
   * @private {Date}
   **/
  this.startTime_ = null;

  /**
   * The time when stop was last called.
   * @private {Date}
   **/
  this.stopTime_ = null;
};


/**
 * Starts the stopwatch.
 * @return {!drive.ds.sync.stat.Stopwatch} this.
 */
drive.ds.sync.stat.Stopwatch.prototype.start = function() {
  this.startTime_ = new Date();
  return this;
};


/**
 * Stops the stopwatch.
 * @return {!drive.ds.sync.stat.Stopwatch} this.
 */
drive.ds.sync.stat.Stopwatch.prototype.stop = function() {
  this.stopTime_ = new Date();
  return this;
};


/**
 * @return {number} The number of milliseconds elapsed between start and stop
 *     calls.
 */
drive.ds.sync.stat.Stopwatch.prototype.getElapsedTimeMillis = function() {
  return this.stopTime_ - this.startTime_;
};

//javascript/apps/drive/dataservice/sync/api/requestwrapper.js
goog.provide('drive.ds.sync.api.RequestWrapper');

goog.require('drive.ds.sync.stat.StatMonitor');
goog.require('drive.ds.sync.stat.Stopwatch');



/**
 * Wrapper around a Genoa api request with it's response handler. Also logs
 * stats for the request.
 * @param {!Function} apiFunctionGenerator Function that returns the API method
 *     to call with a set of parameters.
 * @param {!Object} params The parameters to pass to the Genoa API.
 * @param {!Function} handler The response handler to call on api rqeuest
 *     completion.
 * @param {!drive.ds.sync.stat.RequestType} type The type of request.
 * @constructor
 */
drive.ds.sync.api.RequestWrapper = function(
    apiFunctionGenerator, params, handler, type) {
  /**
   * Function that returns the API method to call with a set of parameters.
   * @private {!Function}
   */
  this.apiFunctionGenerator_ = apiFunctionGenerator;

  /** @private {!Object} The parameters to pass to the Genoa API. */
  this.params_ = params;

  /** @private {!Function} The response handler for the Genoa api response. */
  this.handler_ = handler;

  /** @private {!drive.ds.sync.stat.RequestType} Type of request. */
  this.type_ = type;

  /** @private {!drive.ds.sync.stat.Stopwatch} */
  this.stopwatch_ = new drive.ds.sync.stat.Stopwatch();
};


/**
 * Submits the Genoa api request.
 */
drive.ds.sync.api.RequestWrapper.prototype.run = function() {
  this.stopwatch_.start();

  var apiFunction = this.apiFunctionGenerator_();
  var apiRequest = apiFunction(this.params_);
  apiRequest.execute(goog.bind(this.apiResponseHandler_, this));
};


/**
 * An api response handler that logs stats for the request and passes the
 * the api response to the response handler.
 * @param {!Object} response The response from the Genoa api.
 * @private
 */
drive.ds.sync.api.RequestWrapper.prototype.apiResponseHandler_ =
    function(response) {
  // Log request stats.
  drive.ds.sync.stat.StatMonitor.getInstance().addRequestStat(
      response, this.stopwatch_.stop().getElapsedTimeMillis(), this.type_);

  // Handle api response.
  this.handler_(response);
};

//javascript/apps/drive/dataservice/sync/api/requestmanager.js
goog.provide('drive.ds.sync.api.RequestManager');

goog.require('drive.ds.sync.CommandManager');
goog.require('drive.ds.sync.api.RequestWrapper');



/**
 * A request manager responsible for maintaining a queue of pending Genoa api
 * requests that need to be processed.
 * @extends {drive.ds.sync.CommandManager.<drive.ds.sync.api.RequestWrapper>}
 * @constructor
 */
drive.ds.sync.api.RequestManager = function() {
  goog.base(this);
};
goog.inherits(drive.ds.sync.api.RequestManager, drive.ds.sync.CommandManager);
goog.addSingletonGetter(drive.ds.sync.api.RequestManager);


/** @override */
drive.ds.sync.api.RequestManager.prototype.processCommand =
    function(commandWrapper) {
  var requestWrapper = commandWrapper.getCommand();
  requestWrapper.run();
};


/**
 * Wraps a request and enqueues it.
 * @param {!Function} apiFunctionGenerator Function that returns the API method
 *     to call with a set of parameters.
 * @param {!Object} params The parameters to pass to the Genoa API.
 * @param {!Function} handler The response handler to call on api rqeuest
 *     completion.
 * @param {!drive.ds.sync.stat.RequestType} type The type of request.
 */
drive.ds.sync.api.RequestManager.prototype.enqueueRequest = function(
    apiFunctionGenerator, params, handler, type) {
  var request = new drive.ds.sync.api.RequestWrapper(
      apiFunctionGenerator, params, handler, type);
  this.enqueue(request);
};

//javascript/apps/drive/dataservice/sync/api/about.js
/**
 * @fileoverview Helper that generates a Genoa 'About' query,
 * and executes it.
 */

goog.provide('drive.ds.sync.api.About');

goog.require('drive.ds.sync.api.RequestManager');
goog.require('drive.ds.sync.stat.RequestType');


/**
 * Gets the 'About' resource which contains user information and settings.
 * @param {!Function} responseHandler The response handler to call.
 */
drive.ds.sync.api.About.get = function(responseHandler) {
  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.About.createGetMethod_,
      {}, responseHandler, drive.ds.sync.stat.RequestType.ABOUT);
};


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for information about the current user.
 * @private
 */
drive.ds.sync.api.About.createGetMethod_ = function() {
  return gapi.client.drive.about.get;
};

//javascript/closure/events/eventid.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.provide('goog.events.EventId');



/**
 * A templated class that is used when registering for events. Typical usage:
 * <code>
 *   /** @type {goog.events.EventId.<MyEventObj>}
 *   var myEventId = new goog.events.EventId(
 *       goog.events.getUniqueId(('someEvent'));
 *
 *   // No need to cast or declare here since the compiler knows the correct
 *   // type of 'evt' (MyEventObj).
 *   something.listen(myEventId, function(evt) {});
 * </code>
 *
 * @param {string} eventId
 * @template T
 * @constructor
 * @struct
 * @final
 */
goog.events.EventId = function(eventId) {
  /** @const */ this.id = eventId;
};


/**
 * @override
 */
goog.events.EventId.prototype.toString = function() {
  return this.id;
};

//javascript/closure/events/event.js
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A base class for event objects.
 *
 * @author pupius@google.com (Daniel Pupius)
 */


goog.provide('goog.events.Event');
goog.provide('goog.events.EventLike');

/**
 * goog.events.Event no longer depends on goog.Disposable. Keep requiring
 * goog.Disposable here to not break projects which assume this dependency.
 * @suppress {extraRequire}
 */
goog.require('goog.Disposable');
goog.require('goog.events.EventId');


/**
 * A typedef for event like objects that are dispatchable via the
 * goog.events.dispatchEvent function. strings are treated as the type for a
 * goog.events.Event. Objects are treated as an extension of a new
 * goog.events.Event with the type property of the object being used as the type
 * of the Event.
 * @typedef {string|Object|goog.events.Event|goog.events.EventId}
 */
goog.events.EventLike;



/**
 * A base class for event objects, so that they can support preventDefault and
 * stopPropagation.
 *
 * @param {string|!goog.events.EventId} type Event Type.
 * @param {Object=} opt_target Reference to the object that is the target of
 *     this event. It has to implement the {@code EventTarget} interface
 *     declared at {@link http://developer.mozilla.org/en/DOM/EventTarget}.
 * @constructor
 */
goog.events.Event = function(type, opt_target) {
  /**
   * Event type.
   * @type {string}
   */
  this.type = type instanceof goog.events.EventId ? String(type) : type;

  /**
   * Target of the event.
   * @type {Object|undefined}
   */
  this.target = opt_target;

  /**
   * Object that had the listener attached.
   * @type {Object|undefined}
   */
  this.currentTarget = this.target;

  /**
   * Whether to cancel the event in internal capture/bubble processing for IE.
   * @type {boolean}
   * @public
   * @suppress {underscore|visibility} Technically public, but referencing this
   *     outside this package is strongly discouraged.
   */
  this.propagationStopped_ = false;

  /**
   * Whether the default action has been prevented.
   * This is a property to match the W3C specification at
   * {@link http://www.w3.org/TR/DOM-Level-3-Events/
   * #events-event-type-defaultPrevented}.
   * Must be treated as read-only outside the class.
   * @type {boolean}
   */
  this.defaultPrevented = false;

  /**
   * Return value for in internal capture/bubble processing for IE.
   * @type {boolean}
   * @public
   * @suppress {underscore|visibility} Technically public, but referencing this
   *     outside this package is strongly discouraged.
   */
  this.returnValue_ = true;
};


/**
 * For backwards compatibility (goog.events.Event used to inherit
 * goog.Disposable).
 * @deprecated Events don't need to be disposed.
 */
goog.events.Event.prototype.disposeInternal = function() {
};


/**
 * For backwards compatibility (goog.events.Event used to inherit
 * goog.Disposable).
 * @deprecated Events don't need to be disposed.
 */
goog.events.Event.prototype.dispose = function() {
};


/**
 * Stops event propagation.
 */
goog.events.Event.prototype.stopPropagation = function() {
  this.propagationStopped_ = true;
};


/**
 * Prevents the default action, for example a link redirecting to a url.
 */
goog.events.Event.prototype.preventDefault = function() {
  this.defaultPrevented = true;
  this.returnValue_ = false;
};


/**
 * Stops the propagation of the event. It is equivalent to
 * {@code e.stopPropagation()}, but can be used as the callback argument of
 * {@link goog.events.listen} without declaring another function.
 * @param {!goog.events.Event} e An event.
 */
goog.events.Event.stopPropagation = function(e) {
  e.stopPropagation();
};


/**
 * Prevents the default action. It is equivalent to
 * {@code e.preventDefault()}, but can be used as the callback argument of
 * {@link goog.events.listen} without declaring another function.
 * @param {!goog.events.Event} e An event.
 */
goog.events.Event.preventDefault = function(e) {
  e.preventDefault();
};

//javascript/closure/reflect/reflect.js
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Useful compiler idioms.
 *
 * @author mgoodman@google.com (Mark Goodman)
 * @author johnlenz@google.com (John Lenz)
 */

goog.provide('goog.reflect');


/**
 * Syntax for object literal casts.
 * @see http://go/jscompiler-renaming
 * @see http://code.google.com/p/closure-compiler/wiki/
 *      ExperimentalTypeBasedPropertyRenaming
 *
 * Use this if you have an object literal whose keys need to have the same names
 * as the properties of some class even after they are renamed by the compiler.
 *
 * @param {!Function} type Type to cast to.
 * @param {Object} object Object literal to cast.
 * @return {Object} The object literal.
 */
goog.reflect.object = function(type, object) {
  return object;
};


/**
 * To assert to the compiler that an operation is needed when it would
 * otherwise be stripped. For example:
 * <code>
 *     // Force a layout
 *     goog.reflect.sinkValue(dialog.offsetHeight);
 * </code>
 * @type {!Function}
 */
goog.reflect.sinkValue = function(x) {
  goog.reflect.sinkValue[' '](x);
  return x;
};


/**
 * The compiler should optimize this function away iff no one ever uses
 * goog.reflect.sinkValue.
 */
goog.reflect.sinkValue[' '] = goog.nullFunction;


/**
 * Check if a property can be accessed without throwing an exception.
 * @param {Object} obj The owner of the property.
 * @param {string} prop The property name.
 * @return {boolean} Whether the property is accessible. Will also return true
 *     if obj is null.
 */
goog.reflect.canAccessProperty = function(obj, prop) {
  /** @preserveTry */
  try {
    goog.reflect.sinkValue(obj[prop]);
    return true;
  } catch (e) {}
  return false;
};

//javascript/closure/events/browserfeature.js
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Browser capability checks for the events package.
 *
 * @author zhyder@google.com (Zohair Hyder)
 */


goog.provide('goog.events.BrowserFeature');

goog.require('goog.userAgent');


/**
 * Enum of browser capabilities.
 * @enum {boolean}
 */
goog.events.BrowserFeature = {
  /**
   * Whether the button attribute of the event is W3C compliant.  False in
   * Internet Explorer prior to version 9; document-version dependent.
   */
  HAS_W3C_BUTTON: !goog.userAgent.IE ||
      goog.userAgent.isDocumentModeOrHigher(9),

  /**
   * Whether the browser supports full W3C event model.
   */
  HAS_W3C_EVENT_SUPPORT: !goog.userAgent.IE ||
      goog.userAgent.isDocumentModeOrHigher(9),

  /**
   * To prevent default in IE7-8 for certain keydown events we need set the
   * keyCode to -1.
   */
  SET_KEY_CODE_TO_PREVENT_DEFAULT: goog.userAgent.IE &&
      !goog.userAgent.isVersionOrHigher('9'),

  /**
   * Whether the {@code navigator.onLine} property is supported.
   */
  HAS_NAVIGATOR_ONLINE_PROPERTY: !goog.userAgent.WEBKIT ||
      goog.userAgent.isVersionOrHigher('528'),

  /**
   * Whether HTML5 network online/offline events are supported.
   */
  HAS_HTML5_NETWORK_EVENT_SUPPORT:
      goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9b') ||
      goog.userAgent.IE && goog.userAgent.isVersionOrHigher('8') ||
      goog.userAgent.OPERA && goog.userAgent.isVersionOrHigher('9.5') ||
      goog.userAgent.WEBKIT && goog.userAgent.isVersionOrHigher('528'),

  /**
   * Whether HTML5 network events fire on document.body, or otherwise the
   * window.
   */
  HTML5_NETWORK_EVENTS_FIRE_ON_BODY:
      goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher('8') ||
      goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9'),

  /**
   * Whether touch is enabled in the browser.
   */
  TOUCH_ENABLED:
      ('ontouchstart' in goog.global ||
          !!(goog.global['document'] &&
             document.documentElement &&
             'ontouchstart' in document.documentElement) ||
          // IE10 uses non-standard touch events, so it has a different check.
          !!(goog.global['navigator'] &&
              goog.global['navigator']['msMaxTouchPoints']))
};

//javascript/closure/events/eventtype.js
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Event Types.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author mirkov@google.com (Mirko Visontai)
 */


goog.provide('goog.events.EventType');

goog.require('goog.userAgent');


/**
 * Returns a prefixed event name for the current browser.
 * @param {string} eventName The name of the event.
 * @return {string} The prefixed event name.
 * @suppress {missingRequire|missingProvide}
 * @private
 */
goog.events.getVendorPrefixedName_ = function(eventName) {
  return goog.userAgent.WEBKIT ? 'webkit' + eventName :
      (goog.userAgent.OPERA ? 'o' + eventName.toLowerCase() :
          eventName.toLowerCase());
};


/**
 * Constants for event names.
 * @enum {string}
 */
goog.events.EventType = {
  // Mouse events
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  MOUSEDOWN: 'mousedown',
  MOUSEUP: 'mouseup',
  MOUSEOVER: 'mouseover',
  MOUSEOUT: 'mouseout',
  MOUSEMOVE: 'mousemove',
  MOUSEENTER: 'mouseenter',
  MOUSELEAVE: 'mouseleave',
  // Select start is non-standard.
  // See http://msdn.microsoft.com/en-us/library/ie/ms536969(v=vs.85).aspx.
  SELECTSTART: 'selectstart', // IE, Safari, Chrome

  // Key events
  KEYPRESS: 'keypress',
  KEYDOWN: 'keydown',
  KEYUP: 'keyup',

  // Focus
  BLUR: 'blur',
  FOCUS: 'focus',
  DEACTIVATE: 'deactivate', // IE only
  // NOTE: The following two events are not stable in cross-browser usage.
  //     WebKit and Opera implement DOMFocusIn/Out.
  //     IE implements focusin/out.
  //     Gecko implements neither see bug at
  //     https://bugzilla.mozilla.org/show_bug.cgi?id=396927.
  // The DOM Events Level 3 Draft deprecates DOMFocusIn in favor of focusin:
  //     http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html
  // You can use FOCUS in Capture phase until implementations converge.
  FOCUSIN: goog.userAgent.IE ? 'focusin' : 'DOMFocusIn',
  FOCUSOUT: goog.userAgent.IE ? 'focusout' : 'DOMFocusOut',

  // Forms
  CHANGE: 'change',
  SELECT: 'select',
  SUBMIT: 'submit',
  INPUT: 'input',
  PROPERTYCHANGE: 'propertychange', // IE only

  // Drag and drop
  DRAGSTART: 'dragstart',
  DRAG: 'drag',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DRAGLEAVE: 'dragleave',
  DROP: 'drop',
  DRAGEND: 'dragend',

  // WebKit touch events.
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  TOUCHCANCEL: 'touchcancel',

  // Misc
  BEFOREUNLOAD: 'beforeunload',
  CONSOLEMESSAGE: 'consolemessage',
  CONTEXTMENU: 'contextmenu',
  DOMCONTENTLOADED: 'DOMContentLoaded',
  ERROR: 'error',
  HELP: 'help',
  LOAD: 'load',
  LOSECAPTURE: 'losecapture',
  ORIENTATIONCHANGE: 'orientationchange',
  READYSTATECHANGE: 'readystatechange',
  RESIZE: 'resize',
  SCROLL: 'scroll',
  UNLOAD: 'unload',

  // HTML 5 History events
  // See http://www.w3.org/TR/html5/history.html#event-definitions
  HASHCHANGE: 'hashchange',
  PAGEHIDE: 'pagehide',
  PAGESHOW: 'pageshow',
  POPSTATE: 'popstate',

  // Copy and Paste
  // Support is limited. Make sure it works on your favorite browser
  // before using.
  // http://www.quirksmode.org/dom/events/cutcopypaste.html
  COPY: 'copy',
  PASTE: 'paste',
  CUT: 'cut',
  BEFORECOPY: 'beforecopy',
  BEFORECUT: 'beforecut',
  BEFOREPASTE: 'beforepaste',

  // HTML5 online/offline events.
  // http://www.w3.org/TR/offline-webapps/#related
  ONLINE: 'online',
  OFFLINE: 'offline',

  // HTML 5 worker events
  MESSAGE: 'message',
  CONNECT: 'connect',

  // CSS animation events.
  /** @suppress {missingRequire} */
  ANIMATIONSTART: goog.events.getVendorPrefixedName_('AnimationStart'),
  /** @suppress {missingRequire} */
  ANIMATIONEND: goog.events.getVendorPrefixedName_('AnimationEnd'),
  /** @suppress {missingRequire} */
  ANIMATIONITERATION: goog.events.getVendorPrefixedName_('AnimationIteration'),

  // CSS transition events. Based on the browser support described at:
  // https://developer.mozilla.org/en/css/css_transitions#Browser_compatibility
  /** @suppress {missingRequire} */
  TRANSITIONEND: goog.events.getVendorPrefixedName_('TransitionEnd'),

  // W3C Pointer Events
  // http://www.w3.org/TR/pointerevents/
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTERCANCEL: 'pointercancel',
  POINTERMOVE: 'pointermove',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  GOTPOINTERCAPTURE: 'gotpointercapture',
  LOSTPOINTERCAPTURE: 'lostpointercapture',

  // IE specific events.
  // See http://msdn.microsoft.com/en-us/library/ie/hh772103(v=vs.85).aspx
  // Note: these events will be supplanted in IE11.
  MSGESTURECHANGE: 'MSGestureChange',
  MSGESTUREEND: 'MSGestureEnd',
  MSGESTUREHOLD: 'MSGestureHold',
  MSGESTURESTART: 'MSGestureStart',
  MSGESTURETAP: 'MSGestureTap',
  MSGOTPOINTERCAPTURE: 'MSGotPointerCapture',
  MSINERTIASTART: 'MSInertiaStart',
  MSLOSTPOINTERCAPTURE: 'MSLostPointerCapture',
  MSPOINTERCANCEL: 'MSPointerCancel',
  MSPOINTERDOWN: 'MSPointerDown',
  MSPOINTERENTER: 'MSPointerEnter',
  MSPOINTERHOVER: 'MSPointerHover',
  MSPOINTERLEAVE: 'MSPointerLeave',
  MSPOINTERMOVE: 'MSPointerMove',
  MSPOINTEROUT: 'MSPointerOut',
  MSPOINTEROVER: 'MSPointerOver',
  MSPOINTERUP: 'MSPointerUp',

  // Native IMEs/input tools events.
  TEXTINPUT: 'textinput',
  COMPOSITIONSTART: 'compositionstart',
  COMPOSITIONUPDATE: 'compositionupdate',
  COMPOSITIONEND: 'compositionend',

  // Webview tag events
  // See http://developer.chrome.com/dev/apps/webview_tag.html
  EXIT: 'exit',
  LOADABORT: 'loadabort',
  LOADCOMMIT: 'loadcommit',
  LOADREDIRECT: 'loadredirect',
  LOADSTART: 'loadstart',
  LOADSTOP: 'loadstop',
  RESPONSIVE: 'responsive',
  SIZECHANGED: 'sizechanged',
  UNRESPONSIVE: 'unresponsive',

  // HTML5 Page Visibility API.  See details at
  // {@code goog.labs.dom.PageVisibilityMonitor}.
  VISIBILITYCHANGE: 'visibilitychange'
};

//javascript/closure/events/browserevent.js
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A patched, standardized event object for browser events.
 *
 * <pre>
 * The patched event object contains the following members:
 * - type           {string}    Event type, e.g. 'click'
 * - timestamp      {Date}      A date object for when the event was fired
 * - target         {Object}    The element that actually triggered the event
 * - currentTarget  {Object}    The element the listener is attached to
 * - relatedTarget  {Object}    For mouseover and mouseout, the previous object
 * - offsetX        {number}    X-coordinate relative to target
 * - offsetY        {number}    Y-coordinate relative to target
 * - clientX        {number}    X-coordinate relative to viewport
 * - clientY        {number}    Y-coordinate relative to viewport
 * - screenX        {number}    X-coordinate relative to the edge of the screen
 * - screenY        {number}    Y-coordinate relative to the edge of the screen
 * - button         {number}    Mouse button. Use isButton() to test.
 * - keyCode        {number}    Key-code
 * - ctrlKey        {boolean}   Was ctrl key depressed
 * - altKey         {boolean}   Was alt key depressed
 * - shiftKey       {boolean}   Was shift key depressed
 * - metaKey        {boolean}   Was meta key depressed
 * - defaultPrevented {boolean} Whether the default action has been prevented
 * - state          {Object}    History state object
 *
 * NOTE: The keyCode member contains the raw browser keyCode. For normalized
 * key and character code use {@link goog.events.KeyHandler}.
 * </pre>
 *
 * @author pupius@google.com (Daniel Pupius)
 * @author arv@google.com (Erik Arvidsson)
 */

goog.provide('goog.events.BrowserEvent');
goog.provide('goog.events.BrowserEvent.MouseButton');

goog.require('goog.events.BrowserFeature');
goog.require('goog.events.Event');
goog.require('goog.events.EventType');
goog.require('goog.reflect');
goog.require('goog.userAgent');



/**
 * Accepts a browser event object and creates a patched, cross browser event
 * object.
 * The content of this object will not be initialized if no event object is
 * provided. If this is the case, init() needs to be invoked separately.
 * @param {Event=} opt_e Browser event object.
 * @param {EventTarget=} opt_currentTarget Current target for event.
 * @constructor
 * @extends {goog.events.Event}
 */
goog.events.BrowserEvent = function(opt_e, opt_currentTarget) {
  goog.base(this, opt_e ? opt_e.type : '');

  /**
   * Target that fired the event.
   * @override
   * @type {Node}
   */
  this.target = null;

  /**
   * Node that had the listener attached.
   * @override
   * @type {Node|undefined}
   */
  this.currentTarget = null;

  /**
   * For mouseover and mouseout events, the related object for the event.
   * @type {Node}
   */
  this.relatedTarget = null;

  /**
   * X-coordinate relative to target.
   * @type {number}
   */
  this.offsetX = 0;

  /**
   * Y-coordinate relative to target.
   * @type {number}
   */
  this.offsetY = 0;

  /**
   * X-coordinate relative to the window.
   * @type {number}
   */
  this.clientX = 0;

  /**
   * Y-coordinate relative to the window.
   * @type {number}
   */
  this.clientY = 0;

  /**
   * X-coordinate relative to the monitor.
   * @type {number}
   */
  this.screenX = 0;

  /**
   * Y-coordinate relative to the monitor.
   * @type {number}
   */
  this.screenY = 0;

  /**
   * Which mouse button was pressed.
   * @type {number}
   */
  this.button = 0;

  /**
   * Keycode of key press.
   * @type {number}
   */
  this.keyCode = 0;

  /**
   * Keycode of key press.
   * @type {number}
   */
  this.charCode = 0;

  /**
   * Whether control was pressed at time of event.
   * @type {boolean}
   */
  this.ctrlKey = false;

  /**
   * Whether alt was pressed at time of event.
   * @type {boolean}
   */
  this.altKey = false;

  /**
   * Whether shift was pressed at time of event.
   * @type {boolean}
   */
  this.shiftKey = false;

  /**
   * Whether the meta key was pressed at time of event.
   * @type {boolean}
   */
  this.metaKey = false;

  /**
   * History state object, only set for PopState events where it's a copy of the
   * state object provided to pushState or replaceState.
   * @type {Object}
   */
  this.state = null;

  /**
   * Whether the default platform modifier key was pressed at time of event.
   * (This is control for all platforms except Mac, where it's Meta.)
   * @type {boolean}
   */
  this.platformModifierKey = false;

  /**
   * The browser event object.
   * @private {Event}
   */
  this.event_ = null;

  if (opt_e) {
    this.init(opt_e, opt_currentTarget);
  }
};
goog.inherits(goog.events.BrowserEvent, goog.events.Event);


/**
 * Normalized button constants for the mouse.
 * @enum {number}
 */
goog.events.BrowserEvent.MouseButton = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};


/**
 * Static data for mapping mouse buttons.
 * @type {!Array.<number>}
 */
goog.events.BrowserEvent.IEButtonMap = [
  1, // LEFT
  4, // MIDDLE
  2  // RIGHT
];


/**
 * Accepts a browser event object and creates a patched, cross browser event
 * object.
 * @param {Event} e Browser event object.
 * @param {EventTarget=} opt_currentTarget Current target for event.
 */
goog.events.BrowserEvent.prototype.init = function(e, opt_currentTarget) {
  var type = this.type = e.type;

  // TODO(nicksantos): Change this.target to type EventTarget.
  this.target = /** @type {Node} */ (e.target) || e.srcElement;

  // TODO(nicksantos): Change this.currentTarget to type EventTarget.
  this.currentTarget = /** @type {Node} */ (opt_currentTarget);

  var relatedTarget = /** @type {Node} */ (e.relatedTarget);
  if (relatedTarget) {
    // There's a bug in FireFox where sometimes, relatedTarget will be a
    // chrome element, and accessing any property of it will get a permission
    // denied exception. See:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=497780
    if (goog.userAgent.GECKO) {
      if (!goog.reflect.canAccessProperty(relatedTarget, 'nodeName')) {
        relatedTarget = null;
      }
    }
    // TODO(arv): Use goog.events.EventType when it has been refactored into its
    // own file.
  } else if (type == goog.events.EventType.MOUSEOVER) {
    relatedTarget = e.fromElement;
  } else if (type == goog.events.EventType.MOUSEOUT) {
    relatedTarget = e.toElement;
  }

  this.relatedTarget = relatedTarget;

  // Webkit emits a lame warning whenever layerX/layerY is accessed.
  // http://code.google.com/p/chromium/issues/detail?id=101733
  this.offsetX = (goog.userAgent.WEBKIT || e.offsetX !== undefined) ?
      e.offsetX : e.layerX;
  this.offsetY = (goog.userAgent.WEBKIT || e.offsetY !== undefined) ?
      e.offsetY : e.layerY;

  this.clientX = e.clientX !== undefined ? e.clientX : e.pageX;
  this.clientY = e.clientY !== undefined ? e.clientY : e.pageY;
  this.screenX = e.screenX || 0;
  this.screenY = e.screenY || 0;

  this.button = e.button;

  this.keyCode = e.keyCode || 0;
  this.charCode = e.charCode || (type == 'keypress' ? e.keyCode : 0);
  this.ctrlKey = e.ctrlKey;
  this.altKey = e.altKey;
  this.shiftKey = e.shiftKey;
  this.metaKey = e.metaKey;
  this.platformModifierKey = goog.userAgent.MAC ? e.metaKey : e.ctrlKey;
  this.state = e.state;
  this.event_ = e;
  if (e.defaultPrevented) {
    this.preventDefault();
  }
};


/**
 * Tests to see which button was pressed during the event. This is really only
 * useful in IE and Gecko browsers. And in IE, it's only useful for
 * mousedown/mouseup events, because click only fires for the left mouse button.
 *
 * Safari 2 only reports the left button being clicked, and uses the value '1'
 * instead of 0. Opera only reports a mousedown event for the middle button, and
 * no mouse events for the right button. Opera has default behavior for left and
 * middle click that can only be overridden via a configuration setting.
 *
 * There's a nice table of this mess at http://www.unixpapa.com/js/mouse.html.
 *
 * @param {goog.events.BrowserEvent.MouseButton} button The button
 *     to test for.
 * @return {boolean} True if button was pressed.
 */
goog.events.BrowserEvent.prototype.isButton = function(button) {
  if (!goog.events.BrowserFeature.HAS_W3C_BUTTON) {
    if (this.type == 'click') {
      return button == goog.events.BrowserEvent.MouseButton.LEFT;
    } else {
      return !!(this.event_.button &
          goog.events.BrowserEvent.IEButtonMap[button]);
    }
  } else {
    return this.event_.button == button;
  }
};


/**
 * Whether this has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @return {boolean} The result.
 */
goog.events.BrowserEvent.prototype.isMouseActionButton = function() {
  // Webkit does not ctrl+click to be a right-click, so we
  // normalize it to behave like Gecko and Opera.
  return this.isButton(goog.events.BrowserEvent.MouseButton.LEFT) &&
      !(goog.userAgent.WEBKIT && goog.userAgent.MAC && this.ctrlKey);
};


/**
 * @override
 */
goog.events.BrowserEvent.prototype.stopPropagation = function() {
  goog.events.BrowserEvent.superClass_.stopPropagation.call(this);
  if (this.event_.stopPropagation) {
    this.event_.stopPropagation();
  } else {
    this.event_.cancelBubble = true;
  }
};


/**
 * @override
 */
goog.events.BrowserEvent.prototype.preventDefault = function() {
  goog.events.BrowserEvent.superClass_.preventDefault.call(this);
  var be = this.event_;
  if (!be.preventDefault) {
    be.returnValue = false;
    if (goog.events.BrowserFeature.SET_KEY_CODE_TO_PREVENT_DEFAULT) {
      /** @preserveTry */
      try {
        // Most keys can be prevented using returnValue. Some special keys
        // require setting the keyCode to -1 as well:
        //
        // In IE7:
        // F3, F5, F10, F11, Ctrl+P, Crtl+O, Ctrl+F (these are taken from IE6)
        //
        // In IE8:
        // Ctrl+P, Crtl+O, Ctrl+F (F1-F12 cannot be stopped through the event)
        //
        // We therefore do this for all function keys as well as when Ctrl key
        // is pressed.
        var VK_F1 = 112;
        var VK_F12 = 123;
        if (be.ctrlKey || be.keyCode >= VK_F1 && be.keyCode <= VK_F12) {
          be.keyCode = -1;
        }
      } catch (ex) {
        // IE throws an 'access denied' exception when trying to change
        // keyCode in some situations (e.g. srcElement is input[type=file],
        // or srcElement is an anchor tag rewritten by parent's innerHTML).
        // Do nothing in this case.
      }
    }
  } else {
    be.preventDefault();
  }
};


/**
 * @return {Event} The underlying browser event object.
 */
goog.events.BrowserEvent.prototype.getBrowserEvent = function() {
  return this.event_;
};


/** @override */
goog.events.BrowserEvent.prototype.disposeInternal = function() {
};

//javascript/closure/events/listenable.js
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview An interface for a listenable JavaScript object.
 * @author chrishenry@google.com (Chris Henry)
 */

goog.provide('goog.events.Listenable');
goog.provide('goog.events.ListenableKey');

/** @suppress {extraRequire} */
goog.require('goog.events.EventId');



/**
 * A listenable interface. A listenable is an object with the ability
 * to dispatch/broadcast events to "event listeners" registered via
 * listen/listenOnce.
 *
 * The interface allows for an event propagation mechanism similar
 * to one offered by native browser event targets, such as
 * capture/bubble mechanism, stopping propagation, and preventing
 * default actions. Capture/bubble mechanism depends on the ancestor
 * tree constructed via {@code #getParentEventTarget}; this tree
 * must be directed acyclic graph. The meaning of default action(s)
 * in preventDefault is specific to a particular use case.
 *
 * Implementations that do not support capture/bubble or can not have
 * a parent listenable can simply not implement any ability to set the
 * parent listenable (and have {@code #getParentEventTarget} return
 * null).
 *
 * Implementation of this class can be used with or independently from
 * goog.events.
 *
 * Implementation must call {@code #addImplementation(implClass)}.
 *
 * @interface
 * @see goog.events
 * @see http://www.w3.org/TR/DOM-Level-2-Events/events.html
 */
goog.events.Listenable = function() {};


/**
 * An expando property to indicate that an object implements
 * goog.events.Listenable.
 *
 * See addImplementation/isImplementedBy.
 *
 * @type {string}
 * @const
 */
goog.events.Listenable.IMPLEMENTED_BY_PROP =
    'closure_listenable_' + ((Math.random() * 1e6) | 0);


/**
 * Marks a given class (constructor) as an implementation of
 * Listenable, do that we can query that fact at runtime. The class
 * must have already implemented the interface.
 * @param {!Function} cls The class constructor. The corresponding
 *     class must have already implemented the interface.
 */
goog.events.Listenable.addImplementation = function(cls) {
  cls.prototype[goog.events.Listenable.IMPLEMENTED_BY_PROP] = true;
};


/**
 * @param {Object} obj The object to check.
 * @return {boolean} Whether a given instance implements
 *     Listenable. The class/superclass of the instance must call
 *     addImplementation.
 */
goog.events.Listenable.isImplementedBy = function(obj) {
  try {
    return !!(obj && obj[goog.events.Listenable.IMPLEMENTED_BY_PROP]);
  } catch (e) {
    return false;
  }
};


/**
 * Adds an event listener. A listener can only be added once to an
 * object and if it is added again the key for the listener is
 * returned. Note that if the existing listener is a one-off listener
 * (registered via listenOnce), it will no longer be a one-off
 * listener after a call to listen().
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.listen;


/**
 * Adds an event listener that is removed automatically after the
 * listener fired once.
 *
 * If an existing listener already exists, listenOnce will do
 * nothing. In particular, if the listener was previously registered
 * via listen(), listenOnce() will not turn the listener into a
 * one-off listener. Similarly, if there is already an existing
 * one-off listener, listenOnce does not modify the listeners (it is
 * still a once listener).
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.listenOnce;


/**
 * Removes an event listener which was added with listen() or listenOnce().
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call
 *     the listener.
 * @return {boolean} Whether any listener was removed.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.unlisten;


/**
 * Removes an event listener which was added with listen() by the key
 * returned by listen().
 *
 * @param {goog.events.ListenableKey} key The key returned by
 *     listen() or listenOnce().
 * @return {boolean} Whether any listener was removed.
 */
goog.events.Listenable.prototype.unlistenByKey;


/**
 * Dispatches an event (or event like object) and calls all listeners
 * listening for events of this type. The type of the event is decided by the
 * type property on the event object.
 *
 * If any of the listeners returns false OR calls preventDefault then this
 * function will return false.  If one of the capture listeners calls
 * stopPropagation, then the bubble listeners won't fire.
 *
 * @param {goog.events.EventLike} e Event object.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the listeners returns false) this will also return false.
 */
goog.events.Listenable.prototype.dispatchEvent;


/**
 * Removes all listeners from this listenable. If type is specified,
 * it will only remove listeners of the particular type. otherwise all
 * registered listeners will be removed.
 *
 * @param {string=} opt_type Type of event to remove, default is to
 *     remove all types.
 * @return {number} Number of listeners removed.
 */
goog.events.Listenable.prototype.removeAllListeners;


/**
 * Returns the parent of this event target to use for capture/bubble
 * mechanism.
 *
 * NOTE(chrishenry): The name reflects the original implementation of
 * custom event target ({@code goog.events.EventTarget}). We decided
 * that changing the name is not worth it.
 *
 * @return {goog.events.Listenable} The parent EventTarget or null if
 *     there is no parent.
 */
goog.events.Listenable.prototype.getParentEventTarget;


/**
 * Fires all registered listeners in this listenable for the given
 * type and capture mode, passing them the given eventObject. This
 * does not perform actual capture/bubble. Only implementors of the
 * interface should be using this.
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The type of the
 *     listeners to fire.
 * @param {boolean} capture The capture mode of the listeners to fire.
 * @param {EVENTOBJ} eventObject The event object to fire.
 * @return {boolean} Whether all listeners succeeded without
 *     attempting to prevent default behavior. If any listener returns
 *     false or called goog.events.Event#preventDefault, this returns
 *     false.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.fireListeners;


/**
 * Gets all listeners in this listenable for the given type and
 * capture mode.
 *
 * @param {string|!goog.events.EventId} type The type of the listeners to fire.
 * @param {boolean} capture The capture mode of the listeners to fire.
 * @return {!Array.<goog.events.ListenableKey>} An array of registered
 *     listeners.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.getListeners;


/**
 * Gets the goog.events.ListenableKey for the event or null if no such
 * listener is in use.
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The name of the event
 *     without the 'on' prefix.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener The
 *     listener function to get.
 * @param {boolean} capture Whether the listener is a capturing listener.
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} the found listener or null if not found.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.getListener;


/**
 * Whether there is any active listeners matching the specified
 * signature. If either the type or capture parameters are
 * unspecified, the function will match on the remaining criteria.
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>=} opt_type Event type.
 * @param {boolean=} opt_capture Whether to check for capture or bubble
 *     listeners.
 * @return {boolean} Whether there is any active listeners matching
 *     the requested type and/or capture phase.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.hasListener;



/**
 * An interface that describes a single registered listener.
 * @interface
 */
goog.events.ListenableKey = function() {};


/**
 * Counter used to create a unique key
 * @type {number}
 * @private
 */
goog.events.ListenableKey.counter_ = 0;


/**
 * Reserves a key to be used for ListenableKey#key field.
 * @return {number} A number to be used to fill ListenableKey#key
 *     field.
 */
goog.events.ListenableKey.reserveKey = function() {
  return ++goog.events.ListenableKey.counter_;
};


/**
 * The source event target.
 * @type {!(Object|goog.events.Listenable|goog.events.EventTarget)}
 */
goog.events.ListenableKey.prototype.src;


/**
 * The event type the listener is listening to.
 * @type {string}
 */
goog.events.ListenableKey.prototype.type;


/**
 * The listener function.
 * @type {function(?):?|{handleEvent:function(?):?}|null}
 */
goog.events.ListenableKey.prototype.listener;


/**
 * Whether the listener works on capture phase.
 * @type {boolean}
 */
goog.events.ListenableKey.prototype.capture;


/**
 * The 'this' object for the listener function's scope.
 * @type {Object}
 */
goog.events.ListenableKey.prototype.handler;


/**
 * A globally unique number to identify the key.
 * @type {number}
 */
goog.events.ListenableKey.prototype.key;

//javascript/closure/events/listener.js
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Listener object.
 * @author pupius@google.com (Daniel Pupius)
 * @see ../demos/events.html
 */

goog.provide('goog.events.Listener');

goog.require('goog.events.ListenableKey');



/**
 * Simple class that stores information about a listener
 * @param {!Function} listener Callback function.
 * @param {Function} proxy Wrapper for the listener that patches the event.
 * @param {EventTarget|goog.events.Listenable} src Source object for
 *     the event.
 * @param {string} type Event type.
 * @param {boolean} capture Whether in capture or bubble phase.
 * @param {Object=} opt_handler Object in whose context to execute the callback.
 * @implements {goog.events.ListenableKey}
 * @constructor
 */
goog.events.Listener = function(
    listener, proxy, src, type, capture, opt_handler) {
  if (goog.events.Listener.ENABLE_MONITORING) {
    this.creationStack = new Error().stack;
  }

  /**
   * Callback function.
   * @type {Function}
   */
  this.listener = listener;

  /**
   * A wrapper over the original listener. This is used solely to
   * handle native browser events (it is used to simulate the capture
   * phase and to patch the event object).
   * @type {Function}
   */
  this.proxy = proxy;

  /**
   * Object or node that callback is listening to
   * @type {EventTarget|goog.events.Listenable}
   */
  this.src = src;

  /**
   * The event type.
   * @const {string}
   */
  this.type = type;

  /**
   * Whether the listener is being called in the capture or bubble phase
   * @const {boolean}
   */
  this.capture = !!capture;

  /**
   * Optional object whose context to execute the listener in
   * @type {Object|undefined}
   */
  this.handler = opt_handler;

  /**
   * The key of the listener.
   * @const {number}
   * @override
   */
  this.key = goog.events.ListenableKey.reserveKey();

  /**
   * Whether to remove the listener after it has been called.
   * @type {boolean}
   */
  this.callOnce = false;

  /**
   * Whether the listener has been removed.
   * @type {boolean}
   */
  this.removed = false;
};


/**
 * @define {boolean} Whether to enable the monitoring of the
 *     goog.events.Listener instances. Switching on the monitoring is only
 *     recommended for debugging because it has a significant impact on
 *     performance and memory usage. If switched off, the monitoring code
 *     compiles down to 0 bytes.
 */
goog.define('goog.events.Listener.ENABLE_MONITORING', false);


/**
 * If monitoring the goog.events.Listener instances is enabled, stores the
 * creation stack trace of the Disposable instance.
 * @type {string}
 */
goog.events.Listener.prototype.creationStack;


/**
 * Marks this listener as removed. This also remove references held by
 * this listener object (such as listener and event source).
 */
goog.events.Listener.prototype.markAsRemoved = function() {
  this.removed = true;
  this.listener = null;
  this.proxy = null;
  this.src = null;
  this.handler = null;
};

//javascript/closure/events/listenermap.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A map of listeners that provides utility functions to
 * deal with listeners on an event target. Used by
 * {@code goog.events.EventTarget}.
 *
 * WARNING: Do not use this class from outside goog.events package.
 *
 * @visibility {//javascript/closure/events:__pkg__}
 * @visibility {//javascript/closure/labs/events:__pkg__}
 */

goog.provide('goog.events.ListenerMap');

goog.require('goog.array');
goog.require('goog.events.Listener');
goog.require('goog.object');



/**
 * Creates a new listener map.
 * @param {EventTarget|goog.events.Listenable} src The src object.
 * @constructor
 * @final
 */
goog.events.ListenerMap = function(src) {
  /** @type {EventTarget|goog.events.Listenable} */
  this.src = src;

  /**
   * Maps of event type to an array of listeners.
   * @type {Object.<string, !Array.<!goog.events.Listener>>}
   */
  this.listeners = {};

  /**
   * The count of types in this map that have registered listeners.
   * @private {number}
   */
  this.typeCount_ = 0;
};


/**
 * @return {number} The count of event types in this map that actually
 *     have registered listeners.
 */
goog.events.ListenerMap.prototype.getTypeCount = function() {
  return this.typeCount_;
};


/**
 * @return {number} Total number of registered listeners.
 */
goog.events.ListenerMap.prototype.getListenerCount = function() {
  var count = 0;
  for (var type in this.listeners) {
    count += this.listeners[type].length;
  }
  return count;
};


/**
 * Adds an event listener. A listener can only be added once to an
 * object and if it is added again the key for the listener is
 * returned.
 *
 * Note that a one-off listener will not change an existing listener,
 * if any. On the other hand a normal listener will change existing
 * one-off listener to become a normal listener.
 *
 * @param {string} type The listener event type.
 * @param {!Function} listener This listener callback method.
 * @param {boolean} callOnce Whether the listener is a one-off
 *     listener.
 * @param {boolean=} opt_useCapture The capture mode of the listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 */
goog.events.ListenerMap.prototype.add = function(
    type, listener, callOnce, opt_useCapture, opt_listenerScope) {
  var listenerArray = this.listeners[type];
  if (!listenerArray) {
    listenerArray = this.listeners[type] = [];
    this.typeCount_++;
  }

  var listenerObj;
  var index = goog.events.ListenerMap.findListenerIndex_(
      listenerArray, listener, opt_useCapture, opt_listenerScope);
  if (index > -1) {
    listenerObj = listenerArray[index];
    if (!callOnce) {
      // Ensure that, if there is an existing callOnce listener, it is no
      // longer a callOnce listener.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = new goog.events.Listener(
        listener, null, this.src, type, !!opt_useCapture, opt_listenerScope);
    listenerObj.callOnce = callOnce;
    listenerArray.push(listenerObj);
  }
  return listenerObj;
};


/**
 * Removes a matching listener.
 * @param {string} type The listener event type.
 * @param {!Function} listener This listener callback method.
 * @param {boolean=} opt_useCapture The capture mode of the listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {boolean} Whether any listener was removed.
 */
goog.events.ListenerMap.prototype.remove = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  if (!(type in this.listeners)) {
    return false;
  }

  var listenerArray = this.listeners[type];
  var index = goog.events.ListenerMap.findListenerIndex_(
      listenerArray, listener, opt_useCapture, opt_listenerScope);
  if (index > -1) {
    var listenerObj = listenerArray[index];
    listenerObj.markAsRemoved();
    goog.array.removeAt(listenerArray, index);
    if (listenerArray.length == 0) {
      delete this.listeners[type];
      this.typeCount_--;
    }
    return true;
  }
  return false;
};


/**
 * Removes the given listener object.
 * @param {goog.events.ListenableKey} listener The listener to remove.
 * @return {boolean} Whether the listener is removed.
 */
goog.events.ListenerMap.prototype.removeByKey = function(listener) {
  var type = listener.type;
  if (!(type in this.listeners)) {
    return false;
  }

  var removed = goog.array.remove(this.listeners[type], listener);
  if (removed) {
    listener.markAsRemoved();
    if (this.listeners[type].length == 0) {
      delete this.listeners[type];
      this.typeCount_--;
    }
  }
  return removed;
};


/**
 * Removes all listeners from this map. If opt_type is provided, only
 * listeners that match the given type are removed.
 * @param {string=} opt_type Type of event to remove.
 * @return {number} Number of listeners removed.
 */
goog.events.ListenerMap.prototype.removeAll = function(opt_type) {
  var count = 0;
  for (var type in this.listeners) {
    if (!opt_type || type == opt_type) {
      var listenerArray = this.listeners[type];
      for (var i = 0; i < listenerArray.length; i++) {
        ++count;
        listenerArray[i].markAsRemoved();
      }
      delete this.listeners[type];
      this.typeCount_--;
    }
  }
  return count;
};


/**
 * Gets all listeners that match the given type and capture mode. The
 * returned array is a copy (but the listener objects are not).
 * @param {string} type The type of the listeners to retrieve.
 * @param {boolean} capture The capture mode of the listeners to retrieve.
 * @return {!Array.<goog.events.ListenableKey>} An array of matching
 *     listeners.
 */
goog.events.ListenerMap.prototype.getListeners = function(type, capture) {
  var listenerArray = this.listeners[type];
  var rv = [];
  if (listenerArray) {
    for (var i = 0; i < listenerArray.length; ++i) {
      var listenerObj = listenerArray[i];
      if (listenerObj.capture == capture) {
        rv.push(listenerObj);
      }
    }
  }
  return rv;
};


/**
 * Gets the goog.events.ListenableKey for the event or null if no such
 * listener is in use.
 *
 * @param {string} type The type of the listener to retrieve.
 * @param {!Function} listener The listener function to get.
 * @param {boolean} capture Whether the listener is a capturing listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} the found listener or null if not found.
 */
goog.events.ListenerMap.prototype.getListener = function(
    type, listener, capture, opt_listenerScope) {
  var listenerArray = this.listeners[type];
  var i = -1;
  if (listenerArray) {
    i = goog.events.ListenerMap.findListenerIndex_(
        listenerArray, listener, capture, opt_listenerScope);
  }
  return i > -1 ? listenerArray[i] : null;
};


/**
 * Whether there is a matching listener. If either the type or capture
 * parameters are unspecified, the function will match on the
 * remaining criteria.
 *
 * @param {string=} opt_type The type of the listener.
 * @param {boolean=} opt_capture The capture mode of the listener.
 * @return {boolean} Whether there is an active listener matching
 *     the requested type and/or capture phase.
 */
goog.events.ListenerMap.prototype.hasListener = function(
    opt_type, opt_capture) {
  var hasType = goog.isDef(opt_type);
  var hasCapture = goog.isDef(opt_capture);

  return goog.object.some(
      this.listeners, function(listenerArray, type) {
        for (var i = 0; i < listenerArray.length; ++i) {
          if ((!hasType || listenerArray[i].type == opt_type) &&
              (!hasCapture || listenerArray[i].capture == opt_capture)) {
            return true;
          }
        }

        return false;
      });
};


/**
 * Finds the index of a matching goog.events.Listener in the given
 * listenerArray.
 * @param {!Array.<!goog.events.Listener>} listenerArray Array of listener.
 * @param {!Function} listener The listener function.
 * @param {boolean=} opt_useCapture The capture flag for the listener.
 * @param {Object=} opt_listenerScope The listener scope.
 * @return {number} The index of the matching listener within the
 *     listenerArray.
 * @private
 */
goog.events.ListenerMap.findListenerIndex_ = function(
    listenerArray, listener, opt_useCapture, opt_listenerScope) {
  for (var i = 0; i < listenerArray.length; ++i) {
    var listenerObj = listenerArray[i];
    if (!listenerObj.removed &&
        listenerObj.listener == listener &&
        listenerObj.capture == !!opt_useCapture &&
        listenerObj.handler == opt_listenerScope) {
      return i;
    }
  }
  return -1;
};

//javascript/closure/events/events.js
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview An event manager for both native browser event
 * targets and custom JavaScript event targets
 * ({@code goog.events.Listenable}). This provides an abstraction
 * over browsers' event systems.
 *
 * It also provides a simulation of W3C event model's capture phase in
 * Internet Explorer (IE 8 and below). Caveat: the simulation does not
 * interact well with listeners registered directly on the elements
 * (bypassing goog.events) or even with listeners registered via
 * goog.events in a separate JS binary. In these cases, we provide
 * no ordering guarantees.
 *
 * The listeners will receive a "patched" event object. Such event object
 * contains normalized values for certain event properties that differs in
 * different browsers.
 *
 * Example usage:
 * <pre>
 * goog.events.listen(myNode, 'click', function(e) { alert('woo') });
 * goog.events.listen(myNode, 'mouseover', mouseHandler, true);
 * goog.events.unlisten(myNode, 'mouseover', mouseHandler, true);
 * goog.events.removeAll(myNode);
 * </pre>
 *
 * @author aa@google.com (Aaron Boodman) [Original implementation of listen()]
 * @author pupius@google.com (Daniel Pupius) [Port to closure plus capture phase
 *                                            in IE and event object patching]
 * @author arv@google.com (Erik Arvidsson)
 *
 * @see ../demos/events.html
 * @see ../demos/event-propagation.html
 * @see ../demos/stopevent.html
 */

// IMPLEMENTATION NOTES:
// goog.events stores an auxiliary data structure on each EventTarget
// source being listened on. This allows us to take advantage of GC,
// having the data structure GC'd when the EventTarget is GC'd. This
// GC behavior is equivalent to using W3C DOM Events directly.

goog.provide('goog.events');
goog.provide('goog.events.CaptureSimulationMode');
goog.provide('goog.events.Key');
goog.provide('goog.events.ListenableType');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug.entryPointRegistry');
goog.require('goog.events.BrowserEvent');
goog.require('goog.events.BrowserFeature');
goog.require('goog.events.Listenable');
goog.require('goog.events.ListenerMap');


/**
 * @typedef {number|goog.events.ListenableKey}
 */
goog.events.Key;


/**
 * @typedef {EventTarget|goog.events.Listenable}
 */
goog.events.ListenableType;


/**
 * Container for storing event listeners and their proxies
 *
 * TODO(chrishenry): Remove this when all external usage is
 * purged. goog.events no longer use goog.events.listeners_ for
 * anything meaningful.
 *
 * @private {!Object.<goog.events.ListenableKey>}
 */
goog.events.listeners_ = {};


/**
 * Property name on a native event target for the listener map
 * associated with the event target.
 * @const
 * @private
 */
goog.events.LISTENER_MAP_PROP_ = 'closure_lm_' + ((Math.random() * 1e6) | 0);


/**
 * String used to prepend to IE event types.
 * @const
 * @private
 */
goog.events.onString_ = 'on';


/**
 * Map of computed "on<eventname>" strings for IE event types. Caching
 * this removes an extra object allocation in goog.events.listen which
 * improves IE6 performance.
 * @const
 * @dict
 * @private
 */
goog.events.onStringMap_ = {};


/**
 * @enum {number} Different capture simulation mode for IE8-.
 */
goog.events.CaptureSimulationMode = {
  /**
   * Does not perform capture simulation. Will asserts in IE8- when you
   * add capture listeners.
   */
  OFF_AND_FAIL: 0,

  /**
   * Does not perform capture simulation, silently ignore capture
   * listeners.
   */
  OFF_AND_SILENT: 1,

  /**
   * Performs capture simulation.
   */
  ON: 2
};


/**
 * @define {number} The capture simulation mode for IE8-. By default,
 *     this is ON.
 */
goog.define('goog.events.CAPTURE_SIMULATION_MODE', 2);


/**
 * Estimated count of total native listeners.
 * @private {number}
 */
goog.events.listenerCountEstimate_ = 0;


/**
 * Adds an event listener for a specific event on a native event
 * target (such as a DOM element) or an object that has implemented
 * {@link goog.events.Listenable}. A listener can only be added once
 * to an object and if it is added again the key for the listener is
 * returned. Note that if the existing listener is a one-off listener
 * (registered via listenOnce), it will no longer be a one-off
 * listener after a call to listen().
 *
 * @param {EventTarget|goog.events.Listenable} src The node to listen
 *     to events on.
 * @param {string|Array.<string>} type Event type or array of event types.
 * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener
 *     Callback method, or an object with a handleEvent function.
 *     WARNING: passing an Object is now softly deprecated.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.Key} Unique key for the listener.
 * @template T
 */
goog.events.listen = function(src, type, listener, opt_capt, opt_handler) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.listen(src, type[i], listener, opt_capt, opt_handler);
    }
    return null;
  }

  listener = goog.events.wrapListener_(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.listen(
        /** @type {string} */ (type), listener, opt_capt, opt_handler);
  } else {
    return goog.events.listen_(
        /** @type {EventTarget} */ (src),
        type, listener, /* callOnce */ false, opt_capt, opt_handler);
  }
};


/**
 * Adds an event listener for a specific event on a native event
 * target. A listener can only be added once to an object and if it
 * is added again the key for the listener is returned.
 *
 * Note that a one-off listener will not change an existing listener,
 * if any. On the other hand a normal listener will change existing
 * one-off listener to become a normal listener.
 *
 * @param {EventTarget} src The node to listen to events on.
 * @param {?string} type Event type or array of event types.
 * @param {!Function} listener Callback function.
 * @param {boolean} callOnce Whether the listener is a one-off
 *     listener or otherwise.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 * @private
 */
goog.events.listen_ = function(
    src, type, listener, callOnce, opt_capt, opt_handler) {
  if (!type) {
    throw Error('Invalid event type');
  }

  var capture = !!opt_capt;
  if (capture && !goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
    if (goog.events.CAPTURE_SIMULATION_MODE ==
        goog.events.CaptureSimulationMode.OFF_AND_FAIL) {
      goog.asserts.fail('Can not register capture listener in IE8-.');
      return null;
    } else if (goog.events.CAPTURE_SIMULATION_MODE ==
        goog.events.CaptureSimulationMode.OFF_AND_SILENT) {
      return null;
    }
  }

  var listenerMap = goog.events.getListenerMap_(src);
  if (!listenerMap) {
    src[goog.events.LISTENER_MAP_PROP_] = listenerMap =
        new goog.events.ListenerMap(src);
  }

  var listenerObj = listenerMap.add(
      type, listener, callOnce, opt_capt, opt_handler);

  // If the listenerObj already has a proxy, it has been set up
  // previously. We simply return.
  if (listenerObj.proxy) {
    return listenerObj;
  }

  var proxy = goog.events.getProxy();
  listenerObj.proxy = proxy;

  proxy.src = src;
  proxy.listener = listenerObj;

  // Attach the proxy through the browser's API
  if (src.addEventListener) {
    src.addEventListener(type, proxy, capture);
  } else {
    // The else above used to be else if (src.attachEvent) and then there was
    // another else statement that threw an exception warning the developer
    // they made a mistake. This resulted in an extra object allocation in IE6
    // due to a wrapper object that had to be implemented around the element
    // and so was removed.
    src.attachEvent(goog.events.getOnString_(type), proxy);
  }

  goog.events.listenerCountEstimate_++;
  return listenerObj;
};


/**
 * Helper function for returning a proxy function.
 * @return {Function} A new or reused function object.
 */
goog.events.getProxy = function() {
  var proxyCallbackFunction = goog.events.handleBrowserEvent_;
  // Use a local var f to prevent one allocation.
  var f = goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ?
      function(eventObject) {
        return proxyCallbackFunction.call(f.src, f.listener, eventObject);
      } :
      function(eventObject) {
        var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);
        // NOTE(chrishenry): In IE, we hack in a capture phase. However, if
        // there is inline event handler which tries to prevent default (for
        // example <a href="..." onclick="return false">...</a>) in a
        // descendant element, the prevent default will be overridden
        // by this listener if this listener were to return true. Hence, we
        // return undefined.
        if (!v) return v;
      };
  return f;
};


/**
 * Adds an event listener for a specific event on a native event
 * target (such as a DOM element) or an object that has implemented
 * {@link goog.events.Listenable}. After the event has fired the event
 * listener is removed from the target.
 *
 * If an existing listener already exists, listenOnce will do
 * nothing. In particular, if the listener was previously registered
 * via listen(), listenOnce() will not turn the listener into a
 * one-off listener. Similarly, if there is already an existing
 * one-off listener, listenOnce does not modify the listeners (it is
 * still a once listener).
 *
 * @param {EventTarget|goog.events.Listenable} src The node to listen
 *     to events on.
 * @param {string|Array.<string>} type Event type or array of event types.
 * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener
 *     Callback method.
 * @param {boolean=} opt_capt Fire in capture phase?.
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.Key} Unique key for the listener.
 * @template T
 */
goog.events.listenOnce = function(src, type, listener, opt_capt, opt_handler) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.listenOnce(src, type[i], listener, opt_capt, opt_handler);
    }
    return null;
  }

  listener = goog.events.wrapListener_(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.listenOnce(
        /** @type {string} */ (type), listener, opt_capt, opt_handler);
  } else {
    return goog.events.listen_(
        /** @type {EventTarget} */ (src),
        type, listener, /* callOnce */ true, opt_capt, opt_handler);
  }
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.Listenable}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.Listenable} src The target to
 *     listen to events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener
 *     Callback method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @template T
 */
goog.events.listenWithWrapper = function(src, wrapper, listener, opt_capt,
    opt_handler) {
  wrapper.listen(src, listener, opt_capt, opt_handler);
};


/**
 * Removes an event listener which was added with listen().
 *
 * @param {EventTarget|goog.events.Listenable} src The target to stop
 *     listening to events on.
 * @param {string|Array.<string>} type The name of the event without the 'on'
 *     prefix.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to remove.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase of the
 *     event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {?boolean} indicating whether the listener was there to remove.
 */
goog.events.unlisten = function(src, type, listener, opt_capt, opt_handler) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.unlisten(src, type[i], listener, opt_capt, opt_handler);
    }
    return null;
  }

  listener = goog.events.wrapListener_(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.unlisten(
        /** @type {string} */ (type), listener, opt_capt, opt_handler);
  }

  if (!src) {
    // TODO(chrishenry): We should tighten the API to only accept
    // non-null objects, or add an assertion here.
    return false;
  }

  var capture = !!opt_capt;
  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (src));
  if (listenerMap) {
    var listenerObj = listenerMap.getListener(
        /** @type {string} */ (type), listener, capture, opt_handler);
    if (listenerObj) {
      return goog.events.unlistenByKey(listenerObj);
    }
  }

  return false;
};


/**
 * Removes an event listener which was added with listen() by the key
 * returned by listen().
 *
 * @param {goog.events.Key} key The key returned by listen() for this
 *     event listener.
 * @return {boolean} indicating whether the listener was there to remove.
 */
goog.events.unlistenByKey = function(key) {
  // TODO(chrishenry): Remove this check when tests that rely on this
  // are fixed.
  if (goog.isNumber(key)) {
    return false;
  }

  var listener = /** @type {goog.events.ListenableKey} */ (key);
  if (!listener || listener.removed) {
    return false;
  }

  var src = listener.src;
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.unlistenByKey(listener);
  }

  var type = listener.type;
  var proxy = listener.proxy;
  if (src.removeEventListener) {
    src.removeEventListener(type, proxy, listener.capture);
  } else if (src.detachEvent) {
    src.detachEvent(goog.events.getOnString_(type), proxy);
  }
  goog.events.listenerCountEstimate_--;

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (src));
  // TODO(chrishenry): Try to remove this conditional and execute the
  // first branch always. This should be safe.
  if (listenerMap) {
    listenerMap.removeByKey(listener);
    if (listenerMap.getTypeCount() == 0) {
      // Null the src, just because this is simple to do (and useful
      // for IE <= 7).
      listenerMap.src = null;
      // We don't use delete here because IE does not allow delete
      // on a window object.
      src[goog.events.LISTENER_MAP_PROP_] = null;
    }
  } else {
    listener.markAsRemoved();
  }

  return true;
};


/**
 * Removes an event listener which was added with listenWithWrapper().
 *
 * @param {EventTarget|goog.events.Listenable} src The target to stop
 *     listening to events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to remove.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase of the
 *     event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 */
goog.events.unlistenWithWrapper = function(src, wrapper, listener, opt_capt,
    opt_handler) {
  wrapper.unlisten(src, listener, opt_capt, opt_handler);
};


/**
 * Removes all listeners from an object. You can also optionally
 * remove listeners of a particular type.
 *
 * @param {Object=} opt_obj Object to remove listeners from. Not
 *     specifying opt_obj is now DEPRECATED (it used to remove all
 *     registered listeners).
 * @param {string=} opt_type Type of event to, default is all types.
 * @return {number} Number of listeners removed.
 */
goog.events.removeAll = function(opt_obj, opt_type) {
  // TODO(chrishenry): Change the type of opt_obj from Object= to
  // !EventTarget|goog.events.Listenable). And replace this with an
  // assertion.
  if (!opt_obj) {
    return 0;
  }

  if (goog.events.Listenable.isImplementedBy(opt_obj)) {
    return opt_obj.removeAllListeners(opt_type);
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (opt_obj));
  if (!listenerMap) {
    return 0;
  }

  var count = 0;
  for (var type in listenerMap.listeners) {
    if (!opt_type || type == opt_type) {
      // Clone so that we don't need to worry about unlistenByKey
      // changing the content of the ListenerMap.
      var listeners = goog.array.clone(listenerMap.listeners[type]);
      for (var i = 0; i < listeners.length; ++i) {
        if (goog.events.unlistenByKey(listeners[i])) {
          ++count;
        }
      }
    }
  }
  return count;
};


/**
 * Removes all native listeners registered via goog.events. Native
 * listeners are listeners on native browser objects (such as DOM
 * elements). In particular, goog.events.Listenable and
 * goog.events.EventTarget listeners will NOT be removed.
 * @return {number} Number of listeners removed.
 * @deprecated This doesn't do anything, now that Closure no longer
 * stores a central listener registry.
 */
goog.events.removeAllNativeListeners = function() {
  goog.events.listenerCountEstimate_ = 0;
  return 0;
};


/**
 * Gets the listeners for a given object, type and capture phase.
 *
 * @param {Object} obj Object to get listeners for.
 * @param {string} type Event type.
 * @param {boolean} capture Capture phase?.
 * @return {Array.<goog.events.Listener>} Array of listener objects.
 */
goog.events.getListeners = function(obj, type, capture) {
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return obj.getListeners(type, capture);
  } else {
    if (!obj) {
      // TODO(chrishenry): We should tighten the API to accept
      // !EventTarget|goog.events.Listenable, and add an assertion here.
      return [];
    }

    var listenerMap = goog.events.getListenerMap_(
        /** @type {EventTarget} */ (obj));
    return listenerMap ? listenerMap.getListeners(type, capture) : [];
  }
};


/**
 * Gets the goog.events.Listener for the event or null if no such listener is
 * in use.
 *
 * @param {EventTarget|goog.events.Listenable} src The target from
 *     which to get listeners.
 * @param {?string} type The name of the event without the 'on' prefix.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to get.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *                            whether the listener is fired during the
 *                            capture or bubble phase of the event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.ListenableKey} the found listener or null if not found.
 */
goog.events.getListener = function(src, type, listener, opt_capt, opt_handler) {
  // TODO(chrishenry): Change type from ?string to string, or add assertion.
  type = /** @type {string} */ (type);
  listener = goog.events.wrapListener_(listener);
  var capture = !!opt_capt;
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.getListener(type, listener, capture, opt_handler);
  }

  if (!src) {
    // TODO(chrishenry): We should tighten the API to only accept
    // non-null objects, or add an assertion here.
    return null;
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (src));
  if (listenerMap) {
    return listenerMap.getListener(type, listener, capture, opt_handler);
  }
  return null;
};


/**
 * Returns whether an event target has any active listeners matching the
 * specified signature. If either the type or capture parameters are
 * unspecified, the function will match on the remaining criteria.
 *
 * @param {EventTarget|goog.events.Listenable} obj Target to get
 *     listeners for.
 * @param {string=} opt_type Event type.
 * @param {boolean=} opt_capture Whether to check for capture or bubble-phase
 *     listeners.
 * @return {boolean} Whether an event target has one or more listeners matching
 *     the requested type and/or capture phase.
 */
goog.events.hasListener = function(obj, opt_type, opt_capture) {
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return obj.hasListener(opt_type, opt_capture);
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (obj));
  return !!listenerMap && listenerMap.hasListener(opt_type, opt_capture);
};


/**
 * Provides a nice string showing the normalized event objects public members
 * @param {Object} e Event Object.
 * @return {string} String of the public members of the normalized event object.
 */
goog.events.expose = function(e) {
  var str = [];
  for (var key in e) {
    if (e[key] && e[key].id) {
      str.push(key + ' = ' + e[key] + ' (' + e[key].id + ')');
    } else {
      str.push(key + ' = ' + e[key]);
    }
  }
  return str.join('\n');
};


/**
 * Returns a string with on prepended to the specified type. This is used for IE
 * which expects "on" to be prepended. This function caches the string in order
 * to avoid extra allocations in steady state.
 * @param {string} type Event type.
 * @return {string} The type string with 'on' prepended.
 * @private
 */
goog.events.getOnString_ = function(type) {
  if (type in goog.events.onStringMap_) {
    return goog.events.onStringMap_[type];
  }
  return goog.events.onStringMap_[type] = goog.events.onString_ + type;
};


/**
 * Fires an object's listeners of a particular type and phase
 *
 * @param {Object} obj Object whose listeners to call.
 * @param {string} type Event type.
 * @param {boolean} capture Which event phase.
 * @param {Object} eventObject Event object to be passed to listener.
 * @return {boolean} True if all listeners returned true else false.
 */
goog.events.fireListeners = function(obj, type, capture, eventObject) {
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return obj.fireListeners(type, capture, eventObject);
  }

  return goog.events.fireListeners_(obj, type, capture, eventObject);
};


/**
 * Fires an object's listeners of a particular type and phase.
 * @param {Object} obj Object whose listeners to call.
 * @param {string} type Event type.
 * @param {boolean} capture Which event phase.
 * @param {Object} eventObject Event object to be passed to listener.
 * @return {boolean} True if all listeners returned true else false.
 * @private
 */
goog.events.fireListeners_ = function(obj, type, capture, eventObject) {
  var retval = 1;

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (obj));
  if (listenerMap) {
    // TODO(chrishenry): Original code avoids array creation when there
    // is no listener, so we do the same. If this optimization turns
    // out to be not required, we can replace this with
    // listenerMap.getListeners(type, capture) instead, which is simpler.
    var listenerArray = listenerMap.listeners[type];
    if (listenerArray) {
      listenerArray = goog.array.clone(listenerArray);
      for (var i = 0; i < listenerArray.length; i++) {
        var listener = listenerArray[i];
        // We might not have a listener if the listener was removed.
        if (listener && listener.capture == capture && !listener.removed) {
          retval &=
              goog.events.fireListener(listener, eventObject) !== false;
        }
      }
    }
  }
  return Boolean(retval);
};


/**
 * Fires a listener with a set of arguments
 *
 * @param {goog.events.Listener} listener The listener object to call.
 * @param {Object} eventObject The event object to pass to the listener.
 * @return {boolean} Result of listener.
 */
goog.events.fireListener = function(listener, eventObject) {
  var listenerFn = listener.listener;
  var listenerHandler = listener.handler || listener.src;

  if (listener.callOnce) {
    goog.events.unlistenByKey(listener);
  }
  return listenerFn.call(listenerHandler, eventObject);
};


/**
 * Gets the total number of listeners currently in the system.
 * @return {number} Number of listeners.
 * @deprecated This returns estimated count, now that Closure no longer
 * stores a central listener registry. We still return an estimation
 * to keep existing listener-related tests passing. In the near future,
 * this function will be removed.
 */
goog.events.getTotalListenerCount = function() {
  return goog.events.listenerCountEstimate_;
};


/**
 * Dispatches an event (or event like object) and calls all listeners
 * listening for events of this type. The type of the event is decided by the
 * type property on the event object.
 *
 * If any of the listeners returns false OR calls preventDefault then this
 * function will return false.  If one of the capture listeners calls
 * stopPropagation, then the bubble listeners won't fire.
 *
 * @param {goog.events.Listenable} src The event target.
 * @param {goog.events.EventLike} e Event object.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the handlers returns false) this will also return false.
 *     If there are no handlers, or if all handlers return true, this returns
 *     true.
 */
goog.events.dispatchEvent = function(src, e) {
  goog.asserts.assert(
      goog.events.Listenable.isImplementedBy(src),
      'Can not use goog.events.dispatchEvent with ' +
      'non-goog.events.Listenable instance.');
  return src.dispatchEvent(e);
};


/**
 * Installs exception protection for the browser event entry point using the
 * given error handler.
 *
 * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to
 *     protect the entry point.
 */
goog.events.protectBrowserEventEntryPoint = function(errorHandler) {
  goog.events.handleBrowserEvent_ = errorHandler.protectEntryPoint(
      goog.events.handleBrowserEvent_);
};


/**
 * Handles an event and dispatches it to the correct listeners. This
 * function is a proxy for the real listener the user specified.
 *
 * @param {goog.events.Listener} listener The listener object.
 * @param {Event=} opt_evt Optional event object that gets passed in via the
 *     native event handlers.
 * @return {boolean} Result of the event handler.
 * @this {EventTarget} The object or Element that fired the event.
 * @private
 */
goog.events.handleBrowserEvent_ = function(listener, opt_evt) {
  if (listener.removed) {
    return true;
  }

  // Synthesize event propagation if the browser does not support W3C
  // event model.
  if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
    var ieEvent = opt_evt ||
        /** @type {Event} */ (goog.getObjectByName('window.event'));
    var evt = new goog.events.BrowserEvent(ieEvent, this);
    var retval = true;

    if (goog.events.CAPTURE_SIMULATION_MODE ==
            goog.events.CaptureSimulationMode.ON) {
      // If we have not marked this event yet, we should perform capture
      // simulation.
      if (!goog.events.isMarkedIeEvent_(ieEvent)) {
        goog.events.markIeEvent_(ieEvent);

        var ancestors = [];
        for (var parent = evt.currentTarget; parent;
             parent = parent.parentNode) {
          ancestors.push(parent);
        }

        // Fire capture listeners.
        var type = listener.type;
        for (var i = ancestors.length - 1; !evt.propagationStopped_ && i >= 0;
             i--) {
          evt.currentTarget = ancestors[i];
          retval &= goog.events.fireListeners_(ancestors[i], type, true, evt);
        }

        // Fire bubble listeners.
        //
        // We can technically rely on IE to perform bubble event
        // propagation. However, it turns out that IE fires events in
        // opposite order of attachEvent registration, which broke
        // some code and tests that rely on the order. (While W3C DOM
        // Level 2 Events TR leaves the event ordering unspecified,
        // modern browsers and W3C DOM Level 3 Events Working Draft
        // actually specify the order as the registration order.)
        for (var i = 0; !evt.propagationStopped_ && i < ancestors.length; i++) {
          evt.currentTarget = ancestors[i];
          retval &= goog.events.fireListeners_(ancestors[i], type, false, evt);
        }
      }
    } else {
      retval = goog.events.fireListener(listener, evt);
    }
    return retval;
  }

  // Otherwise, simply fire the listener.
  return goog.events.fireListener(
      listener, new goog.events.BrowserEvent(opt_evt, this));
};


/**
 * This is used to mark the IE event object so we do not do the Closure pass
 * twice for a bubbling event.
 * @param {Event} e The IE browser event.
 * @private
 */
goog.events.markIeEvent_ = function(e) {
  // Only the keyCode and the returnValue can be changed. We use keyCode for
  // non keyboard events.
  // event.returnValue is a bit more tricky. It is undefined by default. A
  // boolean false prevents the default action. In a window.onbeforeunload and
  // the returnValue is non undefined it will be alerted. However, we will only
  // modify the returnValue for keyboard events. We can get a problem if non
  // closure events sets the keyCode or the returnValue

  var useReturnValue = false;

  if (e.keyCode == 0) {
    // We cannot change the keyCode in case that srcElement is input[type=file].
    // We could test that that is the case but that would allocate 3 objects.
    // If we use try/catch we will only allocate extra objects in the case of a
    // failure.
    /** @preserveTry */
    try {
      e.keyCode = -1;
      return;
    } catch (ex) {
      useReturnValue = true;
    }
  }

  if (useReturnValue ||
      /** @type {boolean|undefined} */ (e.returnValue) == undefined) {
    e.returnValue = true;
  }
};


/**
 * This is used to check if an IE event has already been handled by the Closure
 * system so we do not do the Closure pass twice for a bubbling event.
 * @param {Event} e  The IE browser event.
 * @return {boolean} True if the event object has been marked.
 * @private
 */
goog.events.isMarkedIeEvent_ = function(e) {
  return e.keyCode < 0 || e.returnValue != undefined;
};


/**
 * Counter to create unique event ids.
 * @private {number}
 */
goog.events.uniqueIdCounter_ = 0;


/**
 * Creates a unique event id.
 *
 * @param {string} identifier The identifier.
 * @return {string} A unique identifier.
 * @idGenerator
 */
goog.events.getUniqueId = function(identifier) {
  return identifier + '_' + goog.events.uniqueIdCounter_++;
};


/**
 * @param {EventTarget} src The source object.
 * @return {goog.events.ListenerMap} A listener map for the given
 *     source object, or null if none exists.
 * @private
 */
goog.events.getListenerMap_ = function(src) {
  var listenerMap = src[goog.events.LISTENER_MAP_PROP_];
  // IE serializes the property as well (e.g. when serializing outer
  // HTML). So we must check that the value is of the correct type.
  return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null;
};


/**
 * Expando property for listener function wrapper for Object with
 * handleEvent.
 * @const
 * @private
 */
goog.events.LISTENER_WRAPPER_PROP_ = '__closure_events_fn_' +
    ((Math.random() * 1e9) >>> 0);


/**
 * @param {Object|Function} listener The listener function or an
 *     object that contains handleEvent method.
 * @return {!Function} Either the original function or a function that
 *     calls obj.handleEvent. If the same listener is passed to this
 *     function more than once, the same function is guaranteed to be
 *     returned.
 * @private
 */
goog.events.wrapListener_ = function(listener) {
  goog.asserts.assert(listener, 'Listener can not be null.');

  if (goog.isFunction(listener)) {
    return listener;
  }

  goog.asserts.assert(
      listener.handleEvent, 'An object listener must have handleEvent method.');
  return listener[goog.events.LISTENER_WRAPPER_PROP_] ||
      (listener[goog.events.LISTENER_WRAPPER_PROP_] = function(e) {
        return listener.handleEvent(e);
      });
};


// Register the browser event handler as an entry point, so that
// it can be monitored for exception handling, etc.
goog.debug.entryPointRegistry.register(
    /**
     * @param {function(!Function): !Function} transformer The transforming
     *     function.
     */
    function(transformer) {
      goog.events.handleBrowserEvent_ = transformer(
          goog.events.handleBrowserEvent_);
    });

//javascript/closure/events/eventtarget.js
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A disposable implementation of a custom
 * listenable/event target. See also: documentation for
 * {@code goog.events.Listenable}.
 *
 * @author arv@google.com (Erik Arvidsson) [Original implementation]
 * @author pupius@google.com (Daniel Pupius) [Port to use goog.events]
 * @see ../demos/eventtarget.html
 * @see goog.events.Listenable
 */

goog.provide('goog.events.EventTarget');

goog.require('goog.Disposable');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.events');
goog.require('goog.events.Event');
goog.require('goog.events.Listenable');
goog.require('goog.events.ListenerMap');
goog.require('goog.object');



/**
 * An implementation of {@code goog.events.Listenable} with full W3C
 * EventTarget-like support (capture/bubble mechanism, stopping event
 * propagation, preventing default actions).
 *
 * You may subclass this class to turn your class into a Listenable.
 *
 * Unless propagation is stopped, an event dispatched by an
 * EventTarget will bubble to the parent returned by
 * {@code getParentEventTarget}. To set the parent, call
 * {@code setParentEventTarget}. Subclasses that don't support
 * changing the parent can override the setter to throw an error.
 *
 * Example usage:
 * <pre>
 *   var source = new goog.events.EventTarget();
 *   function handleEvent(e) {
 *     alert('Type: ' + e.type + '; Target: ' + e.target);
 *   }
 *   source.listen('foo', handleEvent);
 *   // Or: goog.events.listen(source, 'foo', handleEvent);
 *   ...
 *   source.dispatchEvent('foo');  // will call handleEvent
 *   ...
 *   source.unlisten('foo', handleEvent);
 *   // Or: goog.events.unlisten(source, 'foo', handleEvent);
 * </pre>
 *
 * @constructor
 * @extends {goog.Disposable}
 * @implements {goog.events.Listenable}
 */
goog.events.EventTarget = function() {
  goog.Disposable.call(this);

  /**
   * Maps of event type to an array of listeners.
   * @private {!goog.events.ListenerMap}
   */
  this.eventTargetListeners_ = new goog.events.ListenerMap(this);

  /**
   * The object to use for event.target. Useful when mixing in an
   * EventTarget to another object.
   * @private {!Object}
   */
  this.actualEventTarget_ = this;
};
goog.inherits(goog.events.EventTarget, goog.Disposable);
goog.events.Listenable.addImplementation(goog.events.EventTarget);


/**
 * An artificial cap on the number of ancestors you can have. This is mainly
 * for loop detection.
 * @const {number}
 * @private
 */
goog.events.EventTarget.MAX_ANCESTORS_ = 1000;


/**
 * Parent event target, used during event bubbling.
 *
 * TODO(chrishenry): Change this to goog.events.Listenable. This
 * currently breaks people who expect getParentEventTarget to return
 * goog.events.EventTarget.
 *
 * @type {goog.events.EventTarget}
 * @private
 */
goog.events.EventTarget.prototype.parentEventTarget_ = null;


/**
 * Returns the parent of this event target to use for bubbling.
 *
 * @return {goog.events.EventTarget} The parent EventTarget or null if
 *     there is no parent.
 * @override
 */
goog.events.EventTarget.prototype.getParentEventTarget = function() {
  return this.parentEventTarget_;
};


/**
 * Sets the parent of this event target to use for capture/bubble
 * mechanism.
 * @param {goog.events.EventTarget} parent Parent listenable (null if none).
 */
goog.events.EventTarget.prototype.setParentEventTarget = function(parent) {
  this.parentEventTarget_ = parent;
};


/**
 * Adds an event listener to the event target. The same handler can only be
 * added once per the type. Even if you add the same handler multiple times
 * using the same type then it will only be called once when the event is
 * dispatched.
 *
 * @param {string} type The type of the event to listen for.
 * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function
 *     to handle the event. The handler can also be an object that implements
 *     the handleEvent method which takes the event object as argument.
 * @param {boolean=} opt_capture In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase
 *     of the event.
 * @param {Object=} opt_handlerScope Object in whose scope to call
 *     the listener.
 * @deprecated Use {@code #listen} instead, when possible. Otherwise, use
 *     {@code goog.events.listen} if you are passing Object
 *     (instead of Function) as handler.
 */
goog.events.EventTarget.prototype.addEventListener = function(
    type, handler, opt_capture, opt_handlerScope) {
  goog.events.listen(this, type, handler, opt_capture, opt_handlerScope);
};


/**
 * Removes an event listener from the event target. The handler must be the
 * same object as the one added. If the handler has not been added then
 * nothing is done.
 *
 * @param {string} type The type of the event to listen for.
 * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function
 *     to handle the event. The handler can also be an object that implements
 *     the handleEvent method which takes the event object as argument.
 * @param {boolean=} opt_capture In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase
 *     of the event.
 * @param {Object=} opt_handlerScope Object in whose scope to call
 *     the listener.
 * @deprecated Use {@code #unlisten} instead, when possible. Otherwise, use
 *     {@code goog.events.unlisten} if you are passing Object
 *     (instead of Function) as handler.
 */
goog.events.EventTarget.prototype.removeEventListener = function(
    type, handler, opt_capture, opt_handlerScope) {
  goog.events.unlisten(this, type, handler, opt_capture, opt_handlerScope);
};


/** @override */
goog.events.EventTarget.prototype.dispatchEvent = function(e) {
  this.assertInitialized_();

  var ancestorsTree, ancestor = this.getParentEventTarget();
  if (ancestor) {
    ancestorsTree = [];
    var ancestorCount = 1;
    for (; ancestor; ancestor = ancestor.getParentEventTarget()) {
      ancestorsTree.push(ancestor);
      goog.asserts.assert(
          (++ancestorCount < goog.events.EventTarget.MAX_ANCESTORS_),
          'infinite loop');
    }
  }

  return goog.events.EventTarget.dispatchEventInternal_(
      this.actualEventTarget_, e, ancestorsTree);
};


/**
 * Removes listeners from this object.  Classes that extend EventTarget may
 * need to override this method in order to remove references to DOM Elements
 * and additional listeners.
 * @override
 */
goog.events.EventTarget.prototype.disposeInternal = function() {
  goog.events.EventTarget.superClass_.disposeInternal.call(this);

  this.removeAllListeners();
  this.parentEventTarget_ = null;
};


/** @override */
goog.events.EventTarget.prototype.listen = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  this.assertInitialized_();
  return this.eventTargetListeners_.add(
      String(type), listener, false /* callOnce */, opt_useCapture,
      opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.listenOnce = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  return this.eventTargetListeners_.add(
      String(type), listener, true /* callOnce */, opt_useCapture,
      opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.unlisten = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  return this.eventTargetListeners_.remove(
      String(type), listener, opt_useCapture, opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.unlistenByKey = function(key) {
  return this.eventTargetListeners_.removeByKey(key);
};


/** @override */
goog.events.EventTarget.prototype.removeAllListeners = function(opt_type) {
  // TODO(chrishenry): Previously, removeAllListeners can be called on
  // uninitialized EventTarget, so we preserve that behavior. We
  // should remove this when usages that rely on that fact are purged.
  if (!this.eventTargetListeners_) {
    return 0;
  }
  return this.eventTargetListeners_.removeAll(opt_type);
};


/** @override */
goog.events.EventTarget.prototype.fireListeners = function(
    type, capture, eventObject) {
  // TODO(chrishenry): Original code avoids array creation when there
  // is no listener, so we do the same. If this optimization turns
  // out to be not required, we can replace this with
  // getListeners(type, capture) instead, which is simpler.
  var listenerArray = this.eventTargetListeners_.listeners[String(type)];
  if (!listenerArray) {
    return true;
  }
  listenerArray = goog.array.clone(listenerArray);

  var rv = true;
  for (var i = 0; i < listenerArray.length; ++i) {
    var listener = listenerArray[i];
    // We might not have a listener if the listener was removed.
    if (listener && !listener.removed && listener.capture == capture) {
      var listenerFn = listener.listener;
      var listenerHandler = listener.handler || listener.src;

      if (listener.callOnce) {
        this.unlistenByKey(listener);
      }
      rv = listenerFn.call(listenerHandler, eventObject) !== false && rv;
    }
  }

  return rv && eventObject.returnValue_ != false;
};


/** @override */
goog.events.EventTarget.prototype.getListeners = function(type, capture) {
  return this.eventTargetListeners_.getListeners(String(type), capture);
};


/** @override */
goog.events.EventTarget.prototype.getListener = function(
    type, listener, capture, opt_listenerScope) {
  return this.eventTargetListeners_.getListener(
      String(type), listener, capture, opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.hasListener = function(
    opt_type, opt_capture) {
  var id = goog.isDef(opt_type) ? String(opt_type) : undefined;
  return this.eventTargetListeners_.hasListener(id, opt_capture);
};


/**
 * Sets the target to be used for {@code event.target} when firing
 * event. Mainly used for testing. For example, see
 * {@code goog.testing.events.mixinListenable}.
 * @param {!Object} target The target.
 */
goog.events.EventTarget.prototype.setTargetForTesting = function(target) {
  this.actualEventTarget_ = target;
};


/**
 * Asserts that the event target instance is initialized properly.
 * @private
 */
goog.events.EventTarget.prototype.assertInitialized_ = function() {
  goog.asserts.assert(
      this.eventTargetListeners_,
      'Event target is not initialized. Did you call the superclass ' +
      '(goog.events.EventTarget) constructor?');
};


/**
 * Dispatches the given event on the ancestorsTree.
 *
 * @param {!Object} target The target to dispatch on.
 * @param {goog.events.Event|Object|string} e The event object.
 * @param {Array.<goog.events.Listenable>=} opt_ancestorsTree The ancestors
 *     tree of the target, in reverse order from the closest ancestor
 *     to the root event target. May be null if the target has no ancestor.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the listeners returns false) this will also return false.
 * @private
 */
goog.events.EventTarget.dispatchEventInternal_ = function(
    target, e, opt_ancestorsTree) {
  var type = e.type || /** @type {string} */ (e);

  // If accepting a string or object, create a custom event object so that
  // preventDefault and stopPropagation work with the event.
  if (goog.isString(e)) {
    e = new goog.events.Event(e, target);
  } else if (!(e instanceof goog.events.Event)) {
    var oldEvent = e;
    e = new goog.events.Event(type, target);
    goog.object.extend(e, oldEvent);
  } else {
    e.target = e.target || target;
  }

  var rv = true, currentTarget;

  // Executes all capture listeners on the ancestors, if any.
  if (opt_ancestorsTree) {
    for (var i = opt_ancestorsTree.length - 1; !e.propagationStopped_ && i >= 0;
         i--) {
      currentTarget = e.currentTarget = opt_ancestorsTree[i];
      rv = currentTarget.fireListeners(type, true, e) && rv;
    }
  }

  // Executes capture and bubble listeners on the target.
  if (!e.propagationStopped_) {
    currentTarget = e.currentTarget = target;
    rv = currentTarget.fireListeners(type, true, e) && rv;
    if (!e.propagationStopped_) {
      rv = currentTarget.fireListeners(type, false, e) && rv;
    }
  }

  // Executes all bubble listeners on the ancestors, if any.
  if (opt_ancestorsTree) {
    for (i = 0; !e.propagationStopped_ && i < opt_ancestorsTree.length; i++) {
      currentTarget = e.currentTarget = opt_ancestorsTree[i];
      rv = currentTarget.fireListeners(type, false, e) && rv;
    }
  }

  return rv;
};

//javascript/closure/json/json.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview JSON utility functions.
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.json');
goog.provide('goog.json.Replacer');
goog.provide('goog.json.Reviver');
goog.provide('goog.json.Serializer');


/**
 * Tests if a string is an invalid JSON string. This only ensures that we are
 * not using any invalid characters
 * @param {string} s The string to test.
 * @return {boolean} True if the input is a valid JSON string.
 * @private
 */
goog.json.isValid_ = function(s) {
  // All empty whitespace is not valid.
  if (/^\s*$/.test(s)) {
    return false;
  }

  // This is taken from http://www.json.org/json2.js which is released to the
  // public domain.
  // Changes: We dissallow \u2028 Line separator and \u2029 Paragraph separator
  // inside strings.  We also treat \u2028 and \u2029 as whitespace which they
  // are in the RFC but IE and Safari does not match \s to these so we need to
  // include them in the reg exps in all places where whitespace is allowed.
  // We allowed \x7f inside strings because some tools don't escape it,
  // e.g. http://www.json.org/java/org/json/JSONObject.java

  // Parsing happens in three stages. In the first stage, we run the text
  // against regular expressions that look for non-JSON patterns. We are
  // especially concerned with '()' and 'new' because they can cause invocation,
  // and '=' because it can cause mutation. But just to be safe, we want to
  // reject all unexpected forms.

  // We split the first stage into 4 regexp operations in order to work around
  // crippling inefficiencies in IE's and Safari's regexp engines. First we
  // replace all backslash pairs with '@' (a non-JSON character). Second, we
  // replace all simple value tokens with ']' characters. Third, we delete all
  // open brackets that follow a colon or comma or that begin the text. Finally,
  // we look to see that the remaining characters are only whitespace or ']' or
  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

  // Don't make these static since they have the global flag.
  var backslashesRe = /\\["\\\/bfnrtu]/g;
  var simpleValuesRe =
      /"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  var openBracketsRe = /(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g;
  var remainderRe = /^[\],:{}\s\u2028\u2029]*$/;

  return remainderRe.test(s.replace(backslashesRe, '@').
      replace(simpleValuesRe, ']').
      replace(openBracketsRe, ''));
};


/**
 * Parses a JSON string and returns the result. This throws an exception if
 * the string is an invalid JSON string.
 *
 * Note that this is very slow on large strings. If you trust the source of
 * the string then you should use unsafeParse instead.
 *
 * @param {*} s The JSON string to parse.
 * @throws Error if s is invalid JSON.
 * @return {Object} The object generated from the JSON string, or null.
 */
goog.json.parse = function(s) {
  var o = String(s);
  if (goog.json.isValid_(o)) {
    /** @preserveTry */
    try {
      return /** @type {Object} */ (eval('(' + o + ')'));
    } catch (ex) {
    }
  }
  throw Error('Invalid JSON string: ' + o);
};


/**
 * Parses a JSON string and returns the result. This uses eval so it is open
 * to security issues and it should only be used if you trust the source.
 *
 * @param {string} s The JSON string to parse.
 * @return {Object} The object generated from the JSON string.
 */
goog.json.unsafeParse = function(s) {
  return /** @type {Object} */ (eval('(' + s + ')'));
};


/**
 * JSON replacer, as defined in Section 15.12.3 of the ES5 spec.
 * @see http://ecma-international.org/ecma-262/5.1/#sec-15.12.3
 *
 * TODO(nicksantos): Array should also be a valid replacer.
 *
 * @typedef {function(this:Object, string, *): *}
 */
goog.json.Replacer;


/**
 * JSON reviver, as defined in Section 15.12.2 of the ES5 spec.
 * @see http://ecma-international.org/ecma-262/5.1/#sec-15.12.3
 *
 * @typedef {function(this:Object, string, *): *}
 */
goog.json.Reviver;


/**
 * Serializes an object or a value to a JSON string.
 *
 * @param {*} object The object to serialize.
 * @param {?goog.json.Replacer=} opt_replacer A replacer function
 *     called for each (key, value) pair that determines how the value
 *     should be serialized. By defult, this just returns the value
 *     and allows default serialization to kick in.
 * @throws Error if there are loops in the object graph.
 * @return {string} A JSON string representation of the input.
 */
goog.json.serialize = function(object, opt_replacer) {
  // NOTE(nicksantos): Currently, we never use JSON.stringify.
  //
  // The last time I evaluated this, JSON.stringify had subtle bugs and behavior
  // differences on all browsers, and the performance win was not large enough
  // to justify all the issues. This may change in the future as browser
  // implementations get better.
  //
  // assertSerialize in json_test contains if branches for the cases
  // that fail.
  return new goog.json.Serializer(opt_replacer).serialize(object);
};



/**
 * Class that is used to serialize JSON objects to a string.
 * @param {?goog.json.Replacer=} opt_replacer Replacer.
 * @constructor
 */
goog.json.Serializer = function(opt_replacer) {
  /**
   * @type {goog.json.Replacer|null|undefined}
   * @private
   */
  this.replacer_ = opt_replacer;
};


/**
 * Serializes an object or a value to a JSON string.
 *
 * @param {*} object The object to serialize.
 * @throws Error if there are loops in the object graph.
 * @return {string} A JSON string representation of the input.
 */
goog.json.Serializer.prototype.serialize = function(object) {
  var sb = [];
  this.serialize_(object, sb);
  return sb.join('');
};


/**
 * Serializes a generic value to a JSON string
 * @private
 * @param {*} object The object to serialize.
 * @param {Array} sb Array used as a string builder.
 * @throws Error if there are loops in the object graph.
 */
goog.json.Serializer.prototype.serialize_ = function(object, sb) {
  switch (typeof object) {
    case 'string':
      this.serializeString_(/** @type {string} */ (object), sb);
      break;
    case 'number':
      this.serializeNumber_(/** @type {number} */ (object), sb);
      break;
    case 'boolean':
      sb.push(object);
      break;
    case 'undefined':
      sb.push('null');
      break;
    case 'object':
      if (object == null) {
        sb.push('null');
        break;
      }
      if (goog.isArray(object)) {
        this.serializeArray(/** @type {!Array} */ (object), sb);
        break;
      }
      // should we allow new String, new Number and new Boolean to be treated
      // as string, number and boolean? Most implementations do not and the
      // need is not very big
      this.serializeObject_(/** @type {Object} */ (object), sb);
      break;
    case 'function':
      // Skip functions.
      // TODO(ptucker) Should we return something here?
      break;
    default:
      throw Error('Unknown type: ' + typeof object);
  }
};


/**
 * Character mappings used internally for goog.string.quote
 * @private
 * @type {!Object}
 */
goog.json.Serializer.charToJsonCharCache_ = {
  '\"': '\\"',
  '\\': '\\\\',
  '/': '\\/',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',

  '\x0B': '\\u000b' // '\v' is not supported in JScript
};


/**
 * Regular expression used to match characters that need to be replaced.
 * The S60 browser has a bug where unicode characters are not matched by
 * regular expressions. The condition below detects such behaviour and
 * adjusts the regular expression accordingly.
 * @private
 * @type {!RegExp}
 */
goog.json.Serializer.charsToReplace_ = /\uffff/.test('\uffff') ?
    /[\\\"\x00-\x1f\x7f-\uffff]/g : /[\\\"\x00-\x1f\x7f-\xff]/g;


/**
 * Serializes a string to a JSON string
 * @private
 * @param {string} s The string to serialize.
 * @param {Array} sb Array used as a string builder.
 */
goog.json.Serializer.prototype.serializeString_ = function(s, sb) {
  // The official JSON implementation does not work with international
  // characters.
  sb.push('"', s.replace(goog.json.Serializer.charsToReplace_, function(c) {
    // caching the result improves performance by a factor 2-3
    if (c in goog.json.Serializer.charToJsonCharCache_) {
      return goog.json.Serializer.charToJsonCharCache_[c];
    }

    var cc = c.charCodeAt(0);
    var rv = '\\u';
    if (cc < 16) {
      rv += '000';
    } else if (cc < 256) {
      rv += '00';
    } else if (cc < 4096) { // \u1000
      rv += '0';
    }
    return goog.json.Serializer.charToJsonCharCache_[c] = rv + cc.toString(16);
  }), '"');
};


/**
 * Serializes a number to a JSON string
 * @private
 * @param {number} n The number to serialize.
 * @param {Array} sb Array used as a string builder.
 */
goog.json.Serializer.prototype.serializeNumber_ = function(n, sb) {
  sb.push(isFinite(n) && !isNaN(n) ? n : 'null');
};


/**
 * Serializes an array to a JSON string
 * @param {Array} arr The array to serialize.
 * @param {Array} sb Array used as a string builder.
 * @protected
 */
goog.json.Serializer.prototype.serializeArray = function(arr, sb) {
  var l = arr.length;
  sb.push('[');
  var sep = '';
  for (var i = 0; i < l; i++) {
    sb.push(sep);

    var value = arr[i];
    this.serialize_(
        this.replacer_ ? this.replacer_.call(arr, String(i), value) : value,
        sb);

    sep = ',';
  }
  sb.push(']');
};


/**
 * Serializes an object to a JSON string
 * @private
 * @param {Object} obj The object to serialize.
 * @param {Array} sb Array used as a string builder.
 */
goog.json.Serializer.prototype.serializeObject_ = function(obj, sb) {
  sb.push('{');
  var sep = '';
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var value = obj[key];
      // Skip functions.
      // TODO(ptucker) Should we return something for function properties?
      if (typeof value != 'function') {
        sb.push(sep);
        this.serializeString_(key, sb);
        sb.push(':');

        this.serialize_(
            this.replacer_ ? this.replacer_.call(obj, key, value) : value,
            sb);

        sep = ',';
      }
    }
  }
  sb.push('}');
};

//javascript/closure/log/log.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Basic strippable logging definitions.
 * @see http://go/closurelogging
 *
 * @author johnlenz@google.com (John Lenz)
 */

goog.provide('goog.log');
goog.provide('goog.log.Level');
goog.provide('goog.log.LogRecord');
goog.provide('goog.log.Logger');

goog.require('goog.debug');
goog.require('goog.debug.LogRecord');
goog.require('goog.debug.Logger');


/** @define {boolean} Whether logging is enabled. */
goog.define('goog.log.ENABLED', goog.debug.LOGGING_ENABLED);



/**
 * @constructor
 * @final
 */
goog.log.Logger = goog.debug.Logger;



/**
 * @constructor
 * @final
 */
goog.log.Level = goog.debug.Logger.Level;



/**
 * @constructor
 * @final
 */
goog.log.LogRecord = goog.debug.LogRecord;


/**
 * Finds or creates a logger for a named subsystem. If a logger has already been
 * created with the given name it is returned. Otherwise a new logger is
 * created. If a new logger is created its log level will be configured based
 * on the goog.debug.LogManager configuration and it will configured to also
 * send logging output to its parent's handlers.
 * @see goog.debug.LogManager
 *
 * @param {string} name A name for the logger. This should be a dot-separated
 *     name and should normally be based on the package name or class name of
 *     the subsystem, such as goog.net.BrowserChannel.
 * @param {goog.log.Level=} opt_level If provided, override the
 *     default logging level with the provided level.
 * @return {goog.log.Logger} The named logger or null if logging is disabled.
 */
goog.log.getLogger = function(name, opt_level) {
  if (goog.log.ENABLED) {
    var logger = goog.debug.Logger.getLogger(name);
    if (opt_level && logger) {
      logger.setLevel(opt_level);
    }
    return logger;
  } else {
    return null;
  }
};


// TODO(johnlenz): try to tighten the types to these functions.
/**
 * Adds a handler to the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {goog.log.Logger} logger
 * @param {Function} handler Handler function to add.
 */
goog.log.addHandler = function(logger, handler) {
  if (goog.log.ENABLED && logger) {
    logger.addHandler(handler);
  }
};


/**
 * Removes a handler from the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {goog.log.Logger} logger
 * @param {Function} handler Handler function to remove.
 * @return {boolean} Whether the handler was removed.
 */
goog.log.removeHandler = function(logger, handler) {
  if (goog.log.ENABLED && logger) {
    return logger.removeHandler(handler);
  } else {
    return false;
  }
};


/**
 * Logs a message. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * @param {goog.log.Logger} logger
 * @param {goog.log.Level} level One of the level identifiers.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error|Object=} opt_exception An exception associated with the
 *     message.
 */
goog.log.log = function(logger, level, msg, opt_exception) {
  if (goog.log.ENABLED && logger) {
    logger.log(level, msg, opt_exception);
  }
};


/**
 * Logs a message at the Level.SEVERE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.log.Logger} logger
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.log.error = function(logger, msg, opt_exception) {
  if (goog.log.ENABLED && logger) {
    logger.severe(msg, opt_exception);
  }
};


/**
 * Logs a message at the Level.WARNING level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.log.Logger} logger
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.log.warning = function(logger, msg, opt_exception) {
  if (goog.log.ENABLED && logger) {
    logger.warning(msg, opt_exception);
  }
};


/**
 * Logs a message at the Level.INFO level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.log.Logger} logger
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.log.info = function(logger, msg, opt_exception) {
  if (goog.log.ENABLED && logger) {
    logger.info(msg, opt_exception);
  }
};


/**
 * Logs a message at the Level.Fine level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.log.Logger} logger
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.log.fine = function(logger, msg, opt_exception) {
  if (goog.log.ENABLED && logger) {
    logger.fine(msg, opt_exception);
  }
};

//javascript/closure/timer/timer.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A timer class to which other classes and objects can
 * listen on.  This is only an abstraction above setInterval.
 *
 * @author pupius@google.com (Daniel Pupius)
 * @see ../demos/timers.html
 */

goog.provide('goog.Timer');

goog.require('goog.events.EventTarget');



/**
 * Class for handling timing events.
 *
 * @param {number=} opt_interval Number of ms between ticks (Default: 1ms).
 * @param {Object=} opt_timerObject  An object that has setTimeout, setInterval,
 *     clearTimeout and clearInterval (eg Window).
 * @constructor
 * @extends {goog.events.EventTarget}
 */
goog.Timer = function(opt_interval, opt_timerObject) {
  goog.events.EventTarget.call(this);

  /**
   * Number of ms between ticks
   * @type {number}
   * @private
   */
  this.interval_ = opt_interval || 1;

  /**
   * An object that implements setTimout, setInterval, clearTimeout and
   * clearInterval. We default to the window object. Changing this on
   * goog.Timer.prototype changes the object for all timer instances which can
   * be useful if your environment has some other implementation of timers than
   * the window object.
   * @type {Object}
   * @private
   */
  this.timerObject_ = opt_timerObject || goog.Timer.defaultTimerObject;

  /**
   * Cached tick_ bound to the object for later use in the timer.
   * @type {Function}
   * @private
   */
  this.boundTick_ = goog.bind(this.tick_, this);

  /**
   * Firefox browser often fires the timer event sooner
   * (sometimes MUCH sooner) than the requested timeout. So we
   * compare the time to when the event was last fired, and
   * reschedule if appropriate. See also goog.Timer.intervalScale
   * @type {number}
   * @private
   */
  this.last_ = goog.now();
};
goog.inherits(goog.Timer, goog.events.EventTarget);


/**
 * Maximum timeout value.
 *
 * Timeout values too big to fit into a signed 32-bit integer may cause
 * overflow in FF, Safari, and Chrome, resulting in the timeout being
 * scheduled immediately.  It makes more sense simply not to schedule these
 * timeouts, since 24.8 days is beyond a reasonable expectation for the
 * browser to stay open.
 *
 * @type {number}
 * @private
 */
goog.Timer.MAX_TIMEOUT_ = 2147483647;


/**
 * Whether this timer is enabled
 * @type {boolean}
 */
goog.Timer.prototype.enabled = false;


/**
 * An object that implements setTimout, setInterval, clearTimeout and
 * clearInterval. We default to the global object. Changing
 * goog.Timer.defaultTimerObject changes the object for all timer instances
 * which can be useful if your environment has some other implementation of
 * timers you'd like to use.
 * @type {Object}
 */
goog.Timer.defaultTimerObject = goog.global;


/**
 * A variable that controls the timer error correction. If the
 * timer is called before the requested interval times
 * intervalScale, which often happens on mozilla, the timer is
 * rescheduled. See also this.last_
 * @type {number}
 */
goog.Timer.intervalScale = 0.8;


/**
 * Variable for storing the result of setInterval
 * @type {?number}
 * @private
 */
goog.Timer.prototype.timer_ = null;


/**
 * Gets the interval of the timer.
 * @return {number} interval Number of ms between ticks.
 */
goog.Timer.prototype.getInterval = function() {
  return this.interval_;
};


/**
 * Sets the interval of the timer.
 * @param {number} interval Number of ms between ticks.
 */
goog.Timer.prototype.setInterval = function(interval) {
  this.interval_ = interval;
  if (this.timer_ && this.enabled) {
    // Stop and then start the timer to reset the interval.
    this.stop();
    this.start();
  } else if (this.timer_) {
    this.stop();
  }
};


/**
 * Callback for the setTimeout used by the timer
 * @private
 */
goog.Timer.prototype.tick_ = function() {
  if (this.enabled) {
    var elapsed = goog.now() - this.last_;
    if (elapsed > 0 &&
        elapsed < this.interval_ * goog.Timer.intervalScale) {
      this.timer_ = this.timerObject_.setTimeout(this.boundTick_,
          this.interval_ - elapsed);
      return;
    }

    // Prevents setInterval from registering a duplicate timeout when called
    // in the timer event handler.
    if (this.timer_) {
      this.timerObject_.clearTimeout(this.timer_);
      this.timer_ = null;
    }

    this.dispatchTick();
    // The timer could be stopped in the timer event handler.
    if (this.enabled) {
      this.timer_ = this.timerObject_.setTimeout(this.boundTick_,
          this.interval_);
      this.last_ = goog.now();
    }
  }
};


/**
 * Dispatches the TICK event. This is its own method so subclasses can override.
 */
goog.Timer.prototype.dispatchTick = function() {
  this.dispatchEvent(goog.Timer.TICK);
};


/**
 * Starts the timer.
 */
goog.Timer.prototype.start = function() {
  this.enabled = true;

  // If there is no interval already registered, start it now
  if (!this.timer_) {
    // IMPORTANT!
    // window.setInterval in FireFox has a bug - it fires based on
    // absolute time, rather than on relative time. What this means
    // is that if a computer is sleeping/hibernating for 24 hours
    // and the timer interval was configured to fire every 1000ms,
    // then after the PC wakes up the timer will fire, in rapid
    // succession, 3600*24 times.
    // This bug is described here and is already fixed, but it will
    // take time to propagate, so for now I am switching this over
    // to setTimeout logic.
    //     https://bugzilla.mozilla.org/show_bug.cgi?id=376643
    //
    this.timer_ = this.timerObject_.setTimeout(this.boundTick_,
        this.interval_);
    this.last_ = goog.now();
  }
};


/**
 * Stops the timer.
 */
goog.Timer.prototype.stop = function() {
  this.enabled = false;
  if (this.timer_) {
    this.timerObject_.clearTimeout(this.timer_);
    this.timer_ = null;
  }
};


/** @override */
goog.Timer.prototype.disposeInternal = function() {
  goog.Timer.superClass_.disposeInternal.call(this);
  this.stop();
  delete this.timerObject_;
};


/**
 * Constant for the timer's event type
 * @type {string}
 */
goog.Timer.TICK = 'tick';


/**
 * Calls the given function once, after the optional pause.
 *
 * The function is always called asynchronously, even if the delay is 0. This
 * is a common trick to schedule a function to run after a batch of browser
 * event processing.
 *
 * @param {function(this:SCOPE)|{handleEvent:function()}|null} listener Function
 *     or object that has a handleEvent method.
 * @param {number=} opt_delay Milliseconds to wait; default is 0.
 * @param {SCOPE=} opt_handler Object in whose scope to call the listener.
 * @return {number} A handle to the timer ID.
 * @template SCOPE
 */
goog.Timer.callOnce = function(listener, opt_delay, opt_handler) {
  if (goog.isFunction(listener)) {
    if (opt_handler) {
      listener = goog.bind(listener, opt_handler);
    }
  } else if (listener && typeof listener.handleEvent == 'function') {
    // using typeof to prevent strict js warning
    listener = goog.bind(listener.handleEvent, listener);
  } else {
    throw Error('Invalid listener argument');
  }

  if (opt_delay > goog.Timer.MAX_TIMEOUT_) {
    // Timeouts greater than MAX_INT return immediately due to integer
    // overflow in many browsers.  Since MAX_INT is 24.8 days, just don't
    // schedule anything at all.
    return -1;
  } else {
    return goog.Timer.defaultTimerObject.setTimeout(
        listener, opt_delay || 0);
  }
};


/**
 * Clears a timeout initiated by callOnce
 * @param {?number} timerId a timer ID.
 */
goog.Timer.clear = function(timerId) {
  goog.Timer.defaultTimerObject.clearTimeout(timerId);
};

//javascript/closure/uri/utils.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Simple utilities for dealing with URI strings.
 *
 * This is intended to be a lightweight alternative to constructing goog.Uri
 * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless
 * of how much of its functionality you use, this is designed to be a set of
 * mostly-independent utilities so that the compiler includes only what is
 * necessary for the task.  Estimated savings of porting is 5k pre-gzip and
 * 1.5k post-gzip.  To ensure the savings remain, future developers should
 * avoid adding new functionality to existing functions, but instead create
 * new ones and factor out shared code.
 *
 * Many of these utilities have limited functionality, tailored to common
 * cases.  The query parameter utilities assume that the parameter keys are
 * already encoded, since most keys are compile-time alphanumeric strings.  The
 * query parameter mutation utilities also do not tolerate fragment identifiers.
 *
 * By design, these functions can be slower than goog.Uri equivalents.
 * Repeated calls to some of functions may be quadratic in behavior for IE,
 * although the effect is somewhat limited given the 2kb limit.
 *
 * One advantage of the limited functionality here is that this approach is
 * less sensitive to differences in URI encodings than goog.Uri, since these
 * functions modify the strings in place, rather than decoding and
 * re-encoding.
 *
 * Uses features of RFC 3986 for parsing/formatting URIs:
 *   http://www.ietf.org/rfc/rfc3986.txt
 *
 * @author gboyer@google.com (Garrett Boyer) - The "lightened" design.
 * @author msamuel@google.com (Mike Samuel) - Domain knowledge and regexes.
 */

goog.provide('goog.uri.utils');
goog.provide('goog.uri.utils.ComponentIndex');
goog.provide('goog.uri.utils.QueryArray');
goog.provide('goog.uri.utils.QueryValue');
goog.provide('goog.uri.utils.StandardQueryParam');

goog.require('goog.asserts');
goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * Character codes inlined to avoid object allocations due to charCode.
 * @enum {number}
 * @private
 */
goog.uri.utils.CharCode_ = {
  AMPERSAND: 38,
  EQUAL: 61,
  HASH: 35,
  QUESTION: 63
};


/**
 * Builds a URI string from already-encoded parts.
 *
 * No encoding is performed.  Any component may be omitted as either null or
 * undefined.
 *
 * @param {?string=} opt_scheme The scheme such as 'http'.
 * @param {?string=} opt_userInfo The user name before the '@'.
 * @param {?string=} opt_domain The domain such as 'www.google.com', already
 *     URI-encoded.
 * @param {(string|number|null)=} opt_port The port number.
 * @param {?string=} opt_path The path, already URI-encoded.  If it is not
 *     empty, it must begin with a slash.
 * @param {?string=} opt_queryData The URI-encoded query data.
 * @param {?string=} opt_fragment The URI-encoded fragment identifier.
 * @return {string} The fully combined URI.
 */
goog.uri.utils.buildFromEncodedParts = function(opt_scheme, opt_userInfo,
    opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
  var out = '';

  if (opt_scheme) {
    out += opt_scheme + ':';
  }

  if (opt_domain) {
    out += '//';

    if (opt_userInfo) {
      out += opt_userInfo + '@';
    }

    out += opt_domain;

    if (opt_port) {
      out += ':' + opt_port;
    }
  }

  if (opt_path) {
    out += opt_path;
  }

  if (opt_queryData) {
    out += '?' + opt_queryData;
  }

  if (opt_fragment) {
    out += '#' + opt_fragment;
  }

  return out;
};


/**
 * A regular expression for breaking a URI into its component parts.
 *
 * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B
 * As the "first-match-wins" algorithm is identical to the "greedy"
 * disambiguation method used by POSIX regular expressions, it is natural and
 * commonplace to use a regular expression for parsing the potential five
 * components of a URI reference.
 *
 * The following line is the regular expression for breaking-down a
 * well-formed URI reference into its components.
 *
 * <pre>
 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
 *  12            3  4          5       6  7        8 9
 * </pre>
 *
 * The numbers in the second line above are only to assist readability; they
 * indicate the reference points for each subexpression (i.e., each paired
 * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
 * For example, matching the above expression to
 * <pre>
 *     http://www.ics.uci.edu/pub/ietf/uri/#Related
 * </pre>
 * results in the following subexpression matches:
 * <pre>
 *    $1 = http:
 *    $2 = http
 *    $3 = //www.ics.uci.edu
 *    $4 = www.ics.uci.edu
 *    $5 = /pub/ietf/uri/
 *    $6 = <undefined>
 *    $7 = <undefined>
 *    $8 = #Related
 *    $9 = Related
 * </pre>
 * where <undefined> indicates that the component is not present, as is the
 * case for the query component in the above example. Therefore, we can
 * determine the value of the five components as
 * <pre>
 *    scheme    = $2
 *    authority = $4
 *    path      = $5
 *    query     = $7
 *    fragment  = $9
 * </pre>
 *
 * The regular expression has been modified slightly to expose the
 * userInfo, domain, and port separately from the authority.
 * The modified version yields
 * <pre>
 *    $1 = http              scheme
 *    $2 = <undefined>       userInfo -\
 *    $3 = www.ics.uci.edu   domain     | authority
 *    $4 = <undefined>       port     -/
 *    $5 = /pub/ietf/uri/    path
 *    $6 = <undefined>       query without ?
 *    $7 = Related           fragment without #
 * </pre>
 * @type {!RegExp}
 * @private
 */
goog.uri.utils.splitRe_ = new RegExp(
    '^' +
    '(?:' +
      '([^:/?#.]+)' +                     // scheme - ignore special characters
                                          // used by other URL parts such as :,
                                          // ?, /, #, and .
    ':)?' +
    '(?://' +
      '(?:([^/?#]*)@)?' +                 // userInfo
      '([^/#?]*?)' +                      // domain
      '(?::([0-9]+))?' +                  // port
      '(?=[/#?]|$)' +                     // authority-terminating character
    ')?' +
    '([^?#]+)?' +                         // path
    '(?:\\?([^#]*))?' +                   // query
    '(?:#(.*))?' +                        // fragment
    '$');


/**
 * The index of each URI component in the return value of goog.uri.utils.split.
 * @enum {number}
 */
goog.uri.utils.ComponentIndex = {
  SCHEME: 1,
  USER_INFO: 2,
  DOMAIN: 3,
  PORT: 4,
  PATH: 5,
  QUERY_DATA: 6,
  FRAGMENT: 7
};


/**
 * Splits a URI into its component parts.
 *
 * Each component can be accessed via the component indices; for example:
 * <pre>
 * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
 * </pre>
 *
 * @param {string} uri The URI string to examine.
 * @return {!Array.<string|undefined>} Each component still URI-encoded.
 *     Each component that is present will contain the encoded value, whereas
 *     components that are not present will be undefined or empty, depending
 *     on the browser's regular expression implementation.  Never null, since
 *     arbitrary strings may still look like path names.
 */
goog.uri.utils.split = function(uri) {
  goog.uri.utils.phishingProtection_();

  // See @return comment -- never null.
  return /** @type {!Array.<string|undefined>} */ (
      uri.match(goog.uri.utils.splitRe_));
};


/**
 * Safari has a nasty bug where if you have an http URL with a username, e.g.,
 * http://evil.com%2F@google.com/
 * Safari will report that window.location.href is
 * http://evil.com/google.com/
 * so that anyone who tries to parse the domain of that URL will get
 * the wrong domain. We've seen exploits where people use this to trick
 * Safari into loading resources from evil domains.
 *
 * To work around this, we run a little "Safari phishing check", and throw
 * an exception if we see this happening.
 *
 * There is no convenient place to put this check. We apply it to
 * anyone doing URI parsing on Webkit. We're not happy about this, but
 * it fixes the problem.
 *
 * This should be removed once Safari fixes their bug.
 *
 * Exploit reported by Masato Kinugawa.
 *
 * @type {boolean}
 * @private
 */
goog.uri.utils.needsPhishingProtection_ = goog.userAgent.WEBKIT;


/**
 * Check to see if the user is being phished.
 * @private
 */
goog.uri.utils.phishingProtection_ = function() {
  if (goog.uri.utils.needsPhishingProtection_) {
    // Turn protection off, so that we don't recurse.
    goog.uri.utils.needsPhishingProtection_ = false;

    // Use quoted access, just in case the user isn't using location externs.
    var location = goog.global['location'];
    if (location) {
      var href = location['href'];
      if (href) {
        var domain = goog.uri.utils.getDomain(href);
        if (domain && domain != location['hostname']) {
          // Phishing attack
          goog.uri.utils.needsPhishingProtection_ = true;
          throw Error();
        }
      }
    }
  }
};


/**
 * @param {?string} uri A possibly null string.
 * @return {?string} The string URI-decoded, or null if uri is null.
 * @private
 */
goog.uri.utils.decodeIfPossible_ = function(uri) {
  return uri && decodeURIComponent(uri);
};


/**
 * Gets a URI component by index.
 *
 * It is preferred to use the getPathEncoded() variety of functions ahead,
 * since they are more readable.
 *
 * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.
 * @param {string} uri The URI to examine.
 * @return {?string} The still-encoded component, or null if the component
 *     is not present.
 * @private
 */
goog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {
  // Convert undefined, null, and empty string into null.
  return goog.uri.utils.split(uri)[componentIndex] || null;
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The protocol or scheme, or null if none.  Does not
 *     include trailing colons or slashes.
 */
goog.uri.utils.getScheme = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.SCHEME, uri);
};


/**
 * Gets the effective scheme for the URL.  If the URL is relative then the
 * scheme is derived from the page's location.
 * @param {string} uri The URI to examine.
 * @return {string} The protocol or scheme, always lower case.
 */
goog.uri.utils.getEffectiveScheme = function(uri) {
  var scheme = goog.uri.utils.getScheme(uri);
  if (!scheme && self.location) {
    var protocol = self.location.protocol;
    scheme = protocol.substr(0, protocol.length - 1);
  }
  // NOTE: When called from a web worker in Firefox 3.5, location maybe null.
  // All other browsers with web workers support self.location from the worker.
  return scheme ? scheme.toLowerCase() : '';
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The user name still encoded, or null if none.
 */
goog.uri.utils.getUserInfoEncoded = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.USER_INFO, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded user info, or null if none.
 */
goog.uri.utils.getUserInfo = function(uri) {
  return goog.uri.utils.decodeIfPossible_(
      goog.uri.utils.getUserInfoEncoded(uri));
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The domain name still encoded, or null if none.
 */
goog.uri.utils.getDomainEncoded = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.DOMAIN, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded domain, or null if none.
 */
goog.uri.utils.getDomain = function(uri) {
  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getDomainEncoded(uri));
};


/**
 * @param {string} uri The URI to examine.
 * @return {?number} The port number, or null if none.
 */
goog.uri.utils.getPort = function(uri) {
  // Coerce to a number.  If the result of getComponentByIndex_ is null or
  // non-numeric, the number coersion yields NaN.  This will then return
  // null for all non-numeric cases (though also zero, which isn't a relevant
  // port number).
  return Number(goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.PORT, uri)) || null;
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The path still encoded, or null if none. Includes the
 *     leading slash, if any.
 */
goog.uri.utils.getPathEncoded = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.PATH, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded path, or null if none.  Includes the leading
 *     slash, if any.
 */
goog.uri.utils.getPath = function(uri) {
  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getPathEncoded(uri));
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The query data still encoded, or null if none.  Does not
 *     include the question mark itself.
 */
goog.uri.utils.getQueryData = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The fragment identifier, or null if none.  Does not
 *     include the hash mark itself.
 */
goog.uri.utils.getFragmentEncoded = function(uri) {
  // The hash mark may not appear in any other part of the URL.
  var hashIndex = uri.indexOf('#');
  return hashIndex < 0 ? null : uri.substr(hashIndex + 1);
};


/**
 * @param {string} uri The URI to examine.
 * @param {?string} fragment The encoded fragment identifier, or null if none.
 *     Does not include the hash mark itself.
 * @return {string} The URI with the fragment set.
 */
goog.uri.utils.setFragmentEncoded = function(uri, fragment) {
  return goog.uri.utils.removeFragment(uri) + (fragment ? '#' + fragment : '');
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded fragment identifier, or null if none.  Does
 *     not include the hash mark.
 */
goog.uri.utils.getFragment = function(uri) {
  return goog.uri.utils.decodeIfPossible_(
      goog.uri.utils.getFragmentEncoded(uri));
};


/**
 * Extracts everything up to the port of the URI.
 * @param {string} uri The URI string.
 * @return {string} Everything up to and including the port.
 */
goog.uri.utils.getHost = function(uri) {
  var pieces = goog.uri.utils.split(uri);
  return goog.uri.utils.buildFromEncodedParts(
      pieces[goog.uri.utils.ComponentIndex.SCHEME],
      pieces[goog.uri.utils.ComponentIndex.USER_INFO],
      pieces[goog.uri.utils.ComponentIndex.DOMAIN],
      pieces[goog.uri.utils.ComponentIndex.PORT]);
};


/**
 * Extracts the path of the URL and everything after.
 * @param {string} uri The URI string.
 * @return {string} The URI, starting at the path and including the query
 *     parameters and fragment identifier.
 */
goog.uri.utils.getPathAndAfter = function(uri) {
  var pieces = goog.uri.utils.split(uri);
  return goog.uri.utils.buildFromEncodedParts(null, null, null, null,
      pieces[goog.uri.utils.ComponentIndex.PATH],
      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],
      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);
};


/**
 * Gets the URI with the fragment identifier removed.
 * @param {string} uri The URI to examine.
 * @return {string} Everything preceding the hash mark.
 */
goog.uri.utils.removeFragment = function(uri) {
  // The hash mark may not appear in any other part of the URL.
  var hashIndex = uri.indexOf('#');
  return hashIndex < 0 ? uri : uri.substr(0, hashIndex);
};


/**
 * Ensures that two URI's have the exact same domain, scheme, and port.
 *
 * Unlike the version in goog.Uri, this checks protocol, and therefore is
 * suitable for checking against the browser's same-origin policy.
 *
 * @param {string} uri1 The first URI.
 * @param {string} uri2 The second URI.
 * @return {boolean} Whether they have the same domain and port.
 */
goog.uri.utils.haveSameDomain = function(uri1, uri2) {
  var pieces1 = goog.uri.utils.split(uri1);
  var pieces2 = goog.uri.utils.split(uri2);
  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==
             pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&
         pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==
             pieces2[goog.uri.utils.ComponentIndex.SCHEME] &&
         pieces1[goog.uri.utils.ComponentIndex.PORT] ==
             pieces2[goog.uri.utils.ComponentIndex.PORT];
};


/**
 * Asserts that there are no fragment or query identifiers, only in uncompiled
 * mode.
 * @param {string} uri The URI to examine.
 * @private
 */
goog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {
  // NOTE: would use goog.asserts here, but jscompiler doesn't know that
  // indexOf has no side effects.
  if (goog.DEBUG && (uri.indexOf('#') >= 0 || uri.indexOf('?') >= 0)) {
    throw Error('goog.uri.utils: Fragment or query identifiers are not ' +
        'supported: [' + uri + ']');
  }
};


/**
 * Supported query parameter values by the parameter serializing utilities.
 *
 * If a value is null or undefined, the key-value pair is skipped, as an easy
 * way to omit parameters conditionally.  Non-array parameters are converted
 * to a string and URI encoded.  Array values are expanded into multiple
 * &key=value pairs, with each element stringized and URI-encoded.
 *
 * @typedef {*}
 */
goog.uri.utils.QueryValue;


/**
 * An array representing a set of query parameters with alternating keys
 * and values.
 *
 * Keys are assumed to be URI encoded already and live at even indices.  See
 * goog.uri.utils.QueryValue for details on how parameter values are encoded.
 *
 * Example:
 * <pre>
 * var data = [
 *   // Simple param: ?name=BobBarker
 *   'name', 'BobBarker',
 *   // Conditional param -- may be omitted entirely.
 *   'specialDietaryNeeds', hasDietaryNeeds() ? getDietaryNeeds() : null,
 *   // Multi-valued param: &house=LosAngeles&house=NewYork&house=null
 *   'house', ['LosAngeles', 'NewYork', null]
 * ];
 * </pre>
 *
 * @typedef {!Array.<string|goog.uri.utils.QueryValue>}
 */
goog.uri.utils.QueryArray;


/**
 * Appends a URI and query data in a string buffer with special preconditions.
 *
 * Internal implementation utility, performing very few object allocations.
 *
 * @param {!Array.<string|undefined>} buffer A string buffer.  The first element
 *     must be the base URI, and may have a fragment identifier.  If the array
 *     contains more than one element, the second element must be an ampersand,
 *     and may be overwritten, depending on the base URI.  Undefined elements
 *     are treated as empty-string.
 * @return {string} The concatenated URI and query data.
 * @private
 */
goog.uri.utils.appendQueryData_ = function(buffer) {
  if (buffer[1]) {
    // At least one query parameter was added.  We need to check the
    // punctuation mark, which is currently an ampersand, and also make sure
    // there aren't any interfering fragment identifiers.
    var baseUri = /** @type {string} */ (buffer[0]);
    var hashIndex = baseUri.indexOf('#');
    if (hashIndex >= 0) {
      // Move the fragment off the base part of the URI into the end.
      buffer.push(baseUri.substr(hashIndex));
      buffer[0] = baseUri = baseUri.substr(0, hashIndex);
    }
    var questionIndex = baseUri.indexOf('?');
    if (questionIndex < 0) {
      // No question mark, so we need a question mark instead of an ampersand.
      buffer[1] = '?';
    } else if (questionIndex == baseUri.length - 1) {
      // Question mark is the very last character of the existing URI, so don't
      // append an additional delimiter.
      buffer[1] = undefined;
    }
  }

  return buffer.join('');
};


/**
 * Appends key=value pairs to an array, supporting multi-valued objects.
 * @param {string} key The key prefix.
 * @param {goog.uri.utils.QueryValue} value The value to serialize.
 * @param {!Array.<string>} pairs The array to which the 'key=value' strings
 *     should be appended.
 * @private
 */
goog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {
  if (goog.isArray(value)) {
    // Convince the compiler it's an array.
    goog.asserts.assertArray(value);
    for (var j = 0; j < value.length; j++) {
      // Convert to string explicitly, to short circuit the null and array
      // logic in this function -- this ensures that null and undefined get
      // written as literal 'null' and 'undefined', and arrays don't get
      // expanded out but instead encoded in the default way.
      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);
    }
  } else if (value != null) {
    // Skip a top-level null or undefined entirely.
    pairs.push('&', key,
        // Check for empty string. Zero gets encoded into the url as literal
        // strings.  For empty string, skip the equal sign, to be consistent
        // with UriBuilder.java.
        value === '' ? '' : '=',
        goog.string.urlEncode(value));
  }
};


/**
 * Builds a buffer of query data from a sequence of alternating keys and values.
 *
 * @param {!Array.<string|undefined>} buffer A string buffer to append to.  The
 *     first element appended will be an '&', and may be replaced by the caller.
 * @param {goog.uri.utils.QueryArray|Arguments} keysAndValues An array with
 *     alternating keys and values -- see the typedef.
 * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.
 * @return {!Array.<string|undefined>} The buffer argument.
 * @private
 */
goog.uri.utils.buildQueryDataBuffer_ = function(
    buffer, keysAndValues, opt_startIndex) {
  goog.asserts.assert(Math.max(keysAndValues.length - (opt_startIndex || 0),
      0) % 2 == 0, 'goog.uri.utils: Key/value lists must be even in length.');

  for (var i = opt_startIndex || 0; i < keysAndValues.length; i += 2) {
    goog.uri.utils.appendKeyValuePairs_(
        keysAndValues[i], keysAndValues[i + 1], buffer);
  }

  return buffer;
};


/**
 * Builds a query data string from a sequence of alternating keys and values.
 * Currently generates "&key&" for empty args.
 *
 * @param {goog.uri.utils.QueryArray} keysAndValues Alternating keys and
 *     values.  See the typedef.
 * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.
 * @return {string} The encoded query string, in the form 'a=1&b=2'.
 */
goog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {
  var buffer = goog.uri.utils.buildQueryDataBuffer_(
      [], keysAndValues, opt_startIndex);
  buffer[0] = ''; // Remove the leading ampersand.
  return buffer.join('');
};


/**
 * Builds a buffer of query data from a map.
 *
 * @param {!Array.<string|undefined>} buffer A string buffer to append to.  The
 *     first element appended will be an '&', and may be replaced by the caller.
 * @param {Object.<goog.uri.utils.QueryValue>} map An object where keys are
 *     URI-encoded parameter keys, and the values conform to the contract
 *     specified in the goog.uri.utils.QueryValue typedef.
 * @return {!Array.<string|undefined>} The buffer argument.
 * @private
 */
goog.uri.utils.buildQueryDataBufferFromMap_ = function(buffer, map) {
  for (var key in map) {
    goog.uri.utils.appendKeyValuePairs_(key, map[key], buffer);
  }

  return buffer;
};


/**
 * Builds a query data string from a map.
 * Currently generates "&key&" for empty args.
 *
 * @param {Object} map An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.  Keys with a null value
 *     are dropped.
 * @return {string} The encoded query string, in the form 'a=1&b=2'.
 */
goog.uri.utils.buildQueryDataFromMap = function(map) {
  var buffer = goog.uri.utils.buildQueryDataBufferFromMap_([], map);
  buffer[0] = '';
  return buffer.join('');
};


/**
 * Appends URI parameters to an existing URI.
 *
 * The variable arguments may contain alternating keys and values.  Keys are
 * assumed to be already URI encoded.  The values should not be URI-encoded,
 * and will instead be encoded by this function.
 * <pre>
 * appendParams('http://www.foo.com?existing=true',
 *     'key1', 'value1',
 *     'key2', 'value?willBeEncoded',
 *     'key3', ['valueA', 'valueB', 'valueC'],
 *     'key4', null);
 * result: 'http://www.foo.com?existing=true&' +
 *     'key1=value1&' +
 *     'key2=value%3FwillBeEncoded&' +
 *     'key3=valueA&key3=valueB&key3=valueC'
 * </pre>
 *
 * A single call to this function will not exhibit quadratic behavior in IE,
 * whereas multiple repeated calls may, although the effect is limited by
 * fact that URL's generally can't exceed 2kb.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {...(goog.uri.utils.QueryArray|string|goog.uri.utils.QueryValue)} var_args
 *     An array or argument list conforming to goog.uri.utils.QueryArray.
 * @return {string} The URI with all query parameters added.
 */
goog.uri.utils.appendParams = function(uri, var_args) {
  return goog.uri.utils.appendQueryData_(
      arguments.length == 2 ?
      goog.uri.utils.buildQueryDataBuffer_([uri], arguments[1], 0) :
      goog.uri.utils.buildQueryDataBuffer_([uri], arguments, 1));
};


/**
 * Appends query parameters from a map.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {Object} map An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.  Keys with a null value
 *     are dropped.
 * @return {string} The new parameters.
 */
goog.uri.utils.appendParamsFromMap = function(uri, map) {
  return goog.uri.utils.appendQueryData_(
      goog.uri.utils.buildQueryDataBufferFromMap_([uri], map));
};


/**
 * Appends a single URI parameter.
 *
 * Repeated calls to this can exhibit quadratic behavior in IE6 due to the
 * way string append works, though it should be limited given the 2kb limit.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {string} key The key, which must already be URI encoded.
 * @param {*=} opt_value The value, which will be stringized and encoded
 *     (assumed not already to be encoded).  If omitted, undefined, or null, the
 *     key will be added as a valueless parameter.
 * @return {string} The URI with the query parameter added.
 */
goog.uri.utils.appendParam = function(uri, key, opt_value) {
  var paramArr = [uri, '&', key];
  if (goog.isDefAndNotNull(opt_value)) {
    paramArr.push('=', goog.string.urlEncode(opt_value));
  }
  return goog.uri.utils.appendQueryData_(paramArr);
};


/**
 * Finds the next instance of a query parameter with the specified name.
 *
 * Does not instantiate any objects.
 *
 * @param {string} uri The URI to search.  May contain a fragment identifier
 *     if opt_hashIndex is specified.
 * @param {number} startIndex The index to begin searching for the key at.  A
 *     match may be found even if this is one character after the ampersand.
 * @param {string} keyEncoded The URI-encoded key.
 * @param {number} hashOrEndIndex Index to stop looking at.  If a hash
 *     mark is present, it should be its index, otherwise it should be the
 *     length of the string.
 * @return {number} The position of the first character in the key's name,
 *     immediately after either a question mark or a dot.
 * @private
 */
goog.uri.utils.findParam_ = function(
    uri, startIndex, keyEncoded, hashOrEndIndex) {
  var index = startIndex;
  var keyLength = keyEncoded.length;

  // Search for the key itself and post-filter for surronuding punctuation,
  // rather than expensively building a regexp.
  while ((index = uri.indexOf(keyEncoded, index)) >= 0 &&
      index < hashOrEndIndex) {
    var precedingChar = uri.charCodeAt(index - 1);
    // Ensure that the preceding character is '&' or '?'.
    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||
        precedingChar == goog.uri.utils.CharCode_.QUESTION) {
      // Ensure the following character is '&', '=', '#', or NaN
      // (end of string).
      var followingChar = uri.charCodeAt(index + keyLength);
      if (!followingChar ||
          followingChar == goog.uri.utils.CharCode_.EQUAL ||
          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||
          followingChar == goog.uri.utils.CharCode_.HASH) {
        return index;
      }
    }
    index += keyLength + 1;
  }

  return -1;
};


/**
 * Regular expression for finding a hash mark or end of string.
 * @type {RegExp}
 * @private
 */
goog.uri.utils.hashOrEndRe_ = /#|$/;


/**
 * Determines if the URI contains a specific key.
 *
 * Performs no object instantiations.
 *
 * @param {string} uri The URI to process.  May contain a fragment
 *     identifier.
 * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
 * @return {boolean} Whether the key is present.
 */
goog.uri.utils.hasParam = function(uri, keyEncoded) {
  return goog.uri.utils.findParam_(uri, 0, keyEncoded,
      uri.search(goog.uri.utils.hashOrEndRe_)) >= 0;
};


/**
 * Gets the first value of a query parameter.
 * @param {string} uri The URI to process.  May contain a fragment.
 * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
 * @return {?string} The first value of the parameter (URI-decoded), or null
 *     if the parameter is not found.
 */
goog.uri.utils.getParamValue = function(uri, keyEncoded) {
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var foundIndex = goog.uri.utils.findParam_(
      uri, 0, keyEncoded, hashOrEndIndex);

  if (foundIndex < 0) {
    return null;
  } else {
    var endPosition = uri.indexOf('&', foundIndex);
    if (endPosition < 0 || endPosition > hashOrEndIndex) {
      endPosition = hashOrEndIndex;
    }
    // Progress forth to the end of the "key=" or "key&" substring.
    foundIndex += keyEncoded.length + 1;
    // Use substr, because it (unlike substring) will return empty string
    // if foundIndex > endPosition.
    return goog.string.urlDecode(
        uri.substr(foundIndex, endPosition - foundIndex));
  }
};


/**
 * Gets all values of a query parameter.
 * @param {string} uri The URI to process.  May contain a framgnet.
 * @param {string} keyEncoded The URI-encoded key.  Case-snsitive.
 * @return {!Array.<string>} All URI-decoded values with the given key.
 *     If the key is not found, this will have length 0, but never be null.
 */
goog.uri.utils.getParamValues = function(uri, keyEncoded) {
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var position = 0;
  var foundIndex;
  var result = [];

  while ((foundIndex = goog.uri.utils.findParam_(
      uri, position, keyEncoded, hashOrEndIndex)) >= 0) {
    // Find where this parameter ends, either the '&' or the end of the
    // query parameters.
    position = uri.indexOf('&', foundIndex);
    if (position < 0 || position > hashOrEndIndex) {
      position = hashOrEndIndex;
    }

    // Progress forth to the end of the "key=" or "key&" substring.
    foundIndex += keyEncoded.length + 1;
    // Use substr, because it (unlike substring) will return empty string
    // if foundIndex > position.
    result.push(goog.string.urlDecode(uri.substr(
        foundIndex, position - foundIndex)));
  }

  return result;
};


/**
 * Regexp to find trailing question marks and ampersands.
 * @type {RegExp}
 * @private
 */
goog.uri.utils.trailingQueryPunctuationRe_ = /[?&]($|#)/;


/**
 * Removes all instances of a query parameter.
 * @param {string} uri The URI to process.  Must not contain a fragment.
 * @param {string} keyEncoded The URI-encoded key.
 * @return {string} The URI with all instances of the parameter removed.
 */
goog.uri.utils.removeParam = function(uri, keyEncoded) {
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var position = 0;
  var foundIndex;
  var buffer = [];

  // Look for a query parameter.
  while ((foundIndex = goog.uri.utils.findParam_(
      uri, position, keyEncoded, hashOrEndIndex)) >= 0) {
    // Get the portion of the query string up to, but not including, the ?
    // or & starting the parameter.
    buffer.push(uri.substring(position, foundIndex));
    // Progress to immediately after the '&'.  If not found, go to the end.
    // Avoid including the hash mark.
    position = Math.min((uri.indexOf('&', foundIndex) + 1) || hashOrEndIndex,
        hashOrEndIndex);
  }

  // Append everything that is remaining.
  buffer.push(uri.substr(position));

  // Join the buffer, and remove trailing punctuation that remains.
  return buffer.join('').replace(
      goog.uri.utils.trailingQueryPunctuationRe_, '$1');
};


/**
 * Replaces all existing definitions of a parameter with a single definition.
 *
 * Repeated calls to this can exhibit quadratic behavior due to the need to
 * find existing instances and reconstruct the string, though it should be
 * limited given the 2kb limit.  Consider using appendParams to append multiple
 * parameters in bulk.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {string} keyEncoded The key, which must already be URI encoded.
 * @param {*} value The value, which will be stringized and encoded (assumed
 *     not already to be encoded).
 * @return {string} The URI with the query parameter added.
 */
goog.uri.utils.setParam = function(uri, keyEncoded, value) {
  return goog.uri.utils.appendParam(
      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);
};


/**
 * Generates a URI path using a given URI and a path with checks to
 * prevent consecutive "//". The baseUri passed in must not contain
 * query or fragment identifiers. The path to append may not contain query or
 * fragment identifiers.
 *
 * @param {string} baseUri URI to use as the base.
 * @param {string} path Path to append.
 * @return {string} Updated URI.
 */
goog.uri.utils.appendPath = function(baseUri, path) {
  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);

  // Remove any trailing '/'
  if (goog.string.endsWith(baseUri, '/')) {
    baseUri = baseUri.substr(0, baseUri.length - 1);
  }
  // Remove any leading '/'
  if (goog.string.startsWith(path, '/')) {
    path = path.substr(1);
  }
  return goog.string.buildString(baseUri, '/', path);
};


/**
 * Standard supported query parameters.
 * @enum {string}
 */
goog.uri.utils.StandardQueryParam = {

  /** Unused parameter for unique-ifying. */
  RANDOM: 'zx'
};


/**
 * Sets the zx parameter of a URI to a random value.
 * @param {string} uri Any URI.
 * @return {string} That URI with the "zx" parameter added or replaced to
 *     contain a random string.
 */
goog.uri.utils.makeUnique = function(uri) {
  return goog.uri.utils.setParam(uri,
      goog.uri.utils.StandardQueryParam.RANDOM, goog.string.getRandomString());
};

//javascript/closure/net/errorcode.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Error codes shared between goog.net.IframeIo and
 * goog.net.XhrIo.
 */

goog.provide('goog.net.ErrorCode');


/**
 * Error codes
 * @enum {number}
 */
goog.net.ErrorCode = {

  /**
   * There is no error condition.
   */
  NO_ERROR: 0,

  /**
   * The most common error from iframeio, unfortunately, is that the browser
   * responded with an error page that is classed as a different domain. The
   * situations, are when a browser error page  is shown -- 404, access denied,
   * DNS failure, connection reset etc.)
   *
   */
  ACCESS_DENIED: 1,

  /**
   * Currently the only case where file not found will be caused is when the
   * code is running on the local file system and a non-IE browser makes a
   * request to a file that doesn't exist.
   */
  FILE_NOT_FOUND: 2,

  /**
   * If Firefox shows a browser error page, such as a connection reset by
   * server or access denied, then it will fail silently without the error or
   * load handlers firing.
   */
  FF_SILENT_ERROR: 3,

  /**
   * Custom error provided by the client through the error check hook.
   */
  CUSTOM_ERROR: 4,

  /**
   * Exception was thrown while processing the request.
   */
  EXCEPTION: 5,

  /**
   * The Http response returned a non-successful http status code.
   */
  HTTP_ERROR: 6,

  /**
   * The request was aborted.
   */
  ABORT: 7,

  /**
   * The request timed out.
   */
  TIMEOUT: 8,

  /**
   * The resource is not available offline.
   */
  OFFLINE: 9
};


/**
 * Returns a friendly error message for an error code. These messages are for
 * debugging and are not localized.
 * @param {goog.net.ErrorCode} errorCode An error code.
 * @return {string} A message for debugging.
 */
goog.net.ErrorCode.getDebugMessage = function(errorCode) {
  switch (errorCode) {
    case goog.net.ErrorCode.NO_ERROR:
      return 'No Error';

    case goog.net.ErrorCode.ACCESS_DENIED:
      return 'Access denied to content document';

    case goog.net.ErrorCode.FILE_NOT_FOUND:
      return 'File not found';

    case goog.net.ErrorCode.FF_SILENT_ERROR:
      return 'Firefox silently errored';

    case goog.net.ErrorCode.CUSTOM_ERROR:
      return 'Application custom error';

    case goog.net.ErrorCode.EXCEPTION:
      return 'An exception occurred';

    case goog.net.ErrorCode.HTTP_ERROR:
      return 'Http response at 400 or 500 level';

    case goog.net.ErrorCode.ABORT:
      return 'Request was aborted';

    case goog.net.ErrorCode.TIMEOUT:
      return 'Request timed out';

    case goog.net.ErrorCode.OFFLINE:
      return 'The resource is not available offline';

    default:
      return 'Unrecognized error code';
  }
};

//javascript/closure/net/eventtype.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Common events for the network classes.
 */


goog.provide('goog.net.EventType');


/**
 * Event names for network events
 * @enum {string}
 */
goog.net.EventType = {
  COMPLETE: 'complete',
  SUCCESS: 'success',
  ERROR: 'error',
  ABORT: 'abort',
  READY: 'ready',
  READY_STATE_CHANGE: 'readystatechange',
  TIMEOUT: 'timeout',
  INCREMENTAL_DATA: 'incrementaldata',
  PROGRESS: 'progress'
};

//javascript/closure/net/httpstatus.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Constants for HTTP status codes.
 */

goog.provide('goog.net.HttpStatus');


/**
 * HTTP Status Codes defined in RFC 2616.
 * @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
 * @enum {number}
 */
goog.net.HttpStatus = {
  // Informational 1xx
  CONTINUE: 100,
  SWITCHING_PROTOCOLS: 101,

  // Successful 2xx
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  NON_AUTHORITATIVE_INFORMATION: 203,
  NO_CONTENT: 204,
  RESET_CONTENT: 205,
  PARTIAL_CONTENT: 206,

  // Redirection 3xx
  MULTIPLE_CHOICES: 300,
  MOVED_PERMANENTLY: 301,
  FOUND: 302,
  SEE_OTHER: 303,
  NOT_MODIFIED: 304,
  USE_PROXY: 305,
  TEMPORARY_REDIRECT: 307,

  // Client Error 4xx
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  PAYMENT_REQUIRED: 402,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  NOT_ACCEPTABLE: 406,
  PROXY_AUTHENTICATION_REQUIRED: 407,
  REQUEST_TIMEOUT: 408,
  CONFLICT: 409,
  GONE: 410,
  LENGTH_REQUIRED: 411,
  PRECONDITION_FAILED: 412,
  REQUEST_ENTITY_TOO_LARGE: 413,
  REQUEST_URI_TOO_LONG: 414,
  UNSUPPORTED_MEDIA_TYPE: 415,
  REQUEST_RANGE_NOT_SATISFIABLE: 416,
  EXPECTATION_FAILED: 417,

  // Server Error 5xx
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
  HTTP_VERSION_NOT_SUPPORTED: 505,

  /*
   * IE returns this code for 204 due to its use of URLMon, which returns this
   * code for 'Operation Aborted'. The status text is 'Unknown', the response
   * headers are ''. Known to occur on IE 6 on XP through IE9 on Win7.
   */
  QUIRK_IE_NO_CONTENT: 1223
};


/**
 * Returns whether the given status should be considered successful.
 *
 * Successful codes are OK (200), CREATED (201), ACCEPTED (202),
 * NO CONTENT (204), PARTIAL CONTENT (206), NOT MODIFIED (304),
 * and IE's no content code (1223).
 *
 * @param {number} status The status code to test.
 * @return {boolean} Whether the status code should be considered successful.
 */
goog.net.HttpStatus.isSuccess = function(status) {
  switch (status) {
    case goog.net.HttpStatus.OK:
    case goog.net.HttpStatus.CREATED:
    case goog.net.HttpStatus.ACCEPTED:
    case goog.net.HttpStatus.NO_CONTENT:
    case goog.net.HttpStatus.PARTIAL_CONTENT:
    case goog.net.HttpStatus.NOT_MODIFIED:
    case goog.net.HttpStatus.QUIRK_IE_NO_CONTENT:
      return true;

    default:
      return false;
  }
};

//javascript/closure/net/xhrlike.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.provide('goog.net.XhrLike');



/**
 * Interface for the common parts of XMLHttpRequest.
 *
 * Mostly copied from externs/w3c_xml.js.
 *
 * @interface
 * @see http://www.w3.org/TR/XMLHttpRequest/
 */
goog.net.XhrLike = function() {};


/**
 * Typedef that refers to either native or custom-implemented XHR objects.
 * @typedef {!goog.net.XhrLike|!XMLHttpRequest}
 */
goog.net.XhrLike.OrNative;


/**
 * @type {function()|null|undefined}
 * @see http://www.w3.org/TR/XMLHttpRequest/#handler-xhr-onreadystatechange
 */
goog.net.XhrLike.prototype.onreadystatechange;


/**
 * @type {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetext-attribute
 */
goog.net.XhrLike.prototype.responseText;


/**
 * @type {Document}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsexml-attribute
 */
goog.net.XhrLike.prototype.responseXML;


/**
 * @type {number}
 * @see http://www.w3.org/TR/XMLHttpRequest/#readystate
 */
goog.net.XhrLike.prototype.readyState;


/**
 * @type {number}
 * @see http://www.w3.org/TR/XMLHttpRequest/#status
 */
goog.net.XhrLike.prototype.status;


/**
 * @type {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#statustext
 */
goog.net.XhrLike.prototype.statusText;


/**
 * @param {string} method
 * @param {string} url
 * @param {?boolean=} opt_async
 * @param {?string=} opt_user
 * @param {?string=} opt_password
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-open()-method
 */
goog.net.XhrLike.prototype.open = function(method, url, opt_async, opt_user,
    opt_password) {};


/**
 * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=} opt_data
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-send()-method
 */
goog.net.XhrLike.prototype.send = function(opt_data) {};


/**
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-abort()-method
 */
goog.net.XhrLike.prototype.abort = function() {};


/**
 * @param {string} header
 * @param {string} value
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader()-method
 */
goog.net.XhrLike.prototype.setRequestHeader = function(header, value) {};


/**
 * @param {string} header
 * @return {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method
 */
goog.net.XhrLike.prototype.getResponseHeader = function(header) {};


/**
 * @return {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method
 */
goog.net.XhrLike.prototype.getAllResponseHeaders = function() {};

//javascript/closure/net/xmlhttpfactory.js
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Interface for a factory for creating XMLHttpRequest objects
 * and metadata about them.
 * @author dbk@google.com (David Barrett-Kahn)
 */

goog.provide('goog.net.XmlHttpFactory');

/** @suppress {extraRequire} Typedef. */
goog.require('goog.net.XhrLike');



/**
 * Abstract base class for an XmlHttpRequest factory.
 * @constructor
 */
goog.net.XmlHttpFactory = function() {
};


/**
 * Cache of options - we only actually call internalGetOptions once.
 * @type {Object}
 * @private
 */
goog.net.XmlHttpFactory.prototype.cachedOptions_ = null;


/**
 * @return {!(goog.net.XhrLike.OrNative|GearsHttpRequest)} A new XhrLike
 *     instance.
 */
goog.net.XmlHttpFactory.prototype.createInstance = goog.abstractMethod;


/**
 * @return {Object} Options describing how xhr objects obtained from this
 *     factory should be used.
 */
goog.net.XmlHttpFactory.prototype.getOptions = function() {
  return this.cachedOptions_ ||
      (this.cachedOptions_ = this.internalGetOptions());
};


/**
 * Override this method in subclasses to preserve the caching offered by
 * getOptions().
 * @return {Object} Options describing how xhr objects obtained from this
 *     factory should be used.
 * @protected
 */
goog.net.XmlHttpFactory.prototype.internalGetOptions = goog.abstractMethod;

//javascript/closure/net/wrapperxmlhttpfactory.js
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Implementation of XmlHttpFactory which allows construction from
 * simple factory methods.
 * @author dbk@google.com (David Barrett-Kahn)
 */

goog.provide('goog.net.WrapperXmlHttpFactory');

/** @suppress {extraRequire} Typedef. */
goog.require('goog.net.XhrLike');
goog.require('goog.net.XmlHttpFactory');



/**
 * An xhr factory subclass which can be constructed using two factory methods.
 * This exists partly to allow the preservation of goog.net.XmlHttp.setFactory()
 * with an unchanged signature.
 * @param {function() :
 *     !(goog.net.XhrLike.OrNative|GearsHttpRequest)} xhrFactory
 *     A function which returns a new XHR object.
 * @param {function() : !Object} optionsFactory A function which returns the
 *     options associated with xhr objects from this factory.
 * @extends {goog.net.XmlHttpFactory}
 * @constructor
 * @final
 */
goog.net.WrapperXmlHttpFactory = function(xhrFactory, optionsFactory) {
  goog.net.XmlHttpFactory.call(this);

  /**
   * XHR factory method.
   * @type {function() : !(goog.net.XhrLike.OrNative|GearsHttpRequest)}
   * @private
   */
  this.xhrFactory_ = xhrFactory;

  /**
   * Options factory method.
   * @type {function() : !Object}
   * @private
   */
  this.optionsFactory_ = optionsFactory;
};
goog.inherits(goog.net.WrapperXmlHttpFactory, goog.net.XmlHttpFactory);


/** @override */
goog.net.WrapperXmlHttpFactory.prototype.createInstance = function() {
  return this.xhrFactory_();
};


/** @override */
goog.net.WrapperXmlHttpFactory.prototype.getOptions = function() {
  return this.optionsFactory_();
};


//javascript/closure/net/xmlhttp.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Low level handling of XMLHttpRequest.
 * @author arv@google.com (Erik Arvidsson)
 * @author dbk@google.com (David Barrett-Kahn)
 */

goog.provide('goog.net.DefaultXmlHttpFactory');
goog.provide('goog.net.XmlHttp');
goog.provide('goog.net.XmlHttp.OptionType');
goog.provide('goog.net.XmlHttp.ReadyState');

goog.require('goog.asserts');
goog.require('goog.net.WrapperXmlHttpFactory');
goog.require('goog.net.XmlHttpFactory');


/**
 * Static class for creating XMLHttpRequest objects.
 * @return {!(goog.net.XhrLike.OrNative|GearsHttpRequest)} A new XMLHttpRequest
 *     object.
 */
goog.net.XmlHttp = function() {
  return goog.net.XmlHttp.factory_.createInstance();
};


/**
 * @define {boolean} Whether to assume XMLHttpRequest exists. Setting this to
 *     true strips the ActiveX probing code.
 */
goog.define('goog.net.XmlHttp.ASSUME_NATIVE_XHR', false);


/**
 * Gets the options to use with the XMLHttpRequest objects obtained using
 * the static methods.
 * @return {Object} The options.
 */
goog.net.XmlHttp.getOptions = function() {
  return goog.net.XmlHttp.factory_.getOptions();
};


/**
 * Type of options that an XmlHttp object can have.
 * @enum {number}
 */
goog.net.XmlHttp.OptionType = {
  /**
   * Whether a goog.nullFunction should be used to clear the onreadystatechange
   * handler instead of null.
   */
  USE_NULL_FUNCTION: 0,

  /**
   * NOTE(pupius): In IE if send() errors on a *local* request the readystate
   * is still changed to COMPLETE.  We need to ignore it and allow the
   * try/catch around send() to pick up the error.
   */
  LOCAL_REQUEST_ERROR: 1
};


/**
 * Status constants for XMLHTTP, matches:
 * http://msdn.microsoft.com/library/default.asp?url=/library/
 *   en-us/xmlsdk/html/0e6a34e4-f90c-489d-acff-cb44242fafc6.asp
 * @enum {number}
 */
goog.net.XmlHttp.ReadyState = {
  /**
   * Constant for when xmlhttprequest.readyState is uninitialized
   */
  UNINITIALIZED: 0,

  /**
   * Constant for when xmlhttprequest.readyState is loading.
   */
  LOADING: 1,

  /**
   * Constant for when xmlhttprequest.readyState is loaded.
   */
  LOADED: 2,

  /**
   * Constant for when xmlhttprequest.readyState is in an interactive state.
   */
  INTERACTIVE: 3,

  /**
   * Constant for when xmlhttprequest.readyState is completed
   */
  COMPLETE: 4
};


/**
 * The global factory instance for creating XMLHttpRequest objects.
 * @type {goog.net.XmlHttpFactory}
 * @private
 */
goog.net.XmlHttp.factory_;


/**
 * Sets the factories for creating XMLHttpRequest objects and their options.
 * @param {Function} factory The factory for XMLHttpRequest objects.
 * @param {Function} optionsFactory The factory for options.
 * @deprecated Use setGlobalFactory instead.
 */
goog.net.XmlHttp.setFactory = function(factory, optionsFactory) {
  goog.net.XmlHttp.setGlobalFactory(new goog.net.WrapperXmlHttpFactory(
      goog.asserts.assert(factory),
      goog.asserts.assert(optionsFactory)));
};


/**
 * Sets the global factory object.
 * @param {!goog.net.XmlHttpFactory} factory New global factory object.
 */
goog.net.XmlHttp.setGlobalFactory = function(factory) {
  goog.net.XmlHttp.factory_ = factory;
};



/**
 * Default factory to use when creating xhr objects.  You probably shouldn't be
 * instantiating this directly, but rather using it via goog.net.XmlHttp.
 * @extends {goog.net.XmlHttpFactory}
 * @constructor
 */
goog.net.DefaultXmlHttpFactory = function() {
  goog.net.XmlHttpFactory.call(this);
};
goog.inherits(goog.net.DefaultXmlHttpFactory, goog.net.XmlHttpFactory);


/** @override */
goog.net.DefaultXmlHttpFactory.prototype.createInstance = function() {
  var progId = this.getProgId_();
  if (progId) {
    return new ActiveXObject(progId);
  } else {
    return new XMLHttpRequest();
  }
};


/** @override */
goog.net.DefaultXmlHttpFactory.prototype.internalGetOptions = function() {
  var progId = this.getProgId_();
  var options = {};
  if (progId) {
    options[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] = true;
    options[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] = true;
  }
  return options;
};


/**
 * The ActiveX PROG ID string to use to create xhr's in IE. Lazily initialized.
 * @type {string|undefined}
 * @private
 */
goog.net.DefaultXmlHttpFactory.prototype.ieProgId_;


/**
 * Initialize the private state used by other functions.
 * @return {string} The ActiveX PROG ID string to use to create xhr's in IE.
 * @private
 */
goog.net.DefaultXmlHttpFactory.prototype.getProgId_ = function() {
  if (goog.net.XmlHttp.ASSUME_NATIVE_XHR) {
    return '';
  }

  // The following blog post describes what PROG IDs to use to create the
  // XMLHTTP object in Internet Explorer:
  // http://blogs.msdn.com/xmlteam/archive/2006/10/23/using-the-right-version-of-msxml-in-internet-explorer.aspx
  // However we do not (yet) fully trust that this will be OK for old versions
  // of IE on Win9x so we therefore keep the last 2.
  if (!this.ieProgId_ && typeof XMLHttpRequest == 'undefined' &&
      typeof ActiveXObject != 'undefined') {
    // Candidate Active X types.
    var ACTIVE_X_IDENTS = ['MSXML2.XMLHTTP.6.0', 'MSXML2.XMLHTTP.3.0',
                           'MSXML2.XMLHTTP', 'Microsoft.XMLHTTP'];
    for (var i = 0; i < ACTIVE_X_IDENTS.length; i++) {
      var candidate = ACTIVE_X_IDENTS[i];
      /** @preserveTry */
      try {
        new ActiveXObject(candidate);
        // NOTE(pupius): cannot assign progid and return candidate in one line
        // because JSCompiler complaings: BUG 658126
        this.ieProgId_ = candidate;
        return candidate;
      } catch (e) {
        // do nothing; try next choice
      }
    }

    // couldn't find any matches
    throw Error('Could not create ActiveXObject. ActiveX might be disabled,' +
                ' or MSXML might not be installed');
  }

  return /** @type {string} */ (this.ieProgId_);
};


//Set the global factory to an instance of the default factory.
goog.net.XmlHttp.setGlobalFactory(new goog.net.DefaultXmlHttpFactory());

//javascript/closure/net/xhrio.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Wrapper class for handling XmlHttpRequests.
 *
 * One off requests can be sent through goog.net.XhrIo.send() or an
 * instance can be created to send multiple requests.  Each request uses its
 * own XmlHttpRequest object and handles clearing of the event callback to
 * ensure no leaks.
 *
 * XhrIo is event based, it dispatches events when a request finishes, fails or
 * succeeds or when the ready-state changes. The ready-state or timeout event
 * fires first, followed by a generic completed event. Then the abort, error,
 * or success event is fired as appropriate. Lastly, the ready event will fire
 * to indicate that the object may be used to make another request.
 *
 * The error event may also be called before completed and
 * ready-state-change if the XmlHttpRequest.open() or .send() methods throw.
 *
 * This class does not support multiple requests, queuing, or prioritization.
 *
 * Tested = IE6, FF1.5, Safari, Opera 8.5
 *
 * TODO(pupius): Error cases aren't playing nicely in Safari.
 *
 * @author pupius@google.com (Daniel Pupius)
 */


goog.provide('goog.net.XhrIo');
goog.provide('goog.net.XhrIo.ResponseType');

goog.require('goog.Timer');
goog.require('goog.array');
goog.require('goog.debug.entryPointRegistry');
goog.require('goog.events.EventTarget');
goog.require('goog.json');
goog.require('goog.log');
goog.require('goog.net.ErrorCode');
goog.require('goog.net.EventType');
goog.require('goog.net.HttpStatus');
goog.require('goog.net.XmlHttp');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.structs');
goog.require('goog.structs.Map');
goog.require('goog.uri.utils');
goog.require('goog.userAgent');



/**
 * Basic class for handling XMLHttpRequests.
 * @param {goog.net.XmlHttpFactory=} opt_xmlHttpFactory Factory to use when
 *     creating XMLHttpRequest objects.
 * @constructor
 * @extends {goog.events.EventTarget}
 */
goog.net.XhrIo = function(opt_xmlHttpFactory) {
  goog.base(this);

  /**
   * Map of default headers to add to every request, use:
   * XhrIo.headers.set(name, value)
   * @type {!goog.structs.Map}
   */
  this.headers = new goog.structs.Map();

  /**
   * Optional XmlHttpFactory
   * @private {goog.net.XmlHttpFactory}
   */
  this.xmlHttpFactory_ = opt_xmlHttpFactory || null;

  /**
   * Whether XMLHttpRequest is active.  A request is active from the time send()
   * is called until onReadyStateChange() is complete, or error() or abort()
   * is called.
   * @private {boolean}
   */
  this.active_ = false;

  /**
   * The XMLHttpRequest object that is being used for the transfer.
   * @private {goog.net.XhrLike.OrNative|GearsHttpRequest}
   */
  this.xhr_ = null;

  /**
   * The options to use with the current XMLHttpRequest object.
   * @private {Object}
   */
  this.xhrOptions_ = null;

  /**
   * Last URL that was requested.
   * @private {string|goog.Uri}
   */
  this.lastUri_ = '';

  /**
   * Method for the last request.
   * @private {string}
   */
  this.lastMethod_ = '';

  /**
   * Last error code.
   * @private {!goog.net.ErrorCode}
   */
  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;

  /**
   * Last error message.
   * @private {Error|string}
   */
  this.lastError_ = '';

  /**
   * Used to ensure that we don't dispatch an multiple ERROR events. This can
   * happen in IE when it does a synchronous load and one error is handled in
   * the ready statte change and one is handled due to send() throwing an
   * exception.
   * @private {boolean}
   */
  this.errorDispatched_ = false;

  /**
   * Used to make sure we don't fire the complete event from inside a send call.
   * @private {boolean}
   */
  this.inSend_ = false;

  /**
   * Used in determining if a call to {@link #onReadyStateChange_} is from
   * within a call to this.xhr_.open.
   * @private {boolean}
   */
  this.inOpen_ = false;

  /**
   * Used in determining if a call to {@link #onReadyStateChange_} is from
   * within a call to this.xhr_.abort.
   * @private {boolean}
   */
  this.inAbort_ = false;

  /**
   * Number of milliseconds after which an incomplete request will be aborted
   * and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no timeout
   * is set.
   * @private {number}
   */
  this.timeoutInterval_ = 0;

  /**
   * Timer to track request timeout.
   * @private {?number}
   */
  this.timeoutId_ = null;

  /**
   * The requested type for the response. The empty string means use the default
   * XHR behavior.
   * @private {goog.net.XhrIo.ResponseType}
   */
  this.responseType_ = goog.net.XhrIo.ResponseType.DEFAULT;

  /**
   * Whether a "credentialed" request is to be sent (one that is aware of
   * cookies and authentication). This is applicable only for cross-domain
   * requests and more recent browsers that support this part of the HTTP Access
   * Control standard.
   *
   * @see http://www.w3.org/TR/XMLHttpRequest/#the-withcredentials-attribute
   *
   * @private {boolean}
   */
  this.withCredentials_ = false;

  /**
   * True if we can use XMLHttpRequest's timeout directly.
   * @private {boolean}
   */
  this.useXhr2Timeout_ = false;
};
goog.inherits(goog.net.XhrIo, goog.events.EventTarget);


/**
 * Response types that may be requested for XMLHttpRequests.
 * @enum {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetype-attribute
 */
goog.net.XhrIo.ResponseType = {
  DEFAULT: '',
  TEXT: 'text',
  DOCUMENT: 'document',
  // Not supported as of Chrome 10.0.612.1 dev
  BLOB: 'blob',
  ARRAY_BUFFER: 'arraybuffer'
};


/**
 * A reference to the XhrIo logger
 * @private {goog.debug.Logger}
 * @const
 */
goog.net.XhrIo.prototype.logger_ =
    goog.log.getLogger('goog.net.XhrIo');


/**
 * The Content-Type HTTP header name
 * @type {string}
 */
goog.net.XhrIo.CONTENT_TYPE_HEADER = 'Content-Type';


/**
 * The pattern matching the 'http' and 'https' URI schemes
 * @type {!RegExp}
 */
goog.net.XhrIo.HTTP_SCHEME_PATTERN = /^https?$/i;


/**
 * The methods that typically come along with form data.  We set different
 * headers depending on whether the HTTP action is one of these.
 */
goog.net.XhrIo.METHODS_WITH_FORM_DATA = ['POST', 'PUT'];


/**
 * The Content-Type HTTP header value for a url-encoded form
 * @type {string}
 */
goog.net.XhrIo.FORM_CONTENT_TYPE =
    'application/x-www-form-urlencoded;charset=utf-8';


/**
 * The XMLHttpRequest Level two timeout delay ms property name.
 *
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute
 *
 * @private {string}
 * @const
 */
goog.net.XhrIo.XHR2_TIMEOUT_ = 'timeout';


/**
 * The XMLHttpRequest Level two ontimeout handler property name.
 *
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute
 *
 * @private {string}
 * @const
 */
goog.net.XhrIo.XHR2_ON_TIMEOUT_ = 'ontimeout';


/**
 * All non-disposed instances of goog.net.XhrIo created
 * by {@link goog.net.XhrIo.send} are in this Array.
 * @see goog.net.XhrIo.cleanup
 * @private {!Array.<!goog.net.XhrIo>}
 */
goog.net.XhrIo.sendInstances_ = [];


/**
 * Static send that creates a short lived instance of XhrIo to send the
 * request.
 * @see goog.net.XhrIo.cleanup
 * @param {string|goog.Uri} url Uri to make request to.
 * @param {Function=} opt_callback Callback function for when request is
 *     complete.
 * @param {string=} opt_method Send method, default: GET.
 * @param {ArrayBuffer|Blob|Document|FormData|GearsBlob|string=} opt_content
 *     Body data.
 * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the
 *     request.
 * @param {number=} opt_timeoutInterval Number of milliseconds after which an
 *     incomplete request will be aborted; 0 means no timeout is set.
 * @param {boolean=} opt_withCredentials Whether to send credentials with the
 *     request. Default to false. See {@link goog.net.XhrIo#setWithCredentials}.
 */
goog.net.XhrIo.send = function(url, opt_callback, opt_method, opt_content,
                               opt_headers, opt_timeoutInterval,
                               opt_withCredentials) {
  var x = new goog.net.XhrIo();
  goog.net.XhrIo.sendInstances_.push(x);
  if (opt_callback) {
    x.listen(goog.net.EventType.COMPLETE, opt_callback);
  }
  x.listenOnce(goog.net.EventType.READY, x.cleanupSend_);
  if (opt_timeoutInterval) {
    x.setTimeoutInterval(opt_timeoutInterval);
  }
  if (opt_withCredentials) {
    x.setWithCredentials(opt_withCredentials);
  }
  x.send(url, opt_method, opt_content, opt_headers);
};


/**
 * Disposes all non-disposed instances of goog.net.XhrIo created by
 * {@link goog.net.XhrIo.send}.
 * {@link goog.net.XhrIo.send} cleans up the goog.net.XhrIo instance
 * it creates when the request completes or fails.  However, if
 * the request never completes, then the goog.net.XhrIo is not disposed.
 * This can occur if the window is unloaded before the request completes.
 * We could have {@link goog.net.XhrIo.send} return the goog.net.XhrIo
 * it creates and make the client of {@link goog.net.XhrIo.send} be
 * responsible for disposing it in this case.  However, this makes things
 * significantly more complicated for the client, and the whole point
 * of {@link goog.net.XhrIo.send} is that it's simple and easy to use.
 * Clients of {@link goog.net.XhrIo.send} should call
 * {@link goog.net.XhrIo.cleanup} when doing final
 * cleanup on window unload.
 */
goog.net.XhrIo.cleanup = function() {
  var instances = goog.net.XhrIo.sendInstances_;
  while (instances.length) {
    instances.pop().dispose();
  }
};


/**
 * Installs exception protection for all entry point introduced by
 * goog.net.XhrIo instances which are not protected by
 * {@link goog.debug.ErrorHandler#protectWindowSetTimeout},
 * {@link goog.debug.ErrorHandler#protectWindowSetInterval}, or
 * {@link goog.events.protectBrowserEventEntryPoint}.
 *
 * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to
 *     protect the entry point(s).
 */
goog.net.XhrIo.protectEntryPoints = function(errorHandler) {
  goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =
      errorHandler.protectEntryPoint(
          goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);
};


/**
 * Disposes of the specified goog.net.XhrIo created by
 * {@link goog.net.XhrIo.send} and removes it from
 * {@link goog.net.XhrIo.pendingStaticSendInstances_}.
 * @private
 */
goog.net.XhrIo.prototype.cleanupSend_ = function() {
  this.dispose();
  goog.array.remove(goog.net.XhrIo.sendInstances_, this);
};


/**
 * Returns the number of milliseconds after which an incomplete request will be
 * aborted, or 0 if no timeout is set.
 * @return {number} Timeout interval in milliseconds.
 */
goog.net.XhrIo.prototype.getTimeoutInterval = function() {
  return this.timeoutInterval_;
};


/**
 * Sets the number of milliseconds after which an incomplete request will be
 * aborted and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no
 * timeout is set.
 * @param {number} ms Timeout interval in milliseconds; 0 means none.
 */
goog.net.XhrIo.prototype.setTimeoutInterval = function(ms) {
  this.timeoutInterval_ = Math.max(0, ms);
};


/**
 * Sets the desired type for the response. At time of writing, this is only
 * supported in very recent versions of WebKit (10.0.612.1 dev and later).
 *
 * If this is used, the response may only be accessed via {@link #getResponse}.
 *
 * @param {goog.net.XhrIo.ResponseType} type The desired type for the response.
 */
goog.net.XhrIo.prototype.setResponseType = function(type) {
  this.responseType_ = type;
};


/**
 * Gets the desired type for the response.
 * @return {goog.net.XhrIo.ResponseType} The desired type for the response.
 */
goog.net.XhrIo.prototype.getResponseType = function() {
  return this.responseType_;
};


/**
 * Sets whether a "credentialed" request that is aware of cookie and
 * authentication information should be made. This option is only supported by
 * browsers that support HTTP Access Control. As of this writing, this option
 * is not supported in IE.
 *
 * @param {boolean} withCredentials Whether this should be a "credentialed"
 *     request.
 */
goog.net.XhrIo.prototype.setWithCredentials = function(withCredentials) {
  this.withCredentials_ = withCredentials;
};


/**
 * Gets whether a "credentialed" request is to be sent.
 * @return {boolean} The desired type for the response.
 */
goog.net.XhrIo.prototype.getWithCredentials = function() {
  return this.withCredentials_;
};


/**
 * Instance send that actually uses XMLHttpRequest to make a server call.
 * @param {string|goog.Uri} url Uri to make request to.
 * @param {string=} opt_method Send method, default: GET.
 * @param {ArrayBuffer|Blob|Document|FormData|GearsBlob|string=} opt_content
 *     Body data.
 * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the
 *     request.
 */
goog.net.XhrIo.prototype.send = function(url, opt_method, opt_content,
                                         opt_headers) {
  if (this.xhr_) {
    throw Error('[goog.net.XhrIo] Object is active with another request=' +
        this.lastUri_ + '; newUri=' + url);
  }

  var method = opt_method ? opt_method.toUpperCase() : 'GET';

  this.lastUri_ = url;
  this.lastError_ = '';
  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;
  this.lastMethod_ = method;
  this.errorDispatched_ = false;
  this.active_ = true;

  // Use the factory to create the XHR object and options
  this.xhr_ = this.createXhr();
  this.xhrOptions_ = this.xmlHttpFactory_ ?
      this.xmlHttpFactory_.getOptions() : goog.net.XmlHttp.getOptions();

  // Set up the onreadystatechange callback
  this.xhr_.onreadystatechange = goog.bind(this.onReadyStateChange_, this);

  /**
   * Try to open the XMLHttpRequest (always async), if an error occurs here it
   * is generally permission denied
   * @preserveTry
   */
  try {
    goog.log.fine(this.logger_, this.formatMsg_('Opening Xhr'));
    this.inOpen_ = true;
    this.xhr_.open(method, url, true);  // Always async!
    this.inOpen_ = false;
  } catch (err) {
    goog.log.fine(this.logger_,
        this.formatMsg_('Error opening Xhr: ' + err.message));
    this.error_(goog.net.ErrorCode.EXCEPTION, err);
    return;
  }

  // We can't use null since this won't allow requests with form data to have a
  // content length specified which will cause some proxies to return a 411
  // error.
  var content = opt_content || '';

  var headers = this.headers.clone();

  // Add headers specific to this request
  if (opt_headers) {
    goog.structs.forEach(opt_headers, function(value, key) {
      headers.set(key, value);
    });
  }

  // Find whether a content type header is set, ignoring case.
  // HTTP header names are case-insensitive.  See:
  // http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
  var contentTypeKey = goog.array.find(headers.getKeys(),
      goog.net.XhrIo.isContentTypeHeader_);

  var contentIsFormData = (goog.global['FormData'] &&
      (content instanceof goog.global['FormData']));
  if (goog.array.contains(goog.net.XhrIo.METHODS_WITH_FORM_DATA, method) &&
      !contentTypeKey && !contentIsFormData) {
    // For requests typically with form data, default to the url-encoded form
    // content type unless this is a FormData request.  For FormData,
    // the browser will automatically add a multipart/form-data content type
    // with an appropriate multipart boundary.
    headers.set(goog.net.XhrIo.CONTENT_TYPE_HEADER,
                goog.net.XhrIo.FORM_CONTENT_TYPE);
  }

  // Add the headers to the Xhr object
  goog.structs.forEach(headers, function(value, key) {
    this.xhr_.setRequestHeader(key, value);
  }, this);

  if (this.responseType_) {
    this.xhr_.responseType = this.responseType_;
  }

  if (goog.object.containsKey(this.xhr_, 'withCredentials')) {
    this.xhr_.withCredentials = this.withCredentials_;
  }

  /**
   * Try to send the request, or other wise report an error (404 not found).
   * @preserveTry
   */
  try {
    this.cleanUpTimeoutTimer_(); // Paranoid, should never be running.
    if (this.timeoutInterval_ > 0) {
      this.useXhr2Timeout_ = goog.net.XhrIo.shouldUseXhr2Timeout_(this.xhr_);
      goog.log.fine(this.logger_, this.formatMsg_('Will abort after ' +
          this.timeoutInterval_ + 'ms if incomplete, xhr2 ' +
          this.useXhr2Timeout_));
      if (this.useXhr2Timeout_) {
        this.xhr_[goog.net.XhrIo.XHR2_TIMEOUT_] = this.timeoutInterval_;
        this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] =
            goog.bind(this.timeout_, this);
      } else {
        this.timeoutId_ = goog.Timer.callOnce(this.timeout_,
            this.timeoutInterval_, this);
      }
    }
    goog.log.fine(this.logger_, this.formatMsg_('Sending request'));
    this.inSend_ = true;
    this.xhr_.send(content);
    this.inSend_ = false;

  } catch (err) {
    goog.log.fine(this.logger_, this.formatMsg_('Send error: ' + err.message));
    this.error_(goog.net.ErrorCode.EXCEPTION, err);
  }
};


/**
 * Determines if the argument is an XMLHttpRequest that supports the level 2
 * timeout value and event.
 *
 * Currently, FF 21.0 OS X has the fields but won't actually call the timeout
 * handler.  Perhaps the confusion in the bug referenced below hasn't
 * entirely been resolved.
 *
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute
 * @see https://bugzilla.mozilla.org/show_bug.cgi?id=525816
 *
 * @param {!goog.net.XhrLike.OrNative|!GearsHttpRequest} xhr The request.
 * @return {boolean} True if the request supports level 2 timeout.
 * @private
 */
goog.net.XhrIo.shouldUseXhr2Timeout_ = function(xhr) {
  return goog.userAgent.IE &&
      goog.userAgent.isVersionOrHigher(9) &&
      goog.isNumber(xhr[goog.net.XhrIo.XHR2_TIMEOUT_]) &&
      goog.isDef(xhr[goog.net.XhrIo.XHR2_ON_TIMEOUT_]);
};


/**
 * @param {string} header An HTTP header key.
 * @return {boolean} Whether the key is a content type header (ignoring
 *     case.
 * @private
 */
goog.net.XhrIo.isContentTypeHeader_ = function(header) {
  return goog.string.caseInsensitiveEquals(
      goog.net.XhrIo.CONTENT_TYPE_HEADER, header);
};


/**
 * Creates a new XHR object.
 * @return {goog.net.XhrLike.OrNative|GearsHttpRequest} The newly created XHR
 *     object.
 * @protected
 */
goog.net.XhrIo.prototype.createXhr = function() {
  return this.xmlHttpFactory_ ?
      this.xmlHttpFactory_.createInstance() : goog.net.XmlHttp();
};


/**
 * The request didn't complete after {@link goog.net.XhrIo#timeoutInterval_}
 * milliseconds; raises a {@link goog.net.EventType.TIMEOUT} event and aborts
 * the request.
 * @private
 */
goog.net.XhrIo.prototype.timeout_ = function() {
  if (typeof goog == 'undefined') {
    // If goog is undefined then the callback has occurred as the application
    // is unloading and will error.  Thus we let it silently fail.
  } else if (this.xhr_) {
    this.lastError_ = 'Timed out after ' + this.timeoutInterval_ +
                      'ms, aborting';
    this.lastErrorCode_ = goog.net.ErrorCode.TIMEOUT;
    goog.log.fine(this.logger_, this.formatMsg_(this.lastError_));
    this.dispatchEvent(goog.net.EventType.TIMEOUT);
    this.abort(goog.net.ErrorCode.TIMEOUT);
  }
};


/**
 * Something errorred, so inactivate, fire error callback and clean up
 * @param {goog.net.ErrorCode} errorCode The error code.
 * @param {Error} err The error object.
 * @private
 */
goog.net.XhrIo.prototype.error_ = function(errorCode, err) {
  this.active_ = false;
  if (this.xhr_) {
    this.inAbort_ = true;
    this.xhr_.abort();  // Ensures XHR isn't hung (FF)
    this.inAbort_ = false;
  }
  this.lastError_ = err;
  this.lastErrorCode_ = errorCode;
  this.dispatchErrors_();
  this.cleanUpXhr_();
};


/**
 * Dispatches COMPLETE and ERROR in case of an error. This ensures that we do
 * not dispatch multiple error events.
 * @private
 */
goog.net.XhrIo.prototype.dispatchErrors_ = function() {
  if (!this.errorDispatched_) {
    this.errorDispatched_ = true;
    this.dispatchEvent(goog.net.EventType.COMPLETE);
    this.dispatchEvent(goog.net.EventType.ERROR);
  }
};


/**
 * Abort the current XMLHttpRequest
 * @param {goog.net.ErrorCode=} opt_failureCode Optional error code to use -
 *     defaults to ABORT.
 */
goog.net.XhrIo.prototype.abort = function(opt_failureCode) {
  if (this.xhr_ && this.active_) {
    goog.log.fine(this.logger_, this.formatMsg_('Aborting'));
    this.active_ = false;
    this.inAbort_ = true;
    this.xhr_.abort();
    this.inAbort_ = false;
    this.lastErrorCode_ = opt_failureCode || goog.net.ErrorCode.ABORT;
    this.dispatchEvent(goog.net.EventType.COMPLETE);
    this.dispatchEvent(goog.net.EventType.ABORT);
    this.cleanUpXhr_();
  }
};


/**
 * Nullifies all callbacks to reduce risks of leaks.
 * @override
 * @protected
 */
goog.net.XhrIo.prototype.disposeInternal = function() {
  if (this.xhr_) {
    // We explicitly do not call xhr_.abort() unless active_ is still true.
    // This is to avoid unnecessarily aborting a successful request when
    // dispose() is called in a callback triggered by a complete response, but
    // in which browser cleanup has not yet finished.
    // (See http://b/issue?id=1684217.)
    if (this.active_) {
      this.active_ = false;
      this.inAbort_ = true;
      this.xhr_.abort();
      this.inAbort_ = false;
    }
    this.cleanUpXhr_(true);
  }

  goog.base(this, 'disposeInternal');
};


/**
 * Internal handler for the XHR object's readystatechange event.  This method
 * checks the status and the readystate and fires the correct callbacks.
 * If the request has ended, the handlers are cleaned up and the XHR object is
 * nullified.
 * @private
 */
goog.net.XhrIo.prototype.onReadyStateChange_ = function() {
  if (this.isDisposed()) {
    // This method is the target of an untracked goog.Timer.callOnce().
    return;
  }
  if (!this.inOpen_ && !this.inSend_ && !this.inAbort_) {
    // Were not being called from within a call to this.xhr_.send
    // this.xhr_.abort, or this.xhr_.open, so this is an entry point
    this.onReadyStateChangeEntryPoint_();
  } else {
    this.onReadyStateChangeHelper_();
  }
};


/**
 * Used to protect the onreadystatechange handler entry point.  Necessary
 * as {#onReadyStateChange_} maybe called from within send or abort, this
 * method is only called when {#onReadyStateChange_} is called as an
 * entry point.
 * {@see #protectEntryPoints}
 * @private
 */
goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ = function() {
  this.onReadyStateChangeHelper_();
};


/**
 * Helper for {@link #onReadyStateChange_}.  This is used so that
 * entry point calls to {@link #onReadyStateChange_} can be routed through
 * {@link #onReadyStateChangeEntryPoint_}.
 * @private
 */
goog.net.XhrIo.prototype.onReadyStateChangeHelper_ = function() {
  if (!this.active_) {
    // can get called inside abort call
    return;
  }

  if (typeof goog == 'undefined') {
    // NOTE(pupius): If goog is undefined then the callback has occurred as the
    // application is unloading and will error.  Thus we let it silently fail.

  } else if (
      this.xhrOptions_[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] &&
      this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE &&
      this.getStatus() == 2) {
    // NOTE(pupius): In IE if send() errors on a *local* request the readystate
    // is still changed to COMPLETE.  We need to ignore it and allow the
    // try/catch around send() to pick up the error.
    goog.log.fine(this.logger_, this.formatMsg_(
        'Local request error detected and ignored'));

  } else {

    // In IE when the response has been cached we sometimes get the callback
    // from inside the send call and this usually breaks code that assumes that
    // XhrIo is asynchronous.  If that is the case we delay the callback
    // using a timer.
    if (this.inSend_ &&
        this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE) {
      goog.Timer.callOnce(this.onReadyStateChange_, 0, this);
      return;
    }

    this.dispatchEvent(goog.net.EventType.READY_STATE_CHANGE);

    // readyState indicates the transfer has finished
    if (this.isComplete()) {
      goog.log.fine(this.logger_, this.formatMsg_('Request complete'));

      this.active_ = false;

      try {
        // Call the specific callbacks for success or failure. Only call the
        // success if the status is 200 (HTTP_OK) or 304 (HTTP_CACHED)
        if (this.isSuccess()) {
          this.dispatchEvent(goog.net.EventType.COMPLETE);
          this.dispatchEvent(goog.net.EventType.SUCCESS);
        } else {
          this.lastErrorCode_ = goog.net.ErrorCode.HTTP_ERROR;
          this.lastError_ =
              this.getStatusText() + ' [' + this.getStatus() + ']';
          this.dispatchErrors_();
        }
      } finally {
        this.cleanUpXhr_();
      }
    }
  }
};


/**
 * Remove the listener to protect against leaks, and nullify the XMLHttpRequest
 * object.
 * @param {boolean=} opt_fromDispose If this is from the dispose (don't want to
 *     fire any events).
 * @private
 */
goog.net.XhrIo.prototype.cleanUpXhr_ = function(opt_fromDispose) {
  if (this.xhr_) {
    // Cancel any pending timeout event handler.
    this.cleanUpTimeoutTimer_();

    // Save reference so we can mark it as closed after the READY event.  The
    // READY event may trigger another request, thus we must nullify this.xhr_
    var xhr = this.xhr_;
    var clearedOnReadyStateChange =
        this.xhrOptions_[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] ?
            goog.nullFunction : null;
    this.xhr_ = null;
    this.xhrOptions_ = null;

    if (!opt_fromDispose) {
      this.dispatchEvent(goog.net.EventType.READY);
    }

    try {
      // NOTE(pupius): Not nullifying in FireFox can still leak if the callbacks
      // are defined in the same scope as the instance of XhrIo. But, IE doesn't
      // allow you to set the onreadystatechange to NULL so nullFunction is
      // used.
      xhr.onreadystatechange = clearedOnReadyStateChange;
    } catch (e) {
      // This seems to occur with a Gears HTTP request. Delayed the setting of
      // this onreadystatechange until after READY is sent out and catching the
      // error to see if we can track down the problem.
      goog.log.error(this.logger_,
          'Problem encountered resetting onreadystatechange: ' + e.message);
    }
  }
};


/**
 * Make sure the timeout timer isn't running.
 * @private
 */
goog.net.XhrIo.prototype.cleanUpTimeoutTimer_ = function() {
  if (this.xhr_ && this.useXhr2Timeout_) {
    this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] = null;
  }
  if (goog.isNumber(this.timeoutId_)) {
    goog.Timer.clear(this.timeoutId_);
    this.timeoutId_ = null;
  }
};


/**
 * @return {boolean} Whether there is an active request.
 */
goog.net.XhrIo.prototype.isActive = function() {
  return !!this.xhr_;
};


/**
 * @return {boolean} Whether the request has completed.
 */
goog.net.XhrIo.prototype.isComplete = function() {
  return this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE;
};


/**
 * @return {boolean} Whether the request completed with a success.
 */
goog.net.XhrIo.prototype.isSuccess = function() {
  var status = this.getStatus();
  // A zero status code is considered successful for local files.
  return goog.net.HttpStatus.isSuccess(status) ||
      status === 0 && !this.isLastUriEffectiveSchemeHttp_();
};


/**
 * @return {boolean} whether the effective scheme of the last URI that was
 *     fetched was 'http' or 'https'.
 * @private
 */
goog.net.XhrIo.prototype.isLastUriEffectiveSchemeHttp_ = function() {
  var scheme = goog.uri.utils.getEffectiveScheme(String(this.lastUri_));
  return goog.net.XhrIo.HTTP_SCHEME_PATTERN.test(scheme);
};


/**
 * Get the readystate from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @return {goog.net.XmlHttp.ReadyState} goog.net.XmlHttp.ReadyState.*.
 */
goog.net.XhrIo.prototype.getReadyState = function() {
  return this.xhr_ ?
      /** @type {goog.net.XmlHttp.ReadyState} */ (this.xhr_.readyState) :
      goog.net.XmlHttp.ReadyState.UNINITIALIZED;
};


/**
 * Get the status from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @return {number} Http status.
 */
goog.net.XhrIo.prototype.getStatus = function() {
  /**
   * IE doesn't like you checking status until the readystate is greater than 2
   * (i.e. it is recieving or complete).  The try/catch is used for when the
   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.
   * @preserveTry
   */
  try {
    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?
        this.xhr_.status : -1;
  } catch (e) {
    goog.log.warning(this.logger_, 'Can not get status: ' + e.message);
    return -1;
  }
};


/**
 * Get the status text from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @return {string} Status text.
 */
goog.net.XhrIo.prototype.getStatusText = function() {
  /**
   * IE doesn't like you checking status until the readystate is greater than 2
   * (i.e. it is recieving or complete).  The try/catch is used for when the
   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.
   * @preserveTry
   */
  try {
    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?
        this.xhr_.statusText : '';
  } catch (e) {
    goog.log.fine(this.logger_, 'Can not get status: ' + e.message);
    return '';
  }
};


/**
 * Get the last Uri that was requested
 * @return {string} Last Uri.
 */
goog.net.XhrIo.prototype.getLastUri = function() {
  return String(this.lastUri_);
};


/**
 * Get the response text from the Xhr object
 * Will only return correct result when called from the context of a callback.
 * @return {string} Result from the server, or '' if no result available.
 */
goog.net.XhrIo.prototype.getResponseText = function() {
  /** @preserveTry */
  try {
    return this.xhr_ ? this.xhr_.responseText : '';
  } catch (e) {
    // http://www.w3.org/TR/XMLHttpRequest/#the-responsetext-attribute
    // states that responseText should return '' (and responseXML null)
    // when the state is not LOADING or DONE. Instead, IE and Gears can
    // throw unexpected exceptions, for example when a request is aborted
    // or no data is available yet.
    goog.log.fine(this.logger_, 'Can not get responseText: ' + e.message);
    return '';
  }
};


/**
 * Get the response body from the Xhr object. This property is only available
 * in IE since version 7 according to MSDN:
 * http://msdn.microsoft.com/en-us/library/ie/ms534368(v=vs.85).aspx
 * Will only return correct result when called from the context of a callback.
 *
 * One option is to construct a VBArray from the returned object and convert
 * it to a JavaScript array using the toArray method:
 * {@code (new window['VBArray'](xhrIo.getResponseBody())).toArray()}
 * This will result in an array of numbers in the range of [0..255]
 *
 * Another option is to use the VBScript CStr method to convert it into a
 * string as outlined in http://stackoverflow.com/questions/1919972
 *
 * @return {Object} Binary result from the server or null if not available.
 */
goog.net.XhrIo.prototype.getResponseBody = function() {
  /** @preserveTry */
  try {
    if (this.xhr_ && 'responseBody' in this.xhr_) {
      return this.xhr_['responseBody'];
    }
  } catch (e) {
    // IE can throw unexpected exceptions, for example when a request is aborted
    // or no data is yet available.
    goog.log.fine(this.logger_, 'Can not get responseBody: ' + e.message);
  }
  return null;
};


/**
 * Get the response XML from the Xhr object
 * Will only return correct result when called from the context of a callback.
 * @return {Document} The DOM Document representing the XML file, or null
 * if no result available.
 */
goog.net.XhrIo.prototype.getResponseXml = function() {
  /** @preserveTry */
  try {
    return this.xhr_ ? this.xhr_.responseXML : null;
  } catch (e) {
    goog.log.fine(this.logger_, 'Can not get responseXML: ' + e.message);
    return null;
  }
};


/**
 * Get the response and evaluates it as JSON from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @param {string=} opt_xssiPrefix Optional XSSI prefix string to use for
 *     stripping of the response before parsing. This needs to be set only if
 *     your backend server prepends the same prefix string to the JSON response.
 * @return {Object|undefined} JavaScript object.
 */
goog.net.XhrIo.prototype.getResponseJson = function(opt_xssiPrefix) {
  if (!this.xhr_) {
    return undefined;
  }

  var responseText = this.xhr_.responseText;
  if (opt_xssiPrefix && responseText.indexOf(opt_xssiPrefix) == 0) {
    responseText = responseText.substring(opt_xssiPrefix.length);
  }

  return goog.json.parse(responseText);
};


/**
 * Get the response as the type specificed by {@link #setResponseType}. At time
 * of writing, this is only directly supported in very recent versions of WebKit
 * (10.0.612.1 dev and later). If the field is not supported directly, we will
 * try to emulate it.
 *
 * Emulating the response means following the rules laid out at
 * http://www.w3.org/TR/XMLHttpRequest/#the-response-attribute
 *
 * On browsers with no support for this (Chrome < 10, Firefox < 4, etc), only
 * response types of DEFAULT or TEXT may be used, and the response returned will
 * be the text response.
 *
 * On browsers with Mozilla's draft support for array buffers (Firefox 4, 5),
 * only response types of DEFAULT, TEXT, and ARRAY_BUFFER may be used, and the
 * response returned will be either the text response or the Mozilla
 * implementation of the array buffer response.
 *
 * On browsers will full support, any valid response type supported by the
 * browser may be used, and the response provided by the browser will be
 * returned.
 *
 * @return {*} The response.
 */
goog.net.XhrIo.prototype.getResponse = function() {
  /** @preserveTry */
  try {
    if (!this.xhr_) {
      return null;
    }
    if ('response' in this.xhr_) {
      return this.xhr_.response;
    }
    switch (this.responseType_) {
      case goog.net.XhrIo.ResponseType.DEFAULT:
      case goog.net.XhrIo.ResponseType.TEXT:
        return this.xhr_.responseText;
        // DOCUMENT and BLOB don't need to be handled here because they are
        // introduced in the same spec that adds the .response field, and would
        // have been caught above.
        // ARRAY_BUFFER needs an implementation for Firefox 4, where it was
        // implemented using a draft spec rather than the final spec.
      case goog.net.XhrIo.ResponseType.ARRAY_BUFFER:
        if ('mozResponseArrayBuffer' in this.xhr_) {
          return this.xhr_.mozResponseArrayBuffer;
        }
    }
    // Fell through to a response type that is not supported on this browser.
    goog.log.error(this.logger_,
        'Response type ' + this.responseType_ + ' is not ' +
        'supported on this browser');
    return null;
  } catch (e) {
    goog.log.fine(this.logger_, 'Can not get response: ' + e.message);
    return null;
  }
};


/**
 * Get the value of the response-header with the given name from the Xhr object
 * Will only return correct result when called from the context of a callback
 * and the request has completed
 * @param {string} key The name of the response-header to retrieve.
 * @return {string|undefined} The value of the response-header named key.
 */
goog.net.XhrIo.prototype.getResponseHeader = function(key) {
  return this.xhr_ && this.isComplete() ?
      this.xhr_.getResponseHeader(key) : undefined;
};


/**
 * Gets the text of all the headers in the response.
 * Will only return correct result when called from the context of a callback
 * and the request has completed.
 * @return {string} The value of the response headers or empty string.
 */
goog.net.XhrIo.prototype.getAllResponseHeaders = function() {
  return this.xhr_ && this.isComplete() ?
      this.xhr_.getAllResponseHeaders() : '';
};


/**
 * Returns all response headers as a key-value map.
 * Multiple values for the same header key can be combined into one,
 * separated by a comma and a space.
 * Note that the native getResponseHeader method for retrieving a single header
 * does a case insensitive match on the header name. This method does not
 * include any case normalization logic, it will just return a key-value
 * representation of the headers.
 * See: http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method
 * @return {!Object.<string, string>} An object with the header keys as keys
 *     and header values as values.
 */
goog.net.XhrIo.prototype.getResponseHeaders = function() {
  var headersObject = {};
  var headersArray = this.getAllResponseHeaders().split('\r\n');
  for (var i = 0; i < headersArray.length; i++) {
    if (goog.string.isEmpty(headersArray[i])) {
      continue;
    }
    var keyValue = goog.string.splitLimit(headersArray[i], ': ', 2);
    if (headersObject[keyValue[0]]) {
      headersObject[keyValue[0]] += ', ' + keyValue[1];
    } else {
      headersObject[keyValue[0]] = keyValue[1];
    }
  }
  return headersObject;
};


/**
 * Get the last error message
 * @return {goog.net.ErrorCode} Last error code.
 */
goog.net.XhrIo.prototype.getLastErrorCode = function() {
  return this.lastErrorCode_;
};


/**
 * Get the last error message
 * @return {string} Last error message.
 */
goog.net.XhrIo.prototype.getLastError = function() {
  return goog.isString(this.lastError_) ? this.lastError_ :
      String(this.lastError_);
};


/**
 * Adds the last method, status and URI to the message.  This is used to add
 * this information to the logging calls.
 * @param {string} msg The message text that we want to add the extra text to.
 * @return {string} The message with the extra text appended.
 * @private
 */
goog.net.XhrIo.prototype.formatMsg_ = function(msg) {
  return msg + ' [' + this.lastMethod_ + ' ' + this.lastUri_ + ' ' +
      this.getStatus() + ']';
};


// Register the xhr handler as an entry point, so that
// it can be monitored for exception handling, etc.
goog.debug.entryPointRegistry.register(
    /**
     * @param {function(!Function): !Function} transformer The transforming
     *     function.
     */
    function(transformer) {
      goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =
          transformer(goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);
    });

//javascript/closure/uri/uri.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Class for parsing and formatting URIs.
 *
 * Use goog.Uri(string) to parse a URI string.  Use goog.Uri.create(...) to
 * create a new instance of the goog.Uri object from Uri parts.
 *
 * e.g: <code>var myUri = new goog.Uri(window.location);</code>
 *
 * Implements RFC 3986 for parsing/formatting URIs.
 * http://www.ietf.org/rfc/rfc3986.txt
 *
 * Some changes have been made to the interface (more like .NETs), though the
 * internal representation is now of un-encoded parts, this will change the
 * behavior slightly.
 *
 * @author msamuel@google.com (Mike Samuel)
 * @author pupius@google.com (Dan Pupius) - Ported to Closure
 * @author jonp@google.com (Jon Perlow) - Optimized for IE6
 * @author micapolos@google.com (Michal Pociecha-Los) - Dot segments removal
 */

goog.provide('goog.Uri');
goog.provide('goog.Uri.QueryData');

goog.require('goog.array');
goog.require('goog.string');
goog.require('goog.structs');
goog.require('goog.structs.Map');
goog.require('goog.uri.utils');
goog.require('goog.uri.utils.ComponentIndex');
goog.require('goog.uri.utils.StandardQueryParam');



/**
 * This class contains setters and getters for the parts of the URI.
 * The <code>getXyz</code>/<code>setXyz</code> methods return the decoded part
 * -- so<code>goog.Uri.parse('/foo%20bar').getPath()</code> will return the
 * decoded path, <code>/foo bar</code>.
 *
 * The constructor accepts an optional unparsed, raw URI string.  The parser
 * is relaxed, so special characters that aren't escaped but don't cause
 * ambiguities will not cause parse failures.
 *
 * All setters return <code>this</code> and so may be chained, a la
 * <code>goog.Uri.parse('/foo').setFragment('part').toString()</code>.
 *
 * @param {*=} opt_uri Optional string URI to parse
 *        (use goog.Uri.create() to create a URI from parts), or if
 *        a goog.Uri is passed, a clone is created.
 * @param {boolean=} opt_ignoreCase If true, #getParameterValue will ignore
 * the case of the parameter name.
 *
 * @constructor
 */
goog.Uri = function(opt_uri, opt_ignoreCase) {
  // Parse in the uri string
  var m;
  if (opt_uri instanceof goog.Uri) {
    this.ignoreCase_ = goog.isDef(opt_ignoreCase) ?
        opt_ignoreCase : opt_uri.getIgnoreCase();
    this.setScheme(opt_uri.getScheme());
    this.setUserInfo(opt_uri.getUserInfo());
    this.setDomain(opt_uri.getDomain());
    this.setPort(opt_uri.getPort());
    this.setPath(opt_uri.getPath());
    this.setQueryData(opt_uri.getQueryData().clone());
    this.setFragment(opt_uri.getFragment());
  } else if (opt_uri && (m = goog.uri.utils.split(String(opt_uri)))) {
    this.ignoreCase_ = !!opt_ignoreCase;

    // Set the parts -- decoding as we do so.
    // COMPATABILITY NOTE - In IE, unmatched fields may be empty strings,
    // whereas in other browsers they will be undefined.
    this.setScheme(m[goog.uri.utils.ComponentIndex.SCHEME] || '', true);
    this.setUserInfo(m[goog.uri.utils.ComponentIndex.USER_INFO] || '', true);
    this.setDomain(m[goog.uri.utils.ComponentIndex.DOMAIN] || '', true);
    this.setPort(m[goog.uri.utils.ComponentIndex.PORT]);
    this.setPath(m[goog.uri.utils.ComponentIndex.PATH] || '', true);
    this.setQueryData(m[goog.uri.utils.ComponentIndex.QUERY_DATA] || '', true);
    this.setFragment(m[goog.uri.utils.ComponentIndex.FRAGMENT] || '', true);

  } else {
    this.ignoreCase_ = !!opt_ignoreCase;
    this.queryData_ = new goog.Uri.QueryData(null, null, this.ignoreCase_);
  }
};


/**
 * If true, we preserve the type of query parameters set programmatically.
 *
 * This means that if you set a parameter to a boolean, and then call
 * getParameterValue, you will get a boolean back.
 *
 * If false, we will coerce parameters to strings, just as they would
 * appear in real URIs.
 *
 * TODO(nicksantos): Remove this once people have time to fix all tests.
 *
 * @type {boolean}
 */
goog.Uri.preserveParameterTypesCompatibilityFlag = false;


/**
 * Parameter name added to stop caching.
 * @type {string}
 */
goog.Uri.RANDOM_PARAM = goog.uri.utils.StandardQueryParam.RANDOM;


/**
 * Scheme such as "http".
 * @type {string}
 * @private
 */
goog.Uri.prototype.scheme_ = '';


/**
 * User credentials in the form "username:password".
 * @type {string}
 * @private
 */
goog.Uri.prototype.userInfo_ = '';


/**
 * Domain part, e.g. "www.google.com".
 * @type {string}
 * @private
 */
goog.Uri.prototype.domain_ = '';


/**
 * Port, e.g. 8080.
 * @type {?number}
 * @private
 */
goog.Uri.prototype.port_ = null;


/**
 * Path, e.g. "/tests/img.png".
 * @type {string}
 * @private
 */
goog.Uri.prototype.path_ = '';


/**
 * Object representing query data.
 * @type {!goog.Uri.QueryData}
 * @private
 */
goog.Uri.prototype.queryData_;


/**
 * The fragment without the #.
 * @type {string}
 * @private
 */
goog.Uri.prototype.fragment_ = '';


/**
 * Whether or not this Uri should be treated as Read Only.
 * @type {boolean}
 * @private
 */
goog.Uri.prototype.isReadOnly_ = false;


/**
 * Whether or not to ignore case when comparing query params.
 * @type {boolean}
 * @private
 */
goog.Uri.prototype.ignoreCase_ = false;


/**
 * @return {string} The string form of the url.
 * @override
 */
goog.Uri.prototype.toString = function() {
  var out = [];

  var scheme = this.getScheme();
  if (scheme) {
    out.push(goog.Uri.encodeSpecialChars_(
        scheme, goog.Uri.reDisallowedInSchemeOrUserInfo_), ':');
  }

  var domain = this.getDomain();
  if (domain) {
    out.push('//');

    var userInfo = this.getUserInfo();
    if (userInfo) {
      out.push(goog.Uri.encodeSpecialChars_(
          userInfo, goog.Uri.reDisallowedInSchemeOrUserInfo_), '@');
    }

    out.push(goog.string.urlEncode(domain));

    var port = this.getPort();
    if (port != null) {
      out.push(':', String(port));
    }
  }

  var path = this.getPath();
  if (path) {
    if (this.hasDomain() && path.charAt(0) != '/') {
      out.push('/');
    }
    out.push(goog.Uri.encodeSpecialChars_(
        path,
        path.charAt(0) == '/' ?
            goog.Uri.reDisallowedInAbsolutePath_ :
            goog.Uri.reDisallowedInRelativePath_));
  }

  var query = this.getEncodedQuery();
  if (query) {
    out.push('?', query);
  }

  var fragment = this.getFragment();
  if (fragment) {
    out.push('#', goog.Uri.encodeSpecialChars_(
        fragment, goog.Uri.reDisallowedInFragment_));
  }
  return out.join('');
};


/**
 * Resolves the given relative URI (a goog.Uri object), using the URI
 * represented by this instance as the base URI.
 *
 * There are several kinds of relative URIs:<br>
 * 1. foo - replaces the last part of the path, the whole query and fragment<br>
 * 2. /foo - replaces the the path, the query and fragment<br>
 * 3. //foo - replaces everything from the domain on.  foo is a domain name<br>
 * 4. ?foo - replace the query and fragment<br>
 * 5. #foo - replace the fragment only
 *
 * Additionally, if relative URI has a non-empty path, all ".." and "."
 * segments will be resolved, as described in RFC 3986.
 *
 * @param {goog.Uri} relativeUri The relative URI to resolve.
 * @return {!goog.Uri} The resolved URI.
 */
goog.Uri.prototype.resolve = function(relativeUri) {

  var absoluteUri = this.clone();

  // we satisfy these conditions by looking for the first part of relativeUri
  // that is not blank and applying defaults to the rest

  var overridden = relativeUri.hasScheme();

  if (overridden) {
    absoluteUri.setScheme(relativeUri.getScheme());
  } else {
    overridden = relativeUri.hasUserInfo();
  }

  if (overridden) {
    absoluteUri.setUserInfo(relativeUri.getUserInfo());
  } else {
    overridden = relativeUri.hasDomain();
  }

  if (overridden) {
    absoluteUri.setDomain(relativeUri.getDomain());
  } else {
    overridden = relativeUri.hasPort();
  }

  var path = relativeUri.getPath();
  if (overridden) {
    absoluteUri.setPort(relativeUri.getPort());
  } else {
    overridden = relativeUri.hasPath();
    if (overridden) {
      // resolve path properly
      if (path.charAt(0) != '/') {
        // path is relative
        if (this.hasDomain() && !this.hasPath()) {
          // RFC 3986, section 5.2.3, case 1
          path = '/' + path;
        } else {
          // RFC 3986, section 5.2.3, case 2
          var lastSlashIndex = absoluteUri.getPath().lastIndexOf('/');
          if (lastSlashIndex != -1) {
            path = absoluteUri.getPath().substr(0, lastSlashIndex + 1) + path;
          }
        }
      }
      path = goog.Uri.removeDotSegments(path);
    }
  }

  if (overridden) {
    absoluteUri.setPath(path);
  } else {
    overridden = relativeUri.hasQuery();
  }

  if (overridden) {
    absoluteUri.setQueryData(relativeUri.getDecodedQuery());
  } else {
    overridden = relativeUri.hasFragment();
  }

  if (overridden) {
    absoluteUri.setFragment(relativeUri.getFragment());
  }

  return absoluteUri;
};


/**
 * Clones the URI instance.
 * @return {!goog.Uri} New instance of the URI objcet.
 */
goog.Uri.prototype.clone = function() {
  return new goog.Uri(this);
};


/**
 * @return {string} The encoded scheme/protocol for the URI.
 */
goog.Uri.prototype.getScheme = function() {
  return this.scheme_;
};


/**
 * Sets the scheme/protocol.
 * @param {string} newScheme New scheme value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setScheme = function(newScheme, opt_decode) {
  this.enforceReadOnly();
  this.scheme_ = opt_decode ? goog.Uri.decodeOrEmpty_(newScheme) : newScheme;

  // remove an : at the end of the scheme so somebody can pass in
  // window.location.protocol
  if (this.scheme_) {
    this.scheme_ = this.scheme_.replace(/:$/, '');
  }
  return this;
};


/**
 * @return {boolean} Whether the scheme has been set.
 */
goog.Uri.prototype.hasScheme = function() {
  return !!this.scheme_;
};


/**
 * @return {string} The decoded user info.
 */
goog.Uri.prototype.getUserInfo = function() {
  return this.userInfo_;
};


/**
 * Sets the userInfo.
 * @param {string} newUserInfo New userInfo value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setUserInfo = function(newUserInfo, opt_decode) {
  this.enforceReadOnly();
  this.userInfo_ = opt_decode ? goog.Uri.decodeOrEmpty_(newUserInfo) :
                   newUserInfo;
  return this;
};


/**
 * @return {boolean} Whether the user info has been set.
 */
goog.Uri.prototype.hasUserInfo = function() {
  return !!this.userInfo_;
};


/**
 * @return {string} The decoded domain.
 */
goog.Uri.prototype.getDomain = function() {
  return this.domain_;
};


/**
 * Sets the domain.
 * @param {string} newDomain New domain value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setDomain = function(newDomain, opt_decode) {
  this.enforceReadOnly();
  this.domain_ = opt_decode ? goog.Uri.decodeOrEmpty_(newDomain) : newDomain;
  return this;
};


/**
 * @return {boolean} Whether the domain has been set.
 */
goog.Uri.prototype.hasDomain = function() {
  return !!this.domain_;
};


/**
 * @return {?number} The port number.
 */
goog.Uri.prototype.getPort = function() {
  return this.port_;
};


/**
 * Sets the port number.
 * @param {*} newPort Port number. Will be explicitly casted to a number.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setPort = function(newPort) {
  this.enforceReadOnly();

  if (newPort) {
    newPort = Number(newPort);
    if (isNaN(newPort) || newPort < 0) {
      throw Error('Bad port number ' + newPort);
    }
    this.port_ = newPort;
  } else {
    this.port_ = null;
  }

  return this;
};


/**
 * @return {boolean} Whether the port has been set.
 */
goog.Uri.prototype.hasPort = function() {
  return this.port_ != null;
};


/**
  * @return {string} The decoded path.
 */
goog.Uri.prototype.getPath = function() {
  return this.path_;
};


/**
 * Sets the path.
 * @param {string} newPath New path value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setPath = function(newPath, opt_decode) {
  this.enforceReadOnly();
  this.path_ = opt_decode ? goog.Uri.decodeOrEmpty_(newPath) : newPath;
  return this;
};


/**
 * @return {boolean} Whether the path has been set.
 */
goog.Uri.prototype.hasPath = function() {
  return !!this.path_;
};


/**
 * @return {boolean} Whether the query string has been set.
 */
goog.Uri.prototype.hasQuery = function() {
  return this.queryData_.toString() !== '';
};


/**
 * Sets the query data.
 * @param {goog.Uri.QueryData|string|undefined} queryData QueryData object.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 *     Applies only if queryData is a string.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setQueryData = function(queryData, opt_decode) {
  this.enforceReadOnly();

  if (queryData instanceof goog.Uri.QueryData) {
    this.queryData_ = queryData;
    this.queryData_.setIgnoreCase(this.ignoreCase_);
  } else {
    if (!opt_decode) {
      // QueryData accepts encoded query string, so encode it if
      // opt_decode flag is not true.
      queryData = goog.Uri.encodeSpecialChars_(queryData,
                                               goog.Uri.reDisallowedInQuery_);
    }
    this.queryData_ = new goog.Uri.QueryData(queryData, null, this.ignoreCase_);
  }

  return this;
};


/**
 * Sets the URI query.
 * @param {string} newQuery New query value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setQuery = function(newQuery, opt_decode) {
  return this.setQueryData(newQuery, opt_decode);
};


/**
 * @return {string} The encoded URI query, not including the ?.
 */
goog.Uri.prototype.getEncodedQuery = function() {
  return this.queryData_.toString();
};


/**
 * @return {string} The decoded URI query, not including the ?.
 */
goog.Uri.prototype.getDecodedQuery = function() {
  return this.queryData_.toDecodedString();
};


/**
 * Returns the query data.
 * @return {goog.Uri.QueryData} QueryData object.
 */
goog.Uri.prototype.getQueryData = function() {
  return this.queryData_;
};


/**
 * @return {string} The encoded URI query, not including the ?.
 *
 * Warning: This method, unlike other getter methods, returns encoded
 * value, instead of decoded one.
 */
goog.Uri.prototype.getQuery = function() {
  return this.getEncodedQuery();
};


/**
 * Sets the value of the named query parameters, clearing previous values for
 * that key.
 *
 * @param {string} key The parameter to set.
 * @param {*} value The new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setParameterValue = function(key, value) {
  this.enforceReadOnly();
  this.queryData_.set(key, value);
  return this;
};


/**
 * Sets the values of the named query parameters, clearing previous values for
 * that key.  Not new values will currently be moved to the end of the query
 * string.
 *
 * So, <code>goog.Uri.parse('foo?a=b&c=d&e=f').setParameterValues('c', ['new'])
 * </code> yields <tt>foo?a=b&e=f&c=new</tt>.</p>
 *
 * @param {string} key The parameter to set.
 * @param {*} values The new values. If values is a single
 *     string then it will be treated as the sole value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setParameterValues = function(key, values) {
  this.enforceReadOnly();

  if (!goog.isArray(values)) {
    values = [String(values)];
  }

  // TODO(nicksantos): This cast shouldn't be necessary.
  this.queryData_.setValues(key, /** @type {Array} */ (values));

  return this;
};


/**
 * Returns the value<b>s</b> for a given cgi parameter as a list of decoded
 * query parameter values.
 * @param {string} name The parameter to get values for.
 * @return {Array} The values for a given cgi parameter as a list of
 *     decoded query parameter values.
 */
goog.Uri.prototype.getParameterValues = function(name) {
  return this.queryData_.getValues(name);
};


/**
 * Returns the first value for a given cgi parameter or undefined if the given
 * parameter name does not appear in the query string.
 * @param {string} paramName Unescaped parameter name.
 * @return {string|undefined} The first value for a given cgi parameter or
 *     undefined if the given parameter name does not appear in the query
 *     string.
 */
goog.Uri.prototype.getParameterValue = function(paramName) {
  // NOTE(nicksantos): This type-cast is a lie when
  // preserveParameterTypesCompatibilityFlag is set to true.
  // But this should only be set to true in tests.
  return /** @type {string|undefined} */ (this.queryData_.get(paramName));
};


/**
 * @return {string} The URI fragment, not including the #.
 */
goog.Uri.prototype.getFragment = function() {
  return this.fragment_;
};


/**
 * Sets the URI fragment.
 * @param {string} newFragment New fragment value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setFragment = function(newFragment, opt_decode) {
  this.enforceReadOnly();
  this.fragment_ = opt_decode ? goog.Uri.decodeOrEmpty_(newFragment) :
                   newFragment;
  return this;
};


/**
 * @return {boolean} Whether the URI has a fragment set.
 */
goog.Uri.prototype.hasFragment = function() {
  return !!this.fragment_;
};


/**
 * Returns true if this has the same domain as that of uri2.
 * @param {goog.Uri} uri2 The URI object to compare to.
 * @return {boolean} true if same domain; false otherwise.
 */
goog.Uri.prototype.hasSameDomainAs = function(uri2) {
  return ((!this.hasDomain() && !uri2.hasDomain()) ||
          this.getDomain() == uri2.getDomain()) &&
      ((!this.hasPort() && !uri2.hasPort()) ||
          this.getPort() == uri2.getPort());
};


/**
 * Adds a random parameter to the Uri.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.makeUnique = function() {
  this.enforceReadOnly();
  this.setParameterValue(goog.Uri.RANDOM_PARAM, goog.string.getRandomString());

  return this;
};


/**
 * Removes the named query parameter.
 *
 * @param {string} key The parameter to remove.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.removeParameter = function(key) {
  this.enforceReadOnly();
  this.queryData_.remove(key);
  return this;
};


/**
 * Sets whether Uri is read only. If this goog.Uri is read-only,
 * enforceReadOnly_ will be called at the start of any function that may modify
 * this Uri.
 * @param {boolean} isReadOnly whether this goog.Uri should be read only.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.setReadOnly = function(isReadOnly) {
  this.isReadOnly_ = isReadOnly;
  return this;
};


/**
 * @return {boolean} Whether the URI is read only.
 */
goog.Uri.prototype.isReadOnly = function() {
  return this.isReadOnly_;
};


/**
 * Checks if this Uri has been marked as read only, and if so, throws an error.
 * This should be called whenever any modifying function is called.
 */
goog.Uri.prototype.enforceReadOnly = function() {
  if (this.isReadOnly_) {
    throw Error('Tried to modify a read-only Uri');
  }
};


/**
 * Sets whether to ignore case.
 * NOTE: If there are already key/value pairs in the QueryData, and
 * ignoreCase_ is set to false, the keys will all be lower-cased.
 * @param {boolean} ignoreCase whether this goog.Uri should ignore case.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.setIgnoreCase = function(ignoreCase) {
  this.ignoreCase_ = ignoreCase;
  if (this.queryData_) {
    this.queryData_.setIgnoreCase(ignoreCase);
  }
  return this;
};


/**
 * @return {boolean} Whether to ignore case.
 */
goog.Uri.prototype.getIgnoreCase = function() {
  return this.ignoreCase_;
};


//==============================================================================
// Static members
//==============================================================================


/**
 * Creates a uri from the string form.  Basically an alias of new goog.Uri().
 * If a Uri object is passed to parse then it will return a clone of the object.
 *
 * @param {*} uri Raw URI string or instance of Uri
 *     object.
 * @param {boolean=} opt_ignoreCase Whether to ignore the case of parameter
 * names in #getParameterValue.
 * @return {!goog.Uri} The new URI object.
 */
goog.Uri.parse = function(uri, opt_ignoreCase) {
  return uri instanceof goog.Uri ?
         uri.clone() : new goog.Uri(uri, opt_ignoreCase);
};


/**
 * Creates a new goog.Uri object from unencoded parts.
 *
 * @param {?string=} opt_scheme Scheme/protocol or full URI to parse.
 * @param {?string=} opt_userInfo username:password.
 * @param {?string=} opt_domain www.google.com.
 * @param {?number=} opt_port 9830.
 * @param {?string=} opt_path /some/path/to/a/file.html.
 * @param {string|goog.Uri.QueryData=} opt_query a=1&b=2.
 * @param {?string=} opt_fragment The fragment without the #.
 * @param {boolean=} opt_ignoreCase Whether to ignore parameter name case in
 *     #getParameterValue.
 *
 * @return {!goog.Uri} The new URI object.
 */
goog.Uri.create = function(opt_scheme, opt_userInfo, opt_domain, opt_port,
                           opt_path, opt_query, opt_fragment, opt_ignoreCase) {

  var uri = new goog.Uri(null, opt_ignoreCase);

  // Only set the parts if they are defined and not empty strings.
  opt_scheme && uri.setScheme(opt_scheme);
  opt_userInfo && uri.setUserInfo(opt_userInfo);
  opt_domain && uri.setDomain(opt_domain);
  opt_port && uri.setPort(opt_port);
  opt_path && uri.setPath(opt_path);
  opt_query && uri.setQueryData(opt_query);
  opt_fragment && uri.setFragment(opt_fragment);

  return uri;
};


/**
 * Resolves a relative Uri against a base Uri, accepting both strings and
 * Uri objects.
 *
 * @param {*} base Base Uri.
 * @param {*} rel Relative Uri.
 * @return {!goog.Uri} Resolved uri.
 */
goog.Uri.resolve = function(base, rel) {
  if (!(base instanceof goog.Uri)) {
    base = goog.Uri.parse(base);
  }

  if (!(rel instanceof goog.Uri)) {
    rel = goog.Uri.parse(rel);
  }

  return base.resolve(rel);
};


/**
 * Removes dot segments in given path component, as described in
 * RFC 3986, section 5.2.4.
 *
 * @param {string} path A non-empty path component.
 * @return {string} Path component with removed dot segments.
 */
goog.Uri.removeDotSegments = function(path) {
  if (path == '..' || path == '.') {
    return '';

  } else if (!goog.string.contains(path, './') &&
             !goog.string.contains(path, '/.')) {
    // This optimization detects uris which do not contain dot-segments,
    // and as a consequence do not require any processing.
    return path;

  } else {
    var leadingSlash = goog.string.startsWith(path, '/');
    var segments = path.split('/');
    var out = [];

    for (var pos = 0; pos < segments.length; ) {
      var segment = segments[pos++];

      if (segment == '.') {
        if (leadingSlash && pos == segments.length) {
          out.push('');
        }
      } else if (segment == '..') {
        if (out.length > 1 || out.length == 1 && out[0] != '') {
          out.pop();
        }
        if (leadingSlash && pos == segments.length) {
          out.push('');
        }
      } else {
        out.push(segment);
        leadingSlash = true;
      }
    }

    return out.join('/');
  }
};


/**
 * Decodes a value or returns the empty string if it isn't defined or empty.
 * @param {string|undefined} val Value to decode.
 * @return {string} Decoded value.
 * @private
 */
goog.Uri.decodeOrEmpty_ = function(val) {
  // Don't use UrlDecode() here because val is not a query parameter.
  return val ? decodeURIComponent(val) : '';
};


/**
 * If unescapedPart is non null, then escapes any characters in it that aren't
 * valid characters in a url and also escapes any special characters that
 * appear in extra.
 *
 * @param {*} unescapedPart The string to encode.
 * @param {RegExp} extra A character set of characters in [\01-\177].
 * @return {?string} null iff unescapedPart == null.
 * @private
 */
goog.Uri.encodeSpecialChars_ = function(unescapedPart, extra) {
  if (goog.isString(unescapedPart)) {
    return encodeURI(unescapedPart).replace(extra, goog.Uri.encodeChar_);
  }
  return null;
};


/**
 * Converts a character in [\01-\177] to its unicode character equivalent.
 * @param {string} ch One character string.
 * @return {string} Encoded string.
 * @private
 */
goog.Uri.encodeChar_ = function(ch) {
  var n = ch.charCodeAt(0);
  return '%' + ((n >> 4) & 0xf).toString(16) + (n & 0xf).toString(16);
};


/**
 * Regular expression for characters that are disallowed in the scheme or
 * userInfo part of the URI.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInSchemeOrUserInfo_ = /[#\/\?@]/g;


/**
 * Regular expression for characters that are disallowed in a relative path.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInRelativePath_ = /[\#\?:]/g;


/**
 * Regular expression for characters that are disallowed in an absolute path.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInAbsolutePath_ = /[\#\?]/g;


/**
 * Regular expression for characters that are disallowed in the query.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInQuery_ = /[\#\?@]/g;


/**
 * Regular expression for characters that are disallowed in the fragment.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInFragment_ = /#/g;


/**
 * Checks whether two URIs have the same domain.
 * @param {string} uri1String First URI string.
 * @param {string} uri2String Second URI string.
 * @return {boolean} true if the two URIs have the same domain; false otherwise.
 */
goog.Uri.haveSameDomain = function(uri1String, uri2String) {
  // Differs from goog.uri.utils.haveSameDomain, since this ignores scheme.
  // TODO(gboyer): Have this just call goog.uri.util.haveSameDomain.
  var pieces1 = goog.uri.utils.split(uri1String);
  var pieces2 = goog.uri.utils.split(uri2String);
  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==
             pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&
         pieces1[goog.uri.utils.ComponentIndex.PORT] ==
             pieces2[goog.uri.utils.ComponentIndex.PORT];
};



/**
 * Class used to represent URI query parameters.  It is essentially a hash of
 * name-value pairs, though a name can be present more than once.
 *
 * Has the same interface as the collections in goog.structs.
 *
 * @param {?string=} opt_query Optional encoded query string to parse into
 *     the object.
 * @param {goog.Uri=} opt_uri Optional uri object that should have its
 *     cache invalidated when this object updates. Deprecated -- this
 *     is no longer required.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @constructor
 * @final
 */
goog.Uri.QueryData = function(opt_query, opt_uri, opt_ignoreCase) {
  /**
   * Encoded query string, or null if it requires computing from the key map.
   * @type {?string}
   * @private
   */
  this.encodedQuery_ = opt_query || null;

  /**
   * If true, ignore the case of the parameter name in #get.
   * @type {boolean}
   * @private
   */
  this.ignoreCase_ = !!opt_ignoreCase;
};


/**
 * If the underlying key map is not yet initialized, it parses the
 * query string and fills the map with parsed data.
 * @private
 */
goog.Uri.QueryData.prototype.ensureKeyMapInitialized_ = function() {
  if (!this.keyMap_) {
    this.keyMap_ = new goog.structs.Map();
    this.count_ = 0;

    if (this.encodedQuery_) {
      var pairs = this.encodedQuery_.split('&');
      for (var i = 0; i < pairs.length; i++) {
        var indexOfEquals = pairs[i].indexOf('=');
        var name = null;
        var value = null;
        if (indexOfEquals >= 0) {
          name = pairs[i].substring(0, indexOfEquals);
          value = pairs[i].substring(indexOfEquals + 1);
        } else {
          name = pairs[i];
        }
        name = goog.string.urlDecode(name);
        name = this.getKeyName_(name);
        this.add(name, value ? goog.string.urlDecode(value) : '');
      }
    }
  }
};


/**
 * Creates a new query data instance from a map of names and values.
 *
 * @param {!goog.structs.Map|!Object} map Map of string parameter
 *     names to parameter value. If parameter value is an array, it is
 *     treated as if the key maps to each individual value in the
 *     array.
 * @param {goog.Uri=} opt_uri URI object that should have its cache
 *     invalidated when this object updates.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @return {!goog.Uri.QueryData} The populated query data instance.
 */
goog.Uri.QueryData.createFromMap = function(map, opt_uri, opt_ignoreCase) {
  var keys = goog.structs.getKeys(map);
  if (typeof keys == 'undefined') {
    throw Error('Keys are undefined');
  }

  var queryData = new goog.Uri.QueryData(null, null, opt_ignoreCase);
  var values = goog.structs.getValues(map);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = values[i];
    if (!goog.isArray(value)) {
      queryData.add(key, value);
    } else {
      queryData.setValues(key, value);
    }
  }
  return queryData;
};


/**
 * Creates a new query data instance from parallel arrays of parameter names
 * and values. Allows for duplicate parameter names. Throws an error if the
 * lengths of the arrays differ.
 *
 * @param {Array.<string>} keys Parameter names.
 * @param {Array} values Parameter values.
 * @param {goog.Uri=} opt_uri URI object that should have its cache
 *     invalidated when this object updates.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @return {!goog.Uri.QueryData} The populated query data instance.
 */
goog.Uri.QueryData.createFromKeysValues = function(
    keys, values, opt_uri, opt_ignoreCase) {
  if (keys.length != values.length) {
    throw Error('Mismatched lengths for keys/values');
  }
  var queryData = new goog.Uri.QueryData(null, null, opt_ignoreCase);
  for (var i = 0; i < keys.length; i++) {
    queryData.add(keys[i], values[i]);
  }
  return queryData;
};


/**
 * The map containing name/value or name/array-of-values pairs.
 * May be null if it requires parsing from the query string.
 *
 * We need to use a Map because we cannot guarantee that the key names will
 * not be problematic for IE.
 *
 * @type {goog.structs.Map}
 * @private
 */
goog.Uri.QueryData.prototype.keyMap_ = null;


/**
 * The number of params, or null if it requires computing.
 * @type {?number}
 * @private
 */
goog.Uri.QueryData.prototype.count_ = null;


/**
 * @return {?number} The number of parameters.
 */
goog.Uri.QueryData.prototype.getCount = function() {
  this.ensureKeyMapInitialized_();
  return this.count_;
};


/**
 * Adds a key value pair.
 * @param {string} key Name.
 * @param {*} value Value.
 * @return {!goog.Uri.QueryData} Instance of this object.
 */
goog.Uri.QueryData.prototype.add = function(key, value) {
  this.ensureKeyMapInitialized_();
  this.invalidateCache_();

  key = this.getKeyName_(key);
  var values = this.keyMap_.get(key);
  if (!values) {
    this.keyMap_.set(key, (values = []));
  }
  values.push(value);
  this.count_++;
  return this;
};


/**
 * Removes all the params with the given key.
 * @param {string} key Name.
 * @return {boolean} Whether any parameter was removed.
 */
goog.Uri.QueryData.prototype.remove = function(key) {
  this.ensureKeyMapInitialized_();

  key = this.getKeyName_(key);
  if (this.keyMap_.containsKey(key)) {
    this.invalidateCache_();

    // Decrement parameter count.
    this.count_ -= this.keyMap_.get(key).length;
    return this.keyMap_.remove(key);
  }
  return false;
};


/**
 * Clears the parameters.
 */
goog.Uri.QueryData.prototype.clear = function() {
  this.invalidateCache_();
  this.keyMap_ = null;
  this.count_ = 0;
};


/**
 * @return {boolean} Whether we have any parameters.
 */
goog.Uri.QueryData.prototype.isEmpty = function() {
  this.ensureKeyMapInitialized_();
  return this.count_ == 0;
};


/**
 * Whether there is a parameter with the given name
 * @param {string} key The parameter name to check for.
 * @return {boolean} Whether there is a parameter with the given name.
 */
goog.Uri.QueryData.prototype.containsKey = function(key) {
  this.ensureKeyMapInitialized_();
  key = this.getKeyName_(key);
  return this.keyMap_.containsKey(key);
};


/**
 * Whether there is a parameter with the given value.
 * @param {*} value The value to check for.
 * @return {boolean} Whether there is a parameter with the given value.
 */
goog.Uri.QueryData.prototype.containsValue = function(value) {
  // NOTE(arv): This solution goes through all the params even if it was the
  // first param. We can get around this by not reusing code or by switching to
  // iterators.
  var vals = this.getValues();
  return goog.array.contains(vals, value);
};


/**
 * Returns all the keys of the parameters. If a key is used multiple times
 * it will be included multiple times in the returned array
 * @return {!Array.<string>} All the keys of the parameters.
 */
goog.Uri.QueryData.prototype.getKeys = function() {
  this.ensureKeyMapInitialized_();
  // We need to get the values to know how many keys to add.
  var vals = /** @type {Array.<Array|*>} */ (this.keyMap_.getValues());
  var keys = this.keyMap_.getKeys();
  var rv = [];
  for (var i = 0; i < keys.length; i++) {
    var val = vals[i];
    for (var j = 0; j < val.length; j++) {
      rv.push(keys[i]);
    }
  }
  return rv;
};


/**
 * Returns all the values of the parameters with the given name. If the query
 * data has no such key this will return an empty array. If no key is given
 * all values wil be returned.
 * @param {string=} opt_key The name of the parameter to get the values for.
 * @return {!Array} All the values of the parameters with the given name.
 */
goog.Uri.QueryData.prototype.getValues = function(opt_key) {
  this.ensureKeyMapInitialized_();
  var rv = [];
  if (goog.isString(opt_key)) {
    if (this.containsKey(opt_key)) {
      rv = goog.array.concat(rv, this.keyMap_.get(this.getKeyName_(opt_key)));
    }
  } else {
    // Return all values.
    var values = /** @type {Array.<Array|*>} */ (this.keyMap_.getValues());
    for (var i = 0; i < values.length; i++) {
      rv = goog.array.concat(rv, values[i]);
    }
  }
  return rv;
};


/**
 * Sets a key value pair and removes all other keys with the same value.
 *
 * @param {string} key Name.
 * @param {*} value Value.
 * @return {!goog.Uri.QueryData} Instance of this object.
 */
goog.Uri.QueryData.prototype.set = function(key, value) {
  this.ensureKeyMapInitialized_();
  this.invalidateCache_();

  // TODO(chrishenry): This could be better written as
  // this.remove(key), this.add(key, value), but that would reorder
  // the key (since the key is first removed and then added at the
  // end) and we would have to fix unit tests that depend on key
  // ordering.
  key = this.getKeyName_(key);
  if (this.containsKey(key)) {
    this.count_ -= this.keyMap_.get(key).length;
  }
  this.keyMap_.set(key, [value]);
  this.count_++;
  return this;
};


/**
 * Returns the first value associated with the key. If the query data has no
 * such key this will return undefined or the optional default.
 * @param {string} key The name of the parameter to get the value for.
 * @param {*=} opt_default The default value to return if the query data
 *     has no such key.
 * @return {*} The first string value associated with the key, or opt_default
 *     if there's no value.
 */
goog.Uri.QueryData.prototype.get = function(key, opt_default) {
  var values = key ? this.getValues(key) : [];
  if (goog.Uri.preserveParameterTypesCompatibilityFlag) {
    return values.length > 0 ? values[0] : opt_default;
  } else {
    return values.length > 0 ? String(values[0]) : opt_default;
  }
};


/**
 * Sets the values for a key. If the key already exists, this will
 * override all of the existing values that correspond to the key.
 * @param {string} key The key to set values for.
 * @param {Array} values The values to set.
 */
goog.Uri.QueryData.prototype.setValues = function(key, values) {
  this.remove(key);

  if (values.length > 0) {
    this.invalidateCache_();
    this.keyMap_.set(this.getKeyName_(key), goog.array.clone(values));
    this.count_ += values.length;
  }
};


/**
 * @return {string} Encoded query string.
 * @override
 */
goog.Uri.QueryData.prototype.toString = function() {
  if (this.encodedQuery_) {
    return this.encodedQuery_;
  }

  if (!this.keyMap_) {
    return '';
  }

  var sb = [];

  // In the past, we use this.getKeys() and this.getVals(), but that
  // generates a lot of allocations as compared to simply iterating
  // over the keys.
  var keys = this.keyMap_.getKeys();
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var encodedKey = goog.string.urlEncode(key);
    var val = this.getValues(key);
    for (var j = 0; j < val.length; j++) {
      var param = encodedKey;
      // Ensure that null and undefined are encoded into the url as
      // literal strings.
      if (val[j] !== '') {
        param += '=' + goog.string.urlEncode(val[j]);
      }
      sb.push(param);
    }
  }

  return this.encodedQuery_ = sb.join('&');
};


/**
 * @return {string} Decoded query string.
 */
goog.Uri.QueryData.prototype.toDecodedString = function() {
  return goog.Uri.decodeOrEmpty_(this.toString());
};


/**
 * Invalidate the cache.
 * @private
 */
goog.Uri.QueryData.prototype.invalidateCache_ = function() {
  this.encodedQuery_ = null;
};


/**
 * Removes all keys that are not in the provided list. (Modifies this object.)
 * @param {Array.<string>} keys The desired keys.
 * @return {!goog.Uri.QueryData} a reference to this object.
 */
goog.Uri.QueryData.prototype.filterKeys = function(keys) {
  this.ensureKeyMapInitialized_();
  goog.structs.forEach(this.keyMap_,
      /** @this {goog.Uri.QueryData} */
      function(value, key, map) {
        if (!goog.array.contains(keys, key)) {
          this.remove(key);
        }
      }, this);
  return this;
};


/**
 * Clone the query data instance.
 * @return {!goog.Uri.QueryData} New instance of the QueryData object.
 */
goog.Uri.QueryData.prototype.clone = function() {
  var rv = new goog.Uri.QueryData();
  rv.encodedQuery_ = this.encodedQuery_;
  if (this.keyMap_) {
    rv.keyMap_ = this.keyMap_.clone();
    rv.count_ = this.count_;
  }
  return rv;
};


/**
 * Helper function to get the key name from a JavaScript object. Converts
 * the object to a string, and to lower case if necessary.
 * @private
 * @param {*} arg The object to get a key name from.
 * @return {string} valid key name which can be looked up in #keyMap_.
 */
goog.Uri.QueryData.prototype.getKeyName_ = function(arg) {
  var keyName = String(arg);
  if (this.ignoreCase_) {
    keyName = keyName.toLowerCase();
  }
  return keyName;
};


/**
 * Ignore case in parameter names.
 * NOTE: If there are already key/value pairs in the QueryData, and
 * ignoreCase_ is set to false, the keys will all be lower-cased.
 * @param {boolean} ignoreCase whether this goog.Uri should ignore case.
 */
goog.Uri.QueryData.prototype.setIgnoreCase = function(ignoreCase) {
  var resetKeys = ignoreCase && !this.ignoreCase_;
  if (resetKeys) {
    this.ensureKeyMapInitialized_();
    this.invalidateCache_();
    goog.structs.forEach(this.keyMap_,
        /** @this {goog.Uri.QueryData} */
        function(value, key) {
          var lowerCase = key.toLowerCase();
          if (key != lowerCase) {
            this.remove(key);
            this.setValues(lowerCase, value);
          }
        }, this);
  }
  this.ignoreCase_ = ignoreCase;
};


/**
 * Extends a query data object with another query data or map like object. This
 * operates 'in-place', it does not create a new QueryData object.
 *
 * @param {...(goog.Uri.QueryData|goog.structs.Map|Object)} var_args The object
 *     from which key value pairs will be copied.
 */
goog.Uri.QueryData.prototype.extend = function(var_args) {
  for (var i = 0; i < arguments.length; i++) {
    var data = arguments[i];
    goog.structs.forEach(data,
        /** @this {goog.Uri.QueryData} */
        function(value, key) {
          this.add(key, value);
        }, this);
  }
};

//javascript/apps/drive/dataservice/sync/api/activities.js
/**
 * @fileoverview Helper that takes a ActivityQueryRequest, generates a
 * Genoa activities query, and executes it.
 */

goog.provide('drive.ds.sync.api.Activities');

goog.require('goog.Uri');
goog.require('goog.net.XhrIo');
goog.require('goog.structs.Map');


/** @private {string} Base path for the activity endpoint on Drive. */
drive.ds.sync.api.Activities.BASE_PATH_ = '/e/act';


/** @private {string} Doc id parameter. */
drive.ds.sync.api.Activities.ID_PARAM_ = 'docId';


/** @private {string} Recursive parameter. */
drive.ds.sync.api.Activities.RECURSIVE_PARAM_ = 'recursive';


/** @private {string} Continuation token parameter */
drive.ds.sync.api.Activities.TOKEN_PARAM_ = 'continuationToken';


/** @private {string} XSRF token parameter */
drive.ds.sync.api.Activities.XSRF_TOKEN_PARAM_ = 'token';

/**
 * Gaia session id param.
 * @private {string}
 */
drive.ds.sync.api.Activities.SESSION_ID_PARAM_ = 'authuser';

/**
 * Gets the list of revisions the user has for a specific file.
 * @param {!drive.ds.ActivityQueryRequest} request The revisions request.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item service config
 * @param {!Function} responseHandler The response handler to call.
 * @param {string=} opt_token The optional continuation token.
 */
drive.ds.sync.api.Activities.list =
    function(request, config, responseHandler, opt_token) {

  // TODO(jlure): Switch to querying Genoa when Genoa is ready.
  var uri = new goog.Uri(config.getActivityBaseUrl() +
      drive.ds.sync.api.Activities.BASE_PATH_);

  var queryData = new goog.Uri.QueryData().
      add(drive.ds.sync.api.Activities.ID_PARAM_, request.getId()).
      add(drive.ds.sync.api.Activities.RECURSIVE_PARAM_,
          request.getRecursive()).
      add(drive.ds.sync.api.Activities.XSRF_TOKEN_PARAM_,
          config.getExplorerXsrfToken()).
      add(drive.ds.sync.api.Activities.SESSION_ID_PARAM_,
          config.getGaiaSessionId());
  if (opt_token) {
    queryData.add(drive.ds.sync.api.Activities.TOKEN_PARAM_, opt_token);
  }

  var headers = new goog.structs.Map();
  headers.set('X-Json-Requested', 'true');
  goog.net.XhrIo.send(
      uri, responseHandler, 'POST', queryData.toString(), headers, 0, true);
};

//javascript/apps/drive/dataservice/sync/api/apps.js
/**
 * @fileoverview Helper that generates a Genoa apps query, and executes it.
 */

goog.provide('drive.ds.sync.api.Apps');

goog.require('drive.ds.sync.api.RequestManager');
goog.require('drive.ds.sync.stat.RequestType');


/**
 * Gets the list of apps that the user has installed in their Drive.
 * TODO(towong): Use this for getting list of Apps, leverage open template urls
 * and icon urls for Cellodex.
 * TODO(towong): Pass field list to apps query.
 * @param {!Function} responseHandler The response handler to call.
 */
drive.ds.sync.api.Apps.list = function(responseHandler) {
  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Apps.createListMethod_,
      {}, responseHandler, drive.ds.sync.stat.RequestType.APPS);
};


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for a list of apps.
 * @private
 */
drive.ds.sync.api.Apps.createListMethod_ = function() {
  return gapi.client.drive.apps.list;
};

//javascript/apps/jspb/message.js
// Copyright 2010 Google Inc. All Rights Reserved.

/**
 * @fileoverview Definition of jspb.Message.
 *
 * @author mwr@google.com (Mark Rawling)
 */

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.json');
goog.require('goog.object');

goog.provide('jspb.ExtensionFieldInfo');
goog.provide('jspb.Message');


/**
 * Stores information for a single extension field.
 *
 * For example, an extension field defined like so:
 *
 *     extend BaseMessage {
 *       optional MyMessage my_field = 123;
 *     }
 *
 * will result in an ExtensionFieldInfo object with these properties:
 *
 *     {
 *       fieldIndex: 123,
 *       fieldName: {my_field_renamed: 0},
 *       ctor: proto.example.MyMessage,
 *       toObjectFn: proto.example.MyMessage.toObject,
 *       isRepeated: 1
 *     }
 *
 * We include `toObjectFn` to allow the JSCompiler to perform dead-code removal
 * on unused toObject() methods.
 *
 * If an extension field is primitive, ctor and toObjectFn will be null.
 * isRepeated should be 0 or 1.
 *
 * @param {number} fieldIndex
 * @param {Object} fieldName This has the extension field name as a property.
 * @param {?function(new: jspb.Message, Array=)} ctor
 * @param {?function((boolean|undefined),!jspb.Message):!Object} toObjectFn
 * @param {number} isRepeated
 * @constructor
 * @struct
 * @template T
 */
jspb.ExtensionFieldInfo = function(fieldIndex, fieldName, ctor, toObjectFn,
    isRepeated) {
  /** @const */
  this.fieldIndex = fieldIndex;
  /** @const */
  this.fieldName = fieldName;
  /** @const */
  this.ctor = ctor;
  /** @const */
  this.toObjectFn = toObjectFn;
  /** @const */
  this.isRepeated = isRepeated;
};


/**
 * Base class for all JsPb messages.
 * @constructor
 * @struct
 */
jspb.Message = function() {
};


/**
 * The internal data array.
 * @type {!Array}
 * @protected
 */
jspb.Message.prototype.array;


/**
 * Wrappers are the jspb.Message objects of non-primitive fields. They are
 * built on demand from the raw array data.
 * @type {!Array}
 * @private
 */
jspb.Message.prototype.wrappers_;


/**
 * The object that contains extension fields, if any. This is an object that
 * maps from a proto field index to the field's value. Currently, values are
 * restricted to being full proto messages, so all values in this map will be
 * jspb arrays.
 *
 * Example:
 *
 *     {1301923012:['serialized','extension','proto']}
 *
 * @type {Object}
 * @protected
 */
jspb.Message.prototype.extensionObject;


/**
 * Wrapper objects for extension Message fields, indexed by field number.
 * @type {Object.<number, jspb.Message|Array.<jspb.Message>>}
 * @protected
 */
jspb.Message.prototype.extensionWrappers;


/**
 * The JsPb message_id of this proto.
 * @type {string|undefined} the message id or undefined if this message
 *     has no id.
 */
jspb.Message.prototype.messageId;

/**
 * Returns the JsPb message_id of this proto.
 * @return {string|undefined} the message id or undefined if this message
 *     has no id.
 */
jspb.Message.prototype.getJsPbMessageId = function() {
  return this.messageId;
};


/**
 * Initializes a JsPb Message.
 * Ensures the array contains an extension object that is placed at the given
 * array index.  If the array contains an extension object in its last position,
 * then the object is moved to max(array.length, expectedIndex).
 * @param {!jspb.Message} msg The JsPb proto to modify.
 * @param {Array|undefined} data An initial data array.
 * @param {string} messageId A response message id or ''.
 * @param {number} extensionObjectIndex The index at which we expect the
 *     extension object. -1 if not extendable.
 * @param {Array.<number>} repeatedFields The message's repeated fields.
 */
jspb.Message.initialize = function(msg, data, messageId, extensionObjectIndex,
    repeatedFields) {
  msg.wrappers_ = [];
  if (!data) {
    data = messageId ? [messageId] : [];
  }
  msg.messageId = messageId != '' ? messageId : undefined;
  msg.array = data;
  if (repeatedFields) {
    for (var i = 0; i < repeatedFields.length; i++) {
      msg.array[repeatedFields[i]] = msg.array[repeatedFields[i]] || [];
    }
  }
  if (extensionObjectIndex != -1) {
    msg.extensionWrappers = {};
    msg.extensionObject = jspb.Message.materializeExtensionObject(msg.array,
        extensionObjectIndex);
  }
};


/**
 * Ensures the array contains an extension object that is placed at the given
 * array index.  If the array contains an extension object in its last position,
 * then the object is moved to max(array.length, expectedIndex).
 * @param {!Array} array The array to modify.
 * @param {number} expectedIndex The index at which we expect the extension
 *     object.
 * @return {!Object} The extension object.
 */
jspb.Message.materializeExtensionObject = function(
    array, expectedIndex) {
  var obj;
  if (array.length) {
    var foundIndex = array.length - 1;
    obj = array[foundIndex];
    // Normal fields are never objects, so we can be sure that if we find an
    // object here, then it's the extension object. However, we must ensure that
    // the object is not an array, since arrays are valid field values.
    if (obj && typeof obj == 'object' && typeof obj.length != 'number') {
      if (foundIndex < expectedIndex) {
        // Move the extension object past any fields that we know about.
        array[expectedIndex] = obj;
        delete array[foundIndex];
      }
      return obj;
    }
  }
  obj = {};
  array[Math.max(array.length, expectedIndex)] = obj;
  return obj;
};


/**
 * Converts a JsPb repeated message field into an object list.
 * @param {!Array.<T>} field The repeated message field to be
 *     converted.
 * @param {?function(boolean=): Object|
 *     function((boolean|undefined),T): Object} toObjectFn The toObject
 *     function for this field.  We need to pass this for effective dead code
 *     removal.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Array.<Object>} An array of converted message objects.
 * @template T
 */
jspb.Message.toObjectList = function(field, toObjectFn, opt_includeInstance) {
  // Not using goog.array.map in the generated code to keep it small.
  // And not using it here to avoid a function call.
  var result = [];
  for (var i = 0; i < field.length; i++) {
    result[i] = toObjectFn.call(field[i], opt_includeInstance,
      /** @type {!jspb.Message} */ (field[i]));
  }
  return result;
};


/**
 * Adds a proto's extension data to a Soy rendering object.
 * @param {!jspb.Message} proto The proto whose extensions to convert.
 * @param {!Object} obj The Soy object to add converted extension data to.
 * @param {!Object} extensions The proto class' registered extensions.
 * @param {function(jspb.ExtensionFieldInfo) : *} getExtensionFn The proto
 *     class' getExtension function. Passed for effective dead code removal.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 */
jspb.Message.toObjectExtension = function(proto, obj, extensions,
    getExtensionFn, opt_includeInstance) {
  for (var fieldNumber in extensions) {
    var fieldInfo = extensions[fieldNumber];
    var value = getExtensionFn.call(proto, fieldInfo);
    if (value) {
      for (var name in fieldInfo.fieldName) {
        if (fieldInfo.fieldName.hasOwnProperty(name)) {
          break; // the compiled field name
        }
      }
      if (!fieldInfo.toObjectFn) {
        obj[name] = value;
      } else {
        if (fieldInfo.isRepeated) {
          obj[name] = jspb.Message.toObjectList(
              /** @type {!Array.<jspb.Message>} */ (value),
              fieldInfo.toObjectFn, opt_includeInstance);
        } else {
          obj[name] = fieldInfo.toObjectFn(opt_includeInstance, value);
        }
      }
    }
  }
};


/**
 * Gets and wraps a proto field on access.
 * @param {!jspb.Message} msg A jspb proto.
 * @param {function(new:jspb.Message, Array)} ctor Constructor for the field.
 * @param {number} num The field number.
 * @param {number=} opt_required True (1) if this is a required field.
 * @return {jspb.Message} The field as a jspb proto.
 */
jspb.Message.getWrapperField = function(msg, ctor, num, opt_required) {
  // TODO(mwr): Consider copying data and/or arrays.
  if (!msg.wrappers_[num]) {
    if (opt_required || msg.array[num]) {
      // TODO(mwr): Remove existence test for always valid default protos.
      msg.wrappers_[num] = new ctor(msg.array[num]);
    }
  }
  return msg.wrappers_[num];
};


/**
 * Gets and wraps a repeated proto field on access.
 * @param {!jspb.Message} msg A jspb proto.
 * @param {function(new:jspb.Message, Array)} ctor Constructor for the field.
 * @param {number} num The field number.
 * @return {Array.<!jspb.Message>} The repeated field as an array of protos.
 */
jspb.Message.getRepeatedWrapperField = function(msg, ctor, num) {
  if (!msg.wrappers_[num]) {
    msg.wrappers_[num] = [];
    for (var i = 0; i < msg.array[num].length; i++) {
      msg.wrappers_[num][i] = new ctor(msg.array[num][i]);
    }
  }
  return msg.wrappers_[num];
};


/**
 * Sets a proto field and syncs it to the backing array.
 * @param {!jspb.Message} msg A jspb proto.
 * @param {number} num The field number.
 * @param {jspb.Message|undefined} value A new value for this proto field.
 */
jspb.Message.setWrapperField = function(msg, num, value) {
  msg.wrappers_[num] = value;
  msg.array[num] = value ? value.toArray() : value;
};


/**
 * Sets a repeated proto field and syncs it to the backing array.
 * @param {!jspb.Message} msg A jspb proto.
 * @param {number} num The field number.
 * @param {Array.<!jspb.Message>|undefined} value An array of protos.
 */
jspb.Message.setRepeatedWrapperField = function(msg, num, value) {
  value = value || [];
  msg.wrappers_[num] = value;
  msg.array[num] = [];
  for (var i = 0; i < value.length; i++) {
    msg.array[num][i] = value[i].toArray();
  }
};


/**
 * Converts a JsPb repeated message field into a map. The map will contain
 * protos unless an optional toObject function is given, in which case it will
 * contain objects suitable for Soy rendering.
 * @param {!Array.<T>} field The repeated message field to be
 *     converted.
 * @param {function() : string?} mapKeyGetterFn The function to get the key of
 *     the map.
 * @param {?function(boolean=): Object|
 *     function((boolean|undefined),T): Object} opt_toObjectFn The
 *     toObject function for this field. We need to pass this for effective
 *     dead code removal.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object.<string, Object>} A map of proto or Soy objects.
 * @template T
 */
jspb.Message.toMap = function(
    field, mapKeyGetterFn, opt_toObjectFn, opt_includeInstance) {
  var result = {};
  for (var i = 0; i < field.length; i++) {
    result[mapKeyGetterFn.call(field[i])] = opt_toObjectFn ?
        opt_toObjectFn.call(field[i], opt_includeInstance,
            /** @type {!jspb.Message} */ (field[i])) : field[i];
  }
  return result;
};


/**
 * Returns the internal array of this proto.
 * <p>Note: If you use this array to construct a second proto, the content
 * would then be partially shared between the two protos.
 * @return {!Array} The proto represented as an array.
 */
jspb.Message.prototype.toArray = function() {
  return this.array;
};


/**
 * Serializes a JsPb proto for use in server requests.
 * @return {string} The serialized proto.
 */
jspb.Message.prototype.serialize = function() {
  if (goog.global.JSON && goog.global.JSON.stringify) {
    return goog.global.JSON.stringify(this.toArray());
  } else {
    return goog.json.serialize(this.toArray());
  }
};


/**
 * Creates a string representation of the internal data array of this proto.
 * <p>NOTE: This string is *not* suitable for use in server requests.
 * @return {string} A string representation of this proto.
 * @override
 */
jspb.Message.prototype.toString = function() {
  return this.array.toString();
};


/**
 * Gets the value of the extension field from the extended object.
 * @param {jspb.ExtensionFieldInfo.<T>} fieldInfo Specifies the field to get.
 * @return {T} The value of the field.
 * @template T
 */
jspb.Message.prototype.getExtension = function(fieldInfo) {
  var index = fieldInfo.fieldIndex;
  goog.asserts.assert(!!this.extensionWrappers,
      'Trying to get field number ' + index + ' on a non-extendable object.');
  if (fieldInfo.isRepeated) {
    if (fieldInfo.ctor) {
      if (!this.extensionWrappers[index]) {
        this.extensionWrappers[index] =
            goog.array.map(this.extensionObject[index] || [], function(arr) {
              return new fieldInfo.ctor(arr);
            });
      }
      return this.extensionWrappers[index];
    } else {
      return this.extensionObject[index];
    }
  } else {
    if (fieldInfo.ctor) {
      if (!this.extensionWrappers[index] && this.extensionObject[index]) {
        this.extensionWrappers[index] = new fieldInfo.ctor(
            /** @type {Array|undefined} */ (this.extensionObject[index]));
      }
      return this.extensionWrappers[index];
    } else {
      return this.extensionObject[index];
    }
  }
};


/**
 * Sets the value of the extension field in the extended object.
 * @param {jspb.ExtensionFieldInfo} fieldInfo Specifies the field to set.
 * @param {jspb.Message|string|number|boolean|Array} value The value to set.
 */
jspb.Message.prototype.setExtension = function(fieldInfo, value) {
  var index = fieldInfo.fieldIndex;
  goog.asserts.assert(!!this.extensionWrappers,
      'Trying to set field number ' + index + ' on a non-extendable object.');
  if (fieldInfo.isRepeated) {
    value = value || [];
    if (fieldInfo.ctor) {
      this.extensionWrappers[index] =
          /** @type {Array.<jspb.Message>} */ (value);
      this.extensionObject[index] = goog.array.map(
          /** @type {Array.<jspb.Message>} */ (value), function(msg) {
        return msg.toArray();
      });
    } else {
      this.extensionObject[index] = value;
    }
  } else {
    if (fieldInfo.ctor) {
      this.extensionWrappers[index] = /** @type {jspb.Message} */ (value);
      this.extensionObject[index] = value ? value.toArray() : value;
    } else {
      this.extensionObject[index] = value;
    }
  }
};


/**
 * Creates a difference object between two messages.
 *
 * The result will contain the top-level fields of m2 that differ from those of
 * m1 at any level of nesting. No data is cloned, the result object will
 * share its top-level elements with m2 (but not with m1).
 *
 * Note that repeated fields should not have null/undefined elements, but if
 * they do, this operation will treat repeated fields of different length as
 * the same if the only difference between them is due to trailing
 * null/undefined values.
 *
 * @param {!jspb.Message} m1 The first message object.
 * @param {!jspb.Message} m2 The second message object.
 * @return {!jspb.Message} The difference returned as a proto message.
 *     Note that the returned message may be missing required fields. This is
 *     currently tolerated in Js, but would cause an error if you tried to
 *     send such a proto to the server. You can access the raw difference
 *     array with result.toArray().
 * @throws {Error} If the messages are responses with different types.
 */
jspb.Message.difference = function(m1, m2) {
  if (!(m1 instanceof m2.constructor)) {
    throw new Error('Messages have different types.');
  }
  var arr1 = m1.toArray();
  var arr2 = m2.toArray();
  var res = [];
  var start = 0;
  var length = arr1.length > arr2.length ? arr1.length : arr2.length;
  if (m1.getJsPbMessageId()) {
    res[0] = m1.getJsPbMessageId();
    start = 1;
  }
  for (var i = start; i < length; i++) {
    if (!jspb.Message.compareFields(arr1[i], arr2[i])) {
      res[i] = arr2[i];
    }
  }
  return new m1.constructor(res);
};


/**
 * Tests whether two messages are equal.
 * @param {jspb.Message|undefined} m1 The first message object.
 * @param {jspb.Message|undefined} m2 The second message object.
 * @return {boolean} true if both messages are null/undefined, or if both are
 *     of the same type and have the same field values.
 */
jspb.Message.equals = function(m1, m2) {
  return m1 == m2 || (!!(m1 && m2) && (m1 instanceof m2.constructor) &&
      jspb.Message.compareFields(m1.toArray(), m2.toArray()));
};


/**
 * Compares two message fields recursively.
 * @param {*} field1 The first field.
 * @param {*} field2 The second field.
 * @return {boolean} true if the fields are null/undefined, or otherwise equal.
 */
jspb.Message.compareFields = function(field1, field2) {
  if (goog.isObject(field1) && goog.isObject(field2)) {
    var obj1 = /** @type {!Object} */ (field1);
    var obj2 = /** @type {!Object} */ (field2);
    var keys = {}, name, extensionObject1, extensionObject2;
    for (name in obj1) {
      obj1.hasOwnProperty(name) && (keys[name] = 0);
    }
    for (name in obj2) {
      obj2.hasOwnProperty(name) && (keys[name] = 0);
    }
    for (name in keys) {
      var val1 = obj1[name], val2 = obj2[name];
      if (goog.isObject(val1) && !goog.isArray(val1)) {
        if (extensionObject1 !== undefined) {
          throw new Error('invalid jspb state');
        }
        extensionObject1 = goog.object.isEmpty(val1) ? undefined : val1;
        val1 = undefined;
      }
      if (goog.isObject(val2) && !goog.isArray(val2)) {
        if (extensionObject2 !== undefined) {
          throw new Error('invalid jspb state');
        }
        extensionObject2 = goog.object.isEmpty(val2) ? undefined : val2;
        val2 = undefined;
      }
      if (!jspb.Message.compareFields(val1, val2)) {
        return false;
      }
    }
    if (extensionObject1 || extensionObject2) {
      return jspb.Message.compareFields(extensionObject1, extensionObject2);
    }
    return true;
  }
  // Primitive fields, null and undefined compare as equal.
  return field1 === field2 || field1 == null && field2 == null;
};


/**
 * Static clone function. NOTE: A type-safe clone function exists on each
 * generated JsPb class. Do not call this function directly.
 * @param {!jspb.Message} msg A message to clone.
 * @return {!jspb.Message} A deep clone of the given message.
 */
jspb.Message.clone = function(msg) {
  // Although we could include the wrappers, we leave them out here.
  return new msg.constructor(jspb.Message.clone_(msg.toArray()));
};


/**
 * Helper for cloning an internal JsPb object.
 * @param {!Object} obj A JsPb object, eg, a field, to be cloned.
 * @return {!Object} A clone of the input object.
 * @private
 */
jspb.Message.clone_ = function(obj) {
  var o, clone = goog.isArray(obj) ? [] : {};
  for (var key in obj) {
    if ((o = obj[key]) != null) {
      clone[key] = typeof o == 'object' ? jspb.Message.clone_(o) : o;
    }
  }
  return clone;
};


/**
 * Builds a JsPb message proto from Js array data. This is intended for code
 * like the Request Queue which might need to build protos without knowing
 * their type in advance. The proto type must have a JsPb message_id option.
 * To construct a proto object when you know the type in advance, you should
 * call its constructor directly.
 * @param {!Array} data The response data array.
 * @return {!jspb.Message} The converted proto message.
 * @throws {Error} If the message type is unknown, or the data fails to convert.
 */
jspb.Message.buildMessageFromArray = function(data) {
  var messageCtor = jspb.Message.registry_[data[0]];
  if (!messageCtor) {
    throw Error('Unknown JsPb message type: ' + data[0]);
  }
  return new messageCtor(data);
};


/**
 * Registers a JsPb message type id with its constructor.
 * @param {string} id The id for this type of message.
 * @param {Function} constructor The message constructor.
 */
jspb.Message.registerMessageType = function(id, constructor) {
  jspb.Message.registry_[id] = constructor;
  // This is needed so we can later access messageId directly on the contructor,
  // otherwise it is not available due to 'property collapsing' by the compiler.
  constructor.messageId = id;
};

/**
 * The registry of message ids to message constructors.
 * @private
 */
jspb.Message.registry_ = {};

//apps/activity/frontend/accessinfo.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.AccessInfo');
goog.provide('proto.apps.activity.frontend.AccessInfo.Role');


goog.require('jspb.Message');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.AccessInfo = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1]);
};
goog.inherits(proto.apps.activity.frontend.AccessInfo, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.AccessInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.AccessInfo.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.AccessInfo} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.AccessInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    concentricRole: msg.array[0],
    nonConcentricRoleList: msg.array[1],
    requiresKey: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.AccessInfo} The clone.
 */
proto.apps.activity.frontend.AccessInfo.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.AccessInfo} */ (jspb.Message.clone(this));
};


/**
 * @return {proto.apps.activity.frontend.AccessInfo.Role}
 */
proto.apps.activity.frontend.AccessInfo.prototype.getConcentricRole = function() {
  return /** @type {proto.apps.activity.frontend.AccessInfo.Role} */ (this.array[0]);
};

/**
 * @param {proto.apps.activity.frontend.AccessInfo.Role|undefined} value 
 */
proto.apps.activity.frontend.AccessInfo.prototype.setConcentricRole = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.AccessInfo.prototype.clearConcentricRole = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.apps.activity.frontend.AccessInfo.Role>}
 */
proto.apps.activity.frontend.AccessInfo.prototype.getNonConcentricRoleList = function() {
  return /** @type {!Array.<!proto.apps.activity.frontend.AccessInfo.Role>} */ (this.array[1]);
};

/**
 * @param {Array.<!proto.apps.activity.frontend.AccessInfo.Role>|undefined} value 
 */
proto.apps.activity.frontend.AccessInfo.prototype.setNonConcentricRoleList = function(value) {
  this.array[1] = value || []; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.AccessInfo.prototype.clearNonConcentricRoleList = function() {
  this.array[1] = []; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
proto.apps.activity.frontend.AccessInfo.prototype.getRequiresKey = function() {
  return /** @type {boolean?} */ (this.array[2]);
};

/**
 * @param {boolean?|undefined} value 
 */
proto.apps.activity.frontend.AccessInfo.prototype.setRequiresKey = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.AccessInfo.prototype.clearRequiresKey = function() {
  this.array[2] = undefined; 
};


/**
 * @enum {number}
 */
proto.apps.activity.frontend.AccessInfo.Role = {
  READER: 1,
  COMMENTER: 2,
  WRITER: 3,
  OWNER: 4
};



//apps/activity/frontend/comment.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.Comment');


goog.require('jspb.Message');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.Comment = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1]);
};
goog.inherits(proto.apps.activity.frontend.Comment, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.Comment.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.Comment.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.Comment} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.Comment.toObject = function(includeInstance, msg) {
  var f, obj = {
    numberOfComments: msg.array[0],
    commentersList: msg.array[1]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.Comment} The clone.
 */
proto.apps.activity.frontend.Comment.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.Comment} */ (jspb.Message.clone(this));
};


/**
 * @return {number?}
 */
proto.apps.activity.frontend.Comment.prototype.getNumberOfComments = function() {
  return /** @type {number?} */ (this.array[0]);
};

/**
 * @param {number?|undefined} value 
 */
proto.apps.activity.frontend.Comment.prototype.setNumberOfComments = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Comment.prototype.clearNumberOfComments = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<number>}
 */
proto.apps.activity.frontend.Comment.prototype.getCommentersList = function() {
  return /** @type {!Array.<number>} */ (this.array[1]);
};

/**
 * @param {Array.<number>|undefined} value 
 */
proto.apps.activity.frontend.Comment.prototype.setCommentersList = function(value) {
  this.array[1] = value || []; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Comment.prototype.clearCommentersList = function() {
  this.array[1] = []; 
};




//apps/activity/frontend/copy.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.Copy');


goog.require('jspb.Message');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.Copy = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(proto.apps.activity.frontend.Copy, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.Copy.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.Copy.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.Copy} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.Copy.toObject = function(includeInstance, msg) {
  var f, obj = {
    originalTitle: msg.array[0],
    copyTitle: msg.array[1]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.Copy} The clone.
 */
proto.apps.activity.frontend.Copy.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.Copy} */ (jspb.Message.clone(this));
};


/**
 * @return {string?}
 */
proto.apps.activity.frontend.Copy.prototype.getOriginalTitle = function() {
  return /** @type {string?} */ (this.array[0]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.Copy.prototype.setOriginalTitle = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Copy.prototype.clearOriginalTitle = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
proto.apps.activity.frontend.Copy.prototype.getCopyTitle = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.Copy.prototype.setCopyTitle = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Copy.prototype.clearCopyTitle = function() {
  this.array[1] = undefined; 
};




//apps/activity/frontend/eventtype.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.EventType');





/**
 * @enum {number}
 */
proto.apps.activity.frontend.EventType = {
  UNKNOWN: 1,
  CREATE: 2,
  TRASH: 3,
  EMPTY_TRASH: 4,
  UNTRASH: 5,
  MOVE: 6,
  ADD_PARENT: 7,
  REMOVE_PARENT: 8,
  RENAME: 9,
  ACL_CHANGE: 10,
  UPLOAD: 11,
  NEW_REVISION_UPLOAD: 12,
  REVISION_REMOVED: 13,
  TAKEDOWN: 14,
  COPY: 15,
  DOWNLOAD: 16,
  EDIT: 17,
  COMMENT: 18,
  VIEW: 19
};



//apps/activity/frontend/newrevisionuploaded.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.NewRevisionUploaded');


goog.require('jspb.Message');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.NewRevisionUploaded = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(proto.apps.activity.frontend.NewRevisionUploaded, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.NewRevisionUploaded.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.NewRevisionUploaded.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.NewRevisionUploaded} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.NewRevisionUploaded.toObject = function(includeInstance, msg) {
  var f, obj = {
    revisionId: msg.array[0],
    revisionIndex: msg.array[1]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.NewRevisionUploaded} The clone.
 */
proto.apps.activity.frontend.NewRevisionUploaded.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.NewRevisionUploaded} */ (jspb.Message.clone(this));
};


/**
 * @return {string?}
 */
proto.apps.activity.frontend.NewRevisionUploaded.prototype.getRevisionId = function() {
  return /** @type {string?} */ (this.array[0]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.NewRevisionUploaded.prototype.setRevisionId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.NewRevisionUploaded.prototype.clearRevisionId = function() {
  this.array[0] = undefined; 
};

/**
 * @return {number?}
 */
proto.apps.activity.frontend.NewRevisionUploaded.prototype.getRevisionIndex = function() {
  return /** @type {number?} */ (this.array[1]);
};

/**
 * @param {number?|undefined} value 
 */
proto.apps.activity.frontend.NewRevisionUploaded.prototype.setRevisionIndex = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.NewRevisionUploaded.prototype.clearRevisionIndex = function() {
  this.array[1] = undefined; 
};




//apps/activity/frontend/rename.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.Rename');


goog.require('jspb.Message');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.Rename = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(proto.apps.activity.frontend.Rename, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.Rename.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.Rename.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.Rename} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.Rename.toObject = function(includeInstance, msg) {
  var f, obj = {
    oldTitle: msg.array[0],
    newTitle: msg.array[1]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.Rename} The clone.
 */
proto.apps.activity.frontend.Rename.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.Rename} */ (jspb.Message.clone(this));
};


/**
 * @return {string?}
 */
proto.apps.activity.frontend.Rename.prototype.getOldTitle = function() {
  return /** @type {string?} */ (this.array[0]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.Rename.prototype.setOldTitle = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Rename.prototype.clearOldTitle = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
proto.apps.activity.frontend.Rename.prototype.getNewTitle = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.Rename.prototype.setNewTitle = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Rename.prototype.clearNewTitle = function() {
  this.array[1] = undefined; 
};




//apps/activity/frontend/revisionremoved.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.RevisionRemoved');


goog.require('jspb.Message');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.RevisionRemoved = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(proto.apps.activity.frontend.RevisionRemoved, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.RevisionRemoved.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.RevisionRemoved.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.RevisionRemoved} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.RevisionRemoved.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.RevisionRemoved} The clone.
 */
proto.apps.activity.frontend.RevisionRemoved.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.RevisionRemoved} */ (jspb.Message.clone(this));
};





//apps/activity/frontend/scope.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.Scope');
goog.provide('proto.apps.activity.frontend.Scope.Type');


goog.require('jspb.Message');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.Scope = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(proto.apps.activity.frontend.Scope, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.Scope.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.Scope.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.Scope} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.Scope.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: msg.array[0],
    name: msg.array[1],
    photoUrl: msg.array[2],
    email: msg.array[3],
    isMe: msg.array[4]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.Scope} The clone.
 */
proto.apps.activity.frontend.Scope.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.Scope} */ (jspb.Message.clone(this));
};


/**
 * @return {proto.apps.activity.frontend.Scope.Type}
 */
proto.apps.activity.frontend.Scope.prototype.getType = function() {
  return /** @type {proto.apps.activity.frontend.Scope.Type} */ (this.array[0]);
};

/**
 * @param {proto.apps.activity.frontend.Scope.Type|undefined} value 
 */
proto.apps.activity.frontend.Scope.prototype.setType = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Scope.prototype.clearType = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
proto.apps.activity.frontend.Scope.prototype.getName = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.Scope.prototype.setName = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Scope.prototype.clearName = function() {
  this.array[1] = undefined; 
};

/**
 * @return {string?}
 */
proto.apps.activity.frontend.Scope.prototype.getPhotoUrl = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.Scope.prototype.setPhotoUrl = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Scope.prototype.clearPhotoUrl = function() {
  this.array[2] = undefined; 
};

/**
 * @return {string?}
 */
proto.apps.activity.frontend.Scope.prototype.getEmail = function() {
  return /** @type {string?} */ (this.array[3]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.Scope.prototype.setEmail = function(value) {
  this.array[3] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Scope.prototype.clearEmail = function() {
  this.array[3] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
proto.apps.activity.frontend.Scope.prototype.getIsMe = function() {
  return /** @type {boolean?} */ (this.array[4]);
};

/**
 * @param {boolean?|undefined} value 
 */
proto.apps.activity.frontend.Scope.prototype.setIsMe = function(value) {
  this.array[4] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Scope.prototype.clearIsMe = function() {
  this.array[4] = undefined; 
};


/**
 * @enum {number}
 */
proto.apps.activity.frontend.Scope.Type = {
  GAIA_USER: 1,
  GROUP: 2,
  DOMAIN_SCOPE: 3,
  ANYONE: 4
};



//apps/activity/frontend/acldelta.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.AclDelta');


goog.require('jspb.Message');
goog.require('proto.apps.activity.frontend.AccessInfo');
goog.require('proto.apps.activity.frontend.Scope');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.AclDelta = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(proto.apps.activity.frontend.AclDelta, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.AclDelta.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.AclDelta.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.AclDelta} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.AclDelta.toObject = function(includeInstance, msg) {
  var f, obj = {
    scope: (f = msg.getScope()) && proto.apps.activity.frontend.Scope.toObject(includeInstance, f),
    newAccessInfo: (f = msg.getNewAccessInfo()) && proto.apps.activity.frontend.AccessInfo.toObject(includeInstance, f),
    oldAccessInfo: (f = msg.getOldAccessInfo()) && proto.apps.activity.frontend.AccessInfo.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.AclDelta} The clone.
 */
proto.apps.activity.frontend.AclDelta.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.AclDelta} */ (jspb.Message.clone(this));
};


/**
 * @return {proto.apps.activity.frontend.Scope}
 */
proto.apps.activity.frontend.AclDelta.prototype.getScope = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.Scope} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.Scope, 0));
};

/**
 * @param {proto.apps.activity.frontend.Scope|undefined} value 
 */
proto.apps.activity.frontend.AclDelta.prototype.setScope = function(value) {
  jspb.Message.setWrapperField(this, 0, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.AclDelta.prototype.clearScope = function() {
  this.setScope(undefined); 
};

/**
 * @return {proto.apps.activity.frontend.AccessInfo}
 */
proto.apps.activity.frontend.AclDelta.prototype.getNewAccessInfo = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.AccessInfo} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.AccessInfo, 1));
};

/**
 * @param {proto.apps.activity.frontend.AccessInfo|undefined} value 
 */
proto.apps.activity.frontend.AclDelta.prototype.setNewAccessInfo = function(value) {
  jspb.Message.setWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.AclDelta.prototype.clearNewAccessInfo = function() {
  this.setNewAccessInfo(undefined); 
};

/**
 * @return {proto.apps.activity.frontend.AccessInfo}
 */
proto.apps.activity.frontend.AclDelta.prototype.getOldAccessInfo = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.AccessInfo} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.AccessInfo, 2));
};

/**
 * @param {proto.apps.activity.frontend.AccessInfo|undefined} value 
 */
proto.apps.activity.frontend.AclDelta.prototype.setOldAccessInfo = function(value) {
  jspb.Message.setWrapperField(this, 2, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.AclDelta.prototype.clearOldAccessInfo = function() {
  this.setOldAccessInfo(undefined); 
};




//apps/activity/frontend/aclchange.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.AclChange');


goog.require('jspb.Message');
goog.require('proto.apps.activity.frontend.AclDelta');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.AclChange = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [0]);
};
goog.inherits(proto.apps.activity.frontend.AclChange, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.AclChange.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.AclChange.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.AclChange} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.AclChange.toObject = function(includeInstance, msg) {
  var f, obj = {
    deltaList: jspb.Message.toObjectList(msg.getDeltaList(),
    proto.apps.activity.frontend.AclDelta.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.AclChange} The clone.
 */
proto.apps.activity.frontend.AclChange.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.AclChange} */ (jspb.Message.clone(this));
};


/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.apps.activity.frontend.AclDelta>}
 */
proto.apps.activity.frontend.AclChange.prototype.getDeltaList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!proto.apps.activity.frontend.AclDelta>} */ (
      jspb.Message.getRepeatedWrapperField(this, proto.apps.activity.frontend.AclDelta, 0));
};

/**
 * @param {Array.<!proto.apps.activity.frontend.AclDelta>|undefined} value 
 */
proto.apps.activity.frontend.AclChange.prototype.setDeltaList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 0, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.AclChange.prototype.clearDeltaList = function() {
  this.setDeltaList([]); 
};




//apps/activity/frontend/takedown.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.Takedown');


goog.require('jspb.Message');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.Takedown = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [0,1]);
};
goog.inherits(proto.apps.activity.frontend.Takedown, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.Takedown.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.Takedown.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.Takedown} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.Takedown.toObject = function(includeInstance, msg) {
  var f, obj = {
    reasonTypeList: msg.array[0],
    reasonDescriptionList: msg.array[1]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.Takedown} The clone.
 */
proto.apps.activity.frontend.Takedown.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.Takedown} */ (jspb.Message.clone(this));
};


/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.apps.activity.frontend.TakedownReason>}
 */
proto.apps.activity.frontend.Takedown.prototype.getReasonTypeList = function() {
  return /** @type {!Array.<!proto.apps.activity.frontend.TakedownReason>} */ (this.array[0]);
};

/**
 * @param {Array.<!proto.apps.activity.frontend.TakedownReason>|undefined} value 
 */
proto.apps.activity.frontend.Takedown.prototype.setReasonTypeList = function(value) {
  this.array[0] = value || []; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Takedown.prototype.clearReasonTypeList = function() {
  this.array[0] = []; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
proto.apps.activity.frontend.Takedown.prototype.getReasonDescriptionList = function() {
  return /** @type {!Array.<string>} */ (this.array[1]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
proto.apps.activity.frontend.Takedown.prototype.setReasonDescriptionList = function(value) {
  this.array[1] = value || []; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Takedown.prototype.clearReasonDescriptionList = function() {
  this.array[1] = []; 
};




//apps/activity/frontend/takedownreason.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.TakedownReason');





/**
 * @enum {number}
 */
proto.apps.activity.frontend.TakedownReason = {
  UNKNOWN_REASON: 1
};



//apps/activity/frontend/target.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.Target');


goog.require('jspb.Message');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.Target = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(proto.apps.activity.frontend.Target, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.Target.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.Target.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.Target} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.Target.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.array[0],
    name: msg.array[1],
    mimeType: msg.array[2],
    parent: (f = msg.getParent()) && proto.apps.activity.frontend.Target.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.Target} The clone.
 */
proto.apps.activity.frontend.Target.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.Target} */ (jspb.Message.clone(this));
};


/**
 * @return {string?}
 */
proto.apps.activity.frontend.Target.prototype.getId = function() {
  return /** @type {string?} */ (this.array[0]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.Target.prototype.setId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Target.prototype.clearId = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
proto.apps.activity.frontend.Target.prototype.getName = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.Target.prototype.setName = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Target.prototype.clearName = function() {
  this.array[1] = undefined; 
};

/**
 * @return {string?}
 */
proto.apps.activity.frontend.Target.prototype.getMimeType = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.Target.prototype.setMimeType = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Target.prototype.clearMimeType = function() {
  this.array[2] = undefined; 
};

/**
 * @return {proto.apps.activity.frontend.Target}
 */
proto.apps.activity.frontend.Target.prototype.getParent = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.Target} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.Target, 3));
};

/**
 * @param {proto.apps.activity.frontend.Target|undefined} value 
 */
proto.apps.activity.frontend.Target.prototype.setParent = function(value) {
  jspb.Message.setWrapperField(this, 3, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Target.prototype.clearParent = function() {
  this.setParent(undefined); 
};




//apps/activity/frontend/move.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.Move');


goog.require('jspb.Message');
goog.require('proto.apps.activity.frontend.Target');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.Move = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [0,1]);
};
goog.inherits(proto.apps.activity.frontend.Move, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.Move.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.Move.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.Move} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.Move.toObject = function(includeInstance, msg) {
  var f, obj = {
    addedParentList: jspb.Message.toObjectList(msg.getAddedParentList(),
    proto.apps.activity.frontend.Target.toObject, includeInstance),
    removedParentList: jspb.Message.toObjectList(msg.getRemovedParentList(),
    proto.apps.activity.frontend.Target.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.Move} The clone.
 */
proto.apps.activity.frontend.Move.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.Move} */ (jspb.Message.clone(this));
};


/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.apps.activity.frontend.Target>}
 */
proto.apps.activity.frontend.Move.prototype.getAddedParentList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!proto.apps.activity.frontend.Target>} */ (
      jspb.Message.getRepeatedWrapperField(this, proto.apps.activity.frontend.Target, 0));
};

/**
 * @param {Array.<!proto.apps.activity.frontend.Target>|undefined} value 
 */
proto.apps.activity.frontend.Move.prototype.setAddedParentList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 0, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Move.prototype.clearAddedParentList = function() {
  this.setAddedParentList([]); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.apps.activity.frontend.Target>}
 */
proto.apps.activity.frontend.Move.prototype.getRemovedParentList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!proto.apps.activity.frontend.Target>} */ (
      jspb.Message.getRepeatedWrapperField(this, proto.apps.activity.frontend.Target, 1));
};

/**
 * @param {Array.<!proto.apps.activity.frontend.Target>|undefined} value 
 */
proto.apps.activity.frontend.Move.prototype.setRemovedParentList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.Move.prototype.clearRemovedParentList = function() {
  this.setRemovedParentList([]); 
};




//apps/activity/frontend/timerange.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.TimeRange');


goog.require('jspb.Message');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.TimeRange = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(proto.apps.activity.frontend.TimeRange, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.TimeRange.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.TimeRange.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.TimeRange} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.TimeRange.toObject = function(includeInstance, msg) {
  var f, obj = {
    begin: msg.array[0],
    end: msg.array[1]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.TimeRange} The clone.
 */
proto.apps.activity.frontend.TimeRange.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.TimeRange} */ (jspb.Message.clone(this));
};


/**
 * @return {number?}
 */
proto.apps.activity.frontend.TimeRange.prototype.getBegin = function() {
  return /** @type {number?} */ (this.array[0]);
};

/**
 * @param {number?|undefined} value 
 */
proto.apps.activity.frontend.TimeRange.prototype.setBegin = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.TimeRange.prototype.clearBegin = function() {
  this.array[0] = undefined; 
};

/**
 * @return {number?}
 */
proto.apps.activity.frontend.TimeRange.prototype.getEnd = function() {
  return /** @type {number?} */ (this.array[1]);
};

/**
 * @param {number?|undefined} value 
 */
proto.apps.activity.frontend.TimeRange.prototype.setEnd = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.TimeRange.prototype.clearEnd = function() {
  this.array[1] = undefined; 
};




//apps/activity/frontend/user.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.User');


goog.require('jspb.Message');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.User = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(proto.apps.activity.frontend.User, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.User.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.User.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.User} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.User.toObject = function(includeInstance, msg) {
  var f, obj = {
    emailAddress: msg.array[0],
    displayName: msg.array[1],
    nickname: msg.array[2],
    photoUrl: msg.array[3],
    isMe: msg.array[4]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.User} The clone.
 */
proto.apps.activity.frontend.User.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.User} */ (jspb.Message.clone(this));
};


/**
 * @return {string?}
 */
proto.apps.activity.frontend.User.prototype.getEmailAddress = function() {
  return /** @type {string?} */ (this.array[0]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.User.prototype.setEmailAddress = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.User.prototype.clearEmailAddress = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
proto.apps.activity.frontend.User.prototype.getDisplayName = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.User.prototype.setDisplayName = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.User.prototype.clearDisplayName = function() {
  this.array[1] = undefined; 
};

/**
 * @return {string?}
 */
proto.apps.activity.frontend.User.prototype.getNickname = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.User.prototype.setNickname = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.User.prototype.clearNickname = function() {
  this.array[2] = undefined; 
};

/**
 * @return {string?}
 */
proto.apps.activity.frontend.User.prototype.getPhotoUrl = function() {
  return /** @type {string?} */ (this.array[3]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.User.prototype.setPhotoUrl = function(value) {
  this.array[3] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.User.prototype.clearPhotoUrl = function() {
  this.array[3] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
proto.apps.activity.frontend.User.prototype.getIsMe = function() {
  return /** @type {boolean?} */ (this.array[4]);
};

/**
 * @param {boolean?|undefined} value 
 */
proto.apps.activity.frontend.User.prototype.setIsMe = function(value) {
  this.array[4] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.User.prototype.clearIsMe = function() {
  this.array[4] = undefined; 
};




//apps/activity/frontend/activityevent.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.ActivityEvent');


goog.require('jspb.Message');
goog.require('proto.apps.activity.frontend.AclChange');
goog.require('proto.apps.activity.frontend.Comment');
goog.require('proto.apps.activity.frontend.Copy');
goog.require('proto.apps.activity.frontend.Move');
goog.require('proto.apps.activity.frontend.NewRevisionUploaded');
goog.require('proto.apps.activity.frontend.Rename');
goog.require('proto.apps.activity.frontend.RevisionRemoved');
goog.require('proto.apps.activity.frontend.Takedown');
goog.require('proto.apps.activity.frontend.Target');
goog.require('proto.apps.activity.frontend.TimeRange');
goog.require('proto.apps.activity.frontend.User');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.ActivityEvent = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1,3,4]);
};
goog.inherits(proto.apps.activity.frontend.ActivityEvent, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.ActivityEvent.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.ActivityEvent} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.ActivityEvent.toObject = function(includeInstance, msg) {
  var f, obj = {
    primaryEventType: msg.array[0],
    eventTypeList: msg.array[1],
    timeRange: (f = msg.getTimeRange()) && proto.apps.activity.frontend.TimeRange.toObject(includeInstance, f),
    userList: jspb.Message.toObjectList(msg.getUserList(),
    proto.apps.activity.frontend.User.toObject, includeInstance),
    targetList: jspb.Message.toObjectList(msg.getTargetList(),
    proto.apps.activity.frontend.Target.toObject, includeInstance),
    move: (f = msg.getMove()) && proto.apps.activity.frontend.Move.toObject(includeInstance, f),
    rename: (f = msg.getRename()) && proto.apps.activity.frontend.Rename.toObject(includeInstance, f),
    aclChange: (f = msg.getAclChange()) && proto.apps.activity.frontend.AclChange.toObject(includeInstance, f),
    newRevisionUploaded: (f = msg.getNewRevisionUploaded()) && proto.apps.activity.frontend.NewRevisionUploaded.toObject(includeInstance, f),
    revisionRemoved: (f = msg.getRevisionRemoved()) && proto.apps.activity.frontend.RevisionRemoved.toObject(includeInstance, f),
    takedown: (f = msg.getTakedown()) && proto.apps.activity.frontend.Takedown.toObject(includeInstance, f),
    copy: (f = msg.getCopy()) && proto.apps.activity.frontend.Copy.toObject(includeInstance, f),
    comment: (f = msg.getComment()) && proto.apps.activity.frontend.Comment.toObject(includeInstance, f),
    isNew: msg.array[13]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.ActivityEvent} The clone.
 */
proto.apps.activity.frontend.ActivityEvent.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.ActivityEvent} */ (jspb.Message.clone(this));
};


/**
 * @return {proto.apps.activity.frontend.EventType}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getPrimaryEventType = function() {
  return /** @type {proto.apps.activity.frontend.EventType} */ (this.array[0]);
};

/**
 * @param {proto.apps.activity.frontend.EventType|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setPrimaryEventType = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearPrimaryEventType = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.apps.activity.frontend.EventType>}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getEventTypeList = function() {
  return /** @type {!Array.<!proto.apps.activity.frontend.EventType>} */ (this.array[1]);
};

/**
 * @param {Array.<!proto.apps.activity.frontend.EventType>|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setEventTypeList = function(value) {
  this.array[1] = value || []; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearEventTypeList = function() {
  this.array[1] = []; 
};

/**
 * @return {proto.apps.activity.frontend.TimeRange}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getTimeRange = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.TimeRange} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.TimeRange, 2));
};

/**
 * @param {proto.apps.activity.frontend.TimeRange|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setTimeRange = function(value) {
  jspb.Message.setWrapperField(this, 2, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearTimeRange = function() {
  this.setTimeRange(undefined); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.apps.activity.frontend.User>}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getUserList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!proto.apps.activity.frontend.User>} */ (
      jspb.Message.getRepeatedWrapperField(this, proto.apps.activity.frontend.User, 3));
};

/**
 * @param {Array.<!proto.apps.activity.frontend.User>|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setUserList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearUserList = function() {
  this.setUserList([]); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.apps.activity.frontend.Target>}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getTargetList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!proto.apps.activity.frontend.Target>} */ (
      jspb.Message.getRepeatedWrapperField(this, proto.apps.activity.frontend.Target, 4));
};

/**
 * @param {Array.<!proto.apps.activity.frontend.Target>|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setTargetList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearTargetList = function() {
  this.setTargetList([]); 
};

/**
 * @return {proto.apps.activity.frontend.Move}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getMove = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.Move} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.Move, 5));
};

/**
 * @param {proto.apps.activity.frontend.Move|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setMove = function(value) {
  jspb.Message.setWrapperField(this, 5, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearMove = function() {
  this.setMove(undefined); 
};

/**
 * @return {proto.apps.activity.frontend.Rename}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getRename = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.Rename} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.Rename, 6));
};

/**
 * @param {proto.apps.activity.frontend.Rename|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setRename = function(value) {
  jspb.Message.setWrapperField(this, 6, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearRename = function() {
  this.setRename(undefined); 
};

/**
 * @return {proto.apps.activity.frontend.AclChange}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getAclChange = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.AclChange} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.AclChange, 7));
};

/**
 * @param {proto.apps.activity.frontend.AclChange|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setAclChange = function(value) {
  jspb.Message.setWrapperField(this, 7, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearAclChange = function() {
  this.setAclChange(undefined); 
};

/**
 * @return {proto.apps.activity.frontend.NewRevisionUploaded}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getNewRevisionUploaded = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.NewRevisionUploaded} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.NewRevisionUploaded, 8));
};

/**
 * @param {proto.apps.activity.frontend.NewRevisionUploaded|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setNewRevisionUploaded = function(value) {
  jspb.Message.setWrapperField(this, 8, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearNewRevisionUploaded = function() {
  this.setNewRevisionUploaded(undefined); 
};

/**
 * @return {proto.apps.activity.frontend.RevisionRemoved}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getRevisionRemoved = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.RevisionRemoved} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.RevisionRemoved, 9));
};

/**
 * @param {proto.apps.activity.frontend.RevisionRemoved|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setRevisionRemoved = function(value) {
  jspb.Message.setWrapperField(this, 9, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearRevisionRemoved = function() {
  this.setRevisionRemoved(undefined); 
};

/**
 * @return {proto.apps.activity.frontend.Takedown}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getTakedown = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.Takedown} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.Takedown, 10));
};

/**
 * @param {proto.apps.activity.frontend.Takedown|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setTakedown = function(value) {
  jspb.Message.setWrapperField(this, 10, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearTakedown = function() {
  this.setTakedown(undefined); 
};

/**
 * @return {proto.apps.activity.frontend.Copy}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getCopy = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.Copy} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.Copy, 11));
};

/**
 * @param {proto.apps.activity.frontend.Copy|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setCopy = function(value) {
  jspb.Message.setWrapperField(this, 11, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearCopy = function() {
  this.setCopy(undefined); 
};

/**
 * @return {proto.apps.activity.frontend.Comment}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getComment = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.Comment} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.Comment, 12));
};

/**
 * @param {proto.apps.activity.frontend.Comment|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setComment = function(value) {
  jspb.Message.setWrapperField(this, 12, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearComment = function() {
  this.setComment(undefined); 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
proto.apps.activity.frontend.ActivityEvent.prototype.getIsNew = function() {
  return /** @type {boolean?} */ (this.array[13]);
};

/**
 * @param {boolean?|undefined} value 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.setIsNew = function(value) {
  this.array[13] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityEvent.prototype.clearIsNew = function() {
  this.array[13] = undefined; 
};




//apps/activity/frontend/activityresponse.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.apps.activity.frontend.ActivityResponse');


goog.require('jspb.Message');
goog.require('proto.apps.activity.frontend.ActivityEvent');


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.apps.activity.frontend.ActivityResponse = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [0]);
};
goog.inherits(proto.apps.activity.frontend.ActivityResponse, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.apps.activity.frontend.ActivityResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.apps.activity.frontend.ActivityResponse.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.apps.activity.frontend.ActivityResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.apps.activity.frontend.ActivityResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    eventList: jspb.Message.toObjectList(msg.getEventList(),
    proto.apps.activity.frontend.ActivityEvent.toObject, includeInstance),
    webSafeContinuationToken: msg.array[1],
    nextPollingDelayMs: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.apps.activity.frontend.ActivityResponse} The clone.
 */
proto.apps.activity.frontend.ActivityResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.apps.activity.frontend.ActivityResponse} */ (jspb.Message.clone(this));
};


/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.apps.activity.frontend.ActivityEvent>}
 */
proto.apps.activity.frontend.ActivityResponse.prototype.getEventList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!proto.apps.activity.frontend.ActivityEvent>} */ (
      jspb.Message.getRepeatedWrapperField(this, proto.apps.activity.frontend.ActivityEvent, 0));
};

/**
 * @param {Array.<!proto.apps.activity.frontend.ActivityEvent>|undefined} value 
 */
proto.apps.activity.frontend.ActivityResponse.prototype.setEventList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 0, value); 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityResponse.prototype.clearEventList = function() {
  this.setEventList([]); 
};

/**
 * @return {string?}
 */
proto.apps.activity.frontend.ActivityResponse.prototype.getWebSafeContinuationToken = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
proto.apps.activity.frontend.ActivityResponse.prototype.setWebSafeContinuationToken = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityResponse.prototype.clearWebSafeContinuationToken = function() {
  this.array[1] = undefined; 
};

/**
 * @return {number?}
 */
proto.apps.activity.frontend.ActivityResponse.prototype.getNextPollingDelayMs = function() {
  return /** @type {number?} */ (this.array[2]);
};

/**
 * @param {number?|undefined} value 
 */
proto.apps.activity.frontend.ActivityResponse.prototype.setNextPollingDelayMs = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
proto.apps.activity.frontend.ActivityResponse.prototype.clearNextPollingDelayMs = function() {
  this.array[2] = undefined; 
};




//apps/drive/dataservice/proto/proto_js_lib.js
// GENERATED CODE -- DO NOT EDIT!

goog.provide('drive.ds.Account');
goog.provide('drive.ds.ActivityQueryDeltaResponse');
goog.provide('drive.ds.ActivityQueryRequest');
goog.provide('drive.ds.ActivityQueryResponse');
goog.provide('drive.ds.App');
goog.provide('drive.ds.AppSettingsResponse');
goog.provide('drive.ds.CopyItemRequest');
goog.provide('drive.ds.CreateItemRequest');
goog.provide('drive.ds.DateSpec');
goog.provide('drive.ds.DateSpec.Operator');
goog.provide('drive.ds.DeleteItemRequest');
goog.provide('drive.ds.DeltaActivityEvent');
goog.provide('drive.ds.DeltaItem');
goog.provide('drive.ds.DeltaType');
goog.provide('drive.ds.Dumpello');
goog.provide('drive.ds.DumpelloQuery');
goog.provide('drive.ds.EmptyTrashRequest');
goog.provide('drive.ds.Error');
goog.provide('drive.ds.Error.Cause');
goog.provide('drive.ds.Error.Type');
goog.provide('drive.ds.Field');
goog.provide('drive.ds.FullTextSpec');
goog.provide('drive.ds.Icon');
goog.provide('drive.ds.Icon.Category');
goog.provide('drive.ds.Image');
goog.provide('drive.ds.Item');
goog.provide('drive.ds.ItemChange');
goog.provide('drive.ds.ItemQueryDeltaResponse');
goog.provide('drive.ds.ItemQueryRequest');
goog.provide('drive.ds.ItemQueryResponse');
goog.provide('drive.ds.ListChangesRequest');
goog.provide('drive.ds.ListChangesResponse');
goog.provide('drive.ds.ListPermissionsRequest');
goog.provide('drive.ds.ListPermissionsResponse');
goog.provide('drive.ds.ListRevisionsRequest');
goog.provide('drive.ds.ListRevisionsResponse');
goog.provide('drive.ds.MimeTypeSpec');
goog.provide('drive.ds.MutateItemResponse');
goog.provide('drive.ds.ParentSpec');
goog.provide('drive.ds.Permission');
goog.provide('drive.ds.Permission.Type');
goog.provide('drive.ds.ReparentItemRequest');
goog.provide('drive.ds.Revision');
goog.provide('drive.ds.Role');
goog.provide('drive.ds.SortSpec');
goog.provide('drive.ds.SortSpec.Direction');
goog.provide('drive.ds.SortSpec.Type');
goog.provide('drive.ds.Status');
goog.provide('drive.ds.TitleSpec');
goog.provide('drive.ds.TitleSpec.Operator');
goog.provide('drive.ds.UpdateItemRequest');
goog.provide('drive.ds.UpdateRevisionRequest');
goog.provide('drive.ds.UserAccountResponse');
goog.provide('drive.ds.UserMetadata');
goog.provide('drive.ds.UserMetadata.Quota');
goog.provide('drive.ds.UserMetadata.ServiceUsage');
goog.provide('drive.ds.UserPreference');
goog.provide('drive.ds.UserPreference.Key');
goog.provide('drive.ds.UserPreference.Namespace');
goog.provide('drive.ds.UserSpec');


goog.require('jspb.Message');
goog.require('proto.apps.activity.frontend.ActivityEvent');


/**
 * @enum {number}
 */
drive.ds.Status = {
  SUCCESS: 1,
  UNAVAILABLE_WHILE_OFFLINE: 2,
  GENERIC_ERROR: 3,
  AUTH_ERROR: 4,
  UNSUPPORTED: 5
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ListPermissionsRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.ListPermissionsRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ListPermissionsRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ListPermissionsRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ListPermissionsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ListPermissionsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.array[0]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ListPermissionsRequest} The clone.
 */
drive.ds.ListPermissionsRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ListPermissionsRequest} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.ListPermissionsRequest.prototype.getId = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.ListPermissionsRequest.prototype.setId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListPermissionsRequest.prototype.clearId = function() {
  this.array[0] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ListPermissionsResponse = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1]);
};
goog.inherits(drive.ds.ListPermissionsResponse, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ListPermissionsResponse.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ListPermissionsResponse.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ListPermissionsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ListPermissionsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: msg.array[0],
    permissionList: jspb.Message.toObjectList(msg.getPermissionList(),
    drive.ds.Permission.toObject, includeInstance),
    errorMessage: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ListPermissionsResponse} The clone.
 */
drive.ds.ListPermissionsResponse.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ListPermissionsResponse} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.Status}
 */
drive.ds.ListPermissionsResponse.prototype.getStatus = function() {
  return /** @type {!drive.ds.Status} */ (this.array[0]);
};

/**
 * @param {drive.ds.Status|undefined} value 
 */
drive.ds.ListPermissionsResponse.prototype.setStatus = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListPermissionsResponse.prototype.clearStatus = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.Permission>}
 */
drive.ds.ListPermissionsResponse.prototype.getPermissionList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.Permission>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.Permission, 1));
};

/**
 * @param {Array.<!drive.ds.Permission>|undefined} value 
 */
drive.ds.ListPermissionsResponse.prototype.setPermissionList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ListPermissionsResponse.prototype.clearPermissionList = function() {
  this.setPermissionList([]); 
};

/**
 * @return {string?}
 */
drive.ds.ListPermissionsResponse.prototype.getErrorMessage = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.ListPermissionsResponse.prototype.setErrorMessage = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListPermissionsResponse.prototype.clearErrorMessage = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.Permission = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.Permission, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.Permission.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.Permission.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.Permission} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.Permission.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: msg.array[0],
    id: msg.array[1],
    name: msg.array[2],
    unlisted: msg.array[3],
    photoUrl: msg.array[4],
    role: msg.array[5],
    isMe: msg.array[6]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.Permission} The clone.
 */
drive.ds.Permission.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.Permission} */ (jspb.Message.clone(this));
};


/**
 * @return {drive.ds.Permission.Type}
 */
drive.ds.Permission.prototype.getType = function() {
  return /** @type {drive.ds.Permission.Type} */ (this.array[0]);
};

/**
 * @param {drive.ds.Permission.Type|undefined} value 
 */
drive.ds.Permission.prototype.setType = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Permission.prototype.clearType = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Permission.prototype.getId = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Permission.prototype.setId = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Permission.prototype.clearId = function() {
  this.array[1] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Permission.prototype.getName = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Permission.prototype.setName = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Permission.prototype.clearName = function() {
  this.array[2] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Permission.prototype.getUnlisted = function() {
  return /** @type {boolean?} */ (this.array[3]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Permission.prototype.setUnlisted = function(value) {
  this.array[3] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Permission.prototype.clearUnlisted = function() {
  this.array[3] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Permission.prototype.getPhotoUrl = function() {
  return /** @type {string?} */ (this.array[4]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Permission.prototype.setPhotoUrl = function(value) {
  this.array[4] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Permission.prototype.clearPhotoUrl = function() {
  this.array[4] = undefined; 
};

/**
 * @return {drive.ds.Role}
 */
drive.ds.Permission.prototype.getRole = function() {
  return /** @type {drive.ds.Role} */ (this.array[5]);
};

/**
 * @param {drive.ds.Role|undefined} value 
 */
drive.ds.Permission.prototype.setRole = function(value) {
  this.array[5] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Permission.prototype.clearRole = function() {
  this.array[5] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Permission.prototype.getIsMe = function() {
  return /** @type {boolean?} */ (this.array[6]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Permission.prototype.setIsMe = function(value) {
  this.array[6] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Permission.prototype.clearIsMe = function() {
  this.array[6] = undefined; 
};


/**
 * @enum {number}
 */
drive.ds.Permission.Type = {
  USER: 1,
  GROUP: 2,
  DASHER_DOMAIN: 3,
  ANYONE: 4
};

/**
 * @enum {number}
 */
drive.ds.Role = {
  OWNER: 1,
  READER: 2,
  WRITER: 3,
  COMMENTER: 4
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.UserAccountResponse = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.UserAccountResponse, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.UserAccountResponse.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.UserAccountResponse.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.UserAccountResponse} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.UserAccountResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: msg.array[0],
    account: (f = msg.getAccount()) && drive.ds.Account.toObject(includeInstance, f),
    errorMessage: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.UserAccountResponse} The clone.
 */
drive.ds.UserAccountResponse.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.UserAccountResponse} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.Status}
 */
drive.ds.UserAccountResponse.prototype.getStatus = function() {
  return /** @type {!drive.ds.Status} */ (this.array[0]);
};

/**
 * @param {drive.ds.Status|undefined} value 
 */
drive.ds.UserAccountResponse.prototype.setStatus = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserAccountResponse.prototype.clearStatus = function() {
  this.array[0] = undefined; 
};

/**
 * @return {drive.ds.Account}
 */
drive.ds.UserAccountResponse.prototype.getAccount = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.Account} */ (
      jspb.Message.getWrapperField(this, drive.ds.Account, 1));
};

/**
 * @param {drive.ds.Account|undefined} value 
 */
drive.ds.UserAccountResponse.prototype.setAccount = function(value) {
  jspb.Message.setWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.UserAccountResponse.prototype.clearAccount = function() {
  this.setAccount(undefined); 
};

/**
 * @return {string?}
 */
drive.ds.UserAccountResponse.prototype.getErrorMessage = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.UserAccountResponse.prototype.setErrorMessage = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserAccountResponse.prototype.clearErrorMessage = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.Account = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1]);
};
goog.inherits(drive.ds.Account, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.Account.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.Account.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.Account} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.Account.toObject = function(includeInstance, msg) {
  var f, obj = {
    user: (f = msg.getUser()) && drive.ds.Permission.toObject(includeInstance, f),
    preferenceList: jspb.Message.toObjectList(msg.getPreferenceList(),
    drive.ds.UserPreference.toObject, includeInstance),
    metadata: (f = msg.getMetadata()) && drive.ds.UserMetadata.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.Account} The clone.
 */
drive.ds.Account.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.Account} */ (jspb.Message.clone(this));
};


/**
 * @return {drive.ds.Permission}
 */
drive.ds.Account.prototype.getUser = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.Permission} */ (
      jspb.Message.getWrapperField(this, drive.ds.Permission, 0));
};

/**
 * @param {drive.ds.Permission|undefined} value 
 */
drive.ds.Account.prototype.setUser = function(value) {
  jspb.Message.setWrapperField(this, 0, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Account.prototype.clearUser = function() {
  this.setUser(undefined); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.UserPreference>}
 */
drive.ds.Account.prototype.getPreferenceList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.UserPreference>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.UserPreference, 1));
};

/**
 * @param {Array.<!drive.ds.UserPreference>|undefined} value 
 */
drive.ds.Account.prototype.setPreferenceList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Account.prototype.clearPreferenceList = function() {
  this.setPreferenceList([]); 
};

/**
 * @return {drive.ds.UserMetadata}
 */
drive.ds.Account.prototype.getMetadata = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.UserMetadata} */ (
      jspb.Message.getWrapperField(this, drive.ds.UserMetadata, 2));
};

/**
 * @param {drive.ds.UserMetadata|undefined} value 
 */
drive.ds.Account.prototype.setMetadata = function(value) {
  jspb.Message.setWrapperField(this, 2, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Account.prototype.clearMetadata = function() {
  this.setMetadata(undefined); 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.UserPreference = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.UserPreference, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.UserPreference.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.UserPreference.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.UserPreference} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.UserPreference.toObject = function(includeInstance, msg) {
  var f, obj = {
    key: (f = msg.getKey()) && drive.ds.UserPreference.Key.toObject(includeInstance, f),
    value: msg.array[1]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.UserPreference} The clone.
 */
drive.ds.UserPreference.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.UserPreference} */ (jspb.Message.clone(this));
};


/**
 * @return {drive.ds.UserPreference.Key}
 */
drive.ds.UserPreference.prototype.getKey = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.UserPreference.Key} */ (
      jspb.Message.getWrapperField(this, drive.ds.UserPreference.Key, 0));
};

/**
 * @param {drive.ds.UserPreference.Key|undefined} value 
 */
drive.ds.UserPreference.prototype.setKey = function(value) {
  jspb.Message.setWrapperField(this, 0, value); 
};

/**
 * Clears the value. 
 */
drive.ds.UserPreference.prototype.clearKey = function() {
  this.setKey(undefined); 
};

/**
 * @return {string?}
 */
drive.ds.UserPreference.prototype.getValue = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.UserPreference.prototype.setValue = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserPreference.prototype.clearValue = function() {
  this.array[1] = undefined; 
};


/**
 * @enum {number}
 */
drive.ds.UserPreference.Namespace = {
  EXPLORER: 1,
  DRIVE: 2
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.UserPreference.Key = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.UserPreference.Key, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.UserPreference.Key.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.UserPreference.Key.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.UserPreference.Key} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.UserPreference.Key.toObject = function(includeInstance, msg) {
  var f, obj = {
    namespace: msg.array[0],
    keyname: msg.array[1]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.UserPreference.Key} The clone.
 */
drive.ds.UserPreference.Key.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.UserPreference.Key} */ (jspb.Message.clone(this));
};


/**
 * @return {drive.ds.UserPreference.Namespace}
 */
drive.ds.UserPreference.Key.prototype.getNamespace = function() {
  return /** @type {drive.ds.UserPreference.Namespace} */ (this.array[0]);
};

/**
 * @param {drive.ds.UserPreference.Namespace|undefined} value 
 */
drive.ds.UserPreference.Key.prototype.setNamespace = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserPreference.Key.prototype.clearNamespace = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.UserPreference.Key.prototype.getKeyname = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.UserPreference.Key.prototype.setKeyname = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserPreference.Key.prototype.clearKeyname = function() {
  this.array[1] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.UserMetadata = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.UserMetadata, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.UserMetadata.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.UserMetadata.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.UserMetadata} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.UserMetadata.toObject = function(includeInstance, msg) {
  var f, obj = {
    quota: (f = msg.getQuota()) && drive.ds.UserMetadata.Quota.toObject(includeInstance, f),
    rootFolderId: msg.array[1],
    domainSharingPolicy: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.UserMetadata} The clone.
 */
drive.ds.UserMetadata.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.UserMetadata} */ (jspb.Message.clone(this));
};


/**
 * @return {drive.ds.UserMetadata.Quota}
 */
drive.ds.UserMetadata.prototype.getQuota = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.UserMetadata.Quota} */ (
      jspb.Message.getWrapperField(this, drive.ds.UserMetadata.Quota, 0));
};

/**
 * @param {drive.ds.UserMetadata.Quota|undefined} value 
 */
drive.ds.UserMetadata.prototype.setQuota = function(value) {
  jspb.Message.setWrapperField(this, 0, value); 
};

/**
 * Clears the value. 
 */
drive.ds.UserMetadata.prototype.clearQuota = function() {
  this.setQuota(undefined); 
};

/**
 * @return {string?}
 */
drive.ds.UserMetadata.prototype.getRootFolderId = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.UserMetadata.prototype.setRootFolderId = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserMetadata.prototype.clearRootFolderId = function() {
  this.array[1] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.UserMetadata.prototype.getDomainSharingPolicy = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.UserMetadata.prototype.setDomainSharingPolicy = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserMetadata.prototype.clearDomainSharingPolicy = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.UserMetadata.ServiceUsage = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.UserMetadata.ServiceUsage, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.UserMetadata.ServiceUsage.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.UserMetadata.ServiceUsage.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.UserMetadata.ServiceUsage} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.UserMetadata.ServiceUsage.toObject = function(includeInstance, msg) {
  var f, obj = {
    serviceId: msg.array[0],
    bytesUsed: msg.array[1]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.UserMetadata.ServiceUsage} The clone.
 */
drive.ds.UserMetadata.ServiceUsage.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.UserMetadata.ServiceUsage} */ (jspb.Message.clone(this));
};


/**
 * @return {number?}
 */
drive.ds.UserMetadata.ServiceUsage.prototype.getServiceId = function() {
  return /** @type {number?} */ (this.array[0]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.UserMetadata.ServiceUsage.prototype.setServiceId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserMetadata.ServiceUsage.prototype.clearServiceId = function() {
  this.array[0] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.UserMetadata.ServiceUsage.prototype.getBytesUsed = function() {
  return /** @type {number?} */ (this.array[1]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.UserMetadata.ServiceUsage.prototype.setBytesUsed = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserMetadata.ServiceUsage.prototype.clearBytesUsed = function() {
  this.array[1] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.UserMetadata.Quota = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [4]);
};
goog.inherits(drive.ds.UserMetadata.Quota, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.UserMetadata.Quota.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.UserMetadata.Quota.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.UserMetadata.Quota} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.UserMetadata.Quota.toObject = function(includeInstance, msg) {
  var f, obj = {
    quotaBytesTotal: msg.array[0],
    quotaBytesUsed: msg.array[1],
    quotaBytesUsedAggregate: msg.array[2],
    quotaBytesUsedInTrash: msg.array[3],
    serviceUsageList: jspb.Message.toObjectList(msg.getServiceUsageList(),
    drive.ds.UserMetadata.ServiceUsage.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.UserMetadata.Quota} The clone.
 */
drive.ds.UserMetadata.Quota.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.UserMetadata.Quota} */ (jspb.Message.clone(this));
};


/**
 * @return {number?}
 */
drive.ds.UserMetadata.Quota.prototype.getQuotaBytesTotal = function() {
  return /** @type {number?} */ (this.array[0]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.UserMetadata.Quota.prototype.setQuotaBytesTotal = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserMetadata.Quota.prototype.clearQuotaBytesTotal = function() {
  this.array[0] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.UserMetadata.Quota.prototype.getQuotaBytesUsed = function() {
  return /** @type {number?} */ (this.array[1]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.UserMetadata.Quota.prototype.setQuotaBytesUsed = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserMetadata.Quota.prototype.clearQuotaBytesUsed = function() {
  this.array[1] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.UserMetadata.Quota.prototype.getQuotaBytesUsedAggregate = function() {
  return /** @type {number?} */ (this.array[2]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.UserMetadata.Quota.prototype.setQuotaBytesUsedAggregate = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserMetadata.Quota.prototype.clearQuotaBytesUsedAggregate = function() {
  this.array[2] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.UserMetadata.Quota.prototype.getQuotaBytesUsedInTrash = function() {
  return /** @type {number?} */ (this.array[3]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.UserMetadata.Quota.prototype.setQuotaBytesUsedInTrash = function(value) {
  this.array[3] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserMetadata.Quota.prototype.clearQuotaBytesUsedInTrash = function() {
  this.array[3] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.UserMetadata.ServiceUsage>}
 */
drive.ds.UserMetadata.Quota.prototype.getServiceUsageList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.UserMetadata.ServiceUsage>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.UserMetadata.ServiceUsage, 4));
};

/**
 * @param {Array.<!drive.ds.UserMetadata.ServiceUsage>|undefined} value 
 */
drive.ds.UserMetadata.Quota.prototype.setServiceUsageList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value); 
};

/**
 * Clears the value. 
 */
drive.ds.UserMetadata.Quota.prototype.clearServiceUsageList = function() {
  this.setServiceUsageList([]); 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.AppSettingsResponse = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1]);
};
goog.inherits(drive.ds.AppSettingsResponse, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.AppSettingsResponse.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.AppSettingsResponse.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.AppSettingsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.AppSettingsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: msg.array[0],
    appList: jspb.Message.toObjectList(msg.getAppList(),
    drive.ds.App.toObject, includeInstance),
    errorMessage: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.AppSettingsResponse} The clone.
 */
drive.ds.AppSettingsResponse.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.AppSettingsResponse} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.Status}
 */
drive.ds.AppSettingsResponse.prototype.getStatus = function() {
  return /** @type {!drive.ds.Status} */ (this.array[0]);
};

/**
 * @param {drive.ds.Status|undefined} value 
 */
drive.ds.AppSettingsResponse.prototype.setStatus = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.AppSettingsResponse.prototype.clearStatus = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.App>}
 */
drive.ds.AppSettingsResponse.prototype.getAppList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.App>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.App, 1));
};

/**
 * @param {Array.<!drive.ds.App>|undefined} value 
 */
drive.ds.AppSettingsResponse.prototype.setAppList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.AppSettingsResponse.prototype.clearAppList = function() {
  this.setAppList([]); 
};

/**
 * @return {string?}
 */
drive.ds.AppSettingsResponse.prototype.getErrorMessage = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.AppSettingsResponse.prototype.setErrorMessage = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.AppSettingsResponse.prototype.clearErrorMessage = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.App = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [3,4,5,16,17]);
};
goog.inherits(drive.ds.App, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.App.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.App.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.App} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.App.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.array[0],
    name: msg.array[1],
    useByDefault: msg.array[2] != null ? msg.array[2] : false,
    primaryMimeTypeList: msg.array[3],
    secondaryMimeTypeList: msg.array[4],
    iconList: jspb.Message.toObjectList(msg.getIconList(),
    drive.ds.Icon.toObject, includeInstance),
    openUrlTemplate: msg.array[6],
    createUrl: msg.array[7],
    createInFolderTemplate: msg.array[8],
    objectType: msg.array[9],
    supportsCreate: msg.array[10],
    supportsImport: msg.array[11],
    supportsMultiOpen: msg.array[12],
    installed: msg.array[13],
    authorized: msg.array[14],
    productUrl: msg.array[15],
    primaryFileExtensionList: msg.array[16],
    secondaryFileExtensionList: msg.array[17],
    shortDescription: msg.array[18],
    longDescription: msg.array[19],
    productId: msg.array[20]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.App} The clone.
 */
drive.ds.App.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.App} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.App.prototype.getId = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.App.prototype.setId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearId = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.App.prototype.getName = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.App.prototype.setName = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearName = function() {
  this.array[1] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
drive.ds.App.prototype.getUseByDefault = function() {
  return /** @type {boolean} */ (this.array[2] != null ? this.array[2] : false);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.App.prototype.setUseByDefault = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearUseByDefault = function() {
  this.array[2] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.App.prototype.getPrimaryMimeTypeList = function() {
  return /** @type {!Array.<string>} */ (this.array[3]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.App.prototype.setPrimaryMimeTypeList = function(value) {
  this.array[3] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearPrimaryMimeTypeList = function() {
  this.array[3] = []; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.App.prototype.getSecondaryMimeTypeList = function() {
  return /** @type {!Array.<string>} */ (this.array[4]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.App.prototype.setSecondaryMimeTypeList = function(value) {
  this.array[4] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearSecondaryMimeTypeList = function() {
  this.array[4] = []; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.Icon>}
 */
drive.ds.App.prototype.getIconList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.Icon>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.Icon, 5));
};

/**
 * @param {Array.<!drive.ds.Icon>|undefined} value 
 */
drive.ds.App.prototype.setIconList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value); 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearIconList = function() {
  this.setIconList([]); 
};

/**
 * @return {string?}
 */
drive.ds.App.prototype.getOpenUrlTemplate = function() {
  return /** @type {string?} */ (this.array[6]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.App.prototype.setOpenUrlTemplate = function(value) {
  this.array[6] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearOpenUrlTemplate = function() {
  this.array[6] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.App.prototype.getCreateUrl = function() {
  return /** @type {string?} */ (this.array[7]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.App.prototype.setCreateUrl = function(value) {
  this.array[7] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearCreateUrl = function() {
  this.array[7] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.App.prototype.getCreateInFolderTemplate = function() {
  return /** @type {string?} */ (this.array[8]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.App.prototype.setCreateInFolderTemplate = function(value) {
  this.array[8] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearCreateInFolderTemplate = function() {
  this.array[8] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.App.prototype.getObjectType = function() {
  return /** @type {string?} */ (this.array[9]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.App.prototype.setObjectType = function(value) {
  this.array[9] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearObjectType = function() {
  this.array[9] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.App.prototype.getSupportsCreate = function() {
  return /** @type {boolean?} */ (this.array[10]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.App.prototype.setSupportsCreate = function(value) {
  this.array[10] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearSupportsCreate = function() {
  this.array[10] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.App.prototype.getSupportsImport = function() {
  return /** @type {boolean?} */ (this.array[11]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.App.prototype.setSupportsImport = function(value) {
  this.array[11] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearSupportsImport = function() {
  this.array[11] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.App.prototype.getSupportsMultiOpen = function() {
  return /** @type {boolean?} */ (this.array[12]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.App.prototype.setSupportsMultiOpen = function(value) {
  this.array[12] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearSupportsMultiOpen = function() {
  this.array[12] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.App.prototype.getInstalled = function() {
  return /** @type {boolean?} */ (this.array[13]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.App.prototype.setInstalled = function(value) {
  this.array[13] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearInstalled = function() {
  this.array[13] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.App.prototype.getAuthorized = function() {
  return /** @type {boolean?} */ (this.array[14]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.App.prototype.setAuthorized = function(value) {
  this.array[14] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearAuthorized = function() {
  this.array[14] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.App.prototype.getProductUrl = function() {
  return /** @type {string?} */ (this.array[15]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.App.prototype.setProductUrl = function(value) {
  this.array[15] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearProductUrl = function() {
  this.array[15] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.App.prototype.getPrimaryFileExtensionList = function() {
  return /** @type {!Array.<string>} */ (this.array[16]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.App.prototype.setPrimaryFileExtensionList = function(value) {
  this.array[16] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearPrimaryFileExtensionList = function() {
  this.array[16] = []; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.App.prototype.getSecondaryFileExtensionList = function() {
  return /** @type {!Array.<string>} */ (this.array[17]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.App.prototype.setSecondaryFileExtensionList = function(value) {
  this.array[17] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearSecondaryFileExtensionList = function() {
  this.array[17] = []; 
};

/**
 * @return {string?}
 */
drive.ds.App.prototype.getShortDescription = function() {
  return /** @type {string?} */ (this.array[18]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.App.prototype.setShortDescription = function(value) {
  this.array[18] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearShortDescription = function() {
  this.array[18] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.App.prototype.getLongDescription = function() {
  return /** @type {string?} */ (this.array[19]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.App.prototype.setLongDescription = function(value) {
  this.array[19] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearLongDescription = function() {
  this.array[19] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.App.prototype.getProductId = function() {
  return /** @type {string?} */ (this.array[20]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.App.prototype.setProductId = function(value) {
  this.array[20] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.App.prototype.clearProductId = function() {
  this.array[20] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.Icon = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.Icon, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.Icon.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.Icon.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.Icon} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.Icon.toObject = function(includeInstance, msg) {
  var f, obj = {
    category: msg.array[0],
    size: msg.array[1],
    url: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.Icon} The clone.
 */
drive.ds.Icon.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.Icon} */ (jspb.Message.clone(this));
};


/**
 * @return {drive.ds.Icon.Category}
 */
drive.ds.Icon.prototype.getCategory = function() {
  return /** @type {drive.ds.Icon.Category} */ (this.array[0]);
};

/**
 * @param {drive.ds.Icon.Category|undefined} value 
 */
drive.ds.Icon.prototype.setCategory = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Icon.prototype.clearCategory = function() {
  this.array[0] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.Icon.prototype.getSize = function() {
  return /** @type {number?} */ (this.array[1]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Icon.prototype.setSize = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Icon.prototype.clearSize = function() {
  this.array[1] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Icon.prototype.getUrl = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Icon.prototype.setUrl = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Icon.prototype.clearUrl = function() {
  this.array[2] = undefined; 
};


/**
 * @enum {number}
 */
drive.ds.Icon.Category = {
  APPLICATION: 1,
  DOCUMENT: 2,
  DOCUMENT_SHARED: 3
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.Item = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1,14,36,37]);
};
goog.inherits(drive.ds.Item, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.Item.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.Item.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.Item} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.Item.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.array[0],
    parentList: msg.array[1],
    title: msg.array[2],
    mimeType: msg.array[3],
    starred: msg.array[4],
    hidden: msg.array[5],
    trashed: msg.array[6],
    restricted: msg.array[7],
    viewed: msg.array[8],
    createDateMillis: msg.array[9],
    modifiedDateMillis: msg.array[10],
    modifiedByMeDateMillis: msg.array[11],
    lastViewedByMeDateMillis: msg.array[12],
    fileSize: msg.array[13],
    ownerList: jspb.Message.toObjectList(msg.getOwnerList(),
    drive.ds.Permission.toObject, includeInstance),
    lastModifyingUser: (f = msg.getLastModifyingUser()) && drive.ds.Permission.toObject(includeInstance, f),
    openUrl: msg.array[18],
    thumbnailUrl: msg.array[19],
    iconUrl: msg.array[20],
    shared: msg.array[21],
    sharedWithMeDateMillis: msg.array[22],
    description: msg.array[23],
    userRole: msg.array[24],
    explicitlyTrashed: msg.array[25],
    image: (f = msg.getImage()) && drive.ds.Image.toObject(includeInstance, f),
    quotaBytesUsed: msg.array[27],
    shareable: msg.array[28],
    copyable: msg.array[29],
    subscribed: msg.array[30],
    cosmoType: msg.array[31],
    serviceId: msg.array[32],
    folderColor: msg.array[33],
    hasChildFolder: msg.array[34],
    flaggedForAbuse: msg.array[35],
    userList: jspb.Message.toObjectList(msg.getUserList(),
    drive.ds.Permission.toObject, includeInstance),
    visibilityList: jspb.Message.toObjectList(msg.getVisibilityList(),
    drive.ds.Permission.toObject, includeInstance),
    totalUserCount: msg.array[38],
    downloadable: msg.array[39],
    downloadUrl: msg.array[40],
    creatorAppId: msg.array[41],
    creatorAppValue: msg.array[42],
    hasThumbnail: msg.array[43],
    fileExtension: msg.array[44],
    primarySyncParent: msg.array[45],
    sharingUser: (f = msg.getSharingUser()) && drive.ds.Permission.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.Item} The clone.
 */
drive.ds.Item.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.Item} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.Item.prototype.getId = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.Item.prototype.setId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearId = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.Item.prototype.getParentList = function() {
  return /** @type {!Array.<string>} */ (this.array[1]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.Item.prototype.setParentList = function(value) {
  this.array[1] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearParentList = function() {
  this.array[1] = []; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getTitle = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setTitle = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearTitle = function() {
  this.array[2] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getMimeType = function() {
  return /** @type {string?} */ (this.array[3]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setMimeType = function(value) {
  this.array[3] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearMimeType = function() {
  this.array[3] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getStarred = function() {
  return /** @type {boolean?} */ (this.array[4]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setStarred = function(value) {
  this.array[4] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearStarred = function() {
  this.array[4] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getHidden = function() {
  return /** @type {boolean?} */ (this.array[5]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setHidden = function(value) {
  this.array[5] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearHidden = function() {
  this.array[5] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getTrashed = function() {
  return /** @type {boolean?} */ (this.array[6]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setTrashed = function(value) {
  this.array[6] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearTrashed = function() {
  this.array[6] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getRestricted = function() {
  return /** @type {boolean?} */ (this.array[7]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setRestricted = function(value) {
  this.array[7] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearRestricted = function() {
  this.array[7] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getViewed = function() {
  return /** @type {boolean?} */ (this.array[8]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setViewed = function(value) {
  this.array[8] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearViewed = function() {
  this.array[8] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.Item.prototype.getCreateDateMillis = function() {
  return /** @type {number?} */ (this.array[9]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Item.prototype.setCreateDateMillis = function(value) {
  this.array[9] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearCreateDateMillis = function() {
  this.array[9] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.Item.prototype.getModifiedDateMillis = function() {
  return /** @type {number?} */ (this.array[10]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Item.prototype.setModifiedDateMillis = function(value) {
  this.array[10] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearModifiedDateMillis = function() {
  this.array[10] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.Item.prototype.getModifiedByMeDateMillis = function() {
  return /** @type {number?} */ (this.array[11]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Item.prototype.setModifiedByMeDateMillis = function(value) {
  this.array[11] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearModifiedByMeDateMillis = function() {
  this.array[11] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.Item.prototype.getLastViewedByMeDateMillis = function() {
  return /** @type {number?} */ (this.array[12]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Item.prototype.setLastViewedByMeDateMillis = function(value) {
  this.array[12] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearLastViewedByMeDateMillis = function() {
  this.array[12] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.Item.prototype.getFileSize = function() {
  return /** @type {number?} */ (this.array[13]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Item.prototype.setFileSize = function(value) {
  this.array[13] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearFileSize = function() {
  this.array[13] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.Permission>}
 */
drive.ds.Item.prototype.getOwnerList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.Permission>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.Permission, 14));
};

/**
 * @param {Array.<!drive.ds.Permission>|undefined} value 
 */
drive.ds.Item.prototype.setOwnerList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 14, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearOwnerList = function() {
  this.setOwnerList([]); 
};

/**
 * @return {drive.ds.Permission}
 */
drive.ds.Item.prototype.getLastModifyingUser = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.Permission} */ (
      jspb.Message.getWrapperField(this, drive.ds.Permission, 16));
};

/**
 * @param {drive.ds.Permission|undefined} value 
 */
drive.ds.Item.prototype.setLastModifyingUser = function(value) {
  jspb.Message.setWrapperField(this, 16, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearLastModifyingUser = function() {
  this.setLastModifyingUser(undefined); 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getOpenUrl = function() {
  return /** @type {string?} */ (this.array[18]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setOpenUrl = function(value) {
  this.array[18] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearOpenUrl = function() {
  this.array[18] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getThumbnailUrl = function() {
  return /** @type {string?} */ (this.array[19]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setThumbnailUrl = function(value) {
  this.array[19] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearThumbnailUrl = function() {
  this.array[19] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getIconUrl = function() {
  return /** @type {string?} */ (this.array[20]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setIconUrl = function(value) {
  this.array[20] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearIconUrl = function() {
  this.array[20] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getShared = function() {
  return /** @type {boolean?} */ (this.array[21]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setShared = function(value) {
  this.array[21] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearShared = function() {
  this.array[21] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.Item.prototype.getSharedWithMeDateMillis = function() {
  return /** @type {number?} */ (this.array[22]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Item.prototype.setSharedWithMeDateMillis = function(value) {
  this.array[22] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearSharedWithMeDateMillis = function() {
  this.array[22] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getDescription = function() {
  return /** @type {string?} */ (this.array[23]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setDescription = function(value) {
  this.array[23] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearDescription = function() {
  this.array[23] = undefined; 
};

/**
 * @return {drive.ds.Role}
 */
drive.ds.Item.prototype.getUserRole = function() {
  return /** @type {drive.ds.Role} */ (this.array[24]);
};

/**
 * @param {drive.ds.Role|undefined} value 
 */
drive.ds.Item.prototype.setUserRole = function(value) {
  this.array[24] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearUserRole = function() {
  this.array[24] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getExplicitlyTrashed = function() {
  return /** @type {boolean?} */ (this.array[25]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setExplicitlyTrashed = function(value) {
  this.array[25] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearExplicitlyTrashed = function() {
  this.array[25] = undefined; 
};

/**
 * @return {drive.ds.Image}
 */
drive.ds.Item.prototype.getImage = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.Image} */ (
      jspb.Message.getWrapperField(this, drive.ds.Image, 26));
};

/**
 * @param {drive.ds.Image|undefined} value 
 */
drive.ds.Item.prototype.setImage = function(value) {
  jspb.Message.setWrapperField(this, 26, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearImage = function() {
  this.setImage(undefined); 
};

/**
 * @return {number?}
 */
drive.ds.Item.prototype.getQuotaBytesUsed = function() {
  return /** @type {number?} */ (this.array[27]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Item.prototype.setQuotaBytesUsed = function(value) {
  this.array[27] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearQuotaBytesUsed = function() {
  this.array[27] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getShareable = function() {
  return /** @type {boolean?} */ (this.array[28]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setShareable = function(value) {
  this.array[28] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearShareable = function() {
  this.array[28] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getCopyable = function() {
  return /** @type {boolean?} */ (this.array[29]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setCopyable = function(value) {
  this.array[29] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearCopyable = function() {
  this.array[29] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getSubscribed = function() {
  return /** @type {boolean?} */ (this.array[30]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setSubscribed = function(value) {
  this.array[30] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearSubscribed = function() {
  this.array[30] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getCosmoType = function() {
  return /** @type {string?} */ (this.array[31]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setCosmoType = function(value) {
  this.array[31] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearCosmoType = function() {
  this.array[31] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getServiceId = function() {
  return /** @type {string?} */ (this.array[32]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setServiceId = function(value) {
  this.array[32] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearServiceId = function() {
  this.array[32] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.Item.prototype.getFolderColor = function() {
  return /** @type {number?} */ (this.array[33]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Item.prototype.setFolderColor = function(value) {
  this.array[33] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearFolderColor = function() {
  this.array[33] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getHasChildFolder = function() {
  return /** @type {boolean?} */ (this.array[34]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setHasChildFolder = function(value) {
  this.array[34] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearHasChildFolder = function() {
  this.array[34] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getFlaggedForAbuse = function() {
  return /** @type {boolean?} */ (this.array[35]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setFlaggedForAbuse = function(value) {
  this.array[35] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearFlaggedForAbuse = function() {
  this.array[35] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.Permission>}
 */
drive.ds.Item.prototype.getUserList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.Permission>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.Permission, 36));
};

/**
 * @param {Array.<!drive.ds.Permission>|undefined} value 
 */
drive.ds.Item.prototype.setUserList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 36, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearUserList = function() {
  this.setUserList([]); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.Permission>}
 */
drive.ds.Item.prototype.getVisibilityList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.Permission>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.Permission, 37));
};

/**
 * @param {Array.<!drive.ds.Permission>|undefined} value 
 */
drive.ds.Item.prototype.setVisibilityList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 37, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearVisibilityList = function() {
  this.setVisibilityList([]); 
};

/**
 * @return {number?}
 */
drive.ds.Item.prototype.getTotalUserCount = function() {
  return /** @type {number?} */ (this.array[38]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Item.prototype.setTotalUserCount = function(value) {
  this.array[38] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearTotalUserCount = function() {
  this.array[38] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getDownloadable = function() {
  return /** @type {boolean?} */ (this.array[39]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setDownloadable = function(value) {
  this.array[39] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearDownloadable = function() {
  this.array[39] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getDownloadUrl = function() {
  return /** @type {string?} */ (this.array[40]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setDownloadUrl = function(value) {
  this.array[40] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearDownloadUrl = function() {
  this.array[40] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getCreatorAppId = function() {
  return /** @type {string?} */ (this.array[41]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setCreatorAppId = function(value) {
  this.array[41] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearCreatorAppId = function() {
  this.array[41] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getCreatorAppValue = function() {
  return /** @type {string?} */ (this.array[42]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setCreatorAppValue = function(value) {
  this.array[42] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearCreatorAppValue = function() {
  this.array[42] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Item.prototype.getHasThumbnail = function() {
  return /** @type {boolean?} */ (this.array[43]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Item.prototype.setHasThumbnail = function(value) {
  this.array[43] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearHasThumbnail = function() {
  this.array[43] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getFileExtension = function() {
  return /** @type {string?} */ (this.array[44]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setFileExtension = function(value) {
  this.array[44] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearFileExtension = function() {
  this.array[44] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Item.prototype.getPrimarySyncParent = function() {
  return /** @type {string?} */ (this.array[45]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Item.prototype.setPrimarySyncParent = function(value) {
  this.array[45] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearPrimarySyncParent = function() {
  this.array[45] = undefined; 
};

/**
 * @return {drive.ds.Permission}
 */
drive.ds.Item.prototype.getSharingUser = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.Permission} */ (
      jspb.Message.getWrapperField(this, drive.ds.Permission, 46));
};

/**
 * @param {drive.ds.Permission|undefined} value 
 */
drive.ds.Item.prototype.setSharingUser = function(value) {
  jspb.Message.setWrapperField(this, 46, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Item.prototype.clearSharingUser = function() {
  this.setSharingUser(undefined); 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.Image = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.Image, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.Image.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.Image.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.Image} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.Image.toObject = function(includeInstance, msg) {
  var f, obj = {
    dateMillis: msg.array[0],
    width: msg.array[1],
    height: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.Image} The clone.
 */
drive.ds.Image.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.Image} */ (jspb.Message.clone(this));
};


/**
 * @return {number?}
 */
drive.ds.Image.prototype.getDateMillis = function() {
  return /** @type {number?} */ (this.array[0]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Image.prototype.setDateMillis = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Image.prototype.clearDateMillis = function() {
  this.array[0] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.Image.prototype.getWidth = function() {
  return /** @type {number?} */ (this.array[1]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Image.prototype.setWidth = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Image.prototype.clearWidth = function() {
  this.array[1] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.Image.prototype.getHeight = function() {
  return /** @type {number?} */ (this.array[2]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Image.prototype.setHeight = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Image.prototype.clearHeight = function() {
  this.array[2] = undefined; 
};


/**
 * @enum {number}
 */
drive.ds.Field = {
  PARENTS: 1,
  TITLE: 2,
  MIME_TYPE: 3,
  STARRED: 4,
  HIDDEN: 5,
  TRASHED: 6,
  RESTRICTED: 7,
  VIEWED: 8,
  CREATE_DATE_MILLIS: 9,
  MODIFIED_DATE_MILLIS: 10,
  MODIFIED_BY_ME_DATE_MILLIS: 11,
  LAST_VIEWED_BY_ME_DATE_MILLIS: 12,
  FILE_SIZE: 13,
  OWNERS: 14,
  LAST_MODIFYING_USER: 16,
  OPEN_URL: 18,
  THUMBNAIL_URL: 19,
  ICON_URL: 20,
  ID: 21,
  SHARED: 24,
  SHARED_WITH_ME_DATE_MILLIS: 25,
  DESCRIPTION: 26,
  USER_ROLE: 27,
  EXPLICITLY_TRASHED: 28,
  IMAGE_DATE_MILLIS: 29,
  IMAGE_WIDTH: 30,
  IMAGE_HEIGHT: 31,
  QUOTA_BYTES_USED: 32,
  SHAREABLE: 33,
  COPYABLE: 34,
  SUBSCRIBED: 35,
  COSMO_TYPE: 36,
  SERVICE_ID: 37,
  FOLDER_COLOR: 38,
  HAS_CHILD_FOLDER: 39,
  VISIBILITIES: 40,
  DOWNLOADABLE: 41,
  DOWNLOAD_URL: 42,
  CREATOR_APP: 43,
  FILE_EXTENSION: 44,
  PRIMARY_SYNC_PARENT: 45,
  SHARING_USER: 46
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ListChangesRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [4]);
};
goog.inherits(drive.ds.ListChangesRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ListChangesRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ListChangesRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ListChangesRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ListChangesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    startChangeId: msg.array[0],
    maxResults: msg.array[1] != null ? msg.array[1] : 100,
    includeDeleted: msg.array[2] != null ? msg.array[2] : true,
    includeSubscribed: msg.array[3] != null ? msg.array[3] : true,
    fieldList: msg.array[4]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ListChangesRequest} The clone.
 */
drive.ds.ListChangesRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ListChangesRequest} */ (jspb.Message.clone(this));
};


/**
 * @return {number}
 */
drive.ds.ListChangesRequest.prototype.getStartChangeId = function() {
  return /** @type {number} */ (this.array[0]);
};

/**
 * @param {number|undefined} value 
 */
drive.ds.ListChangesRequest.prototype.setStartChangeId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListChangesRequest.prototype.clearStartChangeId = function() {
  this.array[0] = undefined; 
};

/**
 * @return {number}
 */
drive.ds.ListChangesRequest.prototype.getMaxResults = function() {
  return /** @type {number} */ (this.array[1] != null ? this.array[1] : 100);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.ListChangesRequest.prototype.setMaxResults = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListChangesRequest.prototype.clearMaxResults = function() {
  this.array[1] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
drive.ds.ListChangesRequest.prototype.getIncludeDeleted = function() {
  return /** @type {boolean} */ (this.array[2] != null ? this.array[2] : true);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.ListChangesRequest.prototype.setIncludeDeleted = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListChangesRequest.prototype.clearIncludeDeleted = function() {
  this.array[2] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
drive.ds.ListChangesRequest.prototype.getIncludeSubscribed = function() {
  return /** @type {boolean} */ (this.array[3] != null ? this.array[3] : true);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.ListChangesRequest.prototype.setIncludeSubscribed = function(value) {
  this.array[3] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListChangesRequest.prototype.clearIncludeSubscribed = function() {
  this.array[3] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.Field>}
 */
drive.ds.ListChangesRequest.prototype.getFieldList = function() {
  return /** @type {!Array.<!drive.ds.Field>} */ (this.array[4]);
};

/**
 * @param {Array.<!drive.ds.Field>|undefined} value 
 */
drive.ds.ListChangesRequest.prototype.setFieldList = function(value) {
  this.array[4] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.ListChangesRequest.prototype.clearFieldList = function() {
  this.array[4] = []; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ListChangesResponse = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [3]);
};
goog.inherits(drive.ds.ListChangesResponse, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ListChangesResponse.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ListChangesResponse.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ListChangesResponse} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ListChangesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: msg.array[0],
    nextChangeId: msg.array[1],
    largestChangeId: msg.array[2],
    itemChangeList: jspb.Message.toObjectList(msg.getItemChangeList(),
    drive.ds.ItemChange.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ListChangesResponse} The clone.
 */
drive.ds.ListChangesResponse.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ListChangesResponse} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.Status}
 */
drive.ds.ListChangesResponse.prototype.getStatus = function() {
  return /** @type {!drive.ds.Status} */ (this.array[0]);
};

/**
 * @param {drive.ds.Status|undefined} value 
 */
drive.ds.ListChangesResponse.prototype.setStatus = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListChangesResponse.prototype.clearStatus = function() {
  this.array[0] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.ListChangesResponse.prototype.getNextChangeId = function() {
  return /** @type {number?} */ (this.array[1]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.ListChangesResponse.prototype.setNextChangeId = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListChangesResponse.prototype.clearNextChangeId = function() {
  this.array[1] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.ListChangesResponse.prototype.getLargestChangeId = function() {
  return /** @type {number?} */ (this.array[2]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.ListChangesResponse.prototype.setLargestChangeId = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListChangesResponse.prototype.clearLargestChangeId = function() {
  this.array[2] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.ItemChange>}
 */
drive.ds.ListChangesResponse.prototype.getItemChangeList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.ItemChange>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.ItemChange, 3));
};

/**
 * @param {Array.<!drive.ds.ItemChange>|undefined} value 
 */
drive.ds.ListChangesResponse.prototype.setItemChangeList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ListChangesResponse.prototype.clearItemChangeList = function() {
  this.setItemChangeList([]); 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ItemChange = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.ItemChange, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ItemChange.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ItemChange.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ItemChange} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ItemChange.toObject = function(includeInstance, msg) {
  var f, obj = {
    changeId: msg.array[0],
    itemId: msg.array[1],
    deleted: msg.array[2] != null ? msg.array[2] : false,
    item: (f = msg.getItem()) && drive.ds.Item.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ItemChange} The clone.
 */
drive.ds.ItemChange.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ItemChange} */ (jspb.Message.clone(this));
};


/**
 * @return {number?}
 */
drive.ds.ItemChange.prototype.getChangeId = function() {
  return /** @type {number?} */ (this.array[0]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.ItemChange.prototype.setChangeId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemChange.prototype.clearChangeId = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.ItemChange.prototype.getItemId = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.ItemChange.prototype.setItemId = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemChange.prototype.clearItemId = function() {
  this.array[1] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
drive.ds.ItemChange.prototype.getDeleted = function() {
  return /** @type {boolean} */ (this.array[2] != null ? this.array[2] : false);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.ItemChange.prototype.setDeleted = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemChange.prototype.clearDeleted = function() {
  this.array[2] = undefined; 
};

/**
 * @return {drive.ds.Item}
 */
drive.ds.ItemChange.prototype.getItem = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.Item} */ (
      jspb.Message.getWrapperField(this, drive.ds.Item, 3));
};

/**
 * @param {drive.ds.Item|undefined} value 
 */
drive.ds.ItemChange.prototype.setItem = function(value) {
  jspb.Message.setWrapperField(this, 3, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemChange.prototype.clearItem = function() {
  this.setItem(undefined); 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ItemQueryResponse = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1]);
};
goog.inherits(drive.ds.ItemQueryResponse, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ItemQueryResponse.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ItemQueryResponse.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ItemQueryResponse} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ItemQueryResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: msg.array[0],
    itemList: jspb.Message.toObjectList(msg.getItemList(),
    drive.ds.Item.toObject, includeInstance),
    errorMessage: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ItemQueryResponse} The clone.
 */
drive.ds.ItemQueryResponse.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ItemQueryResponse} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.Status}
 */
drive.ds.ItemQueryResponse.prototype.getStatus = function() {
  return /** @type {!drive.ds.Status} */ (this.array[0]);
};

/**
 * @param {drive.ds.Status|undefined} value 
 */
drive.ds.ItemQueryResponse.prototype.setStatus = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryResponse.prototype.clearStatus = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.Item>}
 */
drive.ds.ItemQueryResponse.prototype.getItemList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.Item>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.Item, 1));
};

/**
 * @param {Array.<!drive.ds.Item>|undefined} value 
 */
drive.ds.ItemQueryResponse.prototype.setItemList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryResponse.prototype.clearItemList = function() {
  this.setItemList([]); 
};

/**
 * @return {string?}
 */
drive.ds.ItemQueryResponse.prototype.getErrorMessage = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.ItemQueryResponse.prototype.setErrorMessage = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryResponse.prototype.clearErrorMessage = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ItemQueryDeltaResponse = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1]);
};
goog.inherits(drive.ds.ItemQueryDeltaResponse, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ItemQueryDeltaResponse.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ItemQueryDeltaResponse.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ItemQueryDeltaResponse} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ItemQueryDeltaResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: msg.array[0],
    deltaItemList: jspb.Message.toObjectList(msg.getDeltaItemList(),
    drive.ds.DeltaItem.toObject, includeInstance),
    errorMessage: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ItemQueryDeltaResponse} The clone.
 */
drive.ds.ItemQueryDeltaResponse.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ItemQueryDeltaResponse} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.Status}
 */
drive.ds.ItemQueryDeltaResponse.prototype.getStatus = function() {
  return /** @type {!drive.ds.Status} */ (this.array[0]);
};

/**
 * @param {drive.ds.Status|undefined} value 
 */
drive.ds.ItemQueryDeltaResponse.prototype.setStatus = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryDeltaResponse.prototype.clearStatus = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.DeltaItem>}
 */
drive.ds.ItemQueryDeltaResponse.prototype.getDeltaItemList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.DeltaItem>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.DeltaItem, 1));
};

/**
 * @param {Array.<!drive.ds.DeltaItem>|undefined} value 
 */
drive.ds.ItemQueryDeltaResponse.prototype.setDeltaItemList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryDeltaResponse.prototype.clearDeltaItemList = function() {
  this.setDeltaItemList([]); 
};

/**
 * @return {string?}
 */
drive.ds.ItemQueryDeltaResponse.prototype.getErrorMessage = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.ItemQueryDeltaResponse.prototype.setErrorMessage = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryDeltaResponse.prototype.clearErrorMessage = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.DeltaItem = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.DeltaItem, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.DeltaItem.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.DeltaItem.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.DeltaItem} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.DeltaItem.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: msg.array[0],
    item: (f = msg.getItem()) && drive.ds.Item.toObject(includeInstance, f),
    prevPosition: msg.array[2],
    position: msg.array[3]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.DeltaItem} The clone.
 */
drive.ds.DeltaItem.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.DeltaItem} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.DeltaType}
 */
drive.ds.DeltaItem.prototype.getType = function() {
  return /** @type {!drive.ds.DeltaType} */ (this.array[0]);
};

/**
 * @param {drive.ds.DeltaType|undefined} value 
 */
drive.ds.DeltaItem.prototype.setType = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.DeltaItem.prototype.clearType = function() {
  this.array[0] = undefined; 
};

/**
 * @return {drive.ds.Item}
 */
drive.ds.DeltaItem.prototype.getItem = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.Item} */ (
      jspb.Message.getWrapperField(this, drive.ds.Item, 1));
};

/**
 * @param {drive.ds.Item|undefined} value 
 */
drive.ds.DeltaItem.prototype.setItem = function(value) {
  jspb.Message.setWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.DeltaItem.prototype.clearItem = function() {
  this.setItem(undefined); 
};

/**
 * @return {number?}
 */
drive.ds.DeltaItem.prototype.getPrevPosition = function() {
  return /** @type {number?} */ (this.array[2]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.DeltaItem.prototype.setPrevPosition = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.DeltaItem.prototype.clearPrevPosition = function() {
  this.array[2] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.DeltaItem.prototype.getPosition = function() {
  return /** @type {number?} */ (this.array[3]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.DeltaItem.prototype.setPosition = function(value) {
  this.array[3] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.DeltaItem.prototype.clearPosition = function() {
  this.array[3] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ItemQueryRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [0,3,4,5,6,7,11,12,13,14]);
};
goog.inherits(drive.ds.ItemQueryRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ItemQueryRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ItemQueryRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ItemQueryRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ItemQueryRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    fieldList: msg.array[0],
    sort: (f = msg.getSort()) && drive.ds.SortSpec.toObject(includeInstance, f),
    id: msg.array[2],
    titleList: jspb.Message.toObjectList(msg.getTitleList(),
    drive.ds.TitleSpec.toObject, includeInstance),
    fullTextList: jspb.Message.toObjectList(msg.getFullTextList(),
    drive.ds.FullTextSpec.toObject, includeInstance),
    mimeTypeList: jspb.Message.toObjectList(msg.getMimeTypeList(),
    drive.ds.MimeTypeSpec.toObject, includeInstance),
    modifiedDateList: jspb.Message.toObjectList(msg.getModifiedDateList(),
    drive.ds.DateSpec.toObject, includeInstance),
    viewedDateList: jspb.Message.toObjectList(msg.getViewedDateList(),
    drive.ds.DateSpec.toObject, includeInstance),
    trashed: msg.array[8],
    starred: msg.array[9],
    hidden: msg.array[10],
    parentList: jspb.Message.toObjectList(msg.getParentList(),
    drive.ds.ParentSpec.toObject, includeInstance),
    ownerList: jspb.Message.toObjectList(msg.getOwnerList(),
    drive.ds.UserSpec.toObject, includeInstance),
    writerList: jspb.Message.toObjectList(msg.getWriterList(),
    drive.ds.UserSpec.toObject, includeInstance),
    readerList: jspb.Message.toObjectList(msg.getReaderList(),
    drive.ds.UserSpec.toObject, includeInstance),
    sharedWithMe: msg.array[15],
    explicitlyTrashed: msg.array[16]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ItemQueryRequest} The clone.
 */
drive.ds.ItemQueryRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ItemQueryRequest} */ (jspb.Message.clone(this));
};


/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.Field>}
 */
drive.ds.ItemQueryRequest.prototype.getFieldList = function() {
  return /** @type {!Array.<!drive.ds.Field>} */ (this.array[0]);
};

/**
 * @param {Array.<!drive.ds.Field>|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setFieldList = function(value) {
  this.array[0] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearFieldList = function() {
  this.array[0] = []; 
};

/**
 * @return {drive.ds.SortSpec}
 */
drive.ds.ItemQueryRequest.prototype.getSort = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.SortSpec} */ (
      jspb.Message.getWrapperField(this, drive.ds.SortSpec, 1));
};

/**
 * @param {drive.ds.SortSpec|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setSort = function(value) {
  jspb.Message.setWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearSort = function() {
  this.setSort(undefined); 
};

/**
 * @return {string?}
 */
drive.ds.ItemQueryRequest.prototype.getId = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setId = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearId = function() {
  this.array[2] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.TitleSpec>}
 */
drive.ds.ItemQueryRequest.prototype.getTitleList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.TitleSpec>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.TitleSpec, 3));
};

/**
 * @param {Array.<!drive.ds.TitleSpec>|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setTitleList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearTitleList = function() {
  this.setTitleList([]); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.FullTextSpec>}
 */
drive.ds.ItemQueryRequest.prototype.getFullTextList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.FullTextSpec>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.FullTextSpec, 4));
};

/**
 * @param {Array.<!drive.ds.FullTextSpec>|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setFullTextList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearFullTextList = function() {
  this.setFullTextList([]); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.MimeTypeSpec>}
 */
drive.ds.ItemQueryRequest.prototype.getMimeTypeList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.MimeTypeSpec>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.MimeTypeSpec, 5));
};

/**
 * @param {Array.<!drive.ds.MimeTypeSpec>|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setMimeTypeList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearMimeTypeList = function() {
  this.setMimeTypeList([]); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.DateSpec>}
 */
drive.ds.ItemQueryRequest.prototype.getModifiedDateList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.DateSpec>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.DateSpec, 6));
};

/**
 * @param {Array.<!drive.ds.DateSpec>|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setModifiedDateList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 6, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearModifiedDateList = function() {
  this.setModifiedDateList([]); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.DateSpec>}
 */
drive.ds.ItemQueryRequest.prototype.getViewedDateList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.DateSpec>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.DateSpec, 7));
};

/**
 * @param {Array.<!drive.ds.DateSpec>|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setViewedDateList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 7, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearViewedDateList = function() {
  this.setViewedDateList([]); 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.ItemQueryRequest.prototype.getTrashed = function() {
  return /** @type {boolean?} */ (this.array[8]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setTrashed = function(value) {
  this.array[8] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearTrashed = function() {
  this.array[8] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.ItemQueryRequest.prototype.getStarred = function() {
  return /** @type {boolean?} */ (this.array[9]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setStarred = function(value) {
  this.array[9] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearStarred = function() {
  this.array[9] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.ItemQueryRequest.prototype.getHidden = function() {
  return /** @type {boolean?} */ (this.array[10]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setHidden = function(value) {
  this.array[10] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearHidden = function() {
  this.array[10] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.ParentSpec>}
 */
drive.ds.ItemQueryRequest.prototype.getParentList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.ParentSpec>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.ParentSpec, 11));
};

/**
 * @param {Array.<!drive.ds.ParentSpec>|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setParentList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 11, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearParentList = function() {
  this.setParentList([]); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.UserSpec>}
 */
drive.ds.ItemQueryRequest.prototype.getOwnerList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.UserSpec>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.UserSpec, 12));
};

/**
 * @param {Array.<!drive.ds.UserSpec>|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setOwnerList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 12, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearOwnerList = function() {
  this.setOwnerList([]); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.UserSpec>}
 */
drive.ds.ItemQueryRequest.prototype.getWriterList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.UserSpec>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.UserSpec, 13));
};

/**
 * @param {Array.<!drive.ds.UserSpec>|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setWriterList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 13, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearWriterList = function() {
  this.setWriterList([]); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.UserSpec>}
 */
drive.ds.ItemQueryRequest.prototype.getReaderList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.UserSpec>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.UserSpec, 14));
};

/**
 * @param {Array.<!drive.ds.UserSpec>|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setReaderList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 14, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearReaderList = function() {
  this.setReaderList([]); 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.ItemQueryRequest.prototype.getSharedWithMe = function() {
  return /** @type {boolean?} */ (this.array[15]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setSharedWithMe = function(value) {
  this.array[15] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearSharedWithMe = function() {
  this.array[15] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.ItemQueryRequest.prototype.getExplicitlyTrashed = function() {
  return /** @type {boolean?} */ (this.array[16]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.ItemQueryRequest.prototype.setExplicitlyTrashed = function(value) {
  this.array[16] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ItemQueryRequest.prototype.clearExplicitlyTrashed = function() {
  this.array[16] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.SortSpec = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.SortSpec, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.SortSpec.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.SortSpec.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.SortSpec} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.SortSpec.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: msg.array[0] != null ? msg.array[0] : 4,
    direction: msg.array[1] != null ? msg.array[1] : 1,
    foldersFirst: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.SortSpec} The clone.
 */
drive.ds.SortSpec.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.SortSpec} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.SortSpec.Type}
 */
drive.ds.SortSpec.prototype.getType = function() {
  return /** @type {!drive.ds.SortSpec.Type} */ (this.array[0] != null ? this.array[0] : 4);
};

/**
 * @param {drive.ds.SortSpec.Type|undefined} value 
 */
drive.ds.SortSpec.prototype.setType = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.SortSpec.prototype.clearType = function() {
  this.array[0] = undefined; 
};

/**
 * @return {!drive.ds.SortSpec.Direction}
 */
drive.ds.SortSpec.prototype.getDirection = function() {
  return /** @type {!drive.ds.SortSpec.Direction} */ (this.array[1] != null ? this.array[1] : 1);
};

/**
 * @param {drive.ds.SortSpec.Direction|undefined} value 
 */
drive.ds.SortSpec.prototype.setDirection = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.SortSpec.prototype.clearDirection = function() {
  this.array[1] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.SortSpec.prototype.getFoldersFirst = function() {
  return /** @type {boolean?} */ (this.array[2]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.SortSpec.prototype.setFoldersFirst = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.SortSpec.prototype.clearFoldersFirst = function() {
  this.array[2] = undefined; 
};


/**
 * @enum {number}
 */
drive.ds.SortSpec.Type = {
  LAST_MODIFIED: 1,
  LAST_MODIFIED_BY_ME: 2,
  USER_QUOTA: 3,
  TITLE: 4,
  RELEVANCE: 5,
  LAST_VIEWED_BY_ME: 6,
  SHARED_DATE: 7,
  STARRED: 9
};

/**
 * @enum {number}
 */
drive.ds.SortSpec.Direction = {
  ASCENDING: 1,
  DESCENDING: 2
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ActivityQueryRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.ActivityQueryRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ActivityQueryRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ActivityQueryRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ActivityQueryRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ActivityQueryRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.array[0],
    recursive: msg.array[1],
    omitNewActivity: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ActivityQueryRequest} The clone.
 */
drive.ds.ActivityQueryRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ActivityQueryRequest} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.ActivityQueryRequest.prototype.getId = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.ActivityQueryRequest.prototype.setId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ActivityQueryRequest.prototype.clearId = function() {
  this.array[0] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.ActivityQueryRequest.prototype.getRecursive = function() {
  return /** @type {boolean?} */ (this.array[1]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.ActivityQueryRequest.prototype.setRecursive = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ActivityQueryRequest.prototype.clearRecursive = function() {
  this.array[1] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
drive.ds.ActivityQueryRequest.prototype.getOmitNewActivity = function() {
  return /** @type {boolean} */ (this.array[2]);
};

/**
 * @param {boolean|undefined} value 
 */
drive.ds.ActivityQueryRequest.prototype.setOmitNewActivity = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ActivityQueryRequest.prototype.clearOmitNewActivity = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ActivityQueryResponse = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1]);
};
goog.inherits(drive.ds.ActivityQueryResponse, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ActivityQueryResponse.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ActivityQueryResponse.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ActivityQueryResponse} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ActivityQueryResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: msg.array[0],
    activityList: jspb.Message.toObjectList(msg.getActivityList(),
    proto.apps.activity.frontend.ActivityEvent.toObject, includeInstance),
    errorMessage: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ActivityQueryResponse} The clone.
 */
drive.ds.ActivityQueryResponse.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ActivityQueryResponse} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.Status}
 */
drive.ds.ActivityQueryResponse.prototype.getStatus = function() {
  return /** @type {!drive.ds.Status} */ (this.array[0]);
};

/**
 * @param {drive.ds.Status|undefined} value 
 */
drive.ds.ActivityQueryResponse.prototype.setStatus = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ActivityQueryResponse.prototype.clearStatus = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.apps.activity.frontend.ActivityEvent>}
 */
drive.ds.ActivityQueryResponse.prototype.getActivityList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!proto.apps.activity.frontend.ActivityEvent>} */ (
      jspb.Message.getRepeatedWrapperField(this, proto.apps.activity.frontend.ActivityEvent, 1));
};

/**
 * @param {Array.<!proto.apps.activity.frontend.ActivityEvent>|undefined} value 
 */
drive.ds.ActivityQueryResponse.prototype.setActivityList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ActivityQueryResponse.prototype.clearActivityList = function() {
  this.setActivityList([]); 
};

/**
 * @return {string?}
 */
drive.ds.ActivityQueryResponse.prototype.getErrorMessage = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.ActivityQueryResponse.prototype.setErrorMessage = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ActivityQueryResponse.prototype.clearErrorMessage = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ActivityQueryDeltaResponse = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1]);
};
goog.inherits(drive.ds.ActivityQueryDeltaResponse, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ActivityQueryDeltaResponse.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ActivityQueryDeltaResponse.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ActivityQueryDeltaResponse} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ActivityQueryDeltaResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: msg.array[0],
    deltaEventList: jspb.Message.toObjectList(msg.getDeltaEventList(),
    drive.ds.DeltaActivityEvent.toObject, includeInstance),
    errorMessage: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ActivityQueryDeltaResponse} The clone.
 */
drive.ds.ActivityQueryDeltaResponse.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ActivityQueryDeltaResponse} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.Status}
 */
drive.ds.ActivityQueryDeltaResponse.prototype.getStatus = function() {
  return /** @type {!drive.ds.Status} */ (this.array[0]);
};

/**
 * @param {drive.ds.Status|undefined} value 
 */
drive.ds.ActivityQueryDeltaResponse.prototype.setStatus = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ActivityQueryDeltaResponse.prototype.clearStatus = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.DeltaActivityEvent>}
 */
drive.ds.ActivityQueryDeltaResponse.prototype.getDeltaEventList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.DeltaActivityEvent>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.DeltaActivityEvent, 1));
};

/**
 * @param {Array.<!drive.ds.DeltaActivityEvent>|undefined} value 
 */
drive.ds.ActivityQueryDeltaResponse.prototype.setDeltaEventList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ActivityQueryDeltaResponse.prototype.clearDeltaEventList = function() {
  this.setDeltaEventList([]); 
};

/**
 * @return {string?}
 */
drive.ds.ActivityQueryDeltaResponse.prototype.getErrorMessage = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.ActivityQueryDeltaResponse.prototype.setErrorMessage = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ActivityQueryDeltaResponse.prototype.clearErrorMessage = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.DeltaActivityEvent = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.DeltaActivityEvent, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.DeltaActivityEvent.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.DeltaActivityEvent.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.DeltaActivityEvent} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.DeltaActivityEvent.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: msg.array[0],
    activity: (f = msg.getActivity()) && proto.apps.activity.frontend.ActivityEvent.toObject(includeInstance, f),
    position: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.DeltaActivityEvent} The clone.
 */
drive.ds.DeltaActivityEvent.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.DeltaActivityEvent} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.DeltaType}
 */
drive.ds.DeltaActivityEvent.prototype.getType = function() {
  return /** @type {!drive.ds.DeltaType} */ (this.array[0]);
};

/**
 * @param {drive.ds.DeltaType|undefined} value 
 */
drive.ds.DeltaActivityEvent.prototype.setType = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.DeltaActivityEvent.prototype.clearType = function() {
  this.array[0] = undefined; 
};

/**
 * @return {proto.apps.activity.frontend.ActivityEvent}
 */
drive.ds.DeltaActivityEvent.prototype.getActivity = function() {
  // The field might be undefined. Just cast.
  return /** @type{proto.apps.activity.frontend.ActivityEvent} */ (
      jspb.Message.getWrapperField(this, proto.apps.activity.frontend.ActivityEvent, 1));
};

/**
 * @param {proto.apps.activity.frontend.ActivityEvent|undefined} value 
 */
drive.ds.DeltaActivityEvent.prototype.setActivity = function(value) {
  jspb.Message.setWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.DeltaActivityEvent.prototype.clearActivity = function() {
  this.setActivity(undefined); 
};

/**
 * @return {number?}
 */
drive.ds.DeltaActivityEvent.prototype.getPosition = function() {
  return /** @type {number?} */ (this.array[2]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.DeltaActivityEvent.prototype.setPosition = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.DeltaActivityEvent.prototype.clearPosition = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.TitleSpec = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.TitleSpec, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.TitleSpec.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.TitleSpec.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.TitleSpec} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.TitleSpec.toObject = function(includeInstance, msg) {
  var f, obj = {
    operator: msg.array[0],
    value: msg.array[1],
    invert: msg.array[2] != null ? msg.array[2] : false
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.TitleSpec} The clone.
 */
drive.ds.TitleSpec.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.TitleSpec} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.TitleSpec.Operator}
 */
drive.ds.TitleSpec.prototype.getOperator = function() {
  return /** @type {!drive.ds.TitleSpec.Operator} */ (this.array[0]);
};

/**
 * @param {drive.ds.TitleSpec.Operator|undefined} value 
 */
drive.ds.TitleSpec.prototype.setOperator = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.TitleSpec.prototype.clearOperator = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string}
 */
drive.ds.TitleSpec.prototype.getValue = function() {
  return /** @type {string} */ (this.array[1]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.TitleSpec.prototype.setValue = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.TitleSpec.prototype.clearValue = function() {
  this.array[1] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
drive.ds.TitleSpec.prototype.getInvert = function() {
  return /** @type {boolean} */ (this.array[2] != null ? this.array[2] : false);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.TitleSpec.prototype.setInvert = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.TitleSpec.prototype.clearInvert = function() {
  this.array[2] = undefined; 
};


/**
 * @enum {number}
 */
drive.ds.TitleSpec.Operator = {
  CONTAINS: 1,
  EQUALS: 2
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.FullTextSpec = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.FullTextSpec, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.FullTextSpec.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.FullTextSpec.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.FullTextSpec} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.FullTextSpec.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: msg.array[0],
    invert: msg.array[1] != null ? msg.array[1] : false
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.FullTextSpec} The clone.
 */
drive.ds.FullTextSpec.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.FullTextSpec} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.FullTextSpec.prototype.getValue = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.FullTextSpec.prototype.setValue = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.FullTextSpec.prototype.clearValue = function() {
  this.array[0] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
drive.ds.FullTextSpec.prototype.getInvert = function() {
  return /** @type {boolean} */ (this.array[1] != null ? this.array[1] : false);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.FullTextSpec.prototype.setInvert = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.FullTextSpec.prototype.clearInvert = function() {
  this.array[1] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.MimeTypeSpec = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.MimeTypeSpec, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.MimeTypeSpec.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.MimeTypeSpec.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.MimeTypeSpec} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.MimeTypeSpec.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: msg.array[0],
    invert: msg.array[1] != null ? msg.array[1] : false
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.MimeTypeSpec} The clone.
 */
drive.ds.MimeTypeSpec.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.MimeTypeSpec} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.MimeTypeSpec.prototype.getValue = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.MimeTypeSpec.prototype.setValue = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.MimeTypeSpec.prototype.clearValue = function() {
  this.array[0] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
drive.ds.MimeTypeSpec.prototype.getInvert = function() {
  return /** @type {boolean} */ (this.array[1] != null ? this.array[1] : false);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.MimeTypeSpec.prototype.setInvert = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.MimeTypeSpec.prototype.clearInvert = function() {
  this.array[1] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.DateSpec = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.DateSpec, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.DateSpec.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.DateSpec.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.DateSpec} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.DateSpec.toObject = function(includeInstance, msg) {
  var f, obj = {
    operator: msg.array[0],
    dateMillis: msg.array[1]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.DateSpec} The clone.
 */
drive.ds.DateSpec.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.DateSpec} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.DateSpec.Operator}
 */
drive.ds.DateSpec.prototype.getOperator = function() {
  return /** @type {!drive.ds.DateSpec.Operator} */ (this.array[0]);
};

/**
 * @param {drive.ds.DateSpec.Operator|undefined} value 
 */
drive.ds.DateSpec.prototype.setOperator = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.DateSpec.prototype.clearOperator = function() {
  this.array[0] = undefined; 
};

/**
 * @return {number}
 */
drive.ds.DateSpec.prototype.getDateMillis = function() {
  return /** @type {number} */ (this.array[1]);
};

/**
 * @param {number|undefined} value 
 */
drive.ds.DateSpec.prototype.setDateMillis = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.DateSpec.prototype.clearDateMillis = function() {
  this.array[1] = undefined; 
};


/**
 * @enum {number}
 */
drive.ds.DateSpec.Operator = {
  LESS_EQUALS: 1,
  LESS_THAN: 2,
  EQUALS: 3,
  GREATER_THAN: 4,
  GREATER_EQUALS: 5
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ParentSpec = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.ParentSpec, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ParentSpec.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ParentSpec.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ParentSpec} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ParentSpec.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: msg.array[0],
    invert: msg.array[1] != null ? msg.array[1] : false
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ParentSpec} The clone.
 */
drive.ds.ParentSpec.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ParentSpec} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.ParentSpec.prototype.getValue = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.ParentSpec.prototype.setValue = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ParentSpec.prototype.clearValue = function() {
  this.array[0] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
drive.ds.ParentSpec.prototype.getInvert = function() {
  return /** @type {boolean} */ (this.array[1] != null ? this.array[1] : false);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.ParentSpec.prototype.setInvert = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ParentSpec.prototype.clearInvert = function() {
  this.array[1] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.UserSpec = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.UserSpec, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.UserSpec.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.UserSpec.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.UserSpec} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.UserSpec.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: msg.array[0],
    invert: msg.array[1] != null ? msg.array[1] : false
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.UserSpec} The clone.
 */
drive.ds.UserSpec.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.UserSpec} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.UserSpec.prototype.getValue = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.UserSpec.prototype.setValue = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserSpec.prototype.clearValue = function() {
  this.array[0] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
drive.ds.UserSpec.prototype.getInvert = function() {
  return /** @type {boolean} */ (this.array[1] != null ? this.array[1] : false);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.UserSpec.prototype.setInvert = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UserSpec.prototype.clearInvert = function() {
  this.array[1] = undefined; 
};


/**
 * @enum {number}
 */
drive.ds.DeltaType = {
  INSERT: 1,
  DELETE: 2,
  MOVE: 3,
  UPDATE: 4
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.DumpelloQuery = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.DumpelloQuery, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.DumpelloQuery.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.DumpelloQuery.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.DumpelloQuery} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.DumpelloQuery.toObject = function(includeInstance, msg) {
  var f, obj = {
    query: (f = msg.getQuery()) && drive.ds.ItemQueryRequest.toObject(includeInstance, f),
    minResultSize: msg.array[1],
    lastItem: (f = msg.getLastItem()) && drive.ds.Item.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.DumpelloQuery} The clone.
 */
drive.ds.DumpelloQuery.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.DumpelloQuery} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.ItemQueryRequest}
 */
drive.ds.DumpelloQuery.prototype.getQuery = function() {
  // The field might be undefined. Just cast.
  return /** @type{!drive.ds.ItemQueryRequest} */ (
      jspb.Message.getWrapperField(this, drive.ds.ItemQueryRequest, 0, 1));
};

/**
 * @param {drive.ds.ItemQueryRequest|undefined} value 
 */
drive.ds.DumpelloQuery.prototype.setQuery = function(value) {
  jspb.Message.setWrapperField(this, 0, value); 
};

/**
 * Clears the value. 
 */
drive.ds.DumpelloQuery.prototype.clearQuery = function() {
  this.setQuery(undefined); 
};

/**
 * @return {number?}
 */
drive.ds.DumpelloQuery.prototype.getMinResultSize = function() {
  return /** @type {number?} */ (this.array[1]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.DumpelloQuery.prototype.setMinResultSize = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.DumpelloQuery.prototype.clearMinResultSize = function() {
  this.array[1] = undefined; 
};

/**
 * @return {drive.ds.Item}
 */
drive.ds.DumpelloQuery.prototype.getLastItem = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.Item} */ (
      jspb.Message.getWrapperField(this, drive.ds.Item, 2));
};

/**
 * @param {drive.ds.Item|undefined} value 
 */
drive.ds.DumpelloQuery.prototype.setLastItem = function(value) {
  jspb.Message.setWrapperField(this, 2, value); 
};

/**
 * Clears the value. 
 */
drive.ds.DumpelloQuery.prototype.clearLastItem = function() {
  this.setLastItem(undefined); 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.Dumpello = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [0,1,4,6]);
};
goog.inherits(drive.ds.Dumpello, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.Dumpello.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.Dumpello.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.Dumpello} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.Dumpello.toObject = function(includeInstance, msg) {
  var f, obj = {
    itemList: jspb.Message.toObjectList(msg.getItemList(),
    drive.ds.Item.toObject, includeInstance),
    permissionList: jspb.Message.toObjectList(msg.getPermissionList(),
    drive.ds.Permission.toObject, includeInstance),
    changeId: msg.array[2],
    rootId: msg.array[3],
    supportedQueryList: jspb.Message.toObjectList(msg.getSupportedQueryList(),
    drive.ds.DumpelloQuery.toObject, includeInstance),
    partial: msg.array[5],
    appList: jspb.Message.toObjectList(msg.getAppList(),
    drive.ds.App.toObject, includeInstance),
    account: (f = msg.getAccount()) && drive.ds.Account.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.Dumpello} The clone.
 */
drive.ds.Dumpello.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.Dumpello} */ (jspb.Message.clone(this));
};


/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.Item>}
 */
drive.ds.Dumpello.prototype.getItemList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.Item>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.Item, 0));
};

/**
 * @param {Array.<!drive.ds.Item>|undefined} value 
 */
drive.ds.Dumpello.prototype.setItemList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 0, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Dumpello.prototype.clearItemList = function() {
  this.setItemList([]); 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.Permission>}
 */
drive.ds.Dumpello.prototype.getPermissionList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.Permission>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.Permission, 1));
};

/**
 * @param {Array.<!drive.ds.Permission>|undefined} value 
 */
drive.ds.Dumpello.prototype.setPermissionList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Dumpello.prototype.clearPermissionList = function() {
  this.setPermissionList([]); 
};

/**
 * @return {number?}
 */
drive.ds.Dumpello.prototype.getChangeId = function() {
  return /** @type {number?} */ (this.array[2]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Dumpello.prototype.setChangeId = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Dumpello.prototype.clearChangeId = function() {
  this.array[2] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Dumpello.prototype.getRootId = function() {
  return /** @type {string?} */ (this.array[3]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Dumpello.prototype.setRootId = function(value) {
  this.array[3] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Dumpello.prototype.clearRootId = function() {
  this.array[3] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.DumpelloQuery>}
 */
drive.ds.Dumpello.prototype.getSupportedQueryList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.DumpelloQuery>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.DumpelloQuery, 4));
};

/**
 * @param {Array.<!drive.ds.DumpelloQuery>|undefined} value 
 */
drive.ds.Dumpello.prototype.setSupportedQueryList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Dumpello.prototype.clearSupportedQueryList = function() {
  this.setSupportedQueryList([]); 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Dumpello.prototype.getPartial = function() {
  return /** @type {boolean?} */ (this.array[5]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Dumpello.prototype.setPartial = function(value) {
  this.array[5] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Dumpello.prototype.clearPartial = function() {
  this.array[5] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.App>}
 */
drive.ds.Dumpello.prototype.getAppList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.App>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.App, 6));
};

/**
 * @param {Array.<!drive.ds.App>|undefined} value 
 */
drive.ds.Dumpello.prototype.setAppList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 6, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Dumpello.prototype.clearAppList = function() {
  this.setAppList([]); 
};

/**
 * @return {drive.ds.Account}
 */
drive.ds.Dumpello.prototype.getAccount = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.Account} */ (
      jspb.Message.getWrapperField(this, drive.ds.Account, 7));
};

/**
 * @param {drive.ds.Account|undefined} value 
 */
drive.ds.Dumpello.prototype.setAccount = function(value) {
  jspb.Message.setWrapperField(this, 7, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Dumpello.prototype.clearAccount = function() {
  this.setAccount(undefined); 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.Error = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.Error, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.Error.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.Error.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.Error} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.Error.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: msg.array[0],
    cause: msg.array[1],
    message: msg.array[2],
    detail: msg.array[3]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.Error} The clone.
 */
drive.ds.Error.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.Error} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.Error.Type}
 */
drive.ds.Error.prototype.getType = function() {
  return /** @type {!drive.ds.Error.Type} */ (this.array[0]);
};

/**
 * @param {drive.ds.Error.Type|undefined} value 
 */
drive.ds.Error.prototype.setType = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Error.prototype.clearType = function() {
  this.array[0] = undefined; 
};

/**
 * @return {drive.ds.Error.Cause}
 */
drive.ds.Error.prototype.getCause = function() {
  return /** @type {drive.ds.Error.Cause} */ (this.array[1]);
};

/**
 * @param {drive.ds.Error.Cause|undefined} value 
 */
drive.ds.Error.prototype.setCause = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Error.prototype.clearCause = function() {
  this.array[1] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Error.prototype.getMessage = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Error.prototype.setMessage = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Error.prototype.clearMessage = function() {
  this.array[2] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Error.prototype.getDetail = function() {
  return /** @type {string?} */ (this.array[3]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Error.prototype.setDetail = function(value) {
  this.array[3] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Error.prototype.clearDetail = function() {
  this.array[3] = undefined; 
};


/**
 * @enum {number}
 */
drive.ds.Error.Type = {
  LOAD: 1,
  RUNTIME: 2
};

/**
 * @enum {number}
 */
drive.ds.Error.Cause = {
  UNAVAILABLE_OFFLINE: 1,
  AUTHORIZATION: 2,
  UNSUPPORTED: 3
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ListRevisionsRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.ListRevisionsRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ListRevisionsRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ListRevisionsRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ListRevisionsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ListRevisionsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    itemId: msg.array[0]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ListRevisionsRequest} The clone.
 */
drive.ds.ListRevisionsRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ListRevisionsRequest} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.ListRevisionsRequest.prototype.getItemId = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.ListRevisionsRequest.prototype.setItemId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListRevisionsRequest.prototype.clearItemId = function() {
  this.array[0] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ListRevisionsResponse = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1]);
};
goog.inherits(drive.ds.ListRevisionsResponse, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ListRevisionsResponse.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ListRevisionsResponse.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ListRevisionsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ListRevisionsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: msg.array[0],
    revisionList: jspb.Message.toObjectList(msg.getRevisionList(),
    drive.ds.Revision.toObject, includeInstance),
    errorMessage: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ListRevisionsResponse} The clone.
 */
drive.ds.ListRevisionsResponse.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ListRevisionsResponse} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.Status}
 */
drive.ds.ListRevisionsResponse.prototype.getStatus = function() {
  return /** @type {!drive.ds.Status} */ (this.array[0]);
};

/**
 * @param {drive.ds.Status|undefined} value 
 */
drive.ds.ListRevisionsResponse.prototype.setStatus = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListRevisionsResponse.prototype.clearStatus = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!drive.ds.Revision>}
 */
drive.ds.ListRevisionsResponse.prototype.getRevisionList = function() {
  // The field might be undefined. Just cast.
  return /** @type{!Array.<!drive.ds.Revision>} */ (
      jspb.Message.getRepeatedWrapperField(this, drive.ds.Revision, 1));
};

/**
 * @param {Array.<!drive.ds.Revision>|undefined} value 
 */
drive.ds.ListRevisionsResponse.prototype.setRevisionList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.ListRevisionsResponse.prototype.clearRevisionList = function() {
  this.setRevisionList([]); 
};

/**
 * @return {string?}
 */
drive.ds.ListRevisionsResponse.prototype.getErrorMessage = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.ListRevisionsResponse.prototype.setErrorMessage = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ListRevisionsResponse.prototype.clearErrorMessage = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.Revision = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.Revision, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.Revision.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.Revision.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.Revision} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.Revision.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.array[0],
    mimeType: msg.array[1],
    modifiedDateMillis: msg.array[2],
    pinned: msg.array[3],
    downloadUrl: msg.array[4],
    originalItemName: msg.array[6],
    fileSize: msg.array[7],
    lastModifyingUser: (f = msg.getLastModifyingUser()) && drive.ds.Permission.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.Revision} The clone.
 */
drive.ds.Revision.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.Revision} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.Revision.prototype.getId = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.Revision.prototype.setId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Revision.prototype.clearId = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string}
 */
drive.ds.Revision.prototype.getMimeType = function() {
  return /** @type {string} */ (this.array[1]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.Revision.prototype.setMimeType = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Revision.prototype.clearMimeType = function() {
  this.array[1] = undefined; 
};

/**
 * @return {number}
 */
drive.ds.Revision.prototype.getModifiedDateMillis = function() {
  return /** @type {number} */ (this.array[2]);
};

/**
 * @param {number|undefined} value 
 */
drive.ds.Revision.prototype.setModifiedDateMillis = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Revision.prototype.clearModifiedDateMillis = function() {
  this.array[2] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.Revision.prototype.getPinned = function() {
  return /** @type {boolean?} */ (this.array[3]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.Revision.prototype.setPinned = function(value) {
  this.array[3] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Revision.prototype.clearPinned = function() {
  this.array[3] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Revision.prototype.getDownloadUrl = function() {
  return /** @type {string?} */ (this.array[4]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Revision.prototype.setDownloadUrl = function(value) {
  this.array[4] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Revision.prototype.clearDownloadUrl = function() {
  this.array[4] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.Revision.prototype.getOriginalItemName = function() {
  return /** @type {string?} */ (this.array[6]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.Revision.prototype.setOriginalItemName = function(value) {
  this.array[6] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Revision.prototype.clearOriginalItemName = function() {
  this.array[6] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.Revision.prototype.getFileSize = function() {
  return /** @type {number?} */ (this.array[7]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.Revision.prototype.setFileSize = function(value) {
  this.array[7] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.Revision.prototype.clearFileSize = function() {
  this.array[7] = undefined; 
};

/**
 * @return {!drive.ds.Permission}
 */
drive.ds.Revision.prototype.getLastModifyingUser = function() {
  // The field might be undefined. Just cast.
  return /** @type{!drive.ds.Permission} */ (
      jspb.Message.getWrapperField(this, drive.ds.Permission, 8, 1));
};

/**
 * @param {drive.ds.Permission|undefined} value 
 */
drive.ds.Revision.prototype.setLastModifyingUser = function(value) {
  jspb.Message.setWrapperField(this, 8, value); 
};

/**
 * Clears the value. 
 */
drive.ds.Revision.prototype.clearLastModifyingUser = function() {
  this.setLastModifyingUser(undefined); 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.CopyItemRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [2]);
};
goog.inherits(drive.ds.CopyItemRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.CopyItemRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.CopyItemRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.CopyItemRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.CopyItemRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.array[0],
    title: msg.array[1],
    parentList: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.CopyItemRequest} The clone.
 */
drive.ds.CopyItemRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.CopyItemRequest} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.CopyItemRequest.prototype.getId = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.CopyItemRequest.prototype.setId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.CopyItemRequest.prototype.clearId = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.CopyItemRequest.prototype.getTitle = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.CopyItemRequest.prototype.setTitle = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.CopyItemRequest.prototype.clearTitle = function() {
  this.array[1] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.CopyItemRequest.prototype.getParentList = function() {
  return /** @type {!Array.<string>} */ (this.array[2]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.CopyItemRequest.prototype.setParentList = function(value) {
  this.array[2] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.CopyItemRequest.prototype.clearParentList = function() {
  this.array[2] = []; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.CreateItemRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [2]);
};
goog.inherits(drive.ds.CreateItemRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.CreateItemRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.CreateItemRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.CreateItemRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.CreateItemRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    mimeType: msg.array[0],
    title: msg.array[1],
    parentList: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.CreateItemRequest} The clone.
 */
drive.ds.CreateItemRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.CreateItemRequest} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.CreateItemRequest.prototype.getMimeType = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.CreateItemRequest.prototype.setMimeType = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.CreateItemRequest.prototype.clearMimeType = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.CreateItemRequest.prototype.getTitle = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.CreateItemRequest.prototype.setTitle = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.CreateItemRequest.prototype.clearTitle = function() {
  this.array[1] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.CreateItemRequest.prototype.getParentList = function() {
  return /** @type {!Array.<string>} */ (this.array[2]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.CreateItemRequest.prototype.setParentList = function(value) {
  this.array[2] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.CreateItemRequest.prototype.clearParentList = function() {
  this.array[2] = []; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.DeleteItemRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.DeleteItemRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.DeleteItemRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.DeleteItemRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.DeleteItemRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.DeleteItemRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.array[0]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.DeleteItemRequest} The clone.
 */
drive.ds.DeleteItemRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.DeleteItemRequest} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.DeleteItemRequest.prototype.getId = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.DeleteItemRequest.prototype.setId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.DeleteItemRequest.prototype.clearId = function() {
  this.array[0] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.ReparentItemRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [1,2]);
};
goog.inherits(drive.ds.ReparentItemRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.ReparentItemRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.ReparentItemRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.ReparentItemRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.ReparentItemRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.array[0],
    parentsToAddList: msg.array[1],
    parentsToRemoveList: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.ReparentItemRequest} The clone.
 */
drive.ds.ReparentItemRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.ReparentItemRequest} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.ReparentItemRequest.prototype.getId = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.ReparentItemRequest.prototype.setId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.ReparentItemRequest.prototype.clearId = function() {
  this.array[0] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.ReparentItemRequest.prototype.getParentsToAddList = function() {
  return /** @type {!Array.<string>} */ (this.array[1]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.ReparentItemRequest.prototype.setParentsToAddList = function(value) {
  this.array[1] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.ReparentItemRequest.prototype.clearParentsToAddList = function() {
  this.array[1] = []; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.ReparentItemRequest.prototype.getParentsToRemoveList = function() {
  return /** @type {!Array.<string>} */ (this.array[2]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.ReparentItemRequest.prototype.setParentsToRemoveList = function(value) {
  this.array[2] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.ReparentItemRequest.prototype.clearParentsToRemoveList = function() {
  this.array[2] = []; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.UpdateItemRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, [7,8,9]);
};
goog.inherits(drive.ds.UpdateItemRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.UpdateItemRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.UpdateItemRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.UpdateItemRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.UpdateItemRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.array[0],
    title: msg.array[1],
    description: msg.array[2],
    starred: msg.array[3],
    trashed: msg.array[4],
    mimeType: msg.array[5],
    modifiedDateMillis: msg.array[6],
    parentList: msg.array[7],
    parentsToAddList: msg.array[8],
    parentsToRemoveList: msg.array[9]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.UpdateItemRequest} The clone.
 */
drive.ds.UpdateItemRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.UpdateItemRequest} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.UpdateItemRequest.prototype.getId = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.UpdateItemRequest.prototype.setId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateItemRequest.prototype.clearId = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.UpdateItemRequest.prototype.getTitle = function() {
  return /** @type {string?} */ (this.array[1]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.UpdateItemRequest.prototype.setTitle = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateItemRequest.prototype.clearTitle = function() {
  this.array[1] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.UpdateItemRequest.prototype.getDescription = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.UpdateItemRequest.prototype.setDescription = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateItemRequest.prototype.clearDescription = function() {
  this.array[2] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.UpdateItemRequest.prototype.getStarred = function() {
  return /** @type {boolean?} */ (this.array[3]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.UpdateItemRequest.prototype.setStarred = function(value) {
  this.array[3] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateItemRequest.prototype.clearStarred = function() {
  this.array[3] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.UpdateItemRequest.prototype.getTrashed = function() {
  return /** @type {boolean?} */ (this.array[4]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.UpdateItemRequest.prototype.setTrashed = function(value) {
  this.array[4] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateItemRequest.prototype.clearTrashed = function() {
  this.array[4] = undefined; 
};

/**
 * @return {string?}
 */
drive.ds.UpdateItemRequest.prototype.getMimeType = function() {
  return /** @type {string?} */ (this.array[5]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.UpdateItemRequest.prototype.setMimeType = function(value) {
  this.array[5] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateItemRequest.prototype.clearMimeType = function() {
  this.array[5] = undefined; 
};

/**
 * @return {number?}
 */
drive.ds.UpdateItemRequest.prototype.getModifiedDateMillis = function() {
  return /** @type {number?} */ (this.array[6]);
};

/**
 * @param {number?|undefined} value 
 */
drive.ds.UpdateItemRequest.prototype.setModifiedDateMillis = function(value) {
  this.array[6] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateItemRequest.prototype.clearModifiedDateMillis = function() {
  this.array[6] = undefined; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.UpdateItemRequest.prototype.getParentList = function() {
  return /** @type {!Array.<string>} */ (this.array[7]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.UpdateItemRequest.prototype.setParentList = function(value) {
  this.array[7] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateItemRequest.prototype.clearParentList = function() {
  this.array[7] = []; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.UpdateItemRequest.prototype.getParentsToAddList = function() {
  return /** @type {!Array.<string>} */ (this.array[8]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.UpdateItemRequest.prototype.setParentsToAddList = function(value) {
  this.array[8] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateItemRequest.prototype.clearParentsToAddList = function() {
  this.array[8] = []; 
};

/**
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
drive.ds.UpdateItemRequest.prototype.getParentsToRemoveList = function() {
  return /** @type {!Array.<string>} */ (this.array[9]);
};

/**
 * @param {Array.<string>|undefined} value 
 */
drive.ds.UpdateItemRequest.prototype.setParentsToRemoveList = function(value) {
  this.array[9] = value || []; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateItemRequest.prototype.clearParentsToRemoveList = function() {
  this.array[9] = []; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.UpdateRevisionRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.UpdateRevisionRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.UpdateRevisionRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.UpdateRevisionRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.UpdateRevisionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.UpdateRevisionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    itemId: msg.array[0],
    revisionId: msg.array[1],
    pinned: msg.array[2]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.UpdateRevisionRequest} The clone.
 */
drive.ds.UpdateRevisionRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.UpdateRevisionRequest} */ (jspb.Message.clone(this));
};


/**
 * @return {string}
 */
drive.ds.UpdateRevisionRequest.prototype.getItemId = function() {
  return /** @type {string} */ (this.array[0]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.UpdateRevisionRequest.prototype.setItemId = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateRevisionRequest.prototype.clearItemId = function() {
  this.array[0] = undefined; 
};

/**
 * @return {string}
 */
drive.ds.UpdateRevisionRequest.prototype.getRevisionId = function() {
  return /** @type {string} */ (this.array[1]);
};

/**
 * @param {string|undefined} value 
 */
drive.ds.UpdateRevisionRequest.prototype.setRevisionId = function(value) {
  this.array[1] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateRevisionRequest.prototype.clearRevisionId = function() {
  this.array[1] = undefined; 
};

/**
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean?}
 */
drive.ds.UpdateRevisionRequest.prototype.getPinned = function() {
  return /** @type {boolean?} */ (this.array[2]);
};

/**
 * @param {boolean?|undefined} value 
 */
drive.ds.UpdateRevisionRequest.prototype.setPinned = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.UpdateRevisionRequest.prototype.clearPinned = function() {
  this.array[2] = undefined; 
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.EmptyTrashRequest = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.EmptyTrashRequest, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.EmptyTrashRequest.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.EmptyTrashRequest.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.EmptyTrashRequest} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.EmptyTrashRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.EmptyTrashRequest} The clone.
 */
drive.ds.EmptyTrashRequest.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.EmptyTrashRequest} */ (jspb.Message.clone(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
drive.ds.MutateItemResponse = function(opt_data) {
  goog.base(this);
  jspb.Message.initialize(this, opt_data, '', -1, []);
};
goog.inherits(drive.ds.MutateItemResponse, jspb.Message);

/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
drive.ds.MutateItemResponse.prototype.toObject = function(opt_includeInstance) {
  return drive.ds.MutateItemResponse.toObject(opt_includeInstance, this);
};

/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!drive.ds.MutateItemResponse} msg The msg instance to transform.
 * @return {!Object}
 */
drive.ds.MutateItemResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: msg.array[0],
    item: (f = msg.getItem()) && drive.ds.Item.toObject(includeInstance, f),
    errorMessage: msg.array[2],
    revision: (f = msg.getRevision()) && drive.ds.Revision.toObject(includeInstance, f),
    itemId: msg.array[4]
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg
  }
  return obj;
};

/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!drive.ds.MutateItemResponse} The clone.
 */
drive.ds.MutateItemResponse.prototype.cloneMessage = function() {
  return /** @type {!drive.ds.MutateItemResponse} */ (jspb.Message.clone(this));
};


/**
 * @return {!drive.ds.Status}
 */
drive.ds.MutateItemResponse.prototype.getStatus = function() {
  return /** @type {!drive.ds.Status} */ (this.array[0]);
};

/**
 * @param {drive.ds.Status|undefined} value 
 */
drive.ds.MutateItemResponse.prototype.setStatus = function(value) {
  this.array[0] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.MutateItemResponse.prototype.clearStatus = function() {
  this.array[0] = undefined; 
};

/**
 * @return {drive.ds.Item}
 */
drive.ds.MutateItemResponse.prototype.getItem = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.Item} */ (
      jspb.Message.getWrapperField(this, drive.ds.Item, 1));
};

/**
 * @param {drive.ds.Item|undefined} value 
 */
drive.ds.MutateItemResponse.prototype.setItem = function(value) {
  jspb.Message.setWrapperField(this, 1, value); 
};

/**
 * Clears the value. 
 */
drive.ds.MutateItemResponse.prototype.clearItem = function() {
  this.setItem(undefined); 
};

/**
 * @return {string?}
 */
drive.ds.MutateItemResponse.prototype.getErrorMessage = function() {
  return /** @type {string?} */ (this.array[2]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.MutateItemResponse.prototype.setErrorMessage = function(value) {
  this.array[2] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.MutateItemResponse.prototype.clearErrorMessage = function() {
  this.array[2] = undefined; 
};

/**
 * @return {drive.ds.Revision}
 */
drive.ds.MutateItemResponse.prototype.getRevision = function() {
  // The field might be undefined. Just cast.
  return /** @type{drive.ds.Revision} */ (
      jspb.Message.getWrapperField(this, drive.ds.Revision, 3));
};

/**
 * @param {drive.ds.Revision|undefined} value 
 */
drive.ds.MutateItemResponse.prototype.setRevision = function(value) {
  jspb.Message.setWrapperField(this, 3, value); 
};

/**
 * Clears the value. 
 */
drive.ds.MutateItemResponse.prototype.clearRevision = function() {
  this.setRevision(undefined); 
};

/**
 * @return {string?}
 */
drive.ds.MutateItemResponse.prototype.getItemId = function() {
  return /** @type {string?} */ (this.array[4]);
};

/**
 * @param {string?|undefined} value 
 */
drive.ds.MutateItemResponse.prototype.setItemId = function(value) {
  this.array[4] = value; 
};

/**
 * Clears the value. 
 */
drive.ds.MutateItemResponse.prototype.clearItemId = function() {
  this.array[4] = undefined; 
};




//javascript/closure/string/stringbuffer.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utility for fast string concatenation.
 * @author timman@google.com (Tim Mansfield)
 */

goog.provide('goog.string.StringBuffer');



/**
 * Utility class to facilitate string concatenation.
 *
 * @param {*=} opt_a1 Optional first initial item to append.
 * @param {...*} var_args Other initial items to
 *     append, e.g., new goog.string.StringBuffer('foo', 'bar').
 * @constructor
 */
goog.string.StringBuffer = function(opt_a1, var_args) {
  if (opt_a1 != null) {
    this.append.apply(this, arguments);
  }
};


/**
 * Internal buffer for the string to be concatenated.
 * @type {string}
 * @private
 */
goog.string.StringBuffer.prototype.buffer_ = '';


/**
 * Sets the contents of the string buffer object, replacing what's currently
 * there.
 *
 * @param {*} s String to set.
 */
goog.string.StringBuffer.prototype.set = function(s) {
  this.buffer_ = '' + s;
};


/**
 * Appends one or more items to the buffer.
 *
 * Calling this with null, undefined, or empty arguments is an error.
 *
 * @param {*} a1 Required first string.
 * @param {*=} opt_a2 Optional second string.
 * @param {...*} var_args Other items to append,
 *     e.g., sb.append('foo', 'bar', 'baz').
 * @return {goog.string.StringBuffer} This same StringBuffer object.
 * @suppress {duplicate}
 */
goog.string.StringBuffer.prototype.append = function(a1, opt_a2, var_args) {
  // Use a1 directly to avoid arguments instantiation for single-arg case.
  this.buffer_ += a1;
  if (opt_a2 != null) { // second argument is undefined (null == undefined)
    for (var i = 1; i < arguments.length; i++) {
      this.buffer_ += arguments[i];
    }
  }
  return this;
};


/**
 * Clears the internal buffer.
 */
goog.string.StringBuffer.prototype.clear = function() {
  this.buffer_ = '';
};


/**
 * @return {number} the length of the current contents of the buffer.
 */
goog.string.StringBuffer.prototype.getLength = function() {
  return this.buffer_.length;
};


/**
 * @return {string} The concatenated string.
 * @override
 */
goog.string.StringBuffer.prototype.toString = function() {
  return this.buffer_;
};

//javascript/apps/drive/dataservice/sync/field.js
/**
 * @fileoverview A Genoa field helper.
 */

goog.provide('drive.ds.sync.Field');

goog.require('drive.ds.Field');
goog.require('goog.array');
goog.require('goog.object');
goog.require('goog.string.StringBuffer');


/**
 * A list of field proto items to Genoa field names.
 * @private {!Object.<drive.ds.Field, string>}
 */
drive.ds.sync.Field.protoToGenoaField_ = {};


/**
 * List of fields that are generated on the client side (either for
 * optimization reasons or because Genoa doesn't provide it).
 * @private {!Array.<!drive.ds.Field>}
 */
drive.ds.sync.Field.ClientCalcFields_ = [
  drive.ds.Field.HAS_CHILD_FOLDER,
  drive.ds.Field.OPEN_URL,
  drive.ds.Field.VISIBILITIES,
  drive.ds.Field.DOWNLOADABLE,
  drive.ds.Field.DOWNLOAD_URL
];


// Populates Genoa field name and ALL_FIELDS object with list of all currently
// supported fields.
(function() {
  var fieldMap = {};
  fieldMap[drive.ds.Field.PARENTS] = 'parents/id';
  fieldMap[drive.ds.Field.TITLE] = 'title';
  fieldMap[drive.ds.Field.MIME_TYPE] = 'mimeType';
  fieldMap[drive.ds.Field.STARRED] = 'labels/starred';
  fieldMap[drive.ds.Field.HIDDEN] = 'labels/hidden';
  fieldMap[drive.ds.Field.TRASHED] = 'labels/trashed';
  fieldMap[drive.ds.Field.RESTRICTED] = 'labels/restricted';
  fieldMap[drive.ds.Field.VIEWED] = 'labels/viewed';
  fieldMap[drive.ds.Field.CREATE_DATE_MILLIS] = 'createdDate';
  fieldMap[drive.ds.Field.MODIFIED_DATE_MILLIS] = 'modifiedDate';
  fieldMap[drive.ds.Field.MODIFIED_BY_ME_DATE_MILLIS] =
      'modifiedByMeDate';
  fieldMap[drive.ds.Field.LAST_VIEWED_BY_ME_DATE_MILLIS] =
      'lastViewedByMeDate';
  fieldMap[drive.ds.Field.FILE_SIZE] = 'fileSize';
  fieldMap[drive.ds.Field.OWNERS] =
      'owners/permissionId,owners/displayName,owners/picture';
  fieldMap[drive.ds.Field.LAST_MODIFYING_USER] = 'lastModifyingUser';
  fieldMap[drive.ds.Field.OPEN_URL] = 'alternateLink';
  fieldMap[drive.ds.Field.THUMBNAIL_URL] = 'thumbnailLink';
  fieldMap[drive.ds.Field.ICON_URL] = 'iconLink';
  fieldMap[drive.ds.Field.ID] = 'id';
  fieldMap[drive.ds.Field.SHARED] = 'shared';
  fieldMap[drive.ds.Field.SHARED_WITH_ME_DATE_MILLIS] =
      'sharedWithMeDate';
  fieldMap[drive.ds.Field.DESCRIPTION] = 'description';
  fieldMap[drive.ds.Field.USER_ROLE] = 'userPermission';
  fieldMap[drive.ds.Field.EXPLICITLY_TRASHED] = 'explicitlyTrashed';
  fieldMap[drive.ds.Field.IMAGE_DATE_MILLIS] = 'imageMediaMetadata/date';
  fieldMap[drive.ds.Field.IMAGE_WIDTH] = 'imageMediaMetadata/width';
  fieldMap[drive.ds.Field.IMAGE_HEIGHT] = 'imageMediaMetadata/height';
  fieldMap[drive.ds.Field.QUOTA_BYTES_USED] = 'quotaBytesUsed';
  fieldMap[drive.ds.Field.SHAREABLE] = 'writersCanShare';
  fieldMap[drive.ds.Field.COPYABLE] = 'copyable';
  fieldMap[drive.ds.Field.SUBSCRIBED] = 'subscribed';
  fieldMap[drive.ds.Field.COSMO_TYPE] = 'expello/cosmoType';
  fieldMap[drive.ds.Field.SERVICE_ID] = 'expello/serviceId';
  fieldMap[drive.ds.Field.FOLDER_COLOR] = 'folderColor';
  fieldMap[drive.ds.Field.HAS_CHILD_FOLDER] = '';
  // TODO(towong): Set Visibility once Genoa adds it (b/11186978).
  fieldMap[drive.ds.Field.VISIBILITIES] = '';
  fieldMap[drive.ds.Field.DOWNLOADABLE] = '';
  fieldMap[drive.ds.Field.DOWNLOAD_URL] = '';
  fieldMap[drive.ds.Field.CREATOR_APP] =
      'source/client_service_id,source/value';
  fieldMap[drive.ds.Field.FILE_EXTENSION] = 'fileExtension';
  // TODO(towong): Use primary_sync_parent once Genoa adds it, currently we just
  // check descendantOfRoot and choose a parent (b/11577157).
  fieldMap[drive.ds.Field.PRIMARY_SYNC_PARENT] = 'descendantOfRoot';
  drive.ds.sync.Field.protoToGenoaField_ = fieldMap;
})();


/**
 * @param {!Array.<!drive.ds.Field>} fields A list of fields for one file
 *     request.
 * @return {string} A stringified Genoa fields list for a files query.
 */
drive.ds.sync.Field.toFileFieldString = function(fields) {
  var sb = new goog.string.StringBuffer();
  drive.ds.sync.Field.toFieldString(sb, fields);
  return sb.toString();
};


/**
 * @param {!Array.<!drive.ds.Field>} fields A list of fields for files
 *     request.
 * @return {string} A stringified Genoa fields list for a files query.
 */
drive.ds.sync.Field.toFilesFieldString = function(fields) {
  var sb = new goog.string.StringBuffer();
  sb.append('kind,nextPageToken,items(');
  drive.ds.sync.Field.toFieldString(sb, fields);
  sb.append(')');
  return sb.toString();
};


/**
 * @param {!Array.<!drive.ds.Field>} fields A list of fields for change
 *     request.
 * @return {string} A stringified Genoa fields list for a change query.
 */
drive.ds.sync.Field.toChangesFieldString = function(fields) {
  var sb = new goog.string.StringBuffer();
  sb.append('kind,largestChangeId,nextPageToken,');
  sb.append('items(deleted,fileId,id,kind,');
  drive.ds.sync.Field.toFieldString(sb, fields, 'file');
  sb.append(')');
  return sb.toString();
};


/**
 * Adds the list of fields to the string buffer. Also appends 'kind' fields as
 * needed as they're used for validation in the response parser.
 * @param {!goog.string.StringBuffer} sb The string buffer.
 * @param {!Array.<!drive.ds.Field>} fields A list of request fields.
 * @param {string=} opt_fieldPrefix Optional field prefix.
 */
drive.ds.sync.Field.toFieldString = function(sb, fields, opt_fieldPrefix) {
  var prefixToFields = {};

  // Append non-prefixed fields.
  var nonPrefixBuffer = new goog.string.StringBuffer();
  nonPrefixBuffer.append('kind');
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];

    // Client side calculated fields that we don't need to get from Genoa.
    if (goog.array.contains(drive.ds.sync.Field.ClientCalcFields_, field)) {
      continue;
    }

    // If there's no Genoa field name, it means Genoa doesn't support it yet so
    // we don't add it to the list.
    var genoaFieldNames = drive.ds.sync.Field.toGenoaField(field);
    if (!genoaFieldNames) {
      continue;
    }

    // Multiple Genoa field names can be specified with a comma separated list.
    var splitGenoaFieldNames = genoaFieldNames.split(',');

    for (var j = 0; j < splitGenoaFieldNames.length; j++) {
      var genoaFieldName = splitGenoaFieldNames[j];
      // If field name has prefix, we save it so we can build an optimized
      // prefix string.
      var split = genoaFieldName.indexOf('/');
      if (split != -1) {
        var prefix = genoaFieldName.substring(0, split);
        var splitField = genoaFieldName.substring(split + 1);

        if (!prefixToFields[prefix]) {
          prefixToFields[prefix] = [];
        }
        prefixToFields[prefix].push(splitField);
      } else {
        nonPrefixBuffer.append(',');
        nonPrefixBuffer.append(genoaFieldName);
      }
    }
  }

  // Append prefixed fields.
  for (var prefix in prefixToFields) {
    var prefixToField = prefixToFields[prefix];

    var prefixBuffer = new goog.string.StringBuffer();
    for (var j = 0; j < prefixToField.length; j++) {
      prefixBuffer.append(j == 0 ? prefixToField[j] : ',' + prefixToField[j]);
    }

    // Append kind for owners field as needed.
    if (prefix == 'owners') {
      prefixBuffer.append(',kind');
    }

    nonPrefixBuffer.append(',' +
        drive.ds.sync.Field.wrapWithPrefix_(prefixBuffer.toString(), prefix));
  }

  sb.append(drive.ds.sync.Field.wrapWithPrefix_(
      nonPrefixBuffer.toString(), opt_fieldPrefix));
};


/**
 * Wraps a given set of string fields with a field field prefix.
 * @param {string} fields A comma delimited string of requested fields.
 * @param {string=} opt_fieldPrefix Optional field prefix.
 * @return {string} String fields wrapped with a field prefix.
 * @private
 */
drive.ds.sync.Field.wrapWithPrefix_ = function(fields, opt_fieldPrefix) {
  return opt_fieldPrefix ? opt_fieldPrefix + '(' + fields + ')' : fields;
};


/**
 * @param {!drive.ds.Field} field A field.
 * @return {string} A Genoa field string.
 */
drive.ds.sync.Field.toGenoaField = function(field) {
  return drive.ds.sync.Field.protoToGenoaField_[field];
};


/**
 * Performs field pruning on a list of items so that it only contains the
 * fields that the client is expecting to get.
 * @param {!Array.<!drive.ds.Field>} fields The list of fields to filter
 *     on.
 * @param {!Array.<!drive.ds.Item>} items The list of items.
 */
drive.ds.sync.Field.filterFields = function(fields, items) {
  var fieldsToClear = [];

  // Figure out list of fields to clear.
  goog.object.forEach(drive.ds.Field, function(value) {
    if (!goog.array.contains(fields, value)) {
      fieldsToClear.push(value);
    }
  });

  // Clear the fields from each item.
  for (var i = 0; i < items.length; i++) {
    for (var j = 0; j < fieldsToClear.length; j++) {
      drive.ds.sync.Field.clearField(fieldsToClear[j], items[i]);
    }
  }
};


/**
 * Clears a particular Field on a Drive item.
 * @param {!drive.ds.Field} field The field to clear.
 * @param {!drive.ds.Item} item The item to clear the field from.
 */
drive.ds.sync.Field.clearField = function(field, item) {
  switch (field) {
    case drive.ds.Field.OPEN_URL:
      item.clearOpenUrl();
      break;
    case drive.ds.Field.CREATE_DATE_MILLIS:
      item.clearCreateDateMillis();
      break;
    case drive.ds.Field.FILE_SIZE:
      item.clearFileSize();
      break;
    case drive.ds.Field.STARRED:
      item.clearStarred();
      break;
    case drive.ds.Field.HIDDEN:
      item.clearHidden();
      break;
    case drive.ds.Field.TRASHED:
      item.clearTrashed();
      break;
    case drive.ds.Field.RESTRICTED:
      item.clearRestricted();
      break;
    case drive.ds.Field.VIEWED:
      item.clearViewed();
      break;
    case drive.ds.Field.LAST_MODIFYING_USER:
      item.clearLastModifyingUser();
      break;
    case drive.ds.Field.LAST_VIEWED_BY_ME_DATE_MILLIS:
      item.clearLastViewedByMeDateMillis();
      break;
    case drive.ds.Field.MIME_TYPE:
      item.clearMimeType();
      break;
    case drive.ds.Field.MODIFIED_BY_ME_DATE_MILLIS:
      item.clearModifiedByMeDateMillis();
      break;
    case drive.ds.Field.MODIFIED_DATE_MILLIS:
      item.clearModifiedDateMillis();
      break;
    case drive.ds.Field.OWNERS:
      item.clearOwnerList();
      break;
    case drive.ds.Field.PARENTS:
      item.clearParentList();
      break;
    case drive.ds.Field.THUMBNAIL_URL:
      item.clearThumbnailUrl();
      item.clearHasThumbnail();
      break;
    case drive.ds.Field.TITLE:
      item.clearTitle();
      break;
    case drive.ds.Field.SHARED:
      item.clearShared();
      break;
    case drive.ds.Field.SHARED_WITH_ME_DATE_MILLIS:
      item.clearSharedWithMeDateMillis();
      break;
    case drive.ds.Field.DESCRIPTION:
      item.clearDescription();
      break;
    case drive.ds.Field.USER_ROLE:
      item.clearUserRole();
      break;
    case drive.ds.Field.EXPLICITLY_TRASHED:
      item.clearExplicitlyTrashed();
      break;
    case drive.ds.Field.IMAGE_DATE_MILLIS:
      if (goog.isDefAndNotNull(item.getImage())) {
        item.getImage().clearDateMillis();
      }
      break;
    case drive.ds.Field.IMAGE_WIDTH:
      if (goog.isDefAndNotNull(item.getImage())) {
        item.getImage().clearWidth();
      }
      break;
    case drive.ds.Field.IMAGE_HEIGHT:
      if (goog.isDefAndNotNull(item.getImage())) {
        item.getImage().clearHeight();
      }
      break;
    case drive.ds.Field.QUOTA_BYTES_USED:
      item.clearQuotaBytesUsed();
      break;
    case drive.ds.Field.SHAREABLE:
      item.clearShareable();
      break;
    case drive.ds.Field.COPYABLE:
      item.clearCopyable();
      break;
    case drive.ds.Field.SUBSCRIBED:
      item.clearSubscribed();
      break;
    case drive.ds.Field.COSMO_TYPE:
      item.clearCosmoType();
      break;
    case drive.ds.Field.SERVICE_ID:
      item.clearServiceId();
      break;
    case drive.ds.Field.FOLDER_COLOR:
      item.clearFolderColor();
      break;
    case drive.ds.Field.HAS_CHILD_FOLDER:
      item.clearHasChildFolder();
      break;
    case drive.ds.Field.VISIBILITIES:
      item.clearUserList();
      item.clearVisibilityList();
      item.clearTotalUserCount();
      break;
    case drive.ds.Field.DOWNLOADABLE:
      item.clearDownloadable();
      break;
    case drive.ds.Field.DOWNLOAD_URL:
      item.clearDownloadUrl();
      break;
    case drive.ds.Field.CREATOR_APP:
      item.clearCreatorAppId();
      item.clearCreatorAppValue();
      break;
    case drive.ds.Field.FILE_EXTENSION:
      item.clearFileExtension();
      break;
    case drive.ds.Field.PRIMARY_SYNC_PARENT:
      item.clearPrimarySyncParent();
      break;
    default:
      break;
  }
};


/**
 * Given an item query, determine which fields are required to satisfy the
 * request.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @return {!Array.<!drive.ds.Field>} A list of fields required to satisfy
 *     the given request.
 */
drive.ds.sync.Field.getRequiredQueryFields = function(request) {
  var requiredFields = [];

  if (request.getTitleList().length > 0) {
    requiredFields.push(drive.ds.Field.TITLE);
  }
  if (request.getMimeTypeList().length > 0) {
    requiredFields.push(drive.ds.Field.MIME_TYPE);
  }
  if (request.getModifiedDateList().length > 0) {
    requiredFields.push(drive.ds.Field.MODIFIED_DATE_MILLIS);
  }
  if (request.getViewedDateList().length > 0) {
    requiredFields.push(drive.ds.Field.LAST_VIEWED_BY_ME_DATE_MILLIS);
  }
  if (goog.isDefAndNotNull(request.getTrashed())) {
    requiredFields.push(drive.ds.Field.TRASHED);
  }
  if (goog.isDefAndNotNull(request.getStarred())) {
    requiredFields.push(drive.ds.Field.STARRED);
  }
  if (goog.isDefAndNotNull(request.getHidden())) {
    requiredFields.push(drive.ds.Field.HIDDEN);
  }
  if (request.getParentList().length > 0) {
    requiredFields.push(drive.ds.Field.PARENTS);
  }
  if (request.getOwnerList().length > 0) {
    requiredFields.push(drive.ds.Field.OWNERS);
  }
  if (goog.isDefAndNotNull(request.getSharedWithMe())) {
    requiredFields.push(drive.ds.Field.USER_ROLE);
  }
  if (goog.isDefAndNotNull(request.getExplicitlyTrashed())) {
    requiredFields.push(drive.ds.Field.EXPLICITLY_TRASHED);
  }

  return requiredFields;
};

//javascript/apps/drive/dataservice/sync/api/params.js
goog.provide('drive.ds.sync.api.Params');


/**
 * A list of all Genoa request params.
 * @enum {string}
 */
drive.ds.sync.api.Params.Request = {
  ADD_PARENTS: 'addParents',
  FIELDS: 'fields',
  FILE_ID: 'fileId',
  INCLUDE_DELETED: 'includeDeleted',
  INCLUDE_SUBSCRIBED: 'includeSubscribed',
  MAX_RESULTS: 'maxResults',
  PAGE_TOKEN: 'pageToken',
  QUERY: 'q',
  PARENT_ID: 'parentId',
  REMOVE_PARENTS: 'removeParents',
  RESOURCE: 'resource',
  REVERSE_SORT: 'reverseSort',
  REVISION_ID: 'revisionId',
  SORT_BY: 'sortBy',
  START_CHANGE_ID: 'startChangeId'
};

//javascript/apps/drive/dataservice/sync/api/change.js
/**
 * @fileoverview Helper that takes a ChangeItemRequest, generates a Genoa change
 * query, and executes it.
 */

goog.provide('drive.ds.sync.api.Change');

goog.require('drive.ds.sync.Field');
goog.require('drive.ds.sync.api.About');
goog.require('drive.ds.sync.api.Params');
goog.require('drive.ds.sync.api.RequestManager');
goog.require('drive.ds.sync.stat.RequestType');


/**
 * Gets the max change ID.
 * @param {!Function} responseHandler The response handler to call.
 */
drive.ds.sync.api.Change.getMaxChangeId = function(responseHandler) {
  drive.ds.sync.api.About.get(responseHandler);
};


/**
 * Gets a list of changes.
 * @param {!drive.ds.ListChangesRequest} request The changes query
 *     request.
 * @param {!Function} responseHandler The response handler to call.
 */
drive.ds.sync.api.Change.getChanges = function(
    request, responseHandler) {
  var params = {};
  params[drive.ds.sync.api.Params.Request.FIELDS] =
      drive.ds.sync.Field.toChangesFieldString(request.getFieldList());

  // TODO(towong): consider case of undef start change id.
  if (goog.isDefAndNotNull(request.getStartChangeId())) {
    params[drive.ds.sync.api.Params.Request.START_CHANGE_ID] =
        request.getStartChangeId();
  }

  params[drive.ds.sync.api.Params.Request.MAX_RESULTS] =
      request.getMaxResults();

  params[drive.ds.sync.api.Params.Request.INCLUDE_DELETED] =
      request.getIncludeDeleted();

  params[drive.ds.sync.api.Params.Request.INCLUDE_SUBSCRIBED] =
      request.getIncludeSubscribed();

  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Change.createListMethod_,
      params, responseHandler, drive.ds.sync.stat.RequestType.CHANGE);
};


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for a list of changes.
 * @private
 */
drive.ds.sync.api.Change.createListMethod_ = function() {
  return gapi.client.drive.changes.list;
};


//javascript/apps/time/util.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Fast utilities for dealing with dates and times, especially
 * for getting calendar information.
 *
 * <p>
 * This file is the base foundation for all of apps.time.  Within the
 * apps.time package, there are a few general sections:
 *
 * <ul>
 * <li> Utilities (this file) - Fast access to Gregorian calendar information
 * <li> Temporal hierarchy (temporal.js and subclasses) - Representing dates
 * and times with the internet calendaring (ical) spec RFC2445 in mind.
 * <li> Parsing dates and times (parse.js)
 * <li> Date and time keys (key.js) - Treating a date and time as a single
 * numeric value, usable in comparisons and as hash keys.
 * <li> List of periods (fastperiodlist.js) - For manipulating a union of
 * disjoint ranges, using the compact date and time key infrastructure.
 * <li> Getting current time (clock.js) - Getting reliable local time in
 * light of clock skew and OS/browser time zone bugs.
 * </ul>
 *
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time');
goog.provide('apps.time.Constants');
goog.provide('apps.time.DayOfWeek');


/**
 * Useful time conversion constants.
 * @enum {number}
 */
apps.time.Constants = {
  SECOND_MS: 1000,
  MINUTE_MS: 60000,
  HOUR_MS: 36e5,
  DAY_MS: 864e5,
  MINUTE_SEC: 60,
  HOUR_SEC: 3600,
  DAY_SEC: 86400,
  HOUR_MIN: 60,
  DAY_MIN: 1440
};


/**
 * Determines whether or not the given year is within the supported range.
 *
 * This library only supports 4-digit years as an optimization for
 * formatting methods.
 *
 * @param {number} n The year.
 * @return {boolean} Whether or not this is a supported year.
 */
apps.time.isSupportedYear = function(n) {
  return !(n < 1000 || n > 9999);
};


/**
 * Formats a year as a 4-digit string.
 *
 * This is pretty much a no-op: This library only handles years after 1970
 * and we're not yet worried about year 10 thousand.  This method only serves
 * a purpose of documenting this assumption.
 *
 * @param {number} n  The year, from 1000-9999.
 * @return {string} The year, as a string.
 * @private
 */
apps.time.formatYear_ = function(n) {
  return String(n);
};


/**
 * Adds a padding zero to an integer of up to 2 digits.
 *
 * This is called in performance-critical code.
 *
 * @param {number} n  The number to format.
 * @return {string} The year, as a string.
 * @private
 */
apps.time.formatInt2_ = function(n) {
  return ((n < 10) ? '0' + n : String(n));
};


/**
 * Formats an optional 4-digit year.
 *
 * This is called in performance-critical code.
 *
 * @param {number|undefined} n  The number to format.  Must be between
 *     1000 and 9999.
 * @return {string} A string value of with padding zeros, or
 *     the 4 question marks on undefined/NaN.
 * @private
 */
apps.time.formatOptionalYear_ = function(n) {
  return n ? apps.time.formatYear_(n) : '????';
};


/**
 * Formats an optional 2-digit field with padding zeros.
 *
 * This is called in performance-critical code.
 *
 * @param {number|undefined} n  The number to format, may be undefined or
 *     NaN.
 * @return {string} A string value of with padding zeros, or
 *     the 4 question marks on undefined/NaN.
 * @suppress {checkTypes}
 * @private
 */
apps.time.formatOptionalInt2_ = function(n) {
  return isNaN(n) ? '??' : apps.time.formatInt2_(n);
};


/**
 * Determines if a value is an integer.
 * @param {Object|number|string|boolean|null|undefined} value  Any javascript
 *     type.
 * @return {boolean} Whether it is a number, and represents an integer value.
 */
apps.time.isInteger = function(value) {
  // Or'ing a value with zero automatically truncates ints, returns NaN for
  // non-ints.  Must use triple-equals, as [1] and 1 are considered
  // equivalent.
  return (value | 0) === value;
};


/**
 * Lookup table used by {@link #apps.time.daysInMonth}.
 *
 * Keys range from 1-12 for normal months, except for February.  For February,
 * this is indexed by the year.  (We will assume no years between 0 and 16).
 *
 * This could also be done arithmetically, but it doesn't buy too much:
 * 30 + ((month + (month >> 3)) & 1) when month is not 2.
 *
 * This is also used by key.js as an optimization -- make sure to update it.
 *
 * @private
 */
apps.time.daysInMonthCache_ = [, // 0 is not indexed reserved (indexed 1-12)
  31, , 31, 30,  // feb is computed
  31, 30, 31, 31,
  30, 31, 30, 31];


/**
 * @param {number} year The gregorian year.
 * @return {boolean} True if a given Gregorian year is leap, false otherwise.
 */
apps.time.isGregorianLeapYear = function(year) {
  return year & 3 ? false : year % 100 ? true : year % 400 ? false : true;
};


/**
 * Returns the number of days in the given month.  This is consistent with
 * the javascript date object.
 *
 * This is time critical code.
 *
 * @param {number} year  The year such as 2008 (must be > 12).
 * @param {number} month  The month from 1 to 12.
 * @return {number} The number days in that month.
 */
apps.time.daysInMonth = function(year, month) {
  // ASSUMPTION: year > 12.
  // If it's not February, index by month.
  // If it's February, index by year.
  // The length of February is lazily computed.
  return apps.time.daysInMonthCache_[month] ||
      apps.time.daysInMonthCache_[year] ||
      (apps.time.daysInMonthCache_[year] =
       28 + (apps.time.isGregorianLeapYear(year) ? 1 : 0));
};


/**
 * Finds the number of days in a given year.
 * @param {number} year  The year, such as 2008.
 * @return {number} The number of days in that year.
 */
apps.time.daysInYear = function(year) {
  return apps.time.daysInMonth(year, 2) + (365 - 28);
};


/**
 * Days of week as an integer.
 *
 * This is intentionally not internationalized, as i18n is part of the view
 * and not the model.
 *
 * @enum {number}
 */
apps.time.DayOfWeek = {
  SUN: 0,
  MON: 1,
  TUE: 2,
  WED: 3,
  THU: 4,
  FRI: 5,
  SAT: 6
};


/**
 * Determines if a day of week (0-6) is a weekend.
 * @param {apps.time.DayOfWeek} dayOfWeek  The day of week.
 * @return {boolean} Whether that day of week is a weekend.
 */
apps.time.isWeekend = function(dayOfWeek) {
  return dayOfWeek == apps.time.DayOfWeek.SUN ||
      dayOfWeek == apps.time.DayOfWeek.SAT;
};


/**
 * Cache for the first day of week in a given month.
 *
 * Key is an integer (year*16 + month), and value is the day of week (0-6).
 *
 * @type {Object}
 * @private
 */
apps.time.getFirstDayOfWeekInMonthCache_ = {};


/**
 * Gets the index of the first day of the week in the given month.
 *
 * @param {number} year  The year (such as 2004).
 * @param {number} month  The month (such as 12=december).
 * @return {apps.time.DayOfWeek} The day of week (0-6).
 */
apps.time.getFirstDayOfWeekInMonth = function(year, month) {
  var k = (year << 4) | month;
  // Use 12pm instead of 12am in order to avoid breakage in time zones,
  // where DST changes around midnight.
  return apps.time.getFirstDayOfWeekInMonthCache_[k] ||
      (apps.time.getFirstDayOfWeekInMonthCache_[k] =
          new Date(year, month - 1, 1, 12, 0, 0, 0).getDay());
};


/**
 * Gets the day of the week for the given date.
 *
 * @param {number} year  The year (eg 2007).
 * @param {number} month  The month (1-12).
 * @param {number} date  The date (1-31).
 * @return {apps.time.DayOfWeek} The day of week (0-6).
 */
apps.time.getDayOfWeek = function(year, month, date) {
  var day = /** @type {apps.time.DayOfWeek} */
      ((apps.time.getFirstDayOfWeekInMonth(year, month) + date - 1) % 7);
  return day;
};


/**
 * Maps months to the start day of the year for non-leap years.
 * @type {[number]}
 * @private
 */
// This could be capitalized as a constant, but that would cause Javascript
// to inline it, which requires dynamic array construction -- bad in IE6.
apps.time.monthStartToDoy_ = [, // 0 is reserved because there is no 0 month
  0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];


/**
 * Gets the day of the year in [0-365] of the given date.
 *
 * @param {number} year  The year (eg 2007).
 * @param {number} month  The month (1-12).
 * @param {number} date  The date (1-31).
 * @return {number} The day of year of this day, starting with 0.
 */
apps.time.getDayOfYear = function(year, month, date) {
  // adjust is 1 if we should subtract 1 for "date" being 1-indexed; it is
  // 0 if the 1-indexedness is counterbalanced by being a leap year.

  // Cases:
  //   month <= 2 --> true --> boolean is coerced to 1 --> subtract 1
  //   month > 2 && not leap year --> 29 - 28 --> 1 --> subtract 1
  //   month > 2 && leap year --> 29 - 29 --> 0 --> do not subtract

  var adjust = (month <= 2) || (29 - apps.time.daysInMonth(year, 2));
  return apps.time.monthStartToDoy_[month] + date - adjust;
};


/**
 * Gets the number of days between two dates specified as (year, month,
 * dayOfMonth) triplets.
 *
 * @param {number} y1  Left-hand year (2007).
 * @param {number} m1  Left-hand month (1-12).
 * @param {number} d1  Left-hand day (1-31).
 * @param {number} y2  Right-hand year (2007).
 * @param {number} m2  Right-hand month (1-12).
 * @param {number} d2  Right-hand day (1-31).
 * @return {number} The number of days between the two.
 */
apps.time.getDaysBetween = function(y1, m1, d1, y2, m2, d2) {
  return (y1 == y2) ?
      apps.time.getDayOfYear(y1, m1, d1) - apps.time.getDayOfYear(y2, m2, d2) :
      Math.round((Date.UTC(y1, m1 - 1, d1) - Date.UTC(y2, m2 - 1, d2)) /
          apps.time.Constants.DAY_MS);
};


/**
 * Formats a date value object into a RFC3339 string with UTC timezone.
 *
 * @param {!apps.time.DateValue} value The object to format.
 * @return {string} The formatted object in RFC3339.
 */
apps.time.format3339 = function(value) {
  var out = [];

  out.push(
      apps.time.formatYear_(value.year),
      '-',
      apps.time.formatInt2_(value.month),
      '-',
      apps.time.formatInt2_(value.date));

  if (!value.isDate()) {
    out.push(
        'T',
        apps.time.formatInt2_(value.hour),
        ':',
        apps.time.formatInt2_(value.minute),
        ':',
        apps.time.formatInt2_(value.second),
        'Z');
  }

  return out.join('');
};

//javascript/apps/time/key.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Utilities for manipulating dates and times as single numeric
 * value.
 *
 * <p>
 * This library integrates the previous ical and rical functionality so that
 * the Comparable returned by ical objects is directly usable as an array
 * key.  These keys allow dates and times to be represented by a single
 * numeric value whose numeric ordering is identical to the calendar
 * ordering.
 *
 * <p>
 * A date is keyed by an integer, whereas a time is a fraction, and a date
 * time is a real number.  To turn a date time into a date, it is simply
 * necessary to truncate the date valueto an integer.  All of these keys
 * are computed primarily with bit arithmetic, in the format:
 *
 * <pre>
 * ...11110000000000 00000000011111111
 * ...32109876543210 12345678901234567
 * ...YYYYYMMMMDDDDD.HHHHHMMMMMMSSSSSS
 * </pre>
 *
 * <p>
 * The constant 1 is added to the number of seconds for times, so that
 * midnight is distinct from a date key.  No roundoff error occurs -- only
 * powers of two are used as digit positions, and we fall quite short of the
 * 52 mantissa bits of the IEEE754 double.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */

goog.provide('apps.time.key');

goog.require('apps.time');


/**
 * The position that hours are divided by in the bit field.
 *
 * @type {number}
 * @private
 */
apps.time.TIME_KEY_HOUR_QUOTIENT_ = (1 << 5);


/**
 * The position that minutes are divided by in the bit field.
 *
 * @type {number}
 * @private
 */
apps.time.TIME_KEY_MINUTE_QUOTIENT_ =
    apps.time.TIME_KEY_HOUR_QUOTIENT_ * (1 << 6);


/**
 * The factor by which time keys are divided.
 *
 * This corresponds to the seconds' place in the bit field.
 *
 * @type {number}
 * @private
 */
apps.time.TIME_KEY_QUOTIENT_ =
    apps.time.TIME_KEY_MINUTE_QUOTIENT_ * (1 << 6);


/**
 * The factor by which time keys are multiplied.
 * @type {number}
 * @private
 */
apps.time.TIME_KEY_MULTIPLIER_ = 1.0 / apps.time.TIME_KEY_QUOTIENT_;


/**
 * The base year for computing date keys.
 *
 * @type {number}
 * @private
 */
// TODO(gboyer): Can we raise this higher and rely on bit-shifting sign
// extension?  I think so, let's write unit tests to verify later.
apps.time.DATE_KEY_YEAR_BASE_ = 1970;


/**
 * Generates a sorting key based on a year/month/date pair.
 *
 * This is unique for each year/month/day pair.  Arithmetic is undefined.
 *
 * Currently, there are 5 bits reserved for the date of month, 4 bits reserved
 * for month, and everything else is reserved for the year.
 *
 * @param {number} year  The year such as 2007.
 * @param {number} month  The month (1-12).
 * @param {number} date  The day (1-31).
 * @return {number} The unique integer sort key for this date.
 */
apps.time.getDateKey = function(year, month, date) {
  return (((year - apps.time.DATE_KEY_YEAR_BASE_ << 4) + month) << 5) +
      date;
};


/**
 * Generates a sorting key for times.
 *
 * These are guaranteed to be a fraction of 1, but arithmetic is undefined.
 *
 * @param {number} hour  The hour (0-23).
 * @param {number} minute  The minute (0-59).
 * @param {number} second  The second (0-59).
 * @return {number} The key for a time, 0 <= x < 1.
 */
apps.time.getTimeKey = function(hour, minute, second) {
  return ((((hour << 6) + minute) << 6) + second + 1) *
      apps.time.TIME_KEY_MULTIPLIER_;
};


/**
 * Generates a sorting key for dates and times.
 *
 * Taking the floor of a DateTimeKey has the convenient property of yielding
 * the date of that key.
 *
 * @param {number} year  The year such as 2007.
 * @param {number} month  The month (1-12).
 * @param {number} date  The day (1-31).
 * @param {number} hour  The hour (0-23).
 * @param {number} minute  The minute (0-59).
 * @param {number} second  The second (0-59).
 * @return {number} The unique sorting key for this date and time.
 */
apps.time.getDateTimeKey = function(
    year, month, date, hour, minute, second) {
  return (((year - apps.time.DATE_KEY_YEAR_BASE_ << 4) + month) << 5) + date +
      ((((hour << 6) + minute) << 6) + second + 1) *
      apps.time.TIME_KEY_MULTIPLIER_;
};


/**
 * Generates a sorting key for durations.
 *
 * @param {number} days  The number of days.
 * @param {number} hour  The hour (0-23).
 * @param {number} minute  The minute (0-59).
 * @param {number} second  The second (0-59).
 * @return {number}  The unique sorting key.
 */
apps.time.getDurationKey = function(
    days, hour, minute, second) {
  return days + apps.time.getTimeKey(hour, minute, second);
};


/**
 * A lower bound on date keys.
 */
apps.time.DATE_KEY_MIN = apps.time.getDateKey(-0xffff, 1, 1);


/**
 * An upper bound on date keys.
 */
apps.time.DATE_KEY_MAX = apps.time.getDateKey(0xffff, 12, 31);


/**
 * Demotes a date-time key to a date key only.
 *
 * @param {number} key  A key generated by getDateTimeKey or DateKey.
 * @return {number} A date key representing only the date portion of
 *     the given key.
 */
apps.time.toDateKey = function(key) {
  // truncates the date time key to an integer, which omits the time portion
  return key | 0;
};


/**
 * Determines if a key is a date-only key.
 *
 * @param {number} key A key generated by getDateTimeKey or getDateKey.
 * @return {boolean} Whether it only has a date component.
 * @private
 */
apps.time.isDateKey_ = function(key) {
  return !(key % 1);
};


/**
 * Gets the year from a date key.
 * @param {number} key  A date or time key from apps.time.getDateKey.
 * @return {number} The year, such as 2007.
 */
apps.time.getKeyYear = function(key) {
  // integer truncation is implicit in bitwise operators
  return (key >> 9) + apps.time.DATE_KEY_YEAR_BASE_;
};


/**
 * Gets the month from a date key.
 * @param {number} key  A date or time key from apps.time.getDateKey.
 * @return {number} The month (1-12).
 */
apps.time.getKeyMonth = function(key) {
  // integer truncation is implicit in bitwise operators
  return (key >> 5) & 0xf;
};


/**
 * Gets the date from a date key.
 * @param {number} key  A date or time key from apps.time.getDateKey.
 * @return {number} The date (1-31).
 */
apps.time.getKeyDate = function(key) {
  // integer truncation is implicit in bitwise operators
  return key & 0x1f;
};


/**
 * Gets the hour from a date/time key.
 * @param {number} key  A time or datetime key from apps.time.geTimeKey.
 * @return {number} The hour (0-23).
 */
apps.time.getKeyHour = function(key) {
  // integer truncation is implicit in bitwise operators
  return (key * apps.time.TIME_KEY_HOUR_QUOTIENT_) & 0x1f;
};


/**
 * Gets the year from a date key.
 * @param {number} key  A time or datetime key from apps.time.geTimeKey.
 * @return {number} The minute (0-59).
 */
apps.time.getKeyMinute = function(key) {
  // integer truncation is implicit in bitwise operators
  return (key * apps.time.TIME_KEY_MINUTE_QUOTIENT_) & 0x3f;
};


/**
 * Gets the year from a date key.
 * @param {number} key  A time or datetime key from apps.time.geTimeKey.
 * @return {number} The second (0-59).
 */
apps.time.getKeySecond = function(key) {
  // integer truncation is implicit in bitwise operators.
  // subtract the offset 1 used to make midnight distinct from a date key
  return ((key * apps.time.TIME_KEY_QUOTIENT_) & 0x3f) - 1;
};


/**
 * Converts a date key to to an ICAL string of the form '20061110'.
 *
 * @param {number} key  A reduced date.
 * @return {string} The ICAL format for the date.
 */
apps.time.getDateKeyIcal = function(key) {
  return apps.time.formatYear_(apps.time.getKeyYear(key)) +
      apps.time.formatInt2_(apps.time.getKeyMonth(key)) +
      apps.time.formatInt2_(apps.time.getKeyDate(key));
};


/**
 * Gets the reduced date immediately after the given date.
 *
 * Fractional portions at the end of the key, such as to represent times,
 * are maintained.
 *
 * @param {number} key  The reduced date.
 * @return {number} Exactly twenty four hours after the original key.
 */
apps.time.getDateKeyAfter = function(key) {
  if ((key & 0x1f) < 28) {
    // simple case works (12*27/365.25) 88.7% of the time
    return key + 1;
  }
  var day = apps.time.getKeyDate(key);
  var month = apps.time.getKeyMonth(key);
  // Arithmetically: (2 != month ? 30 + ((month + (month >> 3)) & 1)
  if (day < (apps.time.daysInMonthCache_[month] ||
             apps.time.daysInMonth(apps.time.getKeyYear(key), 2))) {
    // reached 8% of the time
    return key + 1;
  } else {
    // final (12/365.25) 3.3%; this may step to next year
    var year = apps.time.getKeyYear(key);
    if (++month > 12) {
      month = 1;
      ++year;
    }
    return apps.time.getDateKey(year, month, 1) + (key % 1);
  }
};


/**
 * Creates a function which which can be used as a range query filter for
 * both Dates and DateTimes.
 *
 * Example:
 * <pre>
 * function getEventsInRange(events, start, end) {
 *   var detector = apps.time.getKeyRangeDetector(
 *       start.getComparable(), end.getComparable());
 *   return goog.array.filter(events, function(event) {
 *     return detector(event.getStart().getComparable(),
 *         event.getEnd().getComparable());
 *   });
 *   return result;
 * }
 * </pre>
 *
 * This is slightly asymmetric: this will treat zero-length queries to the
 * returned function as included if they coincide with the start of the range,
 * but will not return anything if rangeStart equals rangeEnd.
 *
 * @param {number} rangeStart The start date or date-time key, inclusive.
 * @param {number} rangeEnd The end date or date-time key, exclusive.
 * @return {function(number,number):boolean} A function which takes in another
 *     half-open date/date-time key range overlaps the current range for a
 *     non-zero amount.
 */
apps.time.getKeyRangeDetector = function(rangeStart, rangeEnd) {
  if (goog.DEBUG) {
    if (!goog.isNumber(rangeStart) || !goog.isNumber(rangeEnd)) {
      throw Error('Date keys required: ' + rangeStart + ',' + rangeEnd);
    }
  }

  // Quirk: The comparable for 20080330 is less than 20080330T000000 by
  // a tiny amount so they have different values.  The issue arises when you
  // want to do date range comparisons, because some events might overlap
  // by the date range for an infinitesimal amount.  To get around this
  // problem, the range will be shrunk: we need to ensure that the beginning
  // of the range is a date-time and the end is a date only.
  var dateKeyOffset = apps.time.TIME_KEY_MULTIPLIER_;

  // Keep track of the original range start for the case of zero-length
  // date-only queries, even if we promote the range start to a DateTime.
  var widenedRangeStart = rangeStart;

  // If the start comparable is a Date only, bump it up to a DateTime to
  // exclude ranges that end exactly on midnight.
  if (apps.time.isDateKey_(rangeStart)) {
    // Convert the date key to a DateTime key.
    rangeStart += dateKeyOffset;
  }

  // If the end comparable is a DateTime at exactly midnight, bump it down
  // to a date to exclude all-day ranges beginning on the end date.
  if (apps.time.isDateKey_(rangeEnd - dateKeyOffset)) {
    rangeEnd -= dateKeyOffset;
  }

  return function(entryStart, entryEnd) {
    if (goog.DEBUG) {
      if (!goog.isNumber(entryStart) || !goog.isNumber(entryEnd)) {
        throw Error('Date keys required: ' + entryStart + ',' + entryEnd);
      }
    }

    // See if the provided entry overlaps.  We do two end checks to
    // accomodate for zero-length queries.
    return entryStart < rangeEnd &&
        (entryEnd > rangeStart || entryStart >= widenedRangeStart);
  };
};

//javascript/apps/time/temporal.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Generic superclass for all sorts of calendar dates or
 * times.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time.Temporal');

goog.require('apps.time');
goog.require('apps.time.key');


/**
 * A generic data structure representing an instance of time, with some
 * fields known and some not known.
 *
 * <p>
 * The goal of the Temporal hierarchy is to provide a unified way for
 * manipulating dates, times, and other icalendar objects.  All temporals
 * have an optional year, month, date, hour, minute, and second.
 *
 * <p>
 * For example, there are the immutable Date, DateTime, and Time objects
 * that represent a date and/or a time.  PartialDate and PartialDateTime
 * represent dates or date time objects where some fields may be unknown.
 * A Duration is an unusual Temporal that always has a month and year of
 * zero, representing a length of time.
 *
 * @constructor
 */
apps.time.Temporal = function() {
};


// TODO(gboyer): I first attempted to make it so that unknown fields can be
// undefined, rather than NaN (which seems clunky).  The problem is that
// jscompiler has no way of attaching to these fields a type of
// {number|undefined}, and then proceed to use any of fields in a manner
// consistent with a number.  A lot of these subclasses, such as Date and
// DateTime, guarantee that some of these fields are integers, and it is not
// worth adding @suppress {checkTypes} to all of them to make it compile.  So,
// we will instead use NaN.


/**
 * The year (eg 2007), or NaN if unknown.
 * @type {number}
 */
apps.time.Temporal.prototype.year = NaN;


/**
 * The month (1-12), or NaN if unknown.
 * @type {number}
 */
apps.time.Temporal.prototype.month = NaN;


/**
 * The day in month (1-31), or NaN if unknown.
 * @type {number}
 */
apps.time.Temporal.prototype.date = NaN;


/**
 * The hour (0-23), or NaN if unknown.
 * @type {number}
 */
apps.time.Temporal.prototype.hour = NaN;


/**
 * The minute (0-59), or NaN if unknown.
 * @type {number}
 */
apps.time.Temporal.prototype.minute = NaN;


/**
 * The second (0-59), or NaN if unknown.
 * @type {number}
 */
apps.time.Temporal.prototype.second = NaN;


/**
 * Converts to a string representation, without caching.
 *
 * @return {string} Ical format of this date.
 * @protected
 */
apps.time.Temporal.prototype.toStringSlow = goog.abstractMethod;


/**
 * @return {string} This date in ical format.
 */
apps.time.Temporal.prototype.toString = function() {
  return this.str_ || (this.str_ = this.toStringSlow());
};


/**
 * Gets a number suitable for comparison.
 *
 * This is NOT a number of units since an epoch -- only comparison
 * is defined, not arithmetic.
 *
 * @return {number} A value suitable for comparing temporals.
 */
apps.time.Temporal.prototype.getComparable = goog.abstractMethod;


/**
 * Compares this object to another for equality.
 *
 * @param {*} that The other object.
 * @return {boolean} Whether the objects are equal.
 */
apps.time.Temporal.prototype.equals = goog.abstractMethod;


/**
 * Gets a a key that is unique for this date (not time).
 *
 * This is equivalent to getting the "reduced ical" form of only the date
 * portion of this value.
 *
 * @return {number} An integer key for the date.
 */
apps.time.Temporal.prototype.getDateKey = function() {
  return apps.time.toDateKey(this.getComparable());
};


/**
 * @return {boolean} Whether there is enough information to get a comparable.
 */
apps.time.Temporal.prototype.isComplete = goog.abstractMethod;


/**
 * Returns this or the specified object, whichever is earlier in time.
 *
 * @param {apps.time.Temporal} that  Another temporal to compare to.
 * @return {!apps.time.Temporal} The minimum of this and the other.
 */
apps.time.Temporal.prototype.min = function(that) {
  return this.getComparable() < that.getComparable() ?
      this : /** @type {!apps.time.Temporal} */ (that);
};


/**
 * Returns this or the specified object, whichever is later in time.
 *
 * @param {apps.time.Temporal} that  Another temporal to compare to.
 * @return {!apps.time.Temporal} The minimum of this and the other.
 */
apps.time.Temporal.prototype.max = function(that) {
  return this.getComparable() > that.getComparable() ?
      this : /** @type {!apps.time.Temporal} */ (that);
};


/**
 * Finds the duration between two temporals.
 *
 * @param {apps.time.Temporal} rhs  The right-hand side of subtraction.
 * @return {!apps.time.Duration} this - rhs.
 */
apps.time.Temporal.prototype.minus = function(rhs) {
  if (goog.DEBUG) {
    if (isNaN(this.year) != isNaN(rhs.year) ||
        isNaN(this.hour) != isNaN(rhs.hour)) {
      throw new Error('Temporal.minus called on differing types: (' +
          this + ', ' + rhs + ')');
    }
  }

  var b = apps.time.DateTimeBuilder.copy(this);

  if (!isNaN(this.year)) {
    // Both this and rhs have a year and probably a month component.
    // First, remove the month and years.
    b.year = NaN;
    b.month = NaN;
    // Next compute the number of days.
    b.date = this.minusInDays(rhs);
  }

  if (!isNaN(this.hour)) {
    // Both this and rhs have a time component.
    b.hour -= rhs.hour;
    b.minute -= rhs.minute;
    b.second -= rhs.second;
  }

  return b.toDuration();
};


/**
 * Finds the number of days between two dates.
 *
 * @param {apps.time.Temporal} rhs  The right-hand side of subtraction.
 * @return {number} The number of days rhs is after this.
 */
apps.time.Temporal.prototype.minusInDays = function(rhs) {
  return apps.time.getDaysBetween(
      this.year, this.month, this.date,
      rhs.year, rhs.month, rhs.date);
};


/**
 * Gets the next date occurring immediately after this.
 *
 * Does not work for partial date values that are incomplete.
 *
 * @return {!apps.time.Date} The date occurring after.
 */
apps.time.Temporal.prototype.getNextDate = function() {
  return apps.time.Date.after(this.year, this.month, this.date);
};


/**
 * Gets the closest date beginning on or after this.
 *
 * Does not work for partial date values that are incomplete.
 * It is pretty much equivalent to toDate(), except this rounds up instead of
 * down.
 *
 * @return {!apps.time.Date} The same date, if hour == minute == second == 0,
 *     otherwise the next date.
 */
apps.time.Temporal.prototype.roundedUpToDate = function() {
  // Return the same date if there is no hour, minute, or second; otherwise,
  // return the next date.
  return (this.hour || this.minute || this.second) ?
      this.getNextDate() : this.toDate();
};


/**
 * Adds a number of days to this date.
 *
 * @param {number} dayDelta  The number of days to add (or subtract).
 * @return {!apps.time.Date} The date, plus or minus the number of days.
 */
apps.time.Temporal.prototype.plusDays = function(dayDelta) {
  return apps.time.DateTimeBuilder.forDateValues(
      this.year, this.month, this.date + dayDelta).toDate();
};


/**
 * Rounds a date downward to a specified day of week.
 *
 * @param {apps.time.DayOfWeek|number} dayOfWeek  The day of week.  If the
 *     value is greater than 6, this will safely take its modulo 7.
 * @return {!apps.time.Date} The last date less than or equal to (y,m,d) that
 *     falls on the specified day or week.
 */
apps.time.Temporal.prototype.roundedDownToDayOfWeek = function(dayOfWeek) {
  return this.plusDays(-((this.getDayOfWeek() - dayOfWeek + 7) % 7));
};


/**
 * Rounds a date upward to a specified day of week.
 *
 * @param {apps.time.DayOfWeek|number} dayOfWeek  The day of week.  If the value
 *     is greater than 6, this will safely take its modulo 7.
 * @return {!apps.time.Date} The first date greater than or equal to (y,m,d)
 *     that falls on the specified day or week.
 */
apps.time.Temporal.prototype.roundedUpToDayOfWeek = function(dayOfWeek) {
  return this.plusDays((dayOfWeek - this.getDayOfWeek() + 7) % 7);
};


/**
 * Gets the day of week.
 *
 * Does not work for partial date values thate are incomplete.
 *
 * @return {apps.time.DayOfWeek} A value from 0 (Sunday) to 6 (Saturday).
 */
apps.time.Temporal.prototype.getDayOfWeek = function() {
  return apps.time.getDayOfWeek(this.year, this.month, this.date);
};


/**
 * Converts this to a Date.
 *
 * Unspecified or partial fields will get default values: year defaults to
 * zero, month defaults to 1, and date defaults to 1.
 * @return {!apps.time.Date} The Date.
 */
apps.time.Temporal.prototype.toDate = function() {
  return apps.time.Date.create(
      this.year || 0, this.month || 1, this.date || 1);
};


/**
 * Converts this to a DateTime.
 *
 * Unspecified or partial fields will get default values: year defaults to
 * zero, month defaults to 1, and date defaults to 1, and time defaults to
 * midnight.
 * @return {!apps.time.DateTime} The DateTime.
 */
apps.time.Temporal.prototype.toDateTime = function() {
  return new apps.time.DateTime(
      this.year || 0, this.month || 1, this.date || 1,
      this.hour || 0, this.minute || 0, this.second || 0);
};


/**
 * Converts this to a Time.
 *
 * Unspecified or partial fields will get default values: hour defaults to
 * zero, minute defaults to 0, and second defaults to 0.
 * @return {!apps.time.Time} The Time.
 */
apps.time.Temporal.prototype.toTime = function() {
  return new apps.time.Time(this.hour || 0, this.minute || 0, this.second || 0);
};


/**
 * Gets the number of minutes from midnight of only the time portion of this
 * value.
 * @return {number} The number of minutes from midnight, or NaN if unknown.
 */
apps.time.Temporal.prototype.getMinutesFromMidnight = function() {
  return this.hour * 60 + this.minute;
};

//javascript/apps/time/datevalue.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Representation for icalendar objects that contain a full
 * or partial date.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time.DateValue');

goog.require('apps.time');
goog.require('apps.time.Temporal');



/**
 * A placeholder interface for apps.time.Temporal subclasses that represent
 * a date or datetime value.
 *
 * Does not contain extra fields or functionality.
 *
 * @constructor
 * @extends {apps.time.Temporal}
 */
apps.time.DateValue = function() {
  // Does not chain to super constructor, for performance reasons.
};
goog.inherits(apps.time.DateValue, apps.time.Temporal);


/**
 * Whether this is an instance of apps.time.Date.
 * @return {boolean} indicating whether this is an instance of apps.time.Date.
 */
apps.time.DateValue.prototype.isDate = function() {
  return false;
};

//javascript/apps/time/time.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Representation for icalendar time.
 *
 * This is the definition for the Time class, *not* the time namespace.
 * See util.js for the base apps.time, and key.js and parse.js for other
 * utilities in the apps.time namespace.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time.Time');

goog.require('apps.time');

goog.require('goog.string');


/**
 * An icalendar time.
 *
 * @param {number} hour  The hour (0-23).
 * @param {number} minute  The minute (0-59).
 * @param {number} second  The second (0-59).
 * @constructor
 * @extends {apps.time.Temporal}
 * @suppress {visibility} Uses private methods of apps.time.
 */
apps.time.Time = function(hour, minute, second) {
  apps.time.Temporal.call(this);
  if (goog.DEBUG) {
    if (!apps.time.isInteger(hour) || !apps.time.isInteger(minute) ||
        !apps.time.isInteger(second)) {
      throw Error('Bad arguments to Time constructor: ' +
          [hour, minute, second].join(','));
    }
  }
  this.hour = hour;
  this.minute = minute;
  this.second = second;
};
goog.inherits(apps.time.Time, apps.time.Temporal);


/** @override */
apps.time.Time.prototype.toTime = function() {
  return this;
};


/**
 * @override
 * @suppress {visibility} Uses private methods of apps.time.
 */
apps.time.Time.prototype.toStringSlow = function() {
  return goog.string.buildString(
      'T',
      apps.time.formatInt2_(this.hour),
      apps.time.formatInt2_(this.minute),
      apps.time.formatInt2_(this.second));
};


/** @override */
apps.time.Time.prototype.equals = function(that) {
  return !!that && this.constructor === that.constructor && // same class
      this.getComparable() == that.getComparable();
};


/** @override */
apps.time.Time.prototype.getComparable = function() {
  return this.cmp_ || (this.cmp_ =
      apps.time.getTimeKey(this.hour, this.minute, this.second));
};


/** @override */
apps.time.Time.prototype.isComplete = function() {
  return true;
};

//javascript/apps/time/datetime.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Representation for icalendar DateTime.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time.DateTime');

goog.require('apps.time');
goog.require('apps.time.DateValue');
goog.require('apps.time.Time');

goog.require('goog.string');


/**
 * An object representing a date and time.
 *
 * @param {number} year  The year (eg 2007).
 * @param {number} month  The month (1-12).
 * @param {number} date  Day of month (1-31).
 * @param {number} hour  Hour (0-23).
 * @param {number} minute  Minute (0-59).
 * @param {number} second  Second (0-59).
 * @constructor
 * @extends {apps.time.DateValue}
 * @suppress {visibility} Uses private methods of apps.time.
 */
apps.time.DateTime = function(year, month, date, hour, minute, second) {
  // no chain to super constructor for performance reasons
  if (goog.DEBUG) {
    if (!apps.time.isInteger(year) || !apps.time.isInteger(month) ||
        !apps.time.isInteger(date) || !apps.time.isInteger(hour) ||
        !apps.time.isInteger(hour) || !apps.time.isInteger(minute) ||
        !apps.time.isInteger(second)) {
      throw Error('Bad arguments to DateTime constructor: ' +
          [year, month, date, hour, minute, second].join(','));
    }
  }
  this.year = year;
  this.month = month;
  this.date = date;
  this.hour = hour;
  this.minute = minute;
  this.second = second;
};
goog.inherits(apps.time.DateTime, apps.time.DateValue);


/** @override */
apps.time.DateTime.prototype.toDateTime = function() {
  return this;
};


/** @override */
apps.time.DateTime.prototype.getComparable = function() {
  return this.cmp_ || (this.cmp_ =
      apps.time.getDateTimeKey(
          this.year, this.month, this.date,
          this.hour, this.minute, this.second));
};


/** @override */
apps.time.DateTime.prototype.isComplete = function() {
  return true;
};


/**
 * @override
 * @suppress {visibility} Uses private methods of apps.time.
 */
apps.time.DateTime.prototype.toStringSlow = function() {
  return goog.string.buildString(
    apps.time.formatYear_(this.year),
    apps.time.formatInt2_(this.month),
    apps.time.formatInt2_(this.date),
    'T',
    apps.time.formatInt2_(this.hour),
    apps.time.formatInt2_(this.minute),
    apps.time.formatInt2_(this.second));
};


/** @override */
apps.time.DateTime.prototype.equals = function(that) {
  return !!that && this.constructor === that.constructor && // same class
    this.getComparable() == that.getComparable();
};


/**
 * Converts Date.UTC(...) to a DateTime.
 *
 * @param {number} utc  A UTC time in Milliseconds.
 * @return {!apps.time.DateTime} A DateTime that corresponds to
 *   the supplied utc value.
 */
apps.time.DateTime.fromUtc = function(utc) {
  return apps.time.DateTime.fromJsDateUtc(new Date(utc));
};


/**
 * Creates a DateTime object from a javascript date, using UTC time.
 *
 * @param {Date} jsDate  A Javascript Date object, whose UTC time is used.
 * @return {!apps.time.DateTime} The interpreted date and time.
 */
apps.time.DateTime.fromJsDateUtc = function(jsDate) {
  return new apps.time.DateTime(jsDate.getUTCFullYear(),
      jsDate.getUTCMonth() + 1, jsDate.getUTCDate(),
      jsDate.getUTCHours(), jsDate.getUTCMinutes(), jsDate.getUTCSeconds());
};


/**
 * Creates a DateTime object from a javascript date, using BROWSER time.
 *
 * This should be avoided whenever possible, since many browsers/operating
 * systems/users have issues.
 *
 * @param {Date} jsDate  A Javascript Date object, whose LOCAL time is used.
 * @return {!apps.time.DateTime} The interpreted date and time.
 */
apps.time.DateTime.fromJsDateLocal = function(jsDate) {
  return new apps.time.DateTime(jsDate.getFullYear(),
      jsDate.getMonth() + 1, jsDate.getDate(),
      jsDate.getHours(), jsDate.getMinutes(), jsDate.getSeconds());
};


/**
 * Create a DateTime object from an apps.time.Date object and an apps.time.Time
 * object.
 *
 * @param {apps.time.DateValue} date  The apps.time.DateValue object which
 *     is to be combined.
 * @param {apps.time.Time} time  The apps.time.Time object which is to be
 *     combined.
 * @return {!apps.time.DateTime}  A DateTime which takes the combined values
 *   from date and time.
 */
apps.time.DateTime.fromDateAndTime = function(date, time) {
  return new apps.time.DateTime(date.year, date.month, date.date, time.hour,
      time.minute, time.second);
};

//javascript/apps/time/date.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Representation for icalendar date.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time.Date');

goog.require('apps.time');
goog.require('apps.time.DateValue');
goog.require('apps.time.Temporal');
goog.require('apps.time.key');

goog.require('goog.string');


/**
 * An icalendar date.
 *
 * Do not use this constructor; instead, use the apps.time.Date.create.
 *
 * Two Date instances of the same date are always pointer-equals.
 *
 * @constructor
 * @extends {apps.time.DateValue}
 */
apps.time.Date = function() {};
goog.inherits(apps.time.Date, apps.time.DateValue);


/** @override */
apps.time.Date.prototype.isDate = function() {
  return true;
};


/**
 * A pseudo-constructor for Date objects.
 *
 * @param {number} year  Year such as 2008.
 * @param {number} month  Month 1-12.
 * @param {number} day  Day 1-31.
 * @param {number} cmp  The date's key from getDateKey.
 * @return {!apps.time.Date} The newly constructed Date.
 * @private
 * @suppress {visibility} Uses private methods of apps.time.
 */
apps.time.Date.construct_ = function(year, month, day, cmp) {
  var result = new apps.time.Date();
  if (goog.DEBUG) {
    if (!apps.time.isInteger(year) || !apps.time.isInteger(month) ||
        !apps.time.isInteger(day) || !apps.time.isInteger(cmp)) {
      throw Error('Bad arguments to Date constructor: ' +
          [year, month, day, cmp].join(','));
    }
  }
  result.year = year;
  result.month = month;
  result.date = day;
  result.cmp_ = cmp;
  apps.time.Date.cache_[cmp] = result;
  return result;
};


/** @override */
apps.time.Date.prototype.toDate = function() {
  return this;
};


/** @override */
apps.time.Date.prototype.getComparable = function() {
  return this.cmp_;
};


/** @override */
apps.time.Date.prototype.isComplete = function() {
  return true;
};


/**
 * @override
 * @suppress {visibility} Uses private methods of apps.time.
 */
apps.time.Date.prototype.toStringSlow = function() {
  return goog.string.buildString(
      apps.time.formatYear_(this.year),
      apps.time.formatInt2_(this.month),
      apps.time.formatInt2_(this.date));
};


/** @override */
apps.time.Date.prototype.equals = function(that) {
  // All Date objects of the same value are pointer-equals.
  return this === that;
};


/**
 * A cache of apps.time.Date objects. The keys are date keys and the
 * values are the corresponding apps.time.Date objects.
 *
 * @type {Object}
 * @private
 */
apps.time.Date.cache_ = {};


/**
 * Factory method for creating apps.time.Date objects.
 *
 * @param {number} year  The four-digit year (eg 2007).
 * @param {number} month  The month number (1-12).
 * @param {number} date  The day of the month (1-31).
 * @return {!apps.time.Date} A date with the corresponding y, m, d.
 */
apps.time.Date.create = function(year, month, date) {
  var key = apps.time.getDateKey(year, month, date);
  return apps.time.Date.cache_[key] ||
      apps.time.Date.construct_(year, month, date, key);
};


/**
 * Gets a Date object from its date key.
 *
 * @param {number} key  The date key from apps.time.getDateKey.
 * @return {!apps.time.Date} A date with the corresponding y, m, d.
 */
apps.time.Date.fromKey = function(key) {
  return apps.time.Date.cache_[key] ||
      apps.time.Date.construct_(
          apps.time.getKeyYear(key), apps.time.getKeyMonth(key),
          apps.time.getKeyDate(key), key);
};


/**
 * Given a Date or DateTime, return the Date representing the next day
 *
 * This is a special case of the advance function, but it is used in tight
 * loops often enough that I have coded up a faster version which does not
 * create any intermediate apps.time.DateTimeBuilder objects.
 *
 * See also apps.time.Date.prototype.getNextDate, which does the same
 * thing for objects that are already date time.
 *
 * @param {number} y  The year, such as 2008.
 * @param {number} m  The month 1-12.
 * @param {number} d  The date 1-31.
 * @return {!apps.time.Date} The date immediately after.
 */
apps.time.Date.after = function(y, m, d) {
  // Have we passed the end of the month?
  // Short-circuit at 28 (the shortest month length) if possible.
  if (++d > 28 && d > apps.time.daysInMonth(y, m)) {
    d = 1;
    // All right, see if we've passed the end of the year.
    if (++m === 13) {
      m = 1;
      ++y;
    }
  }

  return apps.time.Date.create(y, m, d);
};


/**
 * Converts Date.UTC(...) to a Date.
 *
 * @param {number} utc  A UTC time in Milliseconds.
 * @return {!apps.time.Date} A Date that corresponds to
 *   the supplied utc value.
 */
apps.time.Date.fromUtc = function(utc) {
  return apps.time.Date.fromJsDateUtc(new Date(utc));
};


/**
 * Creates a Date object from a javascript date, using UTC accessors.
 *
 * @param {Date} jsDate  A Javascript Date object, whose UTC accessors are used.
 * @return {!apps.time.Date} The ICAL date object.
 */
apps.time.Date.fromJsDateUtc = function(jsDate) {
  return apps.time.Date.create(jsDate.getUTCFullYear(),
      jsDate.getUTCMonth() + 1, jsDate.getUTCDate());
};


/**
 * Creates a Date object from a javascript date, using BROWSER time.
 *
 * This should be avoided whenever possible, since many browsers/operating
 * systems/users have issues.
 *
 * @param {Date} jsDate  A Javascript Date object, whose LOCAL time is used.
 * @return {!apps.time.Date} The interpreted date.
 */
apps.time.Date.fromJsDateLocal = function(jsDate) {
  return apps.time.Date.create(jsDate.getFullYear(),
      jsDate.getMonth() + 1, jsDate.getDate());
};

//javascript/apps/time/duration.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Representation for icalendar duration.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time.Duration');

goog.require('apps.time');
goog.require('apps.time.Temporal');


/**
 * An icalendar duration.
 *
 * @param {number} date  A number of days.
 * @param {number} hour  A number of hours.
 * @param {number} minute  A number of minutes.
 * @param {number} second  A number of seconds.
 *
 * @constructor
 * @extends {apps.time.Temporal}
 */
apps.time.Duration = function(date, hour, minute, second) {
  apps.time.Temporal.call(this);

  // normalize to make sure all non zero fields have the same sign and are
  // in the expected ranges
  var total = ((date * 24 + hour) * 60 + minute) * 60 + second;
  this.total_ = total;
  this.second = total % 60;
  total = (total / 60) | 0; // rounds towards zero
  this.minute = total % 60;
  total = (total / 60) | 0;
  this.hour = total % 24;
  this.date = (total / 24) | 0;
};
goog.inherits(apps.time.Duration, apps.time.Temporal);


/** @return {number} A rounded-towards-zero number of days total. */
apps.time.Duration.prototype.toDays = function() {
  return this.date;
};


/** @return {number} A rounded-towards-zero number of hours total. */
apps.time.Duration.prototype.toHours = function() {
  return (this.total_ / apps.time.Constants.HOUR_SEC) | 0;
};


/** @return {number} A rounded-towards-zero number of minutes total. */
apps.time.Duration.prototype.toMinutes = function() {
  return (this.total_ / apps.time.Constants.MINUTE_SEC) | 0;
};


/** @return {number} The number of seconds total. */
apps.time.Duration.prototype.toSeconds = function() {
  return this.total_;
};


/** @override */
apps.time.Duration.prototype.getComparable = function() {
  return this.cmp_ || (this.cmp_ =
      apps.time.getDurationKey(
          this.date, this.hour, this.minute, this.second));
};


/**
 * String form of a duration.
 *
 * This is a bit different from the RFC2445 format, since icalendar durations
 * don't allow month or year diffs.  Well formed durations shouldn't have
 * these either, but I want to allow them in intermediate form.  <br>The
 * general form of a duration is
 * <tt>[+-]?P(\d+W)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?</tt>.
 * <br>where Y = year, N = month, W = week, D = date, H = hour, M = minute,
 * S = second.
 *
 * @return {string} An ICAL-format string representation of this Temporal.
 */
apps.time.Duration.prototype.toStringSlow = function() {
  var hasTime = this.hour || this.minute || this.second || 0;
  var firstField = this.date || hasTime;
  var sign = (firstField < 0) ? -1 : (firstField > 0) ? 1 : 0;
  var buffer = sign < 0 ? '-P' : 'P';

  if (goog.DEBUG) {
    if (this.year || this.month) {
      throw Error('Durations should not have month or year:' +
          this.year + '/' + this.month);
    }
  }

  // duration is specified as a number of weeks, hours, minutes, and seconds
  if (this.date) {
    if (this.date % 7) {
      buffer += (sign * this.date) + 'D';
    } else {
      buffer += (sign * this.date / 7) + 'W';
    }
  }

  if (hasTime) {
    buffer += 'T';
    if (this.hour) {
      buffer += (sign * this.hour) + 'H';
    }
    if (this.minute) {
      buffer += (sign * this.minute) + 'M';
    }
    if (this.second) {
      buffer += (sign * this.second) + 'S';
    }
  } else if (!sign) {
    // the value was entirely zero
    buffer += '0D';
  }

  return buffer;
};


/** @override */
apps.time.Duration.prototype.equals = function(that) {
  return !!that && this.constructor === that.constructor && // same class
      this.getComparable() == that.getComparable();
};


/**
 * A duration of one day.
 * @type {!apps.time.Duration}
 */
apps.time.Duration.ONE_DAY = new apps.time.Duration(1, 0, 0, 0);

//javascript/apps/time/datetimebuilder.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview A mutable builder for dates and/or times.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time.DateTimeBuilder');

goog.require('apps.time');
goog.require('apps.time.Date');
goog.require('apps.time.DateTime');
goog.require('apps.time.Duration');
goog.require('apps.time.Temporal');
goog.require('apps.time.Time');
goog.require('apps.time.key');
goog.require('goog.string');


/**
 * A builder for dates and times.
 *
 * This constructor is private.
 *
 * @constructor
 * @extends {apps.time.Temporal}
 */
apps.time.DateTimeBuilder = function() {
};
goog.inherits(apps.time.DateTimeBuilder, apps.time.Temporal);


/** @override */
apps.time.DateTimeBuilder.prototype.year = 0;


/** @override */
apps.time.DateTimeBuilder.prototype.month = 0;


/** @override */
apps.time.DateTimeBuilder.prototype.date = 0;


/** @override */
apps.time.DateTimeBuilder.prototype.hour = 0;


/** @override */
apps.time.DateTimeBuilder.prototype.minute = 0;


/** @override */
apps.time.DateTimeBuilder.prototype.second = 0;


/** @override */
apps.time.DateTimeBuilder.prototype.getComparable = function() {
  var result = this.getDateKey(); // normalizes as a side effect
  if (!isNaN(this.hour)) {
    result += apps.time.getTimeKey(this.hour, this.minute, this.second);
  }
  return result;
};


/** @override */
apps.time.DateTimeBuilder.prototype.getDateKey = function() {
  // NOTE: getComparable relies on makeNormalized() being a side-effect
  this.makeNormalized();
  return apps.time.getDateKey(this.year, this.month, this.date);
};


/**
 * Adds a duraction to the builder.
 *
 * NOTE: Adding a month or a year is undefined, since these time periods
 * vary.
 *
 * @param {apps.time.Duration} duration  The amount of time to add.
 */
apps.time.DateTimeBuilder.prototype.advance = function(duration) {
  this.date += duration.date;
  this.hour += duration.hour;
  this.minute += duration.minute;
  this.second += duration.second;
};


/**
 * Fixes any fields that go beyond their allowed ranges (i.e. Nov 31 is
 * December 1).
 *
 * Note this is not called "normalize", since we don't want this function
 * to get externed inadvertently due to the normalize DOM methods.
 */
apps.time.DateTimeBuilder.prototype.makeNormalized = function() {
  this.normalizeHMS_();
  this.normalizeMonth_();
  var n = apps.time.daysInMonth(this.year, this.month);
  while (this.date < 1) {
    this.month -= 1;
    this.normalizeMonth_();
    n = apps.time.daysInMonth(this.year, this.month);
    this.date += n;
  }
  while (this.date > n) {
    this.date -= n;
    this.month += 1;
    this.normalizeMonth_();
    n = apps.time.daysInMonth(this.year, this.month);
  }
};


/**
 * Normalizes the hour, minute, and second fields.
 * @private
 */
apps.time.DateTimeBuilder.prototype.normalizeHMS_ = function() {
  if (this.hour || this.minute || this.second) {
    var total = (this.hour * 60 + this.minute) * 60 + this.second;
    // Must find number of days first, so that we can keep total positive.
    var days = Math.floor(total / apps.time.Constants.DAY_SEC);
    total -= days * apps.time.Constants.DAY_SEC;
    this.date += days;
    this.second = total % 60;
    total /= 60;
    this.minute = (total | 0) % 60;
    total /= 60;
    this.hour = (total | 0) % 24;
  }
};


/**
 * Normalizes the month field.
 * @private
 */
apps.time.DateTimeBuilder.prototype.normalizeMonth_ = function() {
  var n;
  // note that when year and month are NaN, such as for a time or duration,
  // both of these conditions evaluate to false and no month normalization is
  // done.
  if (this.month < 1 || this.month > 12) {
    n = Math.floor((this.month - 1) / 12);
    this.month -= 12 * n;
    this.year += n;
  }
};


/**
 * @return {!apps.time.Date} This as an immutable Date object.
 */
apps.time.DateTimeBuilder.prototype.toDate = function() {
  this.makeNormalized();
  return apps.time.Date.create(this.year, this.month, this.date);
};


/**
 * @return {!apps.time.DateTime} This as an immutable DateTime object.
 */
apps.time.DateTimeBuilder.prototype.toDateTime = function() {
  this.makeNormalized();
  return new apps.time.DateTime(
      this.year, this.month, this.date, this.hour, this.minute, this.second);
};


/**
 * @return {!apps.time.PartialDate} This as an immutable PartialDate
 *     object.
 */
apps.time.DateTimeBuilder.prototype.toPartialDate = function() {
  // comparisons to undefined return false so will not affect partial fields
  this.makeNormalized();
  return apps.time.Temporal.prototype.toPartialDate.call(this);
};


/**
 * @return {!apps.time.PartialDateTime} This as an immutable
 *     PartialDateTime object.
 */
apps.time.DateTimeBuilder.prototype.toPartialDateTime = function() {
  // comparisons to undefined return false so will not affect partial fields
  this.makeNormalized();
  return apps.time.Temporal.prototype.toPartialDateTime.call(this);
};


/**
 * @return {!apps.time.Time} This as a time object.
 */
apps.time.DateTimeBuilder.prototype.toTime = function() {
  this.makeNormalized();
  return new apps.time.Time(this.hour, this.minute, this.second);
};


/**
 * @return {!apps.time.Duration} Converts to a duration of time.
 */
apps.time.DateTimeBuilder.prototype.toDuration = function() {
  if (goog.DEBUG) {
    if (this.year || this.month) {
      throw new Error('Durations cannot have a year or month');
    }
  }
  return new apps.time.Duration(
      this.date, this.hour, this.minute, this.second);
};


/** @override */
apps.time.DateTimeBuilder.prototype.getDayOfWeek = function() {
  this.makeNormalized();
  return apps.time.getDayOfWeek(this.year, this.month, this.date);
};


/**
 * @return {boolean} Whether this date builder can be converted to a proper
 *     apps.time.Date (after normalization).
 * @suppress {visibility} Uses private methods of apps.time.
 */
apps.time.DateTimeBuilder.prototype.isValidDate = function() {
  return apps.time.isInteger(this.year) &&
         apps.time.isInteger(this.month) &&
         apps.time.isInteger(this.date);
};


/**
 * @return {boolean} Whether this date builder can be converted to a proper
 *     apps.time.Time (post normalization).
 * @suppress {visibility} Uses private methods of apps.time.
 */
apps.time.DateTimeBuilder.prototype.isValidTime = function() {
  return apps.time.isInteger(this.hour) &&
         apps.time.isInteger(this.minute) &&
         apps.time.isInteger(this.second);
};


/**
 * @return {boolean} Whether this date builder can be converted to a proper
 *     apps.time.DateTime (post normalization).
 */
apps.time.DateTimeBuilder.prototype.isValidDateTime = function() {
  return this.isValidDate() && this.isValidTime();
};


if (goog.DEBUG) {
  /**
   * @return {string} A string version of this date-time builder.
   * @suppress {visibility} Uses private methods of apps.time.
   */
  apps.time.DateTimeBuilder.prototype.toString = function() {
    // NOTE: This return value is inconsistent with the rest of Temporal
    // implementations and only meant for debugging purposes.  Also, since this
    // is mutable, we override toString directly (versus toStringSlow) to
    // disable caching.
    return goog.string.buildString(
        '[DateTimeBuilder ', apps.time.formatOptionalYear_(this.year),
        '/', apps.time.formatOptionalInt2_(this.month),
        '/', apps.time.formatOptionalInt2_(this.date),
        ' ', apps.time.formatOptionalInt2_(this.hour),
        ' ', apps.time.formatOptionalInt2_(this.minute),
        ' ', apps.time.formatOptionalInt2_(this.second),
        ']');
  };
}


/** @override */
apps.time.DateTimeBuilder.prototype.equals = function(that) {
  return !!that && this.constructor == that.constructor && // same class
      this.getComparable() == that.getComparable();
};


/**
 * Creates a mutable temporal.
 *
 * @return {!apps.time.DateTimeBuilder} A mutable temporal.
 */
apps.time.DateTimeBuilder.create = function() {
  return new apps.time.DateTimeBuilder();
};


/**
 * Creates a builder with unspecified fields set to zero.
 * @param {apps.time.Temporal} t  Originating temporal.
 * @return {!apps.time.DateTimeBuilder} A builder with same values as
 *     the temporal of that temporal, with unspecified fields set to zero.
 */
apps.time.DateTimeBuilder.copy = function(t) {
  return apps.time.DateTimeBuilder.forValues(
      t.year || 0, t.month || 0, t.date || 0,
      t.hour || 0, t.minute || 0, t.second || 0);
};


/**
 * Creates a builder that contains a copy of the given, possibly partial,
 * date value.
 *
 * Unlike the copy method, this leaves undefined or NaN fields as they
 * originally began.
 *
 * @param {apps.time.Temporal} t  The temporal to copy.
 * @return {!apps.time.DateTimeBuilder} A builder with same values as the
 *     temporal.
 */
apps.time.DateTimeBuilder.copyPartial = function(t) {
  return apps.time.DateTimeBuilder.forValues(
      t.year, t.month, t.date, t.hour, t.minute, t.second);
};


/**
 * Creates a builder with specified fields.
 *
 * Allows NaN's to indicate unspecified.
 *
 * @param {number} year  The year (eg 2007).
 * @param {number} month  The month (1-12).
 * @param {number} date  The date (1-31).
 * @param {number} hour  The hour (0-23).
 * @param {number} minute  The minute (0-59).
 * @param {number} second  The second (0-59).
 * @return {!apps.time.DateTimeBuilder} A new builder with specified
 *     fields, unspecified set to zero.
 */
apps.time.DateTimeBuilder.forValues = function(
    year, month, date, hour, minute, second) {
  var b = apps.time.DateTimeBuilder.create();
  b.year = year;
  b.month = month;
  b.date = date;
  b.hour = hour;
  b.minute = minute;
  b.second = second;
  return b;
};


/**
 * Creates a date-only builder with specified fields.
 *
 * @param {number} year  The year (eg 2007).
 * @param {number} month  The month (1-12).
 * @param {number} date  The date (1-31).
 * @return {!apps.time.DateTimeBuilder} A new builder with specified
 *     fields.
 */
apps.time.DateTimeBuilder.forDateValues = function(year, month, date) {
  var b = apps.time.DateTimeBuilder.create();
  b.year = year;
  b.month = month;
  b.date = date;
  return b;
};

//javascript/apps/time/periodoftime.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Representation for icalendar period of time.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time.PeriodOfTime');

goog.require('apps.time.Duration');

/**
 * An icalendar period-of-time with start and end times.
 *
 * A PeriodOfTime is start-inclusive end-exclusive, i.e. [t1, t2).
 *
 * @param {apps.time.Temporal} t1  The start time.
 * @param {apps.time.Temporal} t2  The end time.  If this is a Duration,
 *     it will be added to t1.
 * @constructor
 */
apps.time.PeriodOfTime = function(t1, t2) {
  this.start = t1;
  if (t2.constructor === apps.time.Duration) {
    var b = apps.time.DateTimeBuilder.copy(t1);
    b.advance(/** @type {apps.time.Duration} */ (t2));
    this.end = this.start instanceof apps.time.DateTime ?
        b.toDateTime() : b.toDate();
    this.duration = t2;
  } else {
    this.end = t2;
    this.duration = this.end.minus(this.start);
  }
};


/**
 * Creates a date range of specified start date and length.
 *
 * @param {apps.time.Temporal} start  The start time.
 * @param {number} numDays  The number of days.
 * @return {!apps.time.PeriodOfTime} daterange specified.
 */
apps.time.PeriodOfTime.forRange = function(start, numDays) {
  return new apps.time.PeriodOfTime(start,
      new apps.time.Duration(numDays, 0, 0, 0));
};


/**
 * @return {string}  The ical-formatted string for this period of time.
 */
apps.time.PeriodOfTime.prototype.toString = function() {
  return this.start + '/' + this.end;
};


/**
 * @param {*} that  An object to compare to.
 * @return {boolean} Whether this period of time is equal to another object.
 */
apps.time.PeriodOfTime.prototype.equals = function(that) {
  return !!that && this.constructor === that.constructor && // same class
    this.start.equals(that.start) && this.end.equals(that.end);
};


/**
 * Computes the smallest date range that contains both this and another date
 * range.
 *
 * This is aggressive because [1,2) union [4,5) will return [1,5).
 *
 * @param {apps.time.PeriodOfTime} that  A PeriodOfTime to merge with.
 * @return {!apps.time.PeriodOfTime} A new PeriodOfTime including both
 *     date ranges.
 */
apps.time.PeriodOfTime.prototype.getUnion = function(that) {
  return new apps.time.PeriodOfTime(
      this.start.min(that.start),
      this.end.max(that.end));
};


/**
 * Gets the range of overlap between period1 and period2, or null if no
 * overlap or a zero width overlap.
 *
 * @param {apps.time.PeriodOfTime} that  Another period of time.
 * @return {apps.time.PeriodOfTime} The intersection of the two
 *     ranges, or null if there is no overlap.
 */
apps.time.PeriodOfTime.prototype.getOverlap = function(that) {
  var s1 = this.start;
  var e1 = this.end;
  var s2 = that.start;
  var e2 = that.end;
  // is there any overlap?
  if (e1.getComparable() <= s2.getComparable() ||
      e2.getComparable() <= s1.getComparable()) {
    return null;
  }
  return new apps.time.PeriodOfTime(s1.max(s2), e1.min(e2));
};


/**
 * @param {apps.time.PeriodOfTime} that  Another period of time.
 * @return {boolean} Whether two periods of time overlap.
 */
apps.time.PeriodOfTime.prototype.overlaps = function(that) {
  // Two regions A and B don't overlap if A ends before B starts or
  // A starts after B ends.  Since ends are exclusive we use >= and <=:
  //   overlap = !(A.end <= B.start || A.start >= B.end)
  // By DeMorgan's:
  //   overlap = (A.end > B.start) && (A.start < B.end)
  return that.end.getComparable() > this.start.getComparable() &&
         that.start.getComparable() < this.end.getComparable();
};


/**
 * @param {apps.time.Temporal} start  Start time of another period.
 * @param {apps.time.Temporal} end  End time of another period.
 * @return {boolean} Whether two periods of time overlap.
 */
apps.time.PeriodOfTime.prototype.overlapsDateTimes = function(
    start, end) {
  return end.getComparable() > this.start.getComparable() &&
         start.getComparable() < this.end.getComparable();
};


/**
 * Checks if this region overlaps the region [start, end], allowing for zero
 * length overlap. This deviates from RFC2445 which does not consider intervals
 * that intersect in a point to be overlapping.
 *
 * @param {apps.time.Date} start  The start of the region to compare to.
 * @param {apps.time.Date} end  The end of the region to compare to.
 * @return {boolean} Whether this overlaps [start,end] (zero length overlap
 *     is allowed).
 */
apps.time.PeriodOfTime.prototype.overlapsZeroLength = function(
    start, end) {
  return end.getComparable() >= this.start.getComparable() &&
         start.getComparable() <= this.end.getComparable();
};


/**
 * @param {apps.time.PeriodOfTime} that The other period of time.
 * @return {boolean} Whether this range subsumes the other period of time.
 */
apps.time.PeriodOfTime.prototype.subsumes = function(that) {
  return this.start.getComparable() <= that.start.getComparable() &&
         this.end.getComparable() >= that.end.getComparable();
};


/**
 * @param {apps.time.Temporal} temporal  A date or time to check.
 * @return {boolean} Whether this range contains a particular date or time.
 */
apps.time.PeriodOfTime.prototype.contains = function(temporal) {
  var comp = temporal.getComparable();
  return comp >= this.start.getComparable() &&
      comp < this.end.getComparable();
};

//javascript/apps/time/basicparse.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Parsing dates and times in icalendar and other formats.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author davem@google.com (Dave Marmaros)
 * @author msamuel@google.com (Mike Samuel)
 */

goog.provide('apps.time.fastParse');
goog.provide('apps.time.fastParse3339');

goog.require('apps.time');
goog.require('apps.time.Date');
goog.require('apps.time.DateTime');


/**
 * The ordinal value of character 0.
 * @private
 */
apps.time.CHAR_ZERO_ = 48;


/**
 * The ordinal value of the T character.
 * @private
 */
apps.time.CHAR_T_ = 84;


/**
 * The ordinal value of the Z character.
 * @private
 */
apps.time.CHAR_Z_ = 90;


/**
 * Quickly parses a 2-length substring as a decimal number.
 * @param {string} s  The string.
 * @param {number} a  The first character position.
 * @return {number} The string as a number.
 * @private
 */
apps.time.toInt2_ = function(s, a) {
  // distributive property/polynomial multiplication
  return s.charCodeAt(a) * 10 + s.charCodeAt(a + 1) - 528;
};


/**
 * Converts a character code for either the plus or minus character to
 * a numeric sign of 1 or -1.
 * @param {number} charCode  The character code, either
 *     '+' (43) or '-' (45).
 * @return {number} The sign, either 1 or -1.
 * @private
 */
apps.time.signFromCharCode_ = function(charCode) {
  // for the plus character: 44 - 43 ('+') = 1
  // for the minus character: 44 - 45 ('-') = -1
  return 44 - charCode;
};


/**
 * A faster version of apps.time.parse.
 *
 * It assumes the string is in the form YYYYMMDD or YYYYMMDDTHHMMSS. With
 * values that do not need further normalizing. Runs ~3x faster than the
 * regular version.  Note that this does NOT construct extra strings, and
 * runs with the unicode codes directly, which helps a lot in IE
 *
 * @param {string} icalString  The ical in one of the above formats.
 * @return {!apps.time.Date|!apps.time.DateTime} The parsed Date or DateTime.
 */
// For some reason, jscompiler doesn't think that Date extends Temporal.
apps.time.fastParse = function(icalString) {
  // Parse the year month and date as a single integer.
  var bigDecimalNumber = parseInt(icalString, 10);
  var date = bigDecimalNumber % 100;
  bigDecimalNumber /= 100;
  var month = (bigDecimalNumber | 0) % 100;
  var year = (bigDecimalNumber / 100) | 0;
  var length = icalString.length;
  if (goog.DEBUG && length != 8 && length != 15) {
    throw Error('Not a valid icalString: ' + icalString);
  }

  if (length == 8) {
    // Date YYYYMMDD
    return apps.time.Date.create(year, month, date);
  } else {
    // DateTime YYYYMMDDTHHMMSS
    return new apps.time.DateTime(year, month, date,
        apps.time.toInt2_(icalString, 9),
        apps.time.toInt2_(icalString, 11),
        // TODO(gboyer): Should we ignore seconds?
        apps.time.toInt2_(icalString, 13));
  }
};


/**
 * Converts the incoming RFC3339 date, used by GData, into an ical Date or
 * DateTime object, depending on the format.
 *
 * <p>This accepts the following 3 formats:
 * <ul>
 * <li> 2006-04-28T09:00:00.000-07:00 ==> apps.time.DateTime
 * <li> 2006-04-28T09:00:00.000Z ==> apps.time.DateTime
 * <li> 2006-04-19 ==> apps.time.Date
 * </ul>
 *
 * <p>This provides three options for time zone.  The reliable option is not
 * to do any time zone arithmetic and rely on server and ignore the time
 * zone suffix.  The second option is to use the browser's Date object to
 * convert to lcoal time.  The third is to store times in UTC.
 *
 * <p>Relying on the browser is NOT preferred, because there are at least
 * four relatively *common* points of failure:
 * <ul>
 * <li> user's failure to patch OS to incorporate recent DST changes
 * <li> user's failure to set timezone in OS (especially travelers)
 * <li> bug in the operating system (especially for infrequent time zones)
 * <li> browser bug (Mac Safari and Firefox are inconsistent)
 * </ul>
 *
 * <p>Please realize that RFC3339 does *not* actually provide time zone
 * information, only an offset at a single point in time.  Each date/time
 * could have a unique time zone offset -- even for a single calendar event,
 * the start and end times could span a DST change.
 *
 * <p>Time zones are ignored when it is a date (not a time) being parsed.
 *
 * @param {string} rfc3339  The RFC3339 formatted string (see above).
 * @param {boolean=} opt_useBrowserTime  If true, the browser's time is used
 *     (see above for why this is a bad idea).
 * @param {boolean=} opt_useUtc  If true, the time is returned in UTC.
 * @return {!apps.time.Date|!apps.time.DateTime}
 *     The Date or DateTime represented by the string.
 */
apps.time.fastParse3339 = function(rfc3339, opt_useBrowserTime, opt_useUtc) {
  // Incoming format (without time zone):
  // 0123456789012345678 (count from beginning of string)
  // YYYY-MM-DDTHH:MM:SS
  var year = parseInt(rfc3339, 10); // ignores everythinga after the hyphen
  var month = apps.time.toInt2_(rfc3339, 5);
  var day = apps.time.toInt2_(rfc3339, 8);
  var length = rfc3339.length;
  var result;

  if (rfc3339.charCodeAt(10) == apps.time.CHAR_T_) {
    var hour = apps.time.toInt2_(rfc3339, 11);
    var minute = apps.time.toInt2_(rfc3339, 14);
    var second = apps.time.toInt2_(rfc3339, 17);

    // We got both a date and time.
    if (opt_useBrowserTime || opt_useUtc) {
      // This uses the browser's Date object to compute local time, and also
      // undoes any time zone conversion the server may have done.
      var epochMs = Date.UTC(year, month - 1, day, hour, minute, second);

      // The string will either have a time zone offset, or end with Z,
      // indicating GMT.
      //     654321 (count from end of string)
      // (+/-)HH:MM

      var offsetMinutes = 0;
      if (rfc3339.charCodeAt(length - 1) != apps.time.CHAR_Z_) {
        offsetMinutes =
            apps.time.toInt2_(rfc3339, length - 5) * 60 +
            apps.time.toInt2_(rfc3339, length - 2);
        // Handle the sign
        offsetMinutes *= apps.time.signFromCharCode_(
            rfc3339.charCodeAt(length - 6));
      }

      // pick a constructor based on whether we're using the browser time zone
      var ctor = opt_useBrowserTime ?
          apps.time.DateTime.fromJsDateLocal :
          apps.time.DateTime.fromJsDateUtc;

      result = ctor(new Date(epochMs -
          offsetMinutes * apps.time.Constants.MINUTE_MS));
    } else {
      result = new apps.time.DateTime(
          year, month, day, hour, minute, second);
    }
  } else {
    // Only a date is specified.  No time zone conversion performed.
    result = apps.time.Date.create(year, month, day);
  }

  return result;
};

//javascript/apps/time/partialdate.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Representation for icalendar partial date.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time.PartialDate');

goog.require('apps.time');


/**
 * A date with some fields possibly missing.
 *
 * @param {number} year  The year (eg 2007) or NaN.
 * @param {number} month  The month (1-12) or NaN.
 * @param {number} date  The date (1-31) or NaN.
 * @constructor
 * @extends {apps.time.DateValue}
 */
apps.time.PartialDate = function(year, month, date) {
  this.year = year;
  this.month = month;
  this.date = date;
};
goog.inherits(apps.time.PartialDate, apps.time.DateValue);


// Note: This is the definition of a method in the BASE temporal class! We put
// the definition here so that the base temporal.js does not have an outgoing
// dependency to this file, and so clients who are uninterested in partial
// dates do not risk pulling that in.
/**
 * Gets a PartialDate object best representing this value.
 *
 * @return {!apps.time.PartialDate} A PartialDate value best this.
 */
apps.time.Temporal.prototype.toPartialDate = function() {
  return new apps.time.PartialDate(
      this.year, this.month, this.date);
};


/** @override */
apps.time.PartialDate.prototype.toPartialDate = function() {
  return this;
};


/** @override */
apps.time.PartialDate.prototype.isComplete = function() {
  // neither year, month, nor date can be 0, so if they are boolean
  // false, they are definitely NaN or undefined
  return !!(this.year && this.month && this.date);
};


/** @override */
apps.time.PartialDate.prototype.getComparable = function() {
  if (this.cmp_ === undefined) {
      this.cmp_ = this.isComplete() ? apps.time.getDateKey(
          this.year, this.month, this.date) : NaN;
  }
  return this.cmp_;
};


/** @override */
apps.time.PartialDate.prototype.equals = function(that) {
  return !!that && this.constructor === that.constructor && // same class
      this.toString() == that.toString();
};


/**
 * @override
 * @suppress {visibility} Uses private methods of apps.time.
 */
apps.time.PartialDate.prototype.toStringSlow = function() {
  return goog.string.buildString(
      apps.time.formatOptionalYear_(this.year),
      apps.time.formatOptionalInt2_(this.month),
      apps.time.formatOptionalInt2_(this.date));
};

//javascript/apps/time/partialdatetime.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Representation for icalendar partial DateTime.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time.PartialDateTime');
goog.require('apps.time');
goog.require('apps.time.DateValue');
goog.require('goog.string');


/**
 * A date and time with some fields possibly missing.
 *
 * @param {number} year  The year (eg 2007) or NaN.
 * @param {number} month  The month (1-12) or NaN.
 * @param {number} date  The day (1-31) or NaN.
 * @param {number} hour  The hour (0-23) or NaN.
 * @param {number} minute  The hour (0-60) or NaN.
 * @param {number} second  The hour (0-60) or NaN.
 * @constructor
 * @extends {apps.time.DateValue}
 */
apps.time.PartialDateTime = function(year, month, date, hour, minute, second) {
  // for performance reasons, doesn't chain to super constructor
  this.year = year;
  this.month = month;
  this.date = date;
  this.hour = hour;
  this.minute = minute;
  this.second = second;
};
goog.inherits(apps.time.PartialDateTime, apps.time.DateValue);


/** @override */
apps.time.PartialDateTime.prototype.toPartialDate = function() {
  return new apps.time.PartialDate(this.year, this.month, this.date);
};


// Note: This is the definition of a method in the BASE temporal class! We put
// the definition here so that the base temporal.js does not have an outgoing
// dependency to this file, and so clients who are uninterested in partial
// dates do not risk pulling that in.
/**
 * Gets a PartialDateTime object best representing this value.
 *
 * @return {!apps.time.PartialDateTime} A PartialDateTime value best
 *     this.
 */
apps.time.Temporal.prototype.toPartialDateTime = function() {
  return new apps.time.PartialDateTime(
      this.year, this.month, this.date, this.hour, this.minute, this.second);
};


/** @override */
apps.time.PartialDateTime.prototype.toPartialDateTime = function() {
  return this;
};


/** @override */
apps.time.PartialDateTime.prototype.isComplete = function() {
  // Since year, month, and date can't be zero, we just chain to find
  // if any of them are "false" (implying undefined or NaN).
  return !!(this.year && this.month && this.date) &&
      !(isNaN(this.hour) || isNaN(this.minute) || isNaN(this.second));
};


/**
 * Gets a comparable key for this PartialDateTime.
 *
 * An incomplete PartialDateTime has a comparable of naN.
 * @return {number} A number that can be used in temporal comparisons.
 */
apps.time.PartialDateTime.prototype.getComparable = function() {
  if (this.cmp_ === undefined) {
      this.cmp_ = this.isComplete() ? apps.time.getDateTimeKey(
          this.year, this.month, this.date,
          this.hour, this.minute, this.second) : NaN;
  }
  return this.cmp_;
};


/** @override */
apps.time.PartialDateTime.prototype.equals = function(that) {
  return !!that && this.constructor === that.constructor && // same class
      this.toString() == that.toString();
};


/**
 * @override
 * @suppress {visibility} Uses private methods of apps.time.
 */
apps.time.PartialDateTime.prototype.toStringSlow = function() {
  return goog.string.buildString(
      apps.time.formatOptionalYear_(this.year),
      apps.time.formatOptionalInt2_(this.month),
      apps.time.formatOptionalInt2_(this.date),
      'T',
      apps.time.formatOptionalInt2_(this.hour),
      apps.time.formatOptionalInt2_(this.minute),
      apps.time.formatOptionalInt2_(this.second));
};

//javascript/apps/time/partialperiodoftime.js
// Copyright 2008 Google Inc.
// All rights reserved.

/**
 * @fileoverview Representation for icalendar partial PeriodOfTime.
 *
 * @author gboyer@google.com (Garrett Boyer)
 * @author msamuel@google.com (Mike Samuel)
 */


goog.provide('apps.time.PartialPeriodOfTime');

goog.require('apps.time');


/**
 * An icalendar partial period-of-time that might have undefined fields.
 *
 * @param {apps.time.Temporal} t1  The start time.
 * @param {apps.time.Temporal} t2  The end time.
 * @constructor
 */
apps.time.PartialPeriodOfTime = function(t1, t2) {
  this.start = t1;
  this.end = t2;
  // TODO(davem) - make a special partial duration function. In a partial
  // period. Extracting the duration might legitimately fail
  try {
    this.duration = this.end.minus(this.start);
  } catch (e) {
    // Cleanup here
    this.duration = null;
  }
};


/**
 * @return {string}  The ical-formatted string for this period of time.
 */
apps.time.PartialPeriodOfTime.prototype.toString = function() {
  return this.start + '/' + this.end;
};


/**
 * @param {*} that  An object to compare to.
 * @return {boolean} Whether this period of time is equal to another object.
 */
apps.time.PartialPeriodOfTime.prototype.equals = function(that) {
  return !!that && this.constructor === that.constructor && // same class
      this.start.equals(that.start) && this.end.equals(that.end);
};

//javascript/apps/drive/dataservice/sync/query/querystringbuilder.js
/**
 * @fileoverview Builds a Genoa query string out of an ItemQueryRequest.
 */

goog.provide('drive.ds.sync.query.QueryStringBuilder');

goog.require('apps.time');
/**
 * @suppress {extraRequire} DateTime depends on apps.time.Temporal, which is
 * missing a depedency on apps.time.Date.
 * TODO(towong): Fix the dependency in apps.time.Temporal and remove this.
 */
goog.require('apps.time.Date');
goog.require('apps.time.DateTime');
goog.require('drive.ds.DateSpec');
goog.require('drive.ds.TitleSpec');
goog.require('goog.string.StringBuffer');


/**
 * Builds a Genoa query string out of an ItemQueryRequest.
 * For more details see: https://developers.google.com/drive/search-parameters
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @return {string} A query string.
 */
drive.ds.sync.query.QueryStringBuilder.build = function(request) {
  var sb = new goog.string.StringBuffer();

  drive.ds.sync.query.QueryStringBuilder.appendTitle_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendFullText_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendMimeType_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendModifiedDate_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendViewedDate_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendTrashed_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendStarred_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendHidden_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendParents_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendOwners_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendWriters_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendReaders_(sb, request);
  drive.ds.sync.query.QueryStringBuilder.appendSharedWithMe_(sb, request);

  // TODO(towong) Add a query optimizer to simplify queries.
  return sb.toString();
};


/**
 * Genoa field names to use for querying.
 * @enum {string}
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.Field_ = {
  FULL_TEXT: 'fullText',
  HIDDEN: 'hidden',
  MIME_TYPE: 'mimeType',
  MODIFIED_DATE: 'modifiedDate',
  OWNERS: 'owners',
  PARENTS: 'parents',
  READERS: 'readers',
  SHARED_WITH_ME: 'sharedWithMe',
  STARRED: 'starred',
  TITLE: 'title',
  TRASHED: 'trashed',
  VIEWED_DATE: 'lastViewedByMeDate',
  WRITERS: 'writers'
};


/**
 * Genoa operators to use for querying.
 * @enum {string}
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.Operator_ = {
  CONTAINS: 'contains',
  EQUALS: '=',
  GREATER_EQUALS: '>=',
  GREATER_THAN: '>',
  LESS_EQUALS: '<=',
  LESS_THAN: '<',
  IN: 'in',
  NOT: 'not',
  NOT_EQUALS: '!='
};


/**
 * Genoa logical operator to use for querying.
 * @enum {string}
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.LogicalOp_ = {
  AND: 'and',
  OR: 'or'
};


/**
 * Parses the title spec from the request if available and generates a title
 * query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendTitle_ = function(sb, request) {
  var titles = request.getTitleList();
  for (var i = 0; i < titles.length; i++) {
    var spec = titles[i];
    var value = spec.getValue();

    if (value) {
      var operator = spec.getOperator();
      var invert = spec.getInvert();

      var strings = [];
      if (invert && operator == drive.ds.TitleSpec.Operator.CONTAINS) {
        strings.push(drive.ds.sync.query.QueryStringBuilder.Operator_.NOT);
      }
      strings.push(drive.ds.sync.query.QueryStringBuilder.Field_.TITLE);
      strings.push(operator == drive.ds.TitleSpec.Operator.CONTAINS ?
          drive.ds.sync.query.QueryStringBuilder.Operator_.CONTAINS :
          (invert ?
              drive.ds.sync.query.QueryStringBuilder.Operator_.NOT_EQUALS :
              drive.ds.sync.query.QueryStringBuilder.Operator_.EQUALS));
      strings.push(
          drive.ds.sync.query.QueryStringBuilder.quoteEscapeString_(value));

      drive.ds.sync.query.QueryStringBuilder.appendQuery_(
          sb, strings.join(' '));
    }
  }
};


/**
 * Parses the full text spec from the request if available and generates a full
 * text query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendFullText_ = function(sb, request) {
  var fullTextList = request.getFullTextList();
  for (var i = 0; i < fullTextList.length; i++) {
    var spec = fullTextList[i];
    var value = spec.getValue();

    if (value) {
      var strings = [];
      if (spec.getInvert()) {
        strings.push(drive.ds.sync.query.QueryStringBuilder.Operator_.NOT);
      }
      strings.push(drive.ds.sync.query.QueryStringBuilder.Field_.FULL_TEXT);
      strings.push(drive.ds.sync.query.QueryStringBuilder.Operator_.CONTAINS);
      strings.push(
          drive.ds.sync.query.QueryStringBuilder.quoteEscapeString_(value));

      drive.ds.sync.query.QueryStringBuilder.appendQuery_(
          sb, strings.join(' '));
    }
  }
};


/**
 * Parses the mime type spec from the request if available and generates a mime
 * type query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendMimeType_ = function(sb, request) {
  var mimeTypes = request.getMimeTypeList();
  var equals = [];
  var notEquals = [];

  for (var i = 0; i < mimeTypes.length; i++) {
    var spec = mimeTypes[i];
    if (spec.getValue()) {
      var mimeType = drive.ds.sync.query.QueryStringBuilder.quoteEscapeString_(
          spec.getValue());
      spec.getInvert() ? notEquals.push(mimeType) : equals.push(mimeType);
    }
  }

  // Append the equals mimetypes clause, adding pararenthesis around the
  // entire clause. MimeTypes are combined using the OR operator.
  for (var i = 0; i < equals.length; i++) {
    var strings = [];
    strings.push((i == 0 ? '(' : '') +
        drive.ds.sync.query.QueryStringBuilder.Field_.MIME_TYPE);
    strings.push(drive.ds.sync.query.QueryStringBuilder.Operator_.EQUALS);
    strings.push(equals[i] + (i == equals.length - 1 ? ')' : ''));
    drive.ds.sync.query.QueryStringBuilder.appendQuery_(sb, strings.join(' '),
        (i != 0 ? drive.ds.sync.query.QueryStringBuilder.LogicalOp_.OR :
            drive.ds.sync.query.QueryStringBuilder.LogicalOp_.AND));
  }

  // Append the not equals mimetypes clause, adding pararenthesis around the
  // entire clause. MimeTypes are combined using the AND operator.
  for (var i = 0; i < notEquals.length; i++) {
    var strings = [];
    strings.push((i == 0 ? '(' : '') +
        drive.ds.sync.query.QueryStringBuilder.Operator_.NOT);
    strings.push(drive.ds.sync.query.QueryStringBuilder.Field_.MIME_TYPE);
    strings.push(drive.ds.sync.query.QueryStringBuilder.Operator_.EQUALS);
    strings.push(notEquals[i] + (i == notEquals.length - 1 ? ')' : ''));
    drive.ds.sync.query.QueryStringBuilder.appendQuery_(sb, strings.join(' '));
  }
};


/**
 * Parses the modified date spec from the request if available and generates a
 * modified date query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendModifiedDate_ =
    function(sb, request) {
  var dates = request.getModifiedDateList();
  for (var i = 0; i < dates.length; i++) {
    drive.ds.sync.query.QueryStringBuilder.appendDateSpec_(sb,
        drive.ds.sync.query.QueryStringBuilder.Field_.MODIFIED_DATE, dates[i]);
  }
};


/**
 * Parses the last viewed date spec from the request if available and generates
 * a last viewed date query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendViewedDate_ =
    function(sb, request) {
  var dates = request.getViewedDateList();
  for (var i = 0; i < dates.length; i++) {
    drive.ds.sync.query.QueryStringBuilder.appendDateSpec_(sb,
        drive.ds.sync.query.QueryStringBuilder.Field_.VIEWED_DATE, dates[i]);
  }
};


/**
 * Parses the is trashed spec from the request if available and generates a
 * trashed query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendTrashed_ = function(sb, request) {
  drive.ds.sync.query.QueryStringBuilder.appendBoolean_(
      sb, drive.ds.sync.query.QueryStringBuilder.Field_.TRASHED,
      request.getTrashed());
};


/**
 * Parses the is starred spec from the request if available and generates a
 * starred query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendStarred_ = function(sb, request) {
  drive.ds.sync.query.QueryStringBuilder.appendBoolean_(
      sb, drive.ds.sync.query.QueryStringBuilder.Field_.STARRED,
      request.getStarred());
};


/**
 * Parses the is hidden spec from the request if available and generates a
 * hidden query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendHidden_ = function(sb, request) {
  drive.ds.sync.query.QueryStringBuilder.appendBoolean_(
      sb, drive.ds.sync.query.QueryStringBuilder.Field_.HIDDEN,
      request.getHidden());
};


/**
 * Parses the parent spec from the request if available and generates a parent
 * query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendParents_ = function(sb, request) {
  var parents = request.getParentList();
  for (var i = 0; i < parents.length; i++) {
    var spec = parents[i];
    drive.ds.sync.query.QueryStringBuilder.appendInField_(
        sb, drive.ds.sync.query.QueryStringBuilder.Field_.PARENTS,
        spec.getValue(), spec.getInvert());
  }
};


/**
 * Parses the owners spec from the request if available and generates an owner
 * query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendOwners_ = function(sb, request) {
  var owners = request.getOwnerList();
  for (var i = 0; i < owners.length; i++) {
    var spec = owners[i];
    drive.ds.sync.query.QueryStringBuilder.appendInField_(
        sb, drive.ds.sync.query.QueryStringBuilder.Field_.OWNERS,
        spec.getValue(), spec.getInvert());
  }
};


/**
 * Parses the writer spec from the request if available and generates a writer
 * query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendWriters_ = function(sb, request) {
  var writers = request.getWriterList();
  for (var i = 0; i < writers.length; i++) {
    var spec = writers[i];
    drive.ds.sync.query.QueryStringBuilder.appendInField_(
        sb, drive.ds.sync.query.QueryStringBuilder.Field_.WRITERS,
        spec.getValue(), spec.getInvert());
  }
};


/**
 * Parses the reader spec from the request if available and generates a reader
 * query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendReaders_ = function(sb, request) {
  var readers = request.getReaderList();
  for (var i = 0; i < readers.length; i++) {
    var spec = readers[i];
    drive.ds.sync.query.QueryStringBuilder.appendInField_(
        sb, drive.ds.sync.query.QueryStringBuilder.Field_.READERS,
        spec.getValue(), spec.getInvert());
  }
};


/**
 * Parses the shared with me spec from the request if available and generates a
 * shared with me query string to append to the string buffer.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendSharedWithMe_ =
    function(sb, request) {
  if (request.getSharedWithMe()) {
    drive.ds.sync.query.QueryStringBuilder.appendQuery_(
        sb, drive.ds.sync.query.QueryStringBuilder.Field_.SHARED_WITH_ME);
  }
};


/**
 * Helper for appending a date spec to the query string.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {string} genoaField The Genoa date field name.
 * @param {!drive.ds.DateSpec} dateSpec The date spec.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendDateSpec_ =
    function(sb, genoaField, dateSpec) {
  if (goog.isDefAndNotNull(dateSpec.getDateMillis())) {
    var operator = drive.ds.sync.query.QueryStringBuilder.dateOperator_(
        dateSpec.getOperator());
    var date = drive.ds.sync.query.QueryStringBuilder.quoteEscapeString_(
        apps.time.format3339(apps.time.DateTime.fromUtc(
            dateSpec.getDateMillis())));
    var strings = [genoaField, operator, date];
    drive.ds.sync.query.QueryStringBuilder.appendQuery_(sb, strings.join(' '));
  }
};


/**
 * Helper for generating a Genoa operator out of a DateSpec.Operator.
 * @param {!drive.ds.DateSpec.Operator} operator The date spec operator.
 * @return {string} The Genoa operator.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.dateOperator_ = function(operator) {
  switch (operator) {
    case drive.ds.DateSpec.Operator.LESS_EQUALS:
      return drive.ds.sync.query.QueryStringBuilder.Operator_.LESS_EQUALS;
    case drive.ds.DateSpec.Operator.LESS_THAN:
      return drive.ds.sync.query.QueryStringBuilder.Operator_.LESS_THAN;
    case drive.ds.DateSpec.Operator.EQUALS:
      return drive.ds.sync.query.QueryStringBuilder.Operator_.EQUALS;
    case drive.ds.DateSpec.Operator.GREATER_THAN:
      return drive.ds.sync.query.QueryStringBuilder.Operator_.GREATER_THAN;
    case drive.ds.DateSpec.Operator.GREATER_EQUALS:
      return drive.ds.sync.query.QueryStringBuilder.Operator_.GREATER_EQUALS;
    default:
      return '';
  }
};


/**
 * Helper for adding a boolean value to the query string if the value is set.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {string} genoaField The Genoa field name.
 * @param {?boolean} value The boolean value, or null if not set.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendBoolean_ =
    function(sb, genoaField, value) {
  if (goog.isDefAndNotNull(value)) {
    var strings = [];
    strings.push(genoaField);
    strings.push(drive.ds.sync.query.QueryStringBuilder.Operator_.EQUALS);
    strings.push(value.toString());
    drive.ds.sync.query.QueryStringBuilder.appendQuery_(sb, strings.join(' '));
  }
};


/**
 * Helper for appending a "X in FIELD_NAME" to the query if the value is set.
 * @param {!goog.string.StringBuffer} sb The string buffer to append to.
 * @param {string} genoaField The Genoa field name.
 * @param {?string} value The value to match the field on, or null if not set.
 * @param {boolean} invert Whether this is a not query.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendInField_ =
    function(sb, genoaField, value, invert) {
  if (value) {
    var strings = [];
    if (invert) {
      strings.push(drive.ds.sync.query.QueryStringBuilder.Operator_.NOT);
    }
    strings.push(
        drive.ds.sync.query.QueryStringBuilder.quoteEscapeString_(value));
    strings.push(drive.ds.sync.query.QueryStringBuilder.Operator_.IN);
    strings.push(genoaField);
    drive.ds.sync.query.QueryStringBuilder.appendQuery_(sb, strings.join(' '));
  }
};


/**
 * Helper for escaping an input query string and adding single quotes around it.
 * @param {string} input The input string to escape.
 * @return {string} The escaped string with quotes around it.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.quoteEscapeString_ = function(input) {
  return "'" + input.replace("'", "\\'") + "'";
};


/**
 * Helper for appending an additional string to the final query.
 * @param {!goog.string.StringBuffer} sb Query string buffer to append string.
 * @param {string} appendQuery Query string to add to string buffer.
 * @param {drive.ds.sync.query.QueryStringBuilder.LogicalOp_=} opt_operator The
 *     optional logical operator used when appending the additional query
 *     string, defaults to AND.
 * @private
 */
drive.ds.sync.query.QueryStringBuilder.appendQuery_ = function(
    sb, appendQuery, opt_operator) {
  var operator = opt_operator ||
      drive.ds.sync.query.QueryStringBuilder.LogicalOp_.AND;
  if (sb.getLength()) {
    sb.append(' ' + operator + ' ');
  }
  sb.append(appendQuery);
};

//javascript/apps/drive/dataservice/sync/api/sortparam.js
/**
 * @fileoverview A sort parameter helper.
 */
goog.provide('drive.ds.sync.api.SortParam');

goog.require('drive.ds.SortSpec');
goog.require('drive.ds.sync.api.Params');


/**
 * A list of sort types to Genoa sortBy types.
 * @private {!Object.<drive.ds.SortSpec.Type, string>}
 */
drive.ds.sync.api.SortParam.sortTypeToGenoaSortBy_ = {};


// Populates the sortTypeToGenoaSortBy_ with currently supported sorts.
(function() {
  var map = {};
  map[drive.ds.SortSpec.Type.LAST_MODIFIED] = 'last_modified';
  map[drive.ds.SortSpec.Type.LAST_MODIFIED_BY_ME] = 'last_modified_by_me';
  map[drive.ds.SortSpec.Type.USER_QUOTA] = 'quota_used';
  map[drive.ds.SortSpec.Type.TITLE] = 'title';
  map[drive.ds.SortSpec.Type.LAST_VIEWED_BY_ME] = 'last_viewed_by_me';
  map[drive.ds.SortSpec.Type.RELEVANCE] = 'relevance';
  // TODO(ericzhang): Use FOLDER_TITLE once Genoa adds it.
  // TODO(towong): Add these Genoa params once they're supported
  map[drive.ds.SortSpec.Type.SHARED_DATE] = '';
  map[drive.ds.SortSpec.Type.STARRED] = '';
  drive.ds.sync.api.SortParam.sortTypeToGenoaSortBy_ = map;
})();


/**
 * Appends any applicable sort parameters to the given parameter object.
 * @param {!Object.<string, *>} params A set of Genoa parameters.
 * @param {drive.ds.SortSpec} sort The sort spec, or null if none set.
 * @return {!Object.<string, *>} The object for chaining.
 */
drive.ds.sync.api.SortParam.append = function(params, sort) {
  if (!drive.ds.sync.api.SortParam.isSupportedSort_(sort)) {
    return params;
  }

  var sortSpec = /** @type {!drive.ds.SortSpec} */ (sort);
  params[drive.ds.sync.api.Params.Request.SORT_BY] =
      drive.ds.sync.api.SortParam.getSortBy_(sortSpec);
  params[drive.ds.sync.api.Params.Request.REVERSE_SORT] =
      drive.ds.sync.api.SortParam.isReverseSort_(sortSpec);
  return params;
};


/**
 * @param {drive.ds.SortSpec} sort The sort spec, or null if none set.
 * @return {boolean} Whether specified sort is supported by Genoa.
 * @private
 */
drive.ds.sync.api.SortParam.isSupportedSort_ = function(sort) {
  return !!sort &&
      sort.getType() != drive.ds.SortSpec.Type.SHARED_DATE &&
      sort.getType() != drive.ds.SortSpec.Type.STARRED &&
      !sort.getFoldersFirst();
};


/**
 * Gets the Genoa sortBy parameter value.
 * @param {!drive.ds.SortSpec} sort The sort spec.
 * @return {string} The Genoa sortBy value.
 * @private
 */
drive.ds.sync.api.SortParam.getSortBy_ = function(sort) {
  return drive.ds.sync.api.SortParam.sortTypeToGenoaSortBy_[sort.getType()];
};


/**
 * Genoa has default directions for each type of sort and uses a reverseSort
 * parameter to perform the sort in the reverse direction. This figures out the
 * correct reverseSort parameter given a field and direction.
 * @param {!drive.ds.SortSpec} sort The sort spec.
 * @return {boolean} Whether the given sort maps to a reverseSort in Genoa.
 * @private
 */
drive.ds.sync.api.SortParam.isReverseSort_ = function(sort) {
  switch (sort.getType()) {
    case drive.ds.SortSpec.Type.TITLE:
      return sort.getDirection() == drive.ds.SortSpec.Direction.DESCENDING;
    default:
      return sort.getDirection() == drive.ds.SortSpec.Direction.ASCENDING;
  }
};

//javascript/apps/drive/dataservice/sync/api/files.js
/**
 * @fileoverview Helper that takes an ItemQueryRequest, generates a Genoa
 * request, and executes it.
 */

goog.provide('drive.ds.sync.api.Files');

goog.require('drive.ds.sync.Field');
goog.require('drive.ds.sync.api.Params');
goog.require('drive.ds.sync.api.RequestManager');
goog.require('drive.ds.sync.api.SortParam');
goog.require('drive.ds.sync.query.QueryStringBuilder');
goog.require('drive.ds.sync.stat.RequestType');


/**
 * TODO(towong) Add unit tests.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @param {!function(!goog.async.Deferred, !Object)} responseHandler The
 *     response handler to call.
 * @param {!Array.<!drive.ds.Field>} fields The list of fields to get.
 *     Note we don't use the list provided in the request as that varies from
 *     query to query, the list used should come from the context which the
 *     client provides on client initialization, ensuring the data we fetch
 *     populates each item in the cache fully.
 * @param {string=} opt_nextPageToken The optional continuation token.
 */
drive.ds.sync.api.Files.search = function(
    request, responseHandler, fields, opt_nextPageToken) {
  if (request.getId()) {
    drive.ds.sync.api.Files.get_(request, responseHandler, fields);
  } else {
    drive.ds.sync.api.Files.list_(
        request, responseHandler, fields, opt_nextPageToken);
  }
};


/**
 * Query for particular drive item with a drive id.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @param {!function(!goog.async.Deferred, !Object)} responseHandler The
 *     response handler to call.
 * @param {!Array.<!drive.ds.Field>} fields The list of fields to get.
 * @private
 */
drive.ds.sync.api.Files.get_ = function(request, responseHandler, fields) {
  var params = {};
  params[drive.ds.sync.api.Params.Request.FIELDS] =
      drive.ds.sync.Field.toFileFieldString(fields),
  params[drive.ds.sync.api.Params.Request.FILE_ID] = request.getId();

  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Files.createGetMethod_,
      params, responseHandler, drive.ds.sync.stat.RequestType.QUERY);
};


/**
 * Query for drive items with a given string.
 * TODO(towong) Pass sort order to Genoa once they can handle it.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @param {!function(!goog.async.Deferred, !Object)} responseHandler The
 *     response handler to call.
 * @param {!Array.<!drive.ds.Field>} fields The list of fields to get.
 * @param {string=} opt_nextPageToken The optional continuation token.
 * @private
 */
drive.ds.sync.api.Files.list_ = function(
    request, responseHandler, fields, opt_nextPageToken) {
  // Note that a maxResults param is never passed to ensure that a
  // "nextPageToken" gets returned if there are more results.
  var params = {};
  params[drive.ds.sync.api.Params.Request.FIELDS] =
      drive.ds.sync.Field.toFilesFieldString(fields);
  params[drive.ds.sync.api.Params.Request.QUERY] =
      drive.ds.sync.query.QueryStringBuilder.build(request);

  if (opt_nextPageToken) {
    params[drive.ds.sync.api.Params.Request.PAGE_TOKEN] = opt_nextPageToken;
  }

  drive.ds.sync.api.SortParam.append(params, request.getSort());

  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Files.createListMethod_,
      params, responseHandler, drive.ds.sync.stat.RequestType.QUERY);
};


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for a given item.
 * @private
 */
drive.ds.sync.api.Files.createGetMethod_ = function() {
  return gapi.client.drive.files.get;
};


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for a list of items.
 * @private
 */
drive.ds.sync.api.Files.createListMethod_ = function() {
  return gapi.client.drive.files.list;
};


//javascript/apps/drive/dataservice/sync/mutate/resourceparambuilder.js
/**
 * @fileoverview A builder for generating a resource parameter for performing
 * updates against Genoa.
 */

goog.provide('drive.ds.sync.mutate.ResourceParamBuilder');

goog.require('apps.time');
goog.require('apps.time.DateTime');
goog.require('goog.object');
goog.require('goog.string');


/**
 * Builds a resource parameter for performing a copy request against Genoa.
 * @param {!drive.ds.CopyItemRequest} request The copy item request.
 * @return {!Object} A resource parameter for a copy request.
 */
drive.ds.sync.mutate.ResourceParamBuilder.fromCopy = function(request) {
  var properties = drive.ds.sync.mutate.ResourceParamBuilder.Properties_;
  var props = {};

  if (!goog.string.isEmptySafe(request.getTitle())) {
    props[properties.TITLE] = request.getTitle();
  }

  drive.ds.sync.mutate.ResourceParamBuilder.addParents(
      props, request.getParentList());

  return props;
};


/**
 * Builds a resource parameter for performing a create request against Genoa.
 * @param {!drive.ds.CreateItemRequest} request The create item request.
 * @return {!Object} A resource parameter for a create request.
 */
drive.ds.sync.mutate.ResourceParamBuilder.fromCreate = function(request) {
  var properties = drive.ds.sync.mutate.ResourceParamBuilder.Properties_;
  var props = {};

  if (!goog.string.isEmptySafe(request.getTitle())) {
    props[properties.TITLE] = request.getTitle();
  }

  if (request.getMimeType()) {
    props[properties.MIME_TYPE] = request.getMimeType();
  }

  drive.ds.sync.mutate.ResourceParamBuilder.addParents(
      props, request.getParentList());

  return props;
};


/**
 * @param {!Object} props A resource parameter object.
 * @param {!Array.<string>} parents A list of parents, or an empty array on no
 *     parents.
 */
drive.ds.sync.mutate.ResourceParamBuilder.addParents =
    function(props, parents) {
  var properties = drive.ds.sync.mutate.ResourceParamBuilder.Properties_;

  if (parents.length) {
    props[properties.PARENTS] = [];

    for (var i = 0; i < parents.length; i++) {
      var parentResource = {};
      parentResource[properties.ID] = parents[i];
      props[properties.PARENTS].push(parentResource);
    }
  }
};


/**
 * Builds a resource parameter for performing an update request against Genoa.
 * @param {!drive.ds.UpdateItemRequest} request The update item request.
 * @return {!Object} A resource parameter for an update request.
 */
drive.ds.sync.mutate.ResourceParamBuilder.fromUpdate = function(request) {
  var properties = drive.ds.sync.mutate.ResourceParamBuilder.Properties_;
  var props = {};
  var labels = {};

  if (!goog.string.isEmptySafe(request.getTitle())) {
    props[properties.TITLE] = request.getTitle();
  }

  if (!goog.string.isEmptySafe(request.getDescription())) {
    props[properties.DESCRIPTION] = request.getDescription();
  }

  if (goog.isDefAndNotNull(request.getStarred())) {
    labels[drive.ds.sync.mutate.ResourceParamBuilder.Labels_.STARRED] =
        request.getStarred();
  }

  if (goog.isDefAndNotNull(request.getTrashed())) {
    labels[drive.ds.sync.mutate.ResourceParamBuilder.Labels_.TRASHED] =
        request.getTrashed();
  }

  if (!goog.string.isEmptySafe(request.getMimeType())) {
    props[properties.MIME_TYPE] = request.getMimeType();
  }

  if (goog.isNumber(request.getModifiedDateMillis())) {
    props[properties.MODIFIED_DATE] =
        apps.time.format3339(apps.time.DateTime.fromUtc(
            request.getModifiedDateMillis() || 0));
  }

  if (goog.object.getCount(labels)) {
    props[properties.LABELS] = labels;
  }

  drive.ds.sync.mutate.ResourceParamBuilder.addParents(
      props, request.getParentList());

  return props;
};


/**
 * Builds a resource parameter for performing an update revision request against
 * Genoa.
 * @param {!drive.ds.UpdateRevisionRequest} request The update item request.
 * @return {!Object.<string, boolean>} A resource parameter for an update
 *     revision request.
 */
drive.ds.sync.mutate.ResourceParamBuilder.fromUpdateRevision =
    function(request) {
  var properties = drive.ds.sync.mutate.ResourceParamBuilder.Properties_;
  var props = {};

  if (goog.isDefAndNotNull(request.getPinned())) {
    props[properties.PINNED] = request.getPinned();
  }

  return props;
};


/**
 * List of proerty names allowed in the Resource param.
 * @enum {string}
 * @private
 */
drive.ds.sync.mutate.ResourceParamBuilder.Properties_ = {
  DESCRIPTION: 'description',
  ID: 'id',
  LABELS: 'labels',
  MODIFIED_DATE: 'modifiedDate',
  MIME_TYPE: 'mimeType',
  PARENTS: 'parents',
  PINNED: 'pinned',
  TITLE: 'title'
};


/**
 * List of label names allowed in the labels for the Resource param.
 * @enum {string}
 * @private
 */
drive.ds.sync.mutate.ResourceParamBuilder.Labels_ = {
  STARRED: 'starred',
  TRASHED: 'trashed'
};

//javascript/apps/drive/dataservice/sync/api/mutate.js
/**
 * @fileoverview Helper that takes a mutate item request, creates a Genoa
 * request, and executes it.
 */

goog.provide('drive.ds.sync.api.Mutate');

goog.require('drive.ds.sync.Field');
goog.require('drive.ds.sync.api.Params');
goog.require('drive.ds.sync.api.RequestManager');
goog.require('drive.ds.sync.mutate.ResourceParamBuilder');
goog.require('drive.ds.sync.stat.RequestType');


/**
 * Sends a copy request to Genoa.
 * @param {!drive.ds.CopyItemRequest} request The copy item request.
 * @param {!function(!goog.async.Deferred, !Object)} responseHandler The Genoa
 *     response handler.
 * @param {!Array.<!drive.ds.Field>} fields The list of fields to get in Genoa
 *     response.
 */
drive.ds.sync.api.Mutate.copy = function(request, responseHandler, fields) {
  var params = {};
  params[drive.ds.sync.api.Params.Request.FILE_ID] = request.getId();
  params[drive.ds.sync.api.Params.Request.RESOURCE] =
      drive.ds.sync.mutate.ResourceParamBuilder.fromCopy(request);
  params[drive.ds.sync.api.Params.Request.FIELDS] =
      drive.ds.sync.Field.toFileFieldString(fields);

  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Mutate.createCopyMethod_,
      params, responseHandler, drive.ds.sync.stat.RequestType.MUTATE);
};


/**
 * Sends a create request to Genoa.
 * @param {!drive.ds.CreateItemRequest} request The create item request.
 * @param {!function(!goog.async.Deferred, !Object)} responseHandler The Genoa
 *     response handler.
 * @param {!Array.<!drive.ds.Field>} fields The list of fields to get in Genoa
 *     response.
 */
drive.ds.sync.api.Mutate.create = function(
    request, responseHandler, fields) {
  var params = {};
  params[drive.ds.sync.api.Params.Request.RESOURCE] =
      drive.ds.sync.mutate.ResourceParamBuilder.fromCreate(request);
  params[drive.ds.sync.api.Params.Request.FIELDS] =
      drive.ds.sync.Field.toFileFieldString(fields);

  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Mutate.createCreateMethod_,
      params, responseHandler, drive.ds.sync.stat.RequestType.MUTATE);
};


/**
 * Sends a delete request to Genoa.
 * @param {!drive.ds.DeleteItemRequest} request The delete item request.
 * @param {!function(!goog.async.Deferred, !Object)} responseHandler The Genoa
 *     response handler.
 */
drive.ds.sync.api.Mutate.deleteItem = function(request, responseHandler) {
  var params = {};
  params[drive.ds.sync.api.Params.Request.FILE_ID] = request.getId();

  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Mutate.createDeleteItemMethod_,
      params, responseHandler, drive.ds.sync.stat.RequestType.MUTATE);
};


/**
 * Sends an empty trash request to Genoa.
 * @param {!drive.ds.EmptyTrashRequest} request The delete item request.
 * @param {!function(!goog.async.Deferred, !Object)} responseHandler The Genoa
 *     response handler.
 */
drive.ds.sync.api.Mutate.emptyTrash = function(request, responseHandler) {
  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Mutate.createEmptyTrashMethod_,
      {}, responseHandler, drive.ds.sync.stat.RequestType.MUTATE);
};


/**
 * Sends an update request to Genoa.
 * @param {!drive.ds.UpdateItemRequest} request The update item request.
 * @param {!function(!goog.async.Deferred, !Object)} responseHandler The Genoa
 *     response handler.
 * @param {!Array.<!drive.ds.Field>} fields The list of fields to get in Genoa
 *     response.
 */
drive.ds.sync.api.Mutate.update = function(request, responseHandler, fields) {
  var params = {};
  params[drive.ds.sync.api.Params.Request.FILE_ID] = request.getId();
  params[drive.ds.sync.api.Params.Request.RESOURCE] =
      drive.ds.sync.mutate.ResourceParamBuilder.fromUpdate(request);
  params[drive.ds.sync.api.Params.Request.FIELDS] =
      drive.ds.sync.Field.toFileFieldString(fields);
  if (request.getParentsToAddList().length) {
    params[drive.ds.sync.api.Params.Request.ADD_PARENTS] =
        request.getParentsToAddList().join(',');
  }
  if (request.getParentsToRemoveList().length) {
    params[drive.ds.sync.api.Params.Request.REMOVE_PARENTS] =
        request.getParentsToRemoveList().join(',');
  }

  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Mutate.createUpdateMethod_,
      params, responseHandler, drive.ds.sync.stat.RequestType.MUTATE);
};


/**
 * Sends an update revision request to Genoa.
 * @param {!drive.ds.UpdateRevisionRequest} request The update item request.
 * @param {!function(!goog.async.Deferred, !Object)} responseHandler The Genoa
 *     response handler.
 */
drive.ds.sync.api.Mutate.updateRevision = function(request, responseHandler) {
  var params = {};
  params[drive.ds.sync.api.Params.Request.FILE_ID] = request.getItemId();
  params[drive.ds.sync.api.Params.Request.REVISION_ID] =
      request.getRevisionId();
  params[drive.ds.sync.api.Params.Request.RESOURCE] =
      drive.ds.sync.mutate.ResourceParamBuilder.fromUpdateRevision(request);

  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Mutate.createUpdateRevisionMethod_,
      params, responseHandler, drive.ds.sync.stat.RequestType.MUTATE);
};


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for a copy mutation.
 * @private
 */
drive.ds.sync.api.Mutate.createCopyMethod_ = function() {
  return gapi.client.drive.files.copy;
};


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for a create mutation.
 * @private
 */
drive.ds.sync.api.Mutate.createCreateMethod_ = function() {
  return gapi.client.drive.files.insert;
};


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for a delete item mutation.
 * @private
 */
drive.ds.sync.api.Mutate.createDeleteItemMethod_ = function() {
  // Note: Not very elegent, but recommended solution for getting around
  // javascript reserved 'delete' keyword.
  return gapi.client.drive.files['delete'];
};


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for an empty trash mutation.
 * @private
 */
drive.ds.sync.api.Mutate.createEmptyTrashMethod_ = function() {
  // TODO(towong): Remove literal 'emptyTrash' once Tesla fully moves to using
  // generated Genoa externs.
  return gapi.client.drive.files['emptyTrash'];
};


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for an update mutation.
 * @private
 */
drive.ds.sync.api.Mutate.createUpdateMethod_ = function() {
  return gapi.client.drive.files.update;
};


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for an update revision mutation.
 * @private
 */
drive.ds.sync.api.Mutate.createUpdateRevisionMethod_ = function() {
  return gapi.client.drive.revisions.update;
};

//javascript/apps/drive/dataservice/sync/api/permissions.js
/**
 * @fileoverview Helper that fetches permissions data for a given item via
 * Genoa.
 */

goog.provide('drive.ds.sync.api.Permissions');

goog.require('drive.ds.sync.api.Params');
goog.require('drive.ds.sync.api.RequestManager');
goog.require('drive.ds.sync.stat.RequestType');


/**
 * Gets the list of permissions the user has for a specific file.
 * @param {string} itemId The item id to fetch permissions for.
 * @param {!Function} responseHandler The response handler to call.
 */
drive.ds.sync.api.Permissions.list = function(itemId, responseHandler) {
  var params = {};
  params[drive.ds.sync.api.Params.Request.FILE_ID] = itemId;
  params[drive.ds.sync.api.Params.Request.FIELDS] =
      drive.ds.sync.api.Permissions.FIELDS_;

  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Permissions.createListMethod_,
      params, responseHandler, drive.ds.sync.stat.RequestType.PERMISSIONS);
};


/** @private {string} List of fields to fetch when requesting permissions. */
drive.ds.sync.api.Permissions.FIELDS_ =
    'kind,items(kind,type,id,name,withLink,photoLink,role)';


/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for a list of permissions.
 * @private
 */
drive.ds.sync.api.Permissions.createListMethod_ = function() {
  return gapi.client.drive.permissions.list;
};

//javascript/apps/drive/dataservice/sync/api/revisions.js
/**
 * @fileoverview Helper that takes a ListRevisionsRequest, generates a
 * Genoa revisions query, and executes it.
 */

goog.provide('drive.ds.sync.api.Revisions');

goog.require('drive.ds.sync.api.Params');
goog.require('drive.ds.sync.api.RequestManager');
goog.require('drive.ds.sync.stat.RequestType');


/**
 * Gets the list of revisions the user has for a specific file.
 * @param {!drive.ds.ListRevisionsRequest} request The revisions request.
 * @param {!Function} responseHandler The response handler to call.
 */
drive.ds.sync.api.Revisions.list = function(request, responseHandler) {
  var params = {};
  params[drive.ds.sync.api.Params.Request.FILE_ID] = request.getItemId();

  drive.ds.sync.api.RequestManager.getInstance().enqueueRequest(
      drive.ds.sync.api.Revisions.createListMethod_,
      params, responseHandler, drive.ds.sync.stat.RequestType.REVISIONS);
};

/**
 * @return {!function(!Object)} A function that queries genoa with a set of
 *     parameters for a list of revisions.
 * @private
 */
drive.ds.sync.api.Revisions.createListMethod_ = function() {
  return gapi.client.drive.revisions.list;
};

//javascript/closure/math/exponentialbackoff.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * @fileoverview Utility class to manage the mathematics behind computing an
 * exponential backoff model.  Given an initial backoff value and a maximum
 * backoff value, every call to backoff() will double the value until maximum
 * backoff value is reached.
 *
 * @author rjfioravanti@google.com (Ryan Fioravanti)
 * @author dominicl@google.com (Dominic Leung)
 */


goog.provide('goog.math.ExponentialBackoff');

goog.require('goog.asserts');



/**
 * @constructor
 *
 * @param {number} initialValue The initial backoff value.
 * @param {number} maxValue The maximum backoff value.
 */
goog.math.ExponentialBackoff = function(initialValue, maxValue) {
  goog.asserts.assert(initialValue > 0,
      'Initial value must be greater than zero.');
  goog.asserts.assert(maxValue >= initialValue,
      'Max value should be at least as large as initial value.');

  /**
   * @type {number}
   * @private
   */
  this.initialValue_ = initialValue;

  /**
   * @type {number}
   * @private
   */
  this.maxValue_ = maxValue;

  /**
   * The current backoff value.
   * @type {number}
   * @private
   */
  this.currValue_ = initialValue;
};


/**
 * The number of backoffs that have happened.
 * @type {number}
 * @private
 */
goog.math.ExponentialBackoff.prototype.currCount_ = 0;


/**
 * Resets the backoff value to its initial value.
 */
goog.math.ExponentialBackoff.prototype.reset = function() {
  this.currValue_ = this.initialValue_;
  this.currCount_ = 0;
};


/**
 * @return {number} The current backoff value.
 */
goog.math.ExponentialBackoff.prototype.getValue = function() {
  return this.currValue_;
};


/**
 * @return {number} The number of times this class has backed off.
 */
goog.math.ExponentialBackoff.prototype.getBackoffCount = function() {
  return this.currCount_;
};


/**
 * Initiates a backoff.
 */
goog.math.ExponentialBackoff.prototype.backoff = function() {
  this.currValue_ = Math.min(this.maxValue_, this.currValue_ * 2);
  this.currCount_++;
};

//javascript/apps/drive/dataservice/sync/exponentialbackoff.js
goog.provide('drive.ds.sync.ExponentialBackoff');

goog.require('goog.math.ExponentialBackoff');



/**
 * Wrapper around the {@code goog.math.ExponentialBackoff} with common
 * dataservice settings. Get value returns a number in milliseconds.
 * @extends {goog.math.ExponentialBackoff}
 * @constructor
 */
drive.ds.sync.ExponentialBackoff = function() {
  goog.base(this,
      drive.ds.sync.ExponentialBackoff.INITIAL_VALUE_,
      drive.ds.sync.ExponentialBackoff.MAXIMUM_VALUE_);
};
goog.inherits(drive.ds.sync.ExponentialBackoff, goog.math.ExponentialBackoff);


/**
 * Initial retry time in ms.
 * @private {number}
 */
drive.ds.sync.ExponentialBackoff.INITIAL_VALUE_ = 500;


/**
 * Maximum retry time in ms.
 * @private {number}
 */
drive.ds.sync.ExponentialBackoff.MAXIMUM_VALUE_ = 600000;

//javascript/apps/drive/dataservice/sync/cache/appsettingscache.js
goog.provide('drive.ds.sync.cache.AppSettingsCache');

goog.require('drive.ds.sync.ExponentialBackoff');
goog.require('drive.ds.sync.api.Apps');
goog.require('goog.events');
goog.require('goog.events.EventTarget');



/**
 * An abstract class representing a cache for drive applications that a user has
 * installed.
 * TODO(towong): Provide openUrl/iconUrls to support cellodex.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.cache.AppSettingsCache = function(context) {
  goog.base(this);

  /** @private {boolean} Whether the cache has been initialized. */
  this.initialized_ = false;

  /** @private {!drive.ds.sync.Context} */
  this.context_ = context;

  /** @private {!drive.ds.sync.ExponentialBackoff} */
  this.nextRetry_ = new drive.ds.sync.ExponentialBackoff();
};
goog.inherits(drive.ds.sync.cache.AppSettingsCache, goog.events.EventTarget);


/**
 * App settings cache related event types.
 * @enum {string}
 */
drive.ds.sync.cache.AppSettingsCache.EventType = {
  INITIALIZED: goog.events.getUniqueId('initialized')
};


/**
 * Initialized the apps cache. By default this queries Genoa for the latest apps
 * listing, implementations can overide this as needed (eg. load from IndexDB
 * cache).
 */
drive.ds.sync.cache.AppSettingsCache.prototype.initialize = function() {
  this.loadFromApi();
};


/**
 * Queries Genoa for the latest apps listing.
 * TODO(towong): Need some way to detect apps list update to refresh the apps.
 * @protected
 */
drive.ds.sync.cache.AppSettingsCache.prototype.loadFromApi = function() {
  drive.ds.sync.api.Apps.list(goog.bind(this.handleResponse_, this));
};


/**
 * Handles a response for an apps request.
 * @param {!Object} response The response from the drive api.
 * @private
 */
drive.ds.sync.cache.AppSettingsCache.prototype.handleResponse_ =
    function(response) {
  var appList = this.context_.getResponseParser().parseApps(response);
  appList.length ? this.handleAppSettingsLoaded_(appList) :
      this.handleAppSettingsError_();
};


/**
 * Handles updating the latest set of apps.
 * @param {!Array.<!drive.ds.App>} appsList A list of drive apps.
 * @private
 */
drive.ds.sync.cache.AppSettingsCache.prototype.handleAppSettingsLoaded_ =
    function(appsList) {
  for (var i = 0; i < appsList.length; i++) {
    this.put(appsList[i]);
  }

  this.setInitialized();
};


/**
 * Handles an error on loading the latest set of apps.
 * @private
 */
drive.ds.sync.cache.AppSettingsCache.prototype.handleAppSettingsError_ =
    function() {
  this.nextRetry_.backoff();
  goog.global.setTimeout(goog.bind(this.loadFromApi, this),
      this.nextRetry_.getValue());
};


/**
 * Marks the cache as initialized.
 */
drive.ds.sync.cache.AppSettingsCache.prototype.setInitialized = function() {
  this.initialized_ = true;
  this.dispatchEvent(
      drive.ds.sync.cache.AppSettingsCache.EventType.INITIALIZED);
};


/**
 * @return {boolean} Whether this cache has been initialized.
 */
drive.ds.sync.cache.AppSettingsCache.prototype.getInitialized = function() {
  return this.initialized_;
};


/**
 * Retrieves a list of current user's drive apps.
 * @return {!drive.ds.AppSettingsResponse} The app settings.
 */
drive.ds.sync.cache.AppSettingsCache.prototype.getApps = goog.abstractMethod;


/**
 * Puts an app into the app cache.
 * @param {!drive.ds.App} app The application to put into the cache.
 * @protected
 */
drive.ds.sync.cache.AppSettingsCache.prototype.put = goog.abstractMethod;


/**
 * Removes an app from the app cache.
 * @param {string} id The app id of the app to remove from the cache.
 * @protected
 */
drive.ds.sync.cache.AppSettingsCache.prototype.remove = goog.abstractMethod;

//javascript/apps/drive/dataservice/sync/cache/inmemoryappsettingscache.js
goog.provide('drive.ds.sync.cache.InMemoryAppSettingsCache');

goog.require('drive.ds.AppSettingsResponse');
goog.require('drive.ds.Status');
goog.require('drive.ds.sync.cache.AppSettingsCache');
goog.require('drive.ds.sync.stat.StatMonitor');
goog.require('goog.object');



/**
 * An in-memory cache of drive apps.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.cache.AppSettingsCache}
 * @constructor
 */
drive.ds.sync.cache.InMemoryAppSettingsCache = function(context) {
  goog.base(this, context);

  /** @private {!Object.<string, drive.ds.App>} */
  this.apps_ = {};

  drive.ds.sync.stat.StatMonitor.getInstance().registerMap(
      'Cached Apps', this.apps_);
};
goog.inherits(drive.ds.sync.cache.InMemoryAppSettingsCache,
    drive.ds.sync.cache.AppSettingsCache);


/** @override */
drive.ds.sync.cache.InMemoryAppSettingsCache.prototype.getApps = function() {
  // TODO(towong): Add error handling?
  var result = new drive.ds.AppSettingsResponse();

  result.setStatus(drive.ds.Status.SUCCESS);
  var appsList = [];
  goog.object.forEach(this.apps_, function(app) {
    if (app) {
      appsList.push(app);
    }
  });
  result.setAppList(appsList);

  return result;
};


/** @override */
drive.ds.sync.cache.InMemoryAppSettingsCache.prototype.put = function(app) {
  this.apps_[app.getId()] = app.cloneMessage();
};


/** @override */
drive.ds.sync.cache.InMemoryAppSettingsCache.prototype.remove = function(id) {
  goog.object.remove(this.apps_, id);
};

//javascript/closure/events/eventhandler.js
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Class to create objects which want to handle multiple events
 * and have their listeners easily cleaned up via a dispose method.
 *
 * Example:
 * <pre>
 * function Something() {
 *   goog.base(this);
 *
 *   ... set up object ...
 *
 *   // Add event listeners
 *   this.listen(this.starEl, goog.events.EventType.CLICK, this.handleStar);
 *   this.listen(this.headerEl, goog.events.EventType.CLICK, this.expand);
 *   this.listen(this.collapseEl, goog.events.EventType.CLICK, this.collapse);
 *   this.listen(this.infoEl, goog.events.EventType.MOUSEOVER, this.showHover);
 *   this.listen(this.infoEl, goog.events.EventType.MOUSEOUT, this.hideHover);
 * }
 * goog.inherits(Something, goog.events.EventHandler);
 *
 * Something.prototype.disposeInternal = function() {
 *   goog.base(this, 'disposeInternal');
 *   goog.dom.removeNode(this.container);
 * };
 *
 *
 * // Then elsewhere:
 *
 * var activeSomething = null;
 * function openSomething() {
 *   activeSomething = new Something();
 * }
 *
 * function closeSomething() {
 *   if (activeSomething) {
 *     activeSomething.dispose();  // Remove event listeners
 *     activeSomething = null;
 *   }
 * }
 * </pre>
 *
 * @author pupius@google.com (Daniel Pupius)
 */

goog.provide('goog.events.EventHandler');

goog.require('goog.Disposable');
goog.require('goog.events');
goog.require('goog.object');



/**
 * Super class for objects that want to easily manage a number of event
 * listeners.  It allows a short cut to listen and also provides a quick way
 * to remove all events listeners belonging to this object.
 * @param {SCOPE=} opt_scope Object in whose scope to call the listeners.
 * @constructor
 * @extends {goog.Disposable}
 * @template SCOPE
 */
goog.events.EventHandler = function(opt_scope) {
  goog.Disposable.call(this);
  // TODO(mknichel): Rename this to this.scope_ and fix the classes in google3
  // that access this private variable. :(
  this.handler_ = opt_scope;

  /**
   * Keys for events that are being listened to.
   * @type {!Object.<!goog.events.Key>}
   * @private
   */
  this.keys_ = {};
};
goog.inherits(goog.events.EventHandler, goog.Disposable);


/**
 * Utility array used to unify the cases of listening for an array of types
 * and listening for a single event, without using recursion or allocating
 * an array each time.
 * @type {Array.<string>}
 * @private
 */
goog.events.EventHandler.typeArray_ = [];


/**
 * Listen to an event on a Listenable.  If the function is omitted then the
 * EventHandler's handleEvent method will be used.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(this:SCOPE, ?):?|{handleEvent:function(?):?}|null=} opt_fn
 *    Optional callback function to be used as the listener or an object with
 *    handleEvent function.
 * @param {boolean=} opt_capture Optional whether to use capture phase.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 */
goog.events.EventHandler.prototype.listen = function(
    src, type, opt_fn, opt_capture) {
  return this.listen_(src, type, opt_fn, opt_capture);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted then the
 * EventHandler's handleEvent method will be used.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(this:T, ?):?|{handleEvent:function(this:T, ?):?}|
 *     null|undefined} fn Optional callback function to be used as the
 *     listener or an object with handleEvent function.
 * @param {boolean|undefined} capture Optional whether to use capture phase.
 * @param {T} scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @template T
 */
goog.events.EventHandler.prototype.listenWithScope = function(
    src, type, fn, capture, scope) {
  // TODO(mknichel): Deprecate this function.
  return this.listen_(src, type, fn, capture, scope);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted then the
 * EventHandler's handleEvent method will be used.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(?):?|{handleEvent:function(?):?}|null=} opt_fn Optional
 *     callback function to be used as the listener or an object with
 *     handleEvent function.
 * @param {boolean=} opt_capture Optional whether to use capture phase.
 * @param {Object=} opt_scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @private
 */
goog.events.EventHandler.prototype.listen_ = function(src, type, opt_fn,
                                                      opt_capture,
                                                      opt_scope) {
  if (!goog.isArray(type)) {
    goog.events.EventHandler.typeArray_[0] = /** @type {string} */(type);
    type = goog.events.EventHandler.typeArray_;
  }
  for (var i = 0; i < type.length; i++) {
    var listenerObj = goog.events.listen(
        src, type[i], opt_fn || this.handleEvent,
        opt_capture || false,
        opt_scope || this.handler_ || this);

    if (!listenerObj) {
      // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT
      // (goog.events.CaptureSimulationMode) in IE8-, it will return null
      // value.
      return this;
    }

    var key = listenerObj.key;
    this.keys_[key] = listenerObj;
  }

  return this;
};


/**
 * Listen to an event on a Listenable.  If the function is omitted, then the
 * EventHandler's handleEvent method will be used. After the event has fired the
 * event listener is removed from the target. If an array of event types is
 * provided, each event type will be listened to once.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(this:SCOPE, ?):?|{handleEvent:function(?):?}|null=} opt_fn
 *    Optional callback function to be used as the listener or an object with
 *    handleEvent function.
 * @param {boolean=} opt_capture Optional whether to use capture phase.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 */
goog.events.EventHandler.prototype.listenOnce = function(
    src, type, opt_fn, opt_capture) {
  // TODO(mknichel): Remove the opt_scope from this function and then
  // templatize it.
  return this.listenOnce_(src, type, opt_fn, opt_capture);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted, then the
 * EventHandler's handleEvent method will be used. After the event has fired the
 * event listener is removed from the target. If an array of event types is
 * provided, each event type will be listened to once.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(this:T, ?):?|{handleEvent:function(this:T, ?):?}|
 *     null|undefined} fn Optional callback function to be used as the
 *     listener or an object with handleEvent function.
 * @param {boolean|undefined} capture Optional whether to use capture phase.
 * @param {T} scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @template T
 */
goog.events.EventHandler.prototype.listenOnceWithScope = function(
    src, type, fn, capture, scope) {
  // TODO(mknichel): Deprecate this function.
  return this.listenOnce_(src, type, fn, capture, scope);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted, then the
 * EventHandler's handleEvent method will be used. After the event has fired
 * the event listener is removed from the target. If an array of event types is
 * provided, each event type will be listened to once.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for or array of
 *     event types.
 * @param {function(?):?|{handleEvent:function(?):?}|null=} opt_fn Optional
 *    callback function to be used as the listener or an object with
 *    handleEvent function.
 * @param {boolean=} opt_capture Optional whether to use capture phase.
 * @param {Object=} opt_scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @private
 */
goog.events.EventHandler.prototype.listenOnce_ = function(
    src, type, opt_fn, opt_capture, opt_scope) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      this.listenOnce_(src, type[i], opt_fn, opt_capture, opt_scope);
    }
  } else {
    var listenerObj = goog.events.listenOnce(
        src, type, opt_fn || this.handleEvent, opt_capture,
        opt_scope || this.handler_ || this);
    if (!listenerObj) {
      // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT
      // (goog.events.CaptureSimulationMode) in IE8-, it will return null
      // value.
      return this;
    }

    var key = listenerObj.key;
    this.keys_[key] = listenerObj;
  }

  return this;
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.EventTarget}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.EventTarget} src The node to listen to
 *     events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(this:SCOPE, ?):?|{handleEvent:function(?):?}|null} listener
 *     Callback method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 */
goog.events.EventHandler.prototype.listenWithWrapper = function(
    src, wrapper, listener, opt_capt) {
  // TODO(mknichel): Remove the opt_scope from this function and then
  // templatize it.
  return this.listenWithWrapper_(src, wrapper, listener, opt_capt);
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.EventTarget}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.EventTarget} src The node to listen to
 *     events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(this:T, ?):?|{handleEvent:function(this:T, ?):?}|null}
 *     listener Optional callback function to be used as the
 *     listener or an object with handleEvent function.
 * @param {boolean|undefined} capture Optional whether to use capture phase.
 * @param {T} scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @template T
 */
goog.events.EventHandler.prototype.listenWithWrapperAndScope = function(
    src, wrapper, listener, capture, scope) {
  // TODO(mknichel): Deprecate this function.
  return this.listenWithWrapper_(src, wrapper, listener, capture, scope);
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.EventTarget}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.EventTarget} src The node to listen to
 *     events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener Callback
 *     method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {Object=} opt_scope Element in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 * @private
 */
goog.events.EventHandler.prototype.listenWithWrapper_ = function(
    src, wrapper, listener, opt_capt, opt_scope) {
  wrapper.listen(src, listener, opt_capt, opt_scope || this.handler_ || this,
                 this);
  return this;
};


/**
 * @return {number} Number of listeners registered by this handler.
 */
goog.events.EventHandler.prototype.getListenerCount = function() {
  var count = 0;
  for (var key in this.keys_) {
    if (Object.prototype.hasOwnProperty.call(this.keys_, key)) {
      count++;
    }
  }
  return count;
};


/**
 * Unlistens on an event.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array.<string>} type Event type to listen for.
 * @param {function(?):?|{handleEvent:function(?):?}|null=} opt_fn Optional
 *    callback function to be used as the listener or an object with
 *    handleEvent function.
 * @param {boolean=} opt_capture Optional whether to use capture phase.
 * @param {Object=} opt_scope Object in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 */
goog.events.EventHandler.prototype.unlisten = function(src, type, opt_fn,
                                                       opt_capture,
                                                       opt_scope) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      this.unlisten(src, type[i], opt_fn, opt_capture, opt_scope);
    }
  } else {
    var listener = goog.events.getListener(src, type,
        opt_fn || this.handleEvent,
        opt_capture, opt_scope || this.handler_ || this);

    if (listener) {
      goog.events.unlistenByKey(listener);
      delete this.keys_[listener.key];
    }
  }

  return this;
};


/**
 * Removes an event listener which was added with listenWithWrapper().
 *
 * @param {EventTarget|goog.events.EventTarget} src The target to stop
 *     listening to events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to remove.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase of the
 *     event.
 * @param {Object=} opt_scope Element in whose scope to call the listener.
 * @return {goog.events.EventHandler} This object, allowing for chaining of
 *     calls.
 */
goog.events.EventHandler.prototype.unlistenWithWrapper = function(src, wrapper,
    listener, opt_capt, opt_scope) {
  wrapper.unlisten(src, listener, opt_capt,
                   opt_scope || this.handler_ || this, this);
  return this;
};


/**
 * Unlistens to all events.
 */
goog.events.EventHandler.prototype.removeAll = function() {
  goog.object.forEach(this.keys_, goog.events.unlistenByKey);
  this.keys_ = {};
};


/**
 * Disposes of this EventHandler and removes all listeners that it registered.
 * @override
 * @protected
 */
goog.events.EventHandler.prototype.disposeInternal = function() {
  goog.events.EventHandler.superClass_.disposeInternal.call(this);
  this.removeAll();
};


/**
 * Default event handler
 * @param {goog.events.Event} e Event object.
 */
goog.events.EventHandler.prototype.handleEvent = function(e) {
  throw Error('EventHandler.handleEvent not implemented');
};

//javascript/apps/drive/dataservice/sync/appsettings/appsettingsmanager.js
goog.provide('drive.ds.sync.appsettings.AppSettingsManager');

goog.require('drive.ds.sync.CommandManager');
goog.require('drive.ds.sync.cache.AppSettingsCache');
goog.require('drive.ds.sync.cache.InMemoryAppSettingsCache');
goog.require('goog.events.EventHandler');



/**
 * An app settings manager responsible for maintaining a queue of pending app
 * settings requests that need to be processed.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.CommandManager.<undefined>}
 * @constructor
 */
drive.ds.sync.appsettings.AppSettingsManager = function(context) {
  goog.base(this);

  /** @private {!goog.events.EventHandler} */
  this.handler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.handler_);

  /** @private {!drive.ds.sync.cache.AppSettingsCache} */
  this.appSettingsCache_ =
      new drive.ds.sync.cache.InMemoryAppSettingsCache(context);
};
goog.inherits(drive.ds.sync.appsettings.AppSettingsManager,
    drive.ds.sync.CommandManager);


/**
 * Trigger app settings cache initialization.
 */
drive.ds.sync.appsettings.AppSettingsManager.prototype.initialize = function() {
  this.handler_.listenOnce(this.appSettingsCache_,
      drive.ds.sync.cache.AppSettingsCache.EventType.INITIALIZED,
      goog.bind(this.handleAppCacheInitialized_, this));

  this.appSettingsCache_.initialize();
};


/**
 * Handles app settings cache initialization completion.
 * @private
 */
drive.ds.sync.appsettings.AppSettingsManager.prototype.
    handleAppCacheInitialized_ = function() {
  this.markInitialized();
};


/** @override */
drive.ds.sync.appsettings.AppSettingsManager.prototype.processCommand =
    function(commandWrapper) {
  // Processes the app settings request.
  var deferred = commandWrapper.getDeferred();
  deferred.callback(this.appSettingsCache_.getApps());
};

//javascript/apps/drive/dataservice/sync/folderutil.js
goog.provide('drive.ds.sync.FolderUtil');


/**
 * @param {string} The mime type string for a folder.
 */
drive.ds.sync.FolderUtil.MIME_TYPE = 'application/vnd.google-apps.folder';


/**
 * Checks whether the given item is a folder.
 * TODO(towong): Note there are legacy folders that aren't labeled with the
 * correct mime type, investigate how to handle that.
 * @param {drive.ds.Item} item The item to check.
 * @return {boolean} Whether the item is a folder.
 */
drive.ds.sync.FolderUtil.isFolder = function(item) {
  return goog.isDefAndNotNull(item) ?
      item.getMimeType() == drive.ds.sync.FolderUtil.MIME_TYPE : false;
};

//javascript/closure/i18n/collation.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * @fileoverview Contains helper functions for performing locale-sensitive
 *     collation.
 * @author jchye@google.com (Jennifer Chye)
 */


goog.provide('goog.i18n.collation');


/**
 * Returns the comparator for a locale. If a locale is not explicitly specified,
 * a comparator for the user's locale will be returned. Note that if the browser
 * does not support locale-sensitive string comparisons, the comparator returned
 * will be a simple codepoint comparator.
 *
 * @param {string=} opt_locale the locale that the comparator is used for.
 * @return {function(string, string): number} The locale-specific comparator.
 */
goog.i18n.collation.createComparator = function(opt_locale) {
  // See http://code.google.com/p/v8-i18n.
  if (goog.i18n.collation.hasNativeComparator()) {
    var intl = goog.global.Intl;
    return new intl.Collator([opt_locale || goog.LOCALE]).compare;
  } else {
    return function(arg1, arg2) {
      return arg1.localeCompare(arg2);
    };
  }
};


/**
 * Returns true if a locale-sensitive comparator is available for a locale. If
 * a locale is not explicitly specified, the user's locale is used instead.
 *
 * @param {string=} opt_locale The locale to be checked.
 * @return {boolean} Whether there is a locale-sensitive comparator available
 *     for the locale.
 */
goog.i18n.collation.hasNativeComparator = function(opt_locale) {
  var intl = goog.global.Intl;
  return !!(intl && intl.Collator);
};

//javascript/closure/math/long.js
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines a Long class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "long". This
 * implementation is derived from LongLib in GWT.
 *
 * @author kevinz@google.com (Kevin Zatloukal)
 */

goog.provide('goog.math.Long');



/**
 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
 * values as *signed* integers.  See the from* functions below for more
 * convenient ways of constructing Longs.
 *
 * The internal representation of a long is the two given signed, 32-bit values.
 * We use 32-bit pieces because these are the size of integers on which
 * Javascript performs bit-operations.  For operations like addition and
 * multiplication, we split each number into 16-bit pieces, which can easily be
 * multiplied within Javascript's floating-point representation without overflow
 * or change in sign.
 *
 * In the algorithms below, we frequently reduce the negative case to the
 * positive case by negating the input(s) and then post-processing the result.
 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
 * a positive number, it overflows back into a negative).  Not handling this
 * case would often result in infinite recursion.
 *
 * @param {number} low  The low (signed) 32 bits of the long.
 * @param {number} high  The high (signed) 32 bits of the long.
 * @constructor
 * @final
 */
goog.math.Long = function(low, high) {
  /**
   * @type {number}
   * @private
   */
  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
};


// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
// from* methods on which they depend.


/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @private
 */
goog.math.Long.IntCache_ = {};


/**
 * Returns a Long representing the given (32-bit) integer value.
 * @param {number} value The 32-bit integer in question.
 * @return {!goog.math.Long} The corresponding Long value.
 */
goog.math.Long.fromInt = function(value) {
  if (-128 <= value && value < 128) {
    var cachedObj = goog.math.Long.IntCache_[value];
    if (cachedObj) {
      return cachedObj;
    }
  }

  var obj = new goog.math.Long(value | 0, value < 0 ? -1 : 0);
  if (-128 <= value && value < 128) {
    goog.math.Long.IntCache_[value] = obj;
  }
  return obj;
};


/**
 * Returns a Long representing the given value, provided that it is a finite
 * number.  Otherwise, zero is returned.
 * @param {number} value The number in question.
 * @return {!goog.math.Long} The corresponding Long value.
 */
goog.math.Long.fromNumber = function(value) {
  if (isNaN(value) || !isFinite(value)) {
    return goog.math.Long.ZERO;
  } else if (value <= -goog.math.Long.TWO_PWR_63_DBL_) {
    return goog.math.Long.MIN_VALUE;
  } else if (value + 1 >= goog.math.Long.TWO_PWR_63_DBL_) {
    return goog.math.Long.MAX_VALUE;
  } else if (value < 0) {
    return goog.math.Long.fromNumber(-value).negate();
  } else {
    return new goog.math.Long(
        (value % goog.math.Long.TWO_PWR_32_DBL_) | 0,
        (value / goog.math.Long.TWO_PWR_32_DBL_) | 0);
  }
};


/**
 * Returns a Long representing the 64-bit integer that comes by concatenating
 * the given high and low bits.  Each is assumed to use 32 bits.
 * @param {number} lowBits The low 32-bits.
 * @param {number} highBits The high 32-bits.
 * @return {!goog.math.Long} The corresponding Long value.
 */
goog.math.Long.fromBits = function(lowBits, highBits) {
  return new goog.math.Long(lowBits, highBits);
};


/**
 * Returns a Long representation of the given string, written using the given
 * radix.
 * @param {string} str The textual representation of the Long.
 * @param {number=} opt_radix The radix in which the text is written.
 * @return {!goog.math.Long} The corresponding Long value.
 */
goog.math.Long.fromString = function(str, opt_radix) {
  if (str.length == 0) {
    throw Error('number format error: empty string');
  }

  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (str.charAt(0) == '-') {
    return goog.math.Long.fromString(str.substring(1), radix).negate();
  } else if (str.indexOf('-') >= 0) {
    throw Error('number format error: interior "-" character: ' + str);
  }

  // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 8));

  var result = goog.math.Long.ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i);
    var value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = goog.math.Long.fromNumber(Math.pow(radix, size));
      result = result.multiply(power).add(goog.math.Long.fromNumber(value));
    } else {
      result = result.multiply(radixToPower);
      result = result.add(goog.math.Long.fromNumber(value));
    }
  }
  return result;
};


// NOTE: the compiler should inline these constant values below and then remove
// these variables, so there should be no runtime penalty for these.


/**
 * Number used repeated below in calculations.  This must appear before the
 * first call to any from* function below.
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_16_DBL_ = 1 << 16;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_24_DBL_ = 1 << 24;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_32_DBL_ =
    goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_31_DBL_ =
    goog.math.Long.TWO_PWR_32_DBL_ / 2;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_48_DBL_ =
    goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_64_DBL_ =
    goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_63_DBL_ =
    goog.math.Long.TWO_PWR_64_DBL_ / 2;


/** @type {!goog.math.Long} */
goog.math.Long.ZERO = goog.math.Long.fromInt(0);


/** @type {!goog.math.Long} */
goog.math.Long.ONE = goog.math.Long.fromInt(1);


/** @type {!goog.math.Long} */
goog.math.Long.NEG_ONE = goog.math.Long.fromInt(-1);


/** @type {!goog.math.Long} */
goog.math.Long.MAX_VALUE =
    goog.math.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);


/** @type {!goog.math.Long} */
goog.math.Long.MIN_VALUE = goog.math.Long.fromBits(0, 0x80000000 | 0);


/**
 * @type {!goog.math.Long}
 * @private
 */
goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(1 << 24);


/** @return {number} The value, assuming it is a 32-bit integer. */
goog.math.Long.prototype.toInt = function() {
  return this.low_;
};


/** @return {number} The closest floating-point representation to this value. */
goog.math.Long.prototype.toNumber = function() {
  return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned();
};


/**
 * @param {number=} opt_radix The radix in which the text should be written.
 * @return {string} The textual representation of this value.
 * @override
 */
goog.math.Long.prototype.toString = function(opt_radix) {
  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (this.isZero()) {
    return '0';
  }

  if (this.isNegative()) {
    if (this.equals(goog.math.Long.MIN_VALUE)) {
      // We need to change the Long value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixLong = goog.math.Long.fromNumber(radix);
      var div = this.div(radixLong);
      var rem = div.multiply(radixLong).subtract(this);
      return div.toString(radix) + rem.toInt().toString(radix);
    } else {
      return '-' + this.negate().toString(radix);
    }
  }

  // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 6));

  var rem = this;
  var result = '';
  while (true) {
    var remDiv = rem.div(radixToPower);
    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
    var digits = intval.toString(radix);

    rem = remDiv;
    if (rem.isZero()) {
      return digits + result;
    } else {
      while (digits.length < 6) {
        digits = '0' + digits;
      }
      result = '' + digits + result;
    }
  }
};


/** @return {number} The high 32-bits as a signed value. */
goog.math.Long.prototype.getHighBits = function() {
  return this.high_;
};


/** @return {number} The low 32-bits as a signed value. */
goog.math.Long.prototype.getLowBits = function() {
  return this.low_;
};


/** @return {number} The low 32-bits as an unsigned value. */
goog.math.Long.prototype.getLowBitsUnsigned = function() {
  return (this.low_ >= 0) ?
      this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
};


/**
 * @return {number} Returns the number of bits needed to represent the absolute
 *     value of this Long.
 */
goog.math.Long.prototype.getNumBitsAbs = function() {
  if (this.isNegative()) {
    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return 64;
    } else {
      return this.negate().getNumBitsAbs();
    }
  } else {
    var val = this.high_ != 0 ? this.high_ : this.low_;
    for (var bit = 31; bit > 0; bit--) {
      if ((val & (1 << bit)) != 0) {
        break;
      }
    }
    return this.high_ != 0 ? bit + 33 : bit + 1;
  }
};


/** @return {boolean} Whether this value is zero. */
goog.math.Long.prototype.isZero = function() {
  return this.high_ == 0 && this.low_ == 0;
};


/** @return {boolean} Whether this value is negative. */
goog.math.Long.prototype.isNegative = function() {
  return this.high_ < 0;
};


/** @return {boolean} Whether this value is odd. */
goog.math.Long.prototype.isOdd = function() {
  return (this.low_ & 1) == 1;
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long equals the other.
 */
goog.math.Long.prototype.equals = function(other) {
  return (this.high_ == other.high_) && (this.low_ == other.low_);
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long does not equal the other.
 */
goog.math.Long.prototype.notEquals = function(other) {
  return (this.high_ != other.high_) || (this.low_ != other.low_);
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long is less than the other.
 */
goog.math.Long.prototype.lessThan = function(other) {
  return this.compare(other) < 0;
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long is less than or equal to the other.
 */
goog.math.Long.prototype.lessThanOrEqual = function(other) {
  return this.compare(other) <= 0;
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long is greater than the other.
 */
goog.math.Long.prototype.greaterThan = function(other) {
  return this.compare(other) > 0;
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long is greater than or equal to the other.
 */
goog.math.Long.prototype.greaterThanOrEqual = function(other) {
  return this.compare(other) >= 0;
};


/**
 * Compares this Long with the given one.
 * @param {goog.math.Long} other Long to compare against.
 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
 *     if the given one is greater.
 */
goog.math.Long.prototype.compare = function(other) {
  if (this.equals(other)) {
    return 0;
  }

  var thisNeg = this.isNegative();
  var otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) {
    return -1;
  }
  if (!thisNeg && otherNeg) {
    return 1;
  }

  // at this point, the signs are the same, so subtraction will not overflow
  if (this.subtract(other).isNegative()) {
    return -1;
  } else {
    return 1;
  }
};


/** @return {!goog.math.Long} The negation of this value. */
goog.math.Long.prototype.negate = function() {
  if (this.equals(goog.math.Long.MIN_VALUE)) {
    return goog.math.Long.MIN_VALUE;
  } else {
    return this.not().add(goog.math.Long.ONE);
  }
};


/**
 * Returns the sum of this and the given Long.
 * @param {goog.math.Long} other Long to add to this one.
 * @return {!goog.math.Long} The sum of this and the given Long.
 */
goog.math.Long.prototype.add = function(other) {
  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};


/**
 * Returns the difference of this and the given Long.
 * @param {goog.math.Long} other Long to subtract from this.
 * @return {!goog.math.Long} The difference of this and the given Long.
 */
goog.math.Long.prototype.subtract = function(other) {
  return this.add(other.negate());
};


/**
 * Returns the product of this and the given long.
 * @param {goog.math.Long} other Long to multiply with this.
 * @return {!goog.math.Long} The product of this and the other.
 */
goog.math.Long.prototype.multiply = function(other) {
  if (this.isZero()) {
    return goog.math.Long.ZERO;
  } else if (other.isZero()) {
    return goog.math.Long.ZERO;
  }

  if (this.equals(goog.math.Long.MIN_VALUE)) {
    return other.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
  } else if (other.equals(goog.math.Long.MIN_VALUE)) {
    return this.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().multiply(other.negate());
    } else {
      return this.negate().multiply(other).negate();
    }
  } else if (other.isNegative()) {
    return this.multiply(other.negate()).negate();
  }

  // If both longs are small, use float multiplication
  if (this.lessThan(goog.math.Long.TWO_PWR_24_) &&
      other.lessThan(goog.math.Long.TWO_PWR_24_)) {
    return goog.math.Long.fromNumber(this.toNumber() * other.toNumber());
  }

  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};


/**
 * Returns this Long divided by the given one.
 * @param {goog.math.Long} other Long by which to divide.
 * @return {!goog.math.Long} This Long divided by the given one.
 */
goog.math.Long.prototype.div = function(other) {
  if (other.isZero()) {
    throw Error('division by zero');
  } else if (this.isZero()) {
    return goog.math.Long.ZERO;
  }

  if (this.equals(goog.math.Long.MIN_VALUE)) {
    if (other.equals(goog.math.Long.ONE) ||
        other.equals(goog.math.Long.NEG_ONE)) {
      return goog.math.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.ONE;
    } else {
      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
      var halfThis = this.shiftRight(1);
      var approx = halfThis.div(other).shiftLeft(1);
      if (approx.equals(goog.math.Long.ZERO)) {
        return other.isNegative() ? goog.math.Long.ONE : goog.math.Long.NEG_ONE;
      } else {
        var rem = this.subtract(other.multiply(approx));
        var result = approx.add(rem.div(other));
        return result;
      }
    }
  } else if (other.equals(goog.math.Long.MIN_VALUE)) {
    return goog.math.Long.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().div(other.negate());
    } else {
      return this.negate().div(other).negate();
    }
  } else if (other.isNegative()) {
    return this.div(other.negate()).negate();
  }

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  var res = goog.math.Long.ZERO;
  var rem = this;
  while (rem.greaterThanOrEqual(other)) {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

    // Decrease the approximation until it is smaller than the remainder.  Note
    // that if it is too large, the product overflows and is negative.
    var approxRes = goog.math.Long.fromNumber(approx);
    var approxRem = approxRes.multiply(other);
    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
      approx -= delta;
      approxRes = goog.math.Long.fromNumber(approx);
      approxRem = approxRes.multiply(other);
    }

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero()) {
      approxRes = goog.math.Long.ONE;
    }

    res = res.add(approxRes);
    rem = rem.subtract(approxRem);
  }
  return res;
};


/**
 * Returns this Long modulo the given one.
 * @param {goog.math.Long} other Long by which to mod.
 * @return {!goog.math.Long} This Long modulo the given one.
 */
goog.math.Long.prototype.modulo = function(other) {
  return this.subtract(this.div(other).multiply(other));
};


/** @return {!goog.math.Long} The bitwise-NOT of this value. */
goog.math.Long.prototype.not = function() {
  return goog.math.Long.fromBits(~this.low_, ~this.high_);
};


/**
 * Returns the bitwise-AND of this Long and the given one.
 * @param {goog.math.Long} other The Long with which to AND.
 * @return {!goog.math.Long} The bitwise-AND of this and the other.
 */
goog.math.Long.prototype.and = function(other) {
  return goog.math.Long.fromBits(this.low_ & other.low_,
                                 this.high_ & other.high_);
};


/**
 * Returns the bitwise-OR of this Long and the given one.
 * @param {goog.math.Long} other The Long with which to OR.
 * @return {!goog.math.Long} The bitwise-OR of this and the other.
 */
goog.math.Long.prototype.or = function(other) {
  return goog.math.Long.fromBits(this.low_ | other.low_,
                                 this.high_ | other.high_);
};


/**
 * Returns the bitwise-XOR of this Long and the given one.
 * @param {goog.math.Long} other The Long with which to XOR.
 * @return {!goog.math.Long} The bitwise-XOR of this and the other.
 */
goog.math.Long.prototype.xor = function(other) {
  return goog.math.Long.fromBits(this.low_ ^ other.low_,
                                 this.high_ ^ other.high_);
};


/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number} numBits The number of bits by which to shift.
 * @return {!goog.math.Long} This shifted to the left by the given amount.
 */
goog.math.Long.prototype.shiftLeft = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var low = this.low_;
    if (numBits < 32) {
      var high = this.high_;
      return goog.math.Long.fromBits(
          low << numBits,
          (high << numBits) | (low >>> (32 - numBits)));
    } else {
      return goog.math.Long.fromBits(0, low << (numBits - 32));
    }
  }
};


/**
 * Returns this Long with bits shifted to the right by the given amount.
 * @param {number} numBits The number of bits by which to shift.
 * @return {!goog.math.Long} This shifted to the right by the given amount.
 */
goog.math.Long.prototype.shiftRight = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits < 32) {
      var low = this.low_;
      return goog.math.Long.fromBits(
          (low >>> numBits) | (high << (32 - numBits)),
          high >> numBits);
    } else {
      return goog.math.Long.fromBits(
          high >> (numBits - 32),
          high >= 0 ? 0 : -1);
    }
  }
};


/**
 * Returns this Long with bits shifted to the right by the given amount, with
 * zeros placed into the new leading bits.
 * @param {number} numBits The number of bits by which to shift.
 * @return {!goog.math.Long} This shifted to the right by the given amount, with
 *     zeros placed into the new leading bits.
 */
goog.math.Long.prototype.shiftRightUnsigned = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits < 32) {
      var low = this.low_;
      return goog.math.Long.fromBits(
          (low >>> numBits) | (high << (32 - numBits)),
          high >>> numBits);
    } else if (numBits == 32) {
      return goog.math.Long.fromBits(high, 0);
    } else {
      return goog.math.Long.fromBits(high >>> (numBits - 32), 0);
    }
  }
};

//javascript/apps/drive/dataservice/sync/sort/itemsorter.js
goog.provide('drive.ds.sync.sort.ItemSorter');

goog.require('drive.ds.Field');
goog.require('drive.ds.SortSpec');
goog.require('drive.ds.sync.FolderUtil');
goog.require('goog.array');
goog.require('goog.i18n.collation');
goog.require('goog.math.Long');



/**
 * An item specific sorter.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item config.
 * @constructor
 */
drive.ds.sync.sort.ItemSorter = function(config) {
  /**
   * A locale-specific comparator function for performing locale based string
   * comparisons.
   * @private {function(string, string): number}
   */
  this.comparator_ = goog.i18n.collation.createComparator(config.getLocale());
};


/**
 * Gets the field to sort on based on the sort type.
 * @param {!drive.ds.SortSpec} sort The sort spec.
 * @return {?drive.ds.Field} The field to sort on, null if no field.
 */
drive.ds.sync.sort.ItemSorter.getFieldFromSort = function(sort) {
  var type = sort.getType();
  switch (type) {
    case drive.ds.SortSpec.Type.LAST_MODIFIED:
      return drive.ds.Field.MODIFIED_DATE_MILLIS;
    case drive.ds.SortSpec.Type.LAST_MODIFIED_BY_ME:
      return drive.ds.Field.MODIFIED_BY_ME_DATE_MILLIS;
    case drive.ds.SortSpec.Type.USER_QUOTA:
      return drive.ds.Field.QUOTA_BYTES_USED;
    case drive.ds.SortSpec.Type.TITLE:
      return drive.ds.Field.TITLE;
    case drive.ds.SortSpec.Type.LAST_VIEWED_BY_ME:
      return drive.ds.Field.LAST_VIEWED_BY_ME_DATE_MILLIS;
    case drive.ds.SortSpec.Type.SHARED_DATE:
      return drive.ds.Field.SHARED_WITH_ME_DATE_MILLIS;
    case drive.ds.SortSpec.Type.STARRED:
      return drive.ds.Field.STARRED;
    default:
      return null;
  }
};


/**
 * Sort the drive list on a particular sort spec.
 * TODO(towong): Plumb through relevance support once Genoa supports it.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!Array.<!drive.ds.Item>} items The list of matching items.
 */
drive.ds.sync.sort.ItemSorter.prototype.sort = function(request, items) {
  var sort = request.getSort();
  if (sort && drive.ds.sync.sort.ItemSorter.getFieldFromSort(sort)) {
    goog.array.sort(items, goog.bind(this.compare_, this, sort));
  }
};


/**
 * Compares two items based on the sort in the request.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item1 The first item.
 * @param {!drive.ds.Item} item2 The second item.
 * @return {number} A negative or positive number depending
 *     on if the first argument should come before or after the second.
 *     Returns zero if the two items are equal
 *     (or if there's nothing to sort by).
 */
drive.ds.sync.sort.ItemSorter.prototype.compare =
    function(request, item1, item2) {
  var sort = request.getSort();
  return sort && drive.ds.sync.sort.ItemSorter.getFieldFromSort(sort) ?
      this.compare_(sort, item1, item2) : 0;
};


/**
 * Comparator for performing a sort by field. Two special things are taken into
 * account. For matching fields, we secondary sort on ID.
 * @param {!drive.ds.SortSpec} sort The sort spec.
 * @param {!drive.ds.Item} item1 The first item.
 * @param {!drive.ds.Item} item2 The second item.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second. Inverted if
 *     we are performing descending sort.
 * @private
 */
drive.ds.sync.sort.ItemSorter.prototype.compare_ =
    function(sort, item1, item2) {
  var result = 0;

  var field = /** @type {!drive.ds.Field} */ (
      drive.ds.sync.sort.ItemSorter.getFieldFromSort(sort));
  var isAscending =
      drive.ds.SortSpec.Direction.ASCENDING == sort.getDirection();

  // Sort by folder first if requested, this moves folders to the top in both
  // ascending and descending mode.
  if (sort.getFoldersFirst()) {
    result = this.compareByFolder_(item1, item2);
    if (result != 0) {
      return result;
    }
  }

  // Sort by the field requested.
  result = this.compareByField_(field, item1, item2);

  // Sort by ID.
  if (result == 0) {
    result = this.compareByField_(drive.ds.Field.ID, item1, item2);
  }

  return isAscending ? result : result * -1;
};


/**
 * Compare two item by folder vs non-folder.
 * @param {!drive.ds.Item} item1 The first item.
 * @param {!drive.ds.Item} item2 The second item.
 * @return {number} A negative number, zero, or a positive number if the first
 *     item is a folder, the same type as the second item, or of type
 *     non-folder.
 * @private
 */
drive.ds.sync.sort.ItemSorter.prototype.compareByFolder_ =
    function(item1, item2) {
  var isFolder1 = drive.ds.sync.FolderUtil.isFolder(item1);
  var isFolder2 = drive.ds.sync.FolderUtil.isFolder(item2);
  return (isFolder1 == isFolder2 ? 0 : (isFolder1 ? -1 : 1));
};


/**
 * Compare two items by value.
 * @param {!drive.ds.Field} field The field to sort on.
 * @param {!drive.ds.Item} item1 The first item.
 * @param {!drive.ds.Item} item2 The second item.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 * @private
 */
drive.ds.sync.sort.ItemSorter.prototype.compareByField_ =
    function(field, item1, item2) {
  // TODO(towong): Make sure this matches the existing sort behavior:
  // java/com/google/apps/explorer/client/protocol/document.js&l=9
  var value1 = this.getValueForField_(field, item1);
  var value2 = this.getValueForField_(field, item2);

  if (field == drive.ds.Field.TITLE) {
    return this.comparator_(value1.toLowerCase(), value2.toLowerCase());
  } else if (value1 instanceof goog.math.Long &&
      value2 instanceof goog.math.Long) {
    return value1.compare(value2);
  } else {
    return goog.array.defaultCompare(value1, value2);
  }
};


/**
 * Gets the value of a particular field on the given item.
 * @param {!drive.ds.Field} field The field to extract.
 * @param {!drive.ds.Item} item The item to extract the field from.
 * @return {*} The value of the field from the drive item.
 * @private
 */
drive.ds.sync.sort.ItemSorter.prototype.getValueForField_ =
    function(field, item) {
  switch (field) {
    case drive.ds.Field.ID:
      return item.getId();
    case drive.ds.Field.MIME_TYPE:
      return item.getMimeType();
    case drive.ds.Field.STARRED:
      return item.getStarred();
    case drive.ds.Field.LAST_VIEWED_BY_ME_DATE_MILLIS:
      return item.getLastViewedByMeDateMillis() || 0;
    case drive.ds.Field.MODIFIED_BY_ME_DATE_MILLIS:
      return item.getModifiedByMeDateMillis() || 0;
    case drive.ds.Field.MODIFIED_DATE_MILLIS:
      return item.getModifiedDateMillis() || 0;
    case drive.ds.Field.TITLE:
      return item.getTitle();
    case drive.ds.Field.SHARED_WITH_ME_DATE_MILLIS:
      return item.getSharedWithMeDateMillis() || 0;
    case drive.ds.Field.QUOTA_BYTES_USED:
      return item.getQuotaBytesUsed();
    default:
      // Unsupported fields, currently just return blank string.
      return '';
  }
};

//javascript/apps/drive/dataservice/sync/cache/cache.js
goog.provide('drive.ds.sync.cache.Cache');

goog.require('drive.ds.DateSpec');
goog.require('drive.ds.TitleSpec');
goog.require('drive.ds.sync.Field');
goog.require('drive.ds.sync.sort.ItemSorter');
goog.require('goog.array');
goog.require('goog.debug.Logger');
goog.require('goog.events');
goog.require('goog.events.EventTarget');
goog.require('goog.string');



/**
 * An abstract class representing a cache for drive items. The cache batches
 * changes together and fires events to indicate that the cache has updated.
 * TODO(towong): Look into extracting/consolidating some of the common cache
 * logic from item, apps, user cache.
 * @param {!Array.<!drive.ds.Field>} fields The complete set of fields
 *     that the client could potentially need.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item config.
 * @param {!drive.ds.sync.cache.MetadataStore} metadataStore Metadata store for
 *     this cache.
 * @param {!drive.ds.sync.response.ResponseParser} responseParser The response
 *     parser.
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.cache.Cache = function(
    fields, config, metadataStore, responseParser) {
  goog.base(this);

  /**
   * The complete set of fields that the client could potentially need.
   * @private {!Array.<!drive.ds.Field>}
   */
  this.fields_ = fields;

  /**
   * Whether there are changes that we haven't published an event for.
   * @private {boolean}
   */
  this.changed_ = false;

  /**
   * Whether the cache has been initialized.
   * @private {boolean}
   */
  this.initialized_ = false;

  /** @private {!drive.ds.sync.sort.ItemSorter} */
  this.sorter_ = new drive.ds.sync.sort.ItemSorter(config);

  /** @private {!drive.ds.sync.cache.MetadataStore} */
  this.metadataStore_ = metadataStore;

  /** @protected {!drive.ds.sync.response.ResponseParser} */
  this.responseParser = responseParser;

  /** @private {!goog.debug.Logger} */
  this.logger_ = goog.debug.Logger.getLogger('drive.ds.sync.cache.Cache');

  /** @private {!drive.ds.sync.SyncedConfig} */
  this.config_ = config;
};
goog.inherits(drive.ds.sync.cache.Cache, goog.events.EventTarget);


/**
 * Cache related event types.
 * @enum {string}
 */
drive.ds.sync.cache.Cache.EventType = {
  CHANGED: goog.events.getUniqueId('changed'),
  INITIALIZED: goog.events.getUniqueId('initialized')
};


/**
 * The minimum amount of time between change event publishes.
 * @private
 */
drive.ds.sync.cache.Cache.BATCH_INTERVAL_MS_ = 500;


/**
 * Initializes the cache.
 */
drive.ds.sync.cache.Cache.prototype.initialize = goog.abstractMethod;


/**
 * Retrieves an item from the cache by id.
 * @param {!string} id The id to find.
 * @return {!goog.async.Deferred.<drive.ds.Item>}
 *     A deferred object that provides the item or null if not found.
 */
drive.ds.sync.cache.Cache.prototype.getById = goog.abstractMethod;


/**
 * Queries the cache. Returns a list of items that match the request with field
 * pruning and sorting applied.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {number} limit The desired number of items, -1 for all items.
 * @return {!goog.async.Deferred.<!drive.ds.ItemQueryResponse>}
 *     The query response.
 */
drive.ds.sync.cache.Cache.prototype.query = goog.abstractMethod;


/**
 * Queries the cache with a list of Drive IDs. Returns a list of items that
 * match the requested ids with field pruning and sorting applied.
 * @param {drive.ds.ItemQueryRequest} request The query request. Can be null.
 * @param {!Array.<string>} ids The list of ids.
 * @param {number} limit The desired number of items, -1 for all items.
 * @return {!goog.async.Deferred.<!drive.ds.ItemQueryResponse>}
 *     The query response.
 */
drive.ds.sync.cache.Cache.prototype.queryByIds = goog.abstractMethod;


/**
 * Exports a list of all the items in the cache.  No field pruning, sorting,
 * truncation, or optimized fields (ex. open url) are added to the items.
 * The items are NOT defensively cloned.
 * @return {!goog.async.Deferred.<!Array.<!drive.ds.Item>>} The deferred
 *     object that returns a list of items.
 */
drive.ds.sync.cache.Cache.prototype.bulkExport = goog.abstractMethod;


/**
 * Exports a list of all the permissions in the cache.
 * The permissions are NOT defensively cloned.
 * @return {!Array.<!drive.ds.Permission>} The list of permissions.
 */
drive.ds.sync.cache.Cache.prototype.bulkExportPermissions = goog.abstractMethod;


/**
 * Puts or overwrites items in the cache with the same id. A list of permissions
 * may be provided if the items have bare permissions (only permission id and
 * role set).
 * NOTE(ericzhang): This function assumes it can use the input Items
 * directly and does not do a clone for safety.  This speeds up the code
 * for large corpuses significantly.
 * @param {!Array.<!drive.ds.Item>} items The items to put into the cache.
 * @param {!Array.<!drive.ds.Permission>=} opt_permissions Optional permissions
 *     to import into the cache.
 * @return {!goog.async.Deferred} The deferred object to allow clients to
 *     wait for the operation to complete.
 */
drive.ds.sync.cache.Cache.prototype.bulkImport = goog.abstractMethod;


/**
 * Queues up a series of permissions to fetch from Genoa.
 * Note: This is a temporary hack until the Genoa files.list and changes.list
 * api can provide this information.
 * @param {!Array.<string>} ids The list of item ids to get permission for.
 */
drive.ds.sync.cache.Cache.prototype.requestPermissions = goog.abstractMethod;


/**
 * Puts or overwrites an item in the cache with the same id.
 * @param {!drive.ds.Item} item The item to put into the cache.
 * @return {!goog.async.Deferred} The deferred object to allow clients to
 *     wait for the operation to complete.
 */
drive.ds.sync.cache.Cache.prototype.put = goog.abstractMethod;


/**
 * Removes an item from the cache.
 * @param {!string} id The id to remove.
 * @return {!goog.async.Deferred} The deferred object to allow clients to
 *     wait for the operation to complete.
 */
drive.ds.sync.cache.Cache.prototype.remove = goog.abstractMethod;


/**
 * Applies sorting on a list of items and truncates the list up the desired
 * number of items.
 * @param {drive.ds.ItemQueryRequest} request The query request.
 * @param {!Array.<drive.ds.Item>} items The list of items.
 * @param {number} limit The desired number of items, -1 for all items.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.sortAndTruncate =
    function(request, items, limit) {
  if (request) {
    this.sorter_.sort(request, items);
  }
  if (limit != -1) {
    goog.array.splice(items, limit, items.length - limit);
  }
};


/**
 * Applies field pruning on a list of items.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!Array.<drive.ds.Item>} items The list of items.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.fieldPruning = function(request, items) {
  drive.ds.sync.Field.filterFields(request.getFieldList(), items);
};


/**
 * @return {!drive.ds.sync.cache.MetadataStore} The metadata store for this
 *     cache.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.getMetadataStore = function() {
  return this.metadataStore_;
};


/**
 * Gets the root ID for this cache.
 * @return {string} The cache's root ID.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.getRootId = function() {
  return this.metadataStore_.getRootId();
};


/**
 * Sets the root ID for this cache.
 * @param {string} rootId The root ID to use for the cache.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.setRootId = function(rootId) {
  this.metadataStore_.setRootId(rootId);
};


/**
 * Queues a cache change event.  Will wait BATCH_INTERVAL_MS_ before
 * firing the event to allow a quick succession of changes to be batched
 * together into a single event.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.queueChangeEvent = function() {
  if (!this.changed_) {
    this.changed_ = true;
    goog.global.setTimeout(goog.bind(this.fireBatchedChangeEvent_, this),
        drive.ds.sync.cache.Cache.BATCH_INTERVAL_MS_);
  }
};


/**
 * Fires a change event and marks all pending changes accounted for.
 * @private
 */
drive.ds.sync.cache.Cache.prototype.fireBatchedChangeEvent_ = function() {
  this.changed_ = false;
  this.dispatchEvent(drive.ds.sync.cache.Cache.EventType.CHANGED);
};


/**
 * Deterimines if the given request is supported by the cache.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @return {boolean} True if the request is supported.
 */
drive.ds.sync.cache.Cache.prototype.isRequestSupported = function(request) {
  return this.isRequestSupportedByFields_(request) &&
      request.getFullTextList().length == 0 &&
      request.getWriterList().length == 0 &&
      request.getReaderList().length == 0;
};


/**
 * Determines if the given request is supported by the cache based on the fields
 * that are cached.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @return {boolean} True if the request is supported.
 * @private
 */
drive.ds.sync.cache.Cache.prototype.isRequestSupportedByFields_ =
    function(request) {
  var requiredFields = drive.ds.sync.Field.getRequiredQueryFields(request);
  for (var i = 0; i < requiredFields.length; i++) {
    if (!goog.array.contains(this.fields_, requiredFields[i])) {
      this.logger_.warning(
          'Query requires uncached field, query performance will be degraded.');
      return false;
    }
  }
  return true;
};


/**
 * Checks whether a particular item meets the id spec if defined. This logic
 * also handles the special 'root' id.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the id spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsIdSpec = function(request, item) {
  return !goog.isDefAndNotNull(request.getId()) ||
      request.getId() == item.getId() ||
      (request.getId() == 'root' &&
          this.metadataStore_.getRootId() == item.getId());
};


/**
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the title spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsTitleSpec = function(request, item) {
  var returnValue = true;
  var specList = request.getTitleList();

  for (var i = 0; i < specList.length; i++) {
    var spec = specList[i];

    if (spec.getValue()) {
      var invert = spec.getInvert();

      var title = /** @type {string} */ (item.getTitle()).toLowerCase();
      var specTitle = spec.getValue().toLowerCase();
      if (spec.getOperator() == drive.ds.TitleSpec.Operator.EQUALS) {
        var titleMatch = specTitle == title;
        returnValue = returnValue && (invert ? !titleMatch : titleMatch);
      } else {
        var titleContains = goog.string.contains(title, specTitle);
        returnValue = returnValue && (invert ? !titleContains : titleContains);
      }
    }
  }

  return returnValue;
};


/**
 * Checks to see if the item matches the request spec on mimetype. In the case
 * of multiple mime types, the item matches if at least one mime type matches.
 * In the case of inverted mime types, the item matches if none of the inverted
 * mime types match the mime type value.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the mime type spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsMimeTypeSpec =
    function(request, item) {
  var specList = request.getMimeTypeList();

  var specCount = 0;
  var invertSpecCount = 0;
  var specValueMatch = false;
  var invertSpecValueMatch = false;
  for (var i = 0; i < specList.length; i++) {
    var spec = specList[i];
    if (spec.getValue()) {
      var invert = spec.getInvert();
      var mimeType = /** @type {string} */ (item.getMimeType());
      var hasMimeType = spec.getValue() == mimeType;

      if (invert) {
        invertSpecCount++;
        invertSpecValueMatch = invertSpecValueMatch || hasMimeType;
      } else {
        specCount++;
        specValueMatch = specValueMatch || hasMimeType;
      }
    }
  }

  if (specCount && !specValueMatch) {
    return false;
  }

  if (invertSpecCount && invertSpecValueMatch) {
    return false;
  }

  return true;
};


/**
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the modified date spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsModifiedDateSpec =
    function(request, item) {
  var returnValue = true;
  var specList = request.getModifiedDateList();

  for (var i = 0; i < specList.length; i++) {
    var date = /** @type {number} */ (item.getModifiedDateMillis());
    returnValue = returnValue && this.meetsDateSpec(date, specList[i]);
  }

  return returnValue;
};


/**
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the viewed date spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsViewedDateSpec =
    function(request, item) {
  var returnValue = true;
  var specList = request.getViewedDateList();

  for (var i = 0; i < specList.length; i++) {
    var date = /** @type {number} */ (item.getLastViewedByMeDateMillis());
    returnValue = returnValue && this.meetsDateSpec(date, specList[i]);
  }

  return returnValue;
};


/**
 * @param {number} timeMillis The time in millis.
 * @param {!drive.ds.DateSpec} spec The date spec to test.
 * @return {boolean} True if the time meets the date spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsDateSpec = function(timeMillis, spec) {
  if (goog.isDefAndNotNull(spec.getDateMillis())) {
    switch (spec.getOperator()) {
      case drive.ds.DateSpec.Operator.LESS_EQUALS:
        return timeMillis <= spec.getDateMillis();
      case drive.ds.DateSpec.Operator.LESS_THAN:
        return timeMillis < spec.getDateMillis();
      case drive.ds.DateSpec.Operator.EQUALS:
        return timeMillis == spec.getDateMillis();
      case drive.ds.DateSpec.Operator.GREATER_THAN:
        return timeMillis > spec.getDateMillis();
      case drive.ds.DateSpec.Operator.GREATER_EQUALS:
        return timeMillis >= spec.getDateMillis();
      default:
        return false;
    }
  }
  return true;
};


/**
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the trashed spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsTrashedSpec = function(request, item) {
  // Note: If we're filtering on "trashed = true", we must check that the user
  // owns the file.
  var trashed = request.getTrashed();
  return !goog.isDefAndNotNull(trashed) ||
      (!!trashed == !!item.getTrashed() && (!trashed ||
          this.matchesUser_(item.getOwnerList(), this.config_.getGaiaId())));
};


/**
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the starred spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsStarredSpec = function(request, item) {
  return !goog.isDefAndNotNull(request.getStarred()) ||
      !!request.getStarred() == !!item.getStarred();
};


/**
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the hidden spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsHiddenSpec = function(request, item) {
  return !goog.isDefAndNotNull(request.getHidden()) ||
      !!request.getHidden() == !!item.getHidden();
};


/**
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the parent spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsParentSpec = function(request, item) {
  var specList = request.getParentList();
  for (var i = 0; i < specList.length; i++) {
    var spec = specList[i];
    if (spec.getValue()) {
      var value = spec.getValue() == 'root' && this.metadataStore_.getRootId() ?
          this.metadataStore_.getRootId() : spec.getValue();
      var hasParent = goog.array.contains(item.getParentList(), value);
      if (spec.getInvert() ? hasParent : !hasParent) {
        return false;
      }
    }
  }

  return true;
};


/**
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the owner spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsOwnerSpec = function(request, item) {
  var specList = request.getOwnerList();
  for (var i = 0; i < specList.length; i++) {
    var spec = specList[i];
    var ownerId = spec.getValue();

    if (ownerId) {
      var hasOwner = this.matchesUser_(item.getOwnerList(), ownerId);
      if (spec.getInvert() ? hasOwner : !hasOwner) {
        return false;
      }
    }
  }

  return true;
};


/**
 * @param {!Array.<!drive.ds.Permission>} users A list of users.
 * @param {string} id The user id to find.
 * @return {boolean} Whether a user id exists in the given user list.
 * @private
 */
drive.ds.sync.cache.Cache.prototype.matchesUser_ = function(users, id) {
  return !!goog.array.find(users,
      function(user) {
        return id == user.getId();
      });
};


/**
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the shared with me spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsSharedWithMeSpec =
    function(request, item) {
  // Note: Genoa doesn't support a "not shared with me" query.
  return !goog.isDefAndNotNull(request.getSharedWithMe()) ||
      (request.getSharedWithMe() ?
          goog.isDefAndNotNull(item.getSharedWithMeDateMillis()) : true);
};


/**
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the shared with me spec.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.meetsExplicitlyTrashedSpec =
    function(request, item) {
  // Note: If we're filtering on "explicitly trashed = true", we must check that
  // the user owns the file.
  var trashed = request.getExplicitlyTrashed();
  return !goog.isDefAndNotNull(trashed) ||
      (!!trashed == !!item.getExplicitlyTrashed() && (!trashed ||
          this.matchesUser_(item.getOwnerList(), this.config_.getGaiaId())));
};


/**
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {drive.ds.Item} item The item.
 * @return {boolean} True if the item matches the filters specified
 *     in the request.
 */
drive.ds.sync.cache.Cache.prototype.meetsRequestSpec = function(request, item) {
  return !!item &&
      this.meetsTitleSpec(request, item) &&
      this.meetsMimeTypeSpec(request, item) &&
      this.meetsModifiedDateSpec(request, item) &&
      this.meetsViewedDateSpec(request, item) &&
      this.meetsTrashedSpec(request, item) &&
      this.meetsStarredSpec(request, item) &&
      this.meetsHiddenSpec(request, item) &&
      this.meetsParentSpec(request, item) &&
      this.meetsOwnerSpec(request, item) &&
      this.meetsSharedWithMeSpec(request, item) &&
      this.meetsExplicitlyTrashedSpec(request, item);
};


/**
 * @return {!Array.<!drive.ds.Field>} The complete set of fields
 *     that the client could potentially need.
 */
drive.ds.sync.cache.Cache.prototype.getFields = function() {
  return this.fields_;
};


/**
 * Marks the cache as initialized.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.setInitialized = function() {
  this.initialized_ = true;
  this.dispatchEvent(drive.ds.sync.cache.Cache.EventType.INITIALIZED);
};


/**
 * @return {boolean} Whether this cache has been initialized.
 */
drive.ds.sync.cache.Cache.prototype.getInitialized = function() {
  return this.initialized_;
};


/**
 * @return {!goog.debug.Logger} The logger for this cache.
 * @protected
 */
drive.ds.sync.cache.Cache.prototype.getLogger = function() {
  return this.logger_;
};

//javascript/apps/devapps/mimetypeutil.js
/**
 * @fileoverview This file provides utility methods for determining with which
 * type of app a MIME type is associated. Or given an app, what type of app it
 * is based on its openable types.
 */

goog.provide('apps.devapps.MimeTypeUtil');

goog.require('goog.string');


/**
 * The prefix for the app-specific mimeType, associated with all apps.
 * @type {string}
 */
apps.devapps.MimeTypeUtil.APP_SPECIFIC_MIMETYPE_PREFIX =
    'application/vnd.google-apps.drive-sdk';


/**
 * The prefix for all native types in Google Docs; these are considered to be
 * special app-specific mimeTypes for Google Docs applications such as Kix,
 * Trix, Punch, etc.
 * @type {string}
 */
apps.devapps.MimeTypeUtil.NATIVE_GDOC_MIMETYPE_PREFIX =
    'application/vnd.google-apps';


/**
 * The mimeType for folder items in cosmo.
 * @type {string}
 */
apps.devapps.MimeTypeUtil.FOLDER_MIME_TYPE =
    'application/vnd.google-apps.folder';


/**
 * Gets whether the specified mimeType is an app-specific mimeType. This
 * includes third-party and first-party app-specific mimeTypes (Plaster, Kix,
 * Trix etc).
 * @param {string} mimeType The mimeType.
 * @return {boolean} Whether the specified mimeType is associated with a default
 *     app for default open-with scenarios.
 */
apps.devapps.MimeTypeUtil.isAppSpecificMimeType = function(mimeType) {
  return apps.devapps.MimeTypeUtil.isThirdPartyAppSpecificMimeType_(mimeType) ||
      (apps.devapps.MimeTypeUtil.isNativeGdocMimeType(mimeType) &&
       mimeType != apps.devapps.MimeTypeUtil.FOLDER_MIME_TYPE);
};


/**
 * Gets whether the specified mimeType is a third-party app-specific mimeType.
 * @param {string} mimeType The mimeType.
 * @return {boolean} Whether the specified mimeType is associated with a default
 *     app for default open-with scenarios.
 * @private
 */
apps.devapps.MimeTypeUtil.isThirdPartyAppSpecificMimeType_ =
    function(mimeType) {
  return goog.string.startsWith(mimeType,
      apps.devapps.MimeTypeUtil.APP_SPECIFIC_MIMETYPE_PREFIX);
};


/**
 * Gets whether the specified mimeType is a native Google Docs mimeType.
 * @param {string} mimeType The mimeType.
 * @return {boolean} Whether the specified mimeType is a native Google Docs
 *     mimeType.
 */
apps.devapps.MimeTypeUtil.isNativeGdocMimeType = function(mimeType) {
  return !apps.devapps.MimeTypeUtil.
      isThirdPartyAppSpecificMimeType_(mimeType) &&
      goog.string.startsWith(mimeType,
          apps.devapps.MimeTypeUtil.NATIVE_GDOC_MIMETYPE_PREFIX);
};


/**
 * Gets the ID of the app which owns the given MIME type. Returns null if the
 * MIME type is not owned by any app. An app owns a mimetype if it is an app
 * specific mimetype. See
 * apps.devapps.MimeTypeUtil.APP_SPECIFIC_MIMETYPE_PREFIX and
 * apps.devapps.MimeTypeUtil.NATIVE_GDOC_MIMETYPE_PREFIX for the format of
 * app specific mimetypes.
 * @param {string} mimeType The mimeType.
 * @return {?string} The app ID of the owner app or null if there is no owner.
 */
apps.devapps.MimeTypeUtil.getOwnerAppId = function(mimeType) {
  if (apps.devapps.MimeTypeUtil.isAppSpecificMimeType(mimeType)) {
    var mimeTypeTokens = mimeType.split('.');
    return mimeTypeTokens[mimeTypeTokens.length - 1];
  } else {
    return null;
  }
};


/**
 * @param {!apps.devapps.App} app The app.
 * @return {boolean} Whether the specified app is a reference-type app.
 */
apps.devapps.MimeTypeUtil.isReferenceTypeApp = function(app) {
  if (!app.isDriveApp()) {
    return false;
  }
  // TODO(mprocopio): Work with team to identify a better generic name for
  // this method and these types of apps in general.
  // An app is a "Reference" or "Plaster" app if (1) it is associated with one
  // single (primary) mimeType, (2) that mimeType is an app-specific mimeType,
  // and (3) and there are no associated file extensions.
  var mimeTypes = app.getDriveDetails().getPrimaryMimeTypes();
  var fileExtensions = app.getDriveDetails().getPrimaryFileExtensions();
  var hasFileExtensions = (fileExtensions && fileExtensions.length > 0);

  return ((mimeTypes && mimeTypes.length == 1) &&
      apps.devapps.MimeTypeUtil.isAppSpecificMimeType(mimeTypes[0]) &&
      !hasFileExtensions);
};

//javascript/apps/drive/dataservice/sync/cache/downloadurlprovider.js
/**
 * Static helper for generating a download url.
 */

goog.provide('drive.ds.sync.cache.DownloadUrlProvider');

goog.require('goog.Uri');


/** @private {string} Base path for the download endpoint on Drive. */
drive.ds.sync.cache.DownloadUrlProvider.BASE_PATH_ = '/uc';


/** @private {string} Doc id parameter. */
drive.ds.sync.cache.DownloadUrlProvider.ID_PARAM_ = 'id';


/** @private {string} Gaia session id param. */
drive.ds.sync.cache.DownloadUrlProvider.SESSION_ID_PARAM_ = 'authuser';


/** @private {string} The export parameter key. */
drive.ds.sync.cache.DownloadUrlProvider.EXPORT_PARAM_ = 'export';


/** @private {string} The export parameter value for a download. */
drive.ds.sync.cache.DownloadUrlProvider.DOWNLOAD_VALUE_ = 'download';


/**
 * Provides a download url with the given item id.
 * @param {string} id The item id.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item service config.
 * @return {string} The download url for a given item.
 */
drive.ds.sync.cache.DownloadUrlProvider.get = function(id, config) {
  var uri = new goog.Uri(config.getDownloadBaseUrl() +
      drive.ds.sync.cache.DownloadUrlProvider.BASE_PATH_);
  uri.setParameterValue(drive.ds.sync.cache.DownloadUrlProvider.ID_PARAM_, id);
  uri.setParameterValue(
      drive.ds.sync.cache.DownloadUrlProvider.SESSION_ID_PARAM_,
      config.getGaiaSessionId());
  uri.setParameterValue(
      drive.ds.sync.cache.DownloadUrlProvider.EXPORT_PARAM_,
      drive.ds.sync.cache.DownloadUrlProvider.DOWNLOAD_VALUE_);

  return uri.toString();
};

//javascript/apps/drive/dataservice/sync/cache/openurlprovider.js
/**
 * Static helper for generating an open url.
 * TODO(towong): Consider generating url based on mimetype, default app, etc.
 * instead of depending on /open endpoint which performs a redirect to final
 * destination.
 */

goog.provide('drive.ds.sync.cache.OpenUrlProvider');

goog.require('goog.Uri');


/**
 * Base path for the open endpoint on Drive.
 * @private {string}
 */
drive.ds.sync.cache.OpenUrlProvider.BASE_PATH_ = '/open';


/**
 * Doc id parameter.
 * @private {string}
 */
drive.ds.sync.cache.OpenUrlProvider.ID_PARAM_ = 'id';


/**
 * Gaia session id param.
 * @private {string}
 */
drive.ds.sync.cache.OpenUrlProvider.SESSION_ID_PARAM_ = 'authuser';


/**
 * Provides an open url with the given item id.
 * @param {string} id The item id.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item service config.
 * @return {string} The open url for a given item.
 */
drive.ds.sync.cache.OpenUrlProvider.get = function(id, config) {
  var uri = new goog.Uri(config.getOpenBaseUrl() +
      drive.ds.sync.cache.OpenUrlProvider.BASE_PATH_);
  uri.setParameterValue(drive.ds.sync.cache.OpenUrlProvider.ID_PARAM_, id);
  uri.setParameterValue(drive.ds.sync.cache.OpenUrlProvider.SESSION_ID_PARAM_,
      config.getGaiaSessionId());

  return uri.toString();
};

//javascript/apps/drive/dataservice/sync/cache/thumbnailurlprovider.js
/**
 * Static helper for generating a thumbnail url.
 */

goog.provide('drive.ds.sync.cache.ThumbnailUrlProvider');

goog.require('goog.Uri');


/**
 * @private {string} Base path for the thumbnail endpoint on Drive.
 */
drive.ds.sync.cache.ThumbnailUrlProvider.BASE_PATH_ = '/thumbnail';


/**
 * @private {string} Doc id parameter.
 */
drive.ds.sync.cache.ThumbnailUrlProvider.ID_PARAM_ = 'id';


/**
 * @private {string} The parameter and template value for thumbnail size.
 */
drive.ds.sync.cache.ThumbnailUrlProvider.SIZE_ = '&sz={size}';


/**
 * @private {string} Gaia session id param.
 */
drive.ds.sync.cache.ThumbnailUrlProvider.SESSION_ID_PARAM_ = 'authuser';


/**
 * Provides a thumbnail url with the given item id.
 * @param {string} id The item id.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item service config.
 * @return {string} The thumbnail url for a given item.
 */
drive.ds.sync.cache.ThumbnailUrlProvider.get = function(id, config) {
  var uri = new goog.Uri(config.getThumbnailBaseUrl() +
      drive.ds.sync.cache.ThumbnailUrlProvider.BASE_PATH_);
  uri.setParameterValue(drive.ds.sync.cache.ThumbnailUrlProvider.ID_PARAM_, id);
  uri.setParameterValue(
      drive.ds.sync.cache.ThumbnailUrlProvider.SESSION_ID_PARAM_,
      config.getGaiaSessionId());

  var thumb = uri.toString();

  // The thumbnail size marker is added so clients can set the size of the
  // thumbnail as if the url were a template url.
  // goog.Uri is not used because it encodes the '{' and '}' in the thumnail
  // size marker, rendering the template functionality useless.
  thumb += drive.ds.sync.cache.ThumbnailUrlProvider.SIZE_;
  return thumb;
};

//javascript/apps/drive/dataservice/sync/cache/cacheoptimizer.js
goog.provide('drive.ds.sync.cache.CacheOptimizer');

goog.require('apps.devapps.MimeTypeUtil');
goog.require('drive.ds.Field');
goog.require('drive.ds.Permission');
goog.require('drive.ds.Role');
goog.require('drive.ds.sync.FolderUtil');
goog.require('drive.ds.sync.cache.DownloadUrlProvider');
goog.require('drive.ds.sync.cache.OpenUrlProvider');
goog.require('drive.ds.sync.cache.ThumbnailUrlProvider');
goog.require('goog.array');



/**
 * A cache optimizer for performing optimizations on a given drive item to help
 * reduce cache storage requirements. Note that internally this may store
 * mappings for a particular item, so the cache must send a removal request to
 * the optimizer as well when a particular item is removed.
 * TODO(towong): Use this for owner/lastModifying data as well.
 * @param {!Array.<!drive.ds.Field>} fields The complete set of fields
 *     that the client could potentially need.
 * @param {!drive.ds.sync.cache.PermissionCache} permissionCache The permission
 *     cache.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item service config.
 * @constructor
 */
drive.ds.sync.cache.CacheOptimizer = function(fields, permissionCache, config) {
  /**
   * The complete set of fields that the client could potentially need.
   * @private {!Array.<!drive.ds.Field>}
   */
  this.fields_ = fields;

  /** @private {!drive.ds.sync.cache.PermissionCache} A permission cache. */
  this.permissionCache_ = permissionCache;

  /** @private {!drive.ds.sync.SyncedConfig} */
  this.config_ = config;
};


/**
 * Performs initialization of the cache optimizer. By default this does nothing,
 * individual implementations may want need to populate items to owners and last
 * modifying user maps (eg. Populate from IndexedDb).
 */
drive.ds.sync.cache.CacheOptimizer.prototype.initialize = function() { };


/**
 * Given an item, this replaces the full permissions on the item with bare
 * permissions. The full permissions themselves are added the to permissions
 * cache. This can also take an item with bare permissions already. In the case
 * that the item already has a bare permission, we take no action and assume
 * that the permission information has already been added to the cache elsewhere
 * (ex. bulk import directly into the cache).
 * @param {!drive.ds.Item} item The item to put permissions for.
 */
drive.ds.sync.cache.CacheOptimizer.prototype.putPermissions = function(item) {
  if (goog.array.contains(this.fields_, drive.ds.Field.OWNERS)) {
    var ownerList = item.getOwnerList();
    item.setOwnerList(this.putPermissions_(ownerList));
  }

  if (goog.array.contains(this.fields_, drive.ds.Field.LAST_MODIFYING_USER)) {
    var lastModifyingUser = item.getLastModifyingUser();
    if (lastModifyingUser) {
      item.setLastModifyingUser(this.putPermissions_([lastModifyingUser])[0]);
    }
  }

  if (goog.array.contains(this.fields_, drive.ds.Field.VISIBILITIES)) {
    var userList = item.getUserList();
    item.setUserList(this.putPermissions_(userList));
  }

  if (goog.array.contains(this.fields_, drive.ds.Field.SHARING_USER)) {
    var sharingUser = item.getSharingUser();
    if (sharingUser) {
      item.setSharingUser(this.putPermissions_([sharingUser])[0]);
    }
  }
};


/**
 * A list of permissions to add to the cache. This returns a list of the
 * corresponding bare permissions.
 * @param {!Array.<!drive.ds.Permission>} permissions The permissions to cache.
 * @return {!Array.<!drive.ds.Permission>} A list of bare permissions.
 * @private
 */
drive.ds.sync.cache.CacheOptimizer.prototype.putPermissions_ = function(
    permissions) {
  var barePermissions = [];

  for (var i = 0; i < permissions.length; i++) {
    var permission = permissions[i];

    this.permissionCache_.put(permission);
    barePermissions.push(this.createBarePermission_(permission));
  }

  return barePermissions;
};


/**
 * Creates a bare permission from the given permission.
 * @param {!drive.ds.Permission} permission The permission.
 * @return {!drive.ds.Permission} A bare permission.
 * @private
 */
drive.ds.sync.cache.CacheOptimizer.prototype.createBarePermission_ =
    function(permission) {
  var barePermission = new drive.ds.Permission();
  barePermission.setId(permission.getId());
  barePermission.setRole(permission.getRole());
  return barePermission;
};


/**
 * Populates an item containing bare permissions with a list of full
 * permissions.
 * @param {!drive.ds.Item} item The item to add a list of users.
 * @return {!drive.ds.Item} item The item for chaining.
 */
drive.ds.sync.cache.CacheOptimizer.prototype.addPermissions = function(item) {
  if (goog.array.contains(this.fields_, drive.ds.Field.OWNERS)) {
    var ownerList = this.getFullPermissions_(item.getOwnerList());
    item.setOwnerList(ownerList);
  }

  if (goog.array.contains(this.fields_, drive.ds.Field.LAST_MODIFYING_USER)) {
    var lastModifyingUser = item.getLastModifyingUser();
    if (lastModifyingUser) {
      lastModifyingUser = this.getFullPermissions_([lastModifyingUser]);
      item.setLastModifyingUser(lastModifyingUser[0]);
    }
  }

  if (goog.array.contains(this.fields_, drive.ds.Field.VISIBILITIES)) {
    var userList = this.getFullPermissions_(item.getUserList());
    item.setUserList(userList);
  }

  if (goog.array.contains(this.fields_, drive.ds.Field.SHARING_USER)) {
    var sharingUser = item.getSharingUser();
    if (sharingUser) {
      sharingUser = this.getFullPermissions_([sharingUser]);
      item.setSharingUser(sharingUser[0]);
    }
  }

  return item;
};


/**
 * Given a list of bare permissions, we combine it with the permissions cache
 * and generate a list of full permissions.
 * @param {!Array.<!drive.ds.Permission>} barePermissions The permissions
 *     generate full permissions for.
 * @return {!Array.<!drive.ds.Permission>} A list of full permissions.
 * @private
 */
drive.ds.sync.cache.CacheOptimizer.prototype.getFullPermissions_ = function(
    barePermissions) {
  var fullPermissions = [];

  for (var i = 0; i < barePermissions.length; i++) {
    var barePermission = barePermissions[i];
    var fullPermission = this.permissionCache_.getById(
        /** @type {string} */ (barePermission.getId()));
    fullPermission.setRole(barePermission.getRole());

    fullPermissions.push(fullPermission);
  }

  return fullPermissions;
};


/**
 * Adds the open url to a given item if the client has requested it.
 * @param {!drive.ds.Item} item The item to add an open url.
 * @return {!drive.ds.Item} item The item for chaining.
 */
drive.ds.sync.cache.CacheOptimizer.prototype.addOpenUrl = function(item) {
  // Add open url as needed.
  if (goog.array.contains(this.fields_, drive.ds.Field.OPEN_URL)) {
    item.setOpenUrl(drive.ds.sync.cache.OpenUrlProvider.get(
        item.getId(), this.config_));
  }
  return item;
};


/**
 * Adds a valid thumbnail url to a given item if the client has requested it.
 * @param {!drive.ds.Item} item The item to add a thumbnail url.
 * @return {!drive.ds.Item} item The item for chaining.
 */
drive.ds.sync.cache.CacheOptimizer.prototype.addThumbnailUrl = function(item) {
  // Add thumbnail url as needed.
  if (item.getHasThumbnail() &&
      goog.array.contains(this.fields_, drive.ds.Field.THUMBNAIL_URL)) {
    item.setThumbnailUrl(drive.ds.sync.cache.ThumbnailUrlProvider.get(
        item.getId(), this.config_));
  }
  return item;
};


/**
 * Adds the downloadable and download url fields.
 * @param {!drive.ds.Item} item The item to add a downloadable and download url
 *     field.
 * @return {!drive.ds.Item} item The item for chaining.
 */
drive.ds.sync.cache.CacheOptimizer.prototype.addDownloadFields =
    function(item) {
  // Add downloadable field as needed.
  var downloadable = false;
  if (goog.array.contains(this.fields_, drive.ds.Field.DOWNLOADABLE)) {
    // An item is downloadable for an item that is:
    // - non-folder mimetype
    // - non-app specific mimetype
    // - not a viewer if the item is restricted for viewers.
    var mimeType = /** @type {string} */ (item.getMimeType());
    downloadable = !drive.ds.sync.FolderUtil.isFolder(item) &&
        !apps.devapps.MimeTypeUtil.isAppSpecificMimeType(mimeType) &&
        (!item.getRestricted() || item.getUserRole() != drive.ds.Role.READER);
    item.setDownloadable(downloadable);
  }

  // Add download_url field as needed.
  if (downloadable &&
      goog.array.contains(this.fields_, drive.ds.Field.DOWNLOAD_URL)) {
    item.setDownloadUrl(drive.ds.sync.cache.DownloadUrlProvider.get(
        item.getId(), this.config_));
  }

  return item;
};

//javascript/apps/drive/dataservice/sync/cache/cachepopulationstrategy.js
goog.provide('drive.ds.sync.cache.CachePopulationStrategy');

goog.require('goog.events');
goog.require('goog.events.EventTarget');



/**
 * An abstract class for a particular strategy for performing cache
 * population. Each strategy consists of a set of query runners to be run to
 * fetch the data.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!drive.ds.sync.query.QueryManager} queryManager The query manager.
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.cache.CachePopulationStrategy = function(context, queryManager) {
  goog.base(this);

  /**
   * The app context.
   * @private {!drive.ds.sync.Context}
   */
  this.context_ = context;

  /**
   * The query manager.
   * @private {!drive.ds.sync.query.QueryManager}
   */
  this.queryManager_ = queryManager;
};
goog.inherits(drive.ds.sync.cache.CachePopulationStrategy,
    goog.events.EventTarget);


/**
 * Cache population strategy related events.
 * @enum {string}
 */
drive.ds.sync.cache.CachePopulationStrategy.EventType = {
  /**
   * Event dispatched to indicate that a strategy has additional query runners
   * to be executed.
   */
  CHANGED: goog.events.getUniqueId('changed')
};


/**
 * Gets the next query runner for this particular cache population strategy.
 * @return {drive.ds.sync.query.QueryRunner} A query runner for performing
 *     additional cache population if available, otherwise null.
 */
drive.ds.sync.cache.CachePopulationStrategy.prototype.getNextRunner =
    goog.abstractMethod;


/**
 * Checks whether there are additional runners that need to be run to finish
 * processing this cache population strategy.
 * @return {boolean} Whether there are additional query runners that need to be
 *     processed to finished.
 */
drive.ds.sync.cache.CachePopulationStrategy.prototype.hasMoreRunners =
    goog.abstractMethod;


/**
 * @return {!drive.ds.sync.Context} The app context.
 * @protected
 */
drive.ds.sync.cache.CachePopulationStrategy.prototype.getContext = function() {
  return this.context_;
};


/**
 * @return {!drive.ds.sync.query.QueryManager} The query manager.
 * @protected
 */
drive.ds.sync.cache.CachePopulationStrategy.prototype.getQueryManager =
    function() {
  return this.queryManager_;
};


/**
 * @return {number} The maximum number of items to get for a particular query
 *     runner, defaults to 100.
 */
drive.ds.sync.cache.CachePopulationStrategy.prototype.getMaxItems = function() {
  return 100;
};

//javascript/apps/drive/dataservice/sync/cache/cachepopulator.js
goog.provide('drive.ds.sync.cache.CachePopulator');

goog.require('goog.events');
goog.require('goog.events.EventTarget');



/**
 * A cache populator.
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.cache.CachePopulator = function() {
  goog.base(this);
};
goog.inherits(drive.ds.sync.cache.CachePopulator, goog.events.EventTarget);


/**
 * Cache populator related events.
 */
drive.ds.sync.cache.CachePopulator.EventType = {
  // Event generated when this cache populator is done.
  COMPLETE: goog.events.getUniqueId('complete'),

  // Event generated when this cache populator encounters an error.
  ERROR: goog.events.getUniqueId('error')
};


/**
 * Runs this particular cache populator. Generates a COMPLETE event once it is
 * done running.
 */
drive.ds.sync.cache.CachePopulator.prototype.run = goog.abstractMethod;


/** @return {boolean} Whether this cache populator requires Genoa. */
drive.ds.sync.cache.CachePopulator.prototype.isGenoaRequired = function() {
  return true;
};

//javascript/apps/drive/dataservice/sync/syncedconfig.js
goog.provide('drive.ds.sync.SyncedConfig');

goog.require('goog.asserts');



/**
 * A configuration object for the synced item service.
 * @constructor
 */
drive.ds.sync.SyncedConfig = function() {
  /**
   * Whether to use qual cosmo instead of prod cosmo, defaults to false.
   * @private {boolean}
   */
  this.useQualCosmo_ = false;

  /**
   * Whether to use third party auth instead of first party auth, defaults to
   * false.
   * @private {boolean}
   */
  this.useThirdPartyAuth_ = false;

  /**
   * Whether to use IndexedDb to cache data locally on the client.
   * @private {boolean}
   */
  this.useIndexedDb_ = false;

  /**
   * The client id used with third party auth, defaults to empty string.
   * @private {string}
   */
  this.clientId_ = '';

  /**
   * Determines how change logs should be processed. Defaults to using TANGO.
   * @private {!drive.ds.sync.SyncedConfig.ChangeHandler}
   */
  this.changeHandler_ = drive.ds.sync.SyncedConfig.ChangeHandler.TANGO;

  /** @private {string} Base drive URL to use for constructed URLs. */
  this.baseUrl_ = 'https://drive.google.com';

  /** @private {?string} Base URL to use for open URLs, defaults to base URL. */
  this.openBaseUrl_ = null;

  /**
   * Base URL to use for thumbnail URLs, defaults to base URL.
   * @private {?string}
   */
  this.thumbnailBaseUrl_ = null;

  /**
   * Base URL to use for download URLs, defaults to base URL.
   * @private {?string}
   */
  this.downloadBaseUrl_ = null;

  /**
   * TODO(jlure): Remove this when Genoa can provide activity data.
   * Base URL to use for querying activity data, defaults to base URL.
   * @private {?string}
   */
  this.activityBaseUrl_ = null;

  /**
   * Whether to load cache from a dump endpoint on explorer.
   * @private {boolean}
   */
  this.useDumpello_ = false;

  /** @private {boolean} Whether to enable debug mode, defaults to false. */
  this.debugMode_ = false;

  /** @private {number} The gaia session id of the user, defaults to 0. */
  this.gaiaSessionId_ = 0;

  /** @private {string} The obfuscated gaia id of the user. */
  this.gaiaId_ = '';

  /**
   * First-party client ID enum, used to determine which API version each client
   * should use. Defaults to DEFAULT.
   * @private {drive.ds.sync.SyncedConfig.FirstPartyClientId}
   */
  this.firstPartyClientId_ =
      drive.ds.sync.SyncedConfig.FirstPartyClientId.DEFAULT;

  /** @private {string} The locale, defaults to English. */
  this.locale_ = 'en';

  /**
   * The maximum corpus size supported by Dumpello. This flag only applies when
   * use_dumpello is true. Users with a larger corpus size will fall back to
   * alternative cache population methods that might be more effective. Defaults
   * to -1, which indicates that all corpus sizes are
   * supported.
   * @private {number}
   */
  this.dumpelloMaxItems_ = -1;

  /**
   * Whether the server generated dumpello should include change logs since the
   * dump was generated. This flag only applies when use_dumpello is true.
   * Defaults to false.
   *
   * Note: That in the case of Explorer, this lets us determine whether we can
   * skip over Genoa auth and Genoa change log processing entirely and depend on
   * just dumpello data + browser channel data from the Explorer client.
   * @private {boolean}
   */
  this.dumpelloIncludeChanges_ = false;

  /**
   * Whether the initial dumpello is provided by the client. This optimization
   * allows us to save a request an improve initialization time. This flag only
   * applies when use_dumpello is true.
   * @private {boolean}
   */
  this.dumpelloClientProvided_ = false;

  /**
   * Whether we are encrypting the dumpello and storing it locally. This flag
   * only applies when use_dumpello is true.
   * @private {boolean}
   */
  this.dumpelloEncryption_ = false;

  /**
   * A set of keys used for encryption/decryption. The first key is always used
   * for encryption, and is a possible candidate for decryption. The remaining
   * keys are past keys which may be used for decrypting the dumpello. This flag
   * only applies when dumpello_encryption is true.
   * @private {!Array.<string>}
   */
  this.indexedDbKeys_ = [];

  /**
   * XSRF token used only for communicating the with legacy Explorer server.
   * @private {string}
   */
  this.explorerXsrfToken_ = '';

  /**
   * Whether the client expects a Javascript error. If true, errors returned
   * will have 'dataServiceError' fields set with drive.ds.Error instances. If
   * false, a drive.ds.Error is returned instead. Defaults to true.
   * @private {boolean}
   */
  this.returnJsErrors_ = true;
};


/**
 * Client ID enum, used to determine Drive API version for each client.
 * @enum {number}
 */
drive.ds.sync.SyncedConfig.FirstPartyClientId = {
  DEFAULT: 0,
  EXPLORER: 1,
  TESLA: 2,
  TOPHAT: 3
};


/**
 * List of support change processing types.
 * @enum {number}
 */
drive.ds.sync.SyncedConfig.ChangeHandler = {
  // Uses tango for change notifications if possible, this approach falls back
  // on polling as needed (Eg. tango not supported by domain).
  TANGO: 1,

  // Uses polling only.
  POLLING: 2
};


/** @return {boolean} Whether to use qual cosmo. */
drive.ds.sync.SyncedConfig.prototype.getUseQualCosmo = function() {
  return this.useQualCosmo_;
};


/**
 * @param {boolean} useQualCosmo Whether to use qual cosmo.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setUseQualCosmo = function(useQualCosmo) {
  this.useQualCosmo_ = useQualCosmo;
  return this;
};


/** @return {boolean} Whether to use third party auth. */
drive.ds.sync.SyncedConfig.prototype.getUseThirdPartyAuth = function() {
  return this.useThirdPartyAuth_;
};


/**
 * @param {boolean} useThirdPartyAuth Whether to use third paty auth.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setUseThirdPartyAuth =
    function(useThirdPartyAuth) {
  this.useThirdPartyAuth_ = useThirdPartyAuth;
  return this;
};


/** @return {boolean} Whether to use local caching in an indexed db. */
drive.ds.sync.SyncedConfig.prototype.getUseIndexedDb = function() {
  return this.useIndexedDb_;
};


/**
 * @param {boolean} useIndexedDb Whether to use local caching in an indexed db.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setUseIndexedDb = function(useIndexedDb) {
  this.useIndexedDb_ = useIndexedDb;
  return this;
};


/** @return {string} The client id. */
drive.ds.sync.SyncedConfig.prototype.getClientId = function() {
  return this.clientId_;
};


/**
 * @param {string} clientId The client id.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setClientId = function(clientId) {
  this.clientId_ = clientId;
  return this;
};


/**
 * @return {!drive.ds.sync.SyncedConfig.ChangeHandler} Value indicating
 *     how change logs should be processed.
 */
drive.ds.sync.SyncedConfig.prototype.getChangeHandler = function() {
  return this.changeHandler_;
};


/**
 * @param {!drive.ds.sync.SyncedConfig.ChangeHandler} changeHandler
 *     Value indicating how change logs should be processed.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setChangeHandler =
    function(changeHandler) {
  this.changeHandler_ = changeHandler;
  return this;
};


/**
 * @return {string} Base drive URL to use for constructed URLs.
 */
drive.ds.sync.SyncedConfig.prototype.getBaseUrl = function() {
  return this.baseUrl_;
};


/**
 * @param {string} baseUrl The base URL to use for constructed URLs.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setBaseUrl = function(baseUrl) {
  this.baseUrl_ = baseUrl;
  return this;
};


/**
 * @return {string} Base drive URL to use for open URLs.
 */
drive.ds.sync.SyncedConfig.prototype.getOpenBaseUrl = function() {
  return goog.isDefAndNotNull(this.openBaseUrl_) ?
      this.openBaseUrl_ : this.baseUrl_;
};


/**
 * @param {?string} openUrl The base URL to use for open URLs.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setOpenBaseUrl = function(openUrl) {
  this.openBaseUrl_ = openUrl;
  return this;
};


/**
 * @return {string} Base drive URL to use for thumbnail URLs.
 */
drive.ds.sync.SyncedConfig.prototype.getThumbnailBaseUrl = function() {
  return goog.isDefAndNotNull(this.thumbnailBaseUrl_) ?
      this.thumbnailBaseUrl_ : this.baseUrl_;
};


/**
 * @param {?string} thumbUrl The base URL to use for thumbnail URLs.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setThumbnailBaseUrl = function(thumbUrl) {
  this.thumbnailBaseUrl_ = thumbUrl;
  return this;
};


/**
 * @return {string} Base drive URL to use for download URLs.
 */
drive.ds.sync.SyncedConfig.prototype.getDownloadBaseUrl = function() {
  return goog.isDefAndNotNull(this.downloadBaseUrl_) ?
      this.downloadBaseUrl_ : this.baseUrl_;
};


/**
 * @param {?string} downloadUrl The base URL to use for thumbnail URLs.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setDownloadBaseUrl =
    function(downloadUrl) {
  this.downloadBaseUrl_ = downloadUrl;
  return this;
};


/**
 * @return {string} Base drive URL to use for querying activity data.
 */
drive.ds.sync.SyncedConfig.prototype.getActivityBaseUrl = function() {
  return goog.isDefAndNotNull(this.activityBaseUrl_) ?
      this.activityBaseUrl_ : this.baseUrl_;
};


/**
 * @param {?string} activityUrl The base URL to use for querying activity data.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setActivityBaseUrl =
    function(activityUrl) {
  this.activityBaseUrl_ = activityUrl;
  return this;
};


/**
 * @return {boolean} Whether to load the cache from an explorer dump endpoint.
 */
drive.ds.sync.SyncedConfig.prototype.getUseDumpello = function() {
  return this.useDumpello_;
};


/**
 * @param {boolean} useDumpello Whether to load the cache from an explorer dump
 *     endpoint.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setUseDumpello = function(useDumpello) {
  this.useDumpello_ = useDumpello;
  return this;
};


/** @return {boolean} Whether to enable debug mode. */
drive.ds.sync.SyncedConfig.prototype.getDebugMode = function() {
  return this.debugMode_;
};


/**
 * @param {boolean} debugMode Whether to enable debug mode.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setDebugMode =
    function(debugMode) {
  this.debugMode_ = debugMode;
  return this;
};


/** @return {number} The gaia session id of the current user. */
drive.ds.sync.SyncedConfig.prototype.getGaiaSessionId = function() {
  return this.gaiaSessionId_;
};


/**
 * @param {number} gaiaSessionId The gaia session id of the current user.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setGaiaSessionId =
    function(gaiaSessionId) {
  this.gaiaSessionId_ = gaiaSessionId;
  return this;
};


/** @return {string} The obfuscated gaia id of the current user. */
drive.ds.sync.SyncedConfig.prototype.getGaiaId = function() {
  return this.gaiaId_;
};


/**
 * @param {string} gaiaId The obfuscated gaia id of the current user.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setGaiaId = function(gaiaId) {
  this.gaiaId_ = gaiaId;
  return this;
};


/**
 * @return {drive.ds.sync.SyncedConfig.FirstPartyClientId} The first-party
 *     client id.
 */
drive.ds.sync.SyncedConfig.prototype.getFirstPartyClientId = function() {
  return this.firstPartyClientId_;
};


/**
 * @param {drive.ds.sync.SyncedConfig.FirstPartyClientId} id ID enum value for
 *     this first-party client.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setFirstPartyClientId = function(id) {
  this.firstPartyClientId_ = id;
  return this;
};


/** @return {string} The client locale. */
drive.ds.sync.SyncedConfig.prototype.getLocale = function() {
  return this.locale_;
};


/**
 * @param {string} locale The client locale.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setLocale = function(locale) {
  this.locale_ = locale;
  return this;
};


/** @return {number} The max corpus size supported by dumpello. */
drive.ds.sync.SyncedConfig.prototype.getDumpelloMaxItems = function() {
  return this.dumpelloMaxItems_;
};


/**
 * @param {number} dumpelloMaxItems The max corpus size supported by dumpello.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setDumpelloMaxItems =
    function(dumpelloMaxItems) {
  this.dumpelloMaxItems_ = dumpelloMaxItems;
  return this;
};


/** @return {boolean} Whether dumpello includes change logs. */
drive.ds.sync.SyncedConfig.prototype.getDumpelloIncludeChanges = function() {
  return this.dumpelloIncludeChanges_;
};


/**
 * @param {boolean} dumpelloIncludeChanges Whether dumpello includes change
 *     logs.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setDumpelloIncludeChanges =
    function(dumpelloIncludeChanges) {
  this.dumpelloIncludeChanges_ = dumpelloIncludeChanges;
  return this;
};


/** @return {boolean} Whether clients provide the initial dumpello. */
drive.ds.sync.SyncedConfig.prototype.getDumpelloClientProvided = function() {
  return this.dumpelloClientProvided_;
};


/**
 * @param {boolean} dumpelloClientProvided Whether clients provide the initial
 *     dumpello.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setDumpelloClientProvided =
    function(dumpelloClientProvided) {
  this.dumpelloClientProvided_ = dumpelloClientProvided;
  return this;
};


/**
 * @return {boolean} Whether we are encrypting the dumpello and storing it
 * locally.
 */
drive.ds.sync.SyncedConfig.prototype.getDumpelloEncryption = function() {
  return this.dumpelloEncryption_;
};


/**
 * @param {boolean} dumpelloEncryption Whether we are encrypting the
 *     dumpello and storing it locally.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setDumpelloEncryption =
    function(dumpelloEncryption) {
  this.dumpelloEncryption_ = dumpelloEncryption;
  return this;
};


/**
 * @return {!Array.<string>} A set of keys used for encryption/decryption.
 */
drive.ds.sync.SyncedConfig.prototype.getIndexedDbKeys = function() {
  return this.indexedDbKeys_;
};


/**
 * @param {!Array.<string>} indexedDbKeys A list of keys used for
 *     encryption/decryption.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setIndexedDbKeys =
    function(indexedDbKeys) {
  this.indexedDbKeys_ = indexedDbKeys;
  return this;
};


/**
 * @return {string} The Explorer XSRF token.
 */
drive.ds.sync.SyncedConfig.prototype.getExplorerXsrfToken = function() {
  return this.explorerXsrfToken_;
};


/**
 * @param {string} token The Explorer XSRF token.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setExplorerXsrfToken = function(token) {
  this.explorerXsrfToken_ = token;
  return this;
};


/**
 * @return {boolean} Whether the client wants to receive native Javascript
 *     errors instead of drive.ds.Error's.
 */
drive.ds.sync.SyncedConfig.prototype.getReturnJsErrors = function() {
  return this.returnJsErrors_;
};


/**
 * @param {boolean} jsErrors Whether we should return native Javascript errors.
 *     If false, instances of drive.ds.Error are returned.
 * @return {!drive.ds.sync.SyncedConfig} This object for chaining.
 */
drive.ds.sync.SyncedConfig.prototype.setReturnJsErrors = function(jsErrors) {
  this.returnJsErrors_ = jsErrors;
  return this;
};


/**
 * Validates that the current configuration is acceptable.
 */
drive.ds.sync.SyncedConfig.prototype.validate = function() {
  // TODO(towong): Tango is only available for Prod apiary currently, make this
  // work test Apiary.
  if (this.useQualCosmo_) {
    this.changeHandler_ = drive.ds.sync.SyncedConfig.ChangeHandler.POLLING;
  }

  if (this.getFirstPartyClientId() ==
      drive.ds.sync.SyncedConfig.FirstPartyClientId.EXPLORER) {
    goog.asserts.assert(this.getUseDumpello(),
        'Explorer uses client change log processing which requires Dumpello.');
  }
};

//javascript/apps/drive/dataservice/sync/cache/dumpellocachepopulator.js
goog.provide('drive.ds.sync.cache.DumpelloCachePopulator');

goog.require('drive.ds.Dumpello');
goog.require('drive.ds.sync.cache.CachePopulator');
goog.require('drive.ds.sync.stat.Stopwatch');
goog.require('goog.debug.Logger');
goog.require('goog.math.Long');



/**
 * A cache populator that attempts to load an encrypted dumpello from indexeddb,
 * if no local encrypted dumpello is available we fetch the data.
 *
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.cache.CachePopulator}
 * @constructor
 */
drive.ds.sync.cache.DumpelloCachePopulator = function(context) {
  goog.base(this);

  /** @protected {!drive.ds.sync.Context} The app context. */
  this.context = context;

  /** @protected {!goog.debug.Logger} */
  this.logger = goog.debug.Logger.getLogger(
      'drive.ds.sync.cache.DumpelloCachePopulator');

  /**
   * The stopwatch for performance timing.
   * @private {!drive.ds.sync.stat.Stopwatch}
   */
  this.stopwatch_ = new drive.ds.sync.stat.Stopwatch();
};
goog.inherits(drive.ds.sync.cache.DumpelloCachePopulator,
    drive.ds.sync.cache.CachePopulator);


/**
 * Attempts to load the dumpello from the encrypted store if available,
 * otherwise leaves it up to the implementation to load it.
 * @override
 */
drive.ds.sync.cache.DumpelloCachePopulator.prototype.run = function() {
  this.context.getEncryptedDumpello() ?
      this.loadFromIndexedDb_(0) : this.getDumpello();
};


/**
 * Implementation specific logic for fetching a dumpello.
 * @protected
 */
drive.ds.sync.cache.DumpelloCachePopulator.prototype.getDumpello =
    goog.abstractMethod;


/**
 * Tries to load the dumpello from indexed db using the given key in the index.
 * If no keys are available we fallback to fetching the dumpello.
 * @param {number} keyIndex The index of the decryption key to use.
 * @private
 */
drive.ds.sync.cache.DumpelloCachePopulator.prototype.loadFromIndexedDb_ =
    function(keyIndex) {
  var key = this.context.getConfig().getIndexedDbKeys()[keyIndex];
  if (!key) {
    this.getDumpello();
    return;
  }

  var gaiaId = this.context.getConfig().getGaiaId();
  var deferred = this.context.getEncryptedDumpello().get(gaiaId, key);
  deferred.addCallback(
      goog.partial(this.tryProcessingDecryptedJson_, keyIndex), this);
};


/**
 * Tries to process a decrypted json. If the json fails to parse, we attempt to
 * decrypt the json with the next key.
 * TODO(towong): Get more information about key so we can determine which key to
 *     use without actually performing decryption.
 * @param {number} keyIndex The index of the decryption key to use.
 * @param {string} response The json response string containing the dumpello, or
 *     undefined in the case of a bad json (ex. integrity check failed).
 * @private
 */
drive.ds.sync.cache.DumpelloCachePopulator.prototype.
    tryProcessingDecryptedJson_ = function(keyIndex, response) {
  var success = false;

  if (response) {
    success = this.processResponse(response, true);
  }

  if (success) {
    this.dispatchEvent(drive.ds.sync.cache.CachePopulator.EventType.COMPLETE);
  } else {
    this.loadFromIndexedDb_(keyIndex + 1);
  }
};


/** @override */
drive.ds.sync.cache.DumpelloCachePopulator.prototype.isGenoaRequired =
    function() {
  return false;
};


/**
 * Processes the response.
 *
 * @param {string} response The json response string containing the
 *     dumpello.
 * @param {boolean=} opt_skipEncryptedDumpello Skips writing to the encrypted
 *     dumpello, defaults to false.
 * @return {boolean} Whether the response was processed successfully.
 * @protected
 */
drive.ds.sync.cache.DumpelloCachePopulator.prototype.processResponse =
    function(response, opt_skipEncryptedDumpello) {
  this.stopwatch_.start();

  // We use JSON.parse instead of goog.json.parse because it is significantly
  // faster and safer.  JSON.parse is well supported in all tier 1 browsers
  // that we care about.
  var dump = '';
  try {
    dump = new drive.ds.Dumpello(/** @type {!Array} */ (JSON.parse(response)));
  } catch (e) {
    return false;
  }

  // Load the root id.
  if (dump.getRootId()) {
    this.context.getMetadataStore().setRootId(
        /** @type {string} */ (dump.getRootId()));
  }

  // Load the items.
  var items = dump.getItemList();
  this.logger.info('Adding items to cache ' + items.length);
  this.context.getCache().bulkImport(items, dump.getPermissionList());

  // Load the supported queries.
  if (!dump.getPartial()) {
    this.context.setFullCorpusCached();
  } else {
    this.context.getQueryCache().bulkImport(dump.getSupportedQueryList());
  }

  // Load the change id.
  var changeId = goog.math.Long.fromNumber(dump.getChangeId() || 0);
  this.context.getMetadataStore().setLastChangeId(changeId);

  if (!opt_skipEncryptedDumpello) {
    this.updateEncryptedDumpello_(response);
  }

  this.stopwatch_.stop();
  this.logger.info(
      'Parsing dumpello took ' + this.stopwatch_.getElapsedTimeMillis() + 'ms');

  this.context.setInitViaDumpello(true);

  return true;
};


/**
 * Updates the encrypted dumpello asynchronously.
 * @param {string} json The dumpello in json form.
 * @private
 */
drive.ds.sync.cache.DumpelloCachePopulator.prototype.updateEncryptedDumpello_ =
    function(json) {
  var updater = this.context.getEncryptedDumpelloUpdater();
  // TODO(towong): Maybe add an async priority based job processor? Currently
  // just using setTimeout with an arbitrary 2000ms delay.
  goog.global.setTimeout(goog.bind(updater.put, updater, json), 2000);
};

//javascript/apps/drive/dataservice/sync/cache/clientdumpellocachepopulator.js
goog.provide('drive.ds.sync.cache.ClientDumpelloCachePopulator');

goog.require('drive.ds.sync.cache.CachePopulator');
goog.require('drive.ds.sync.cache.DumpelloCachePopulator');



/**
 * A cache populator that loads a metadata dump provided by the client.
 *
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.cache.DumpelloCachePopulator}
 * @constructor
 */
drive.ds.sync.cache.ClientDumpelloCachePopulator = function(context) {
  goog.base(this, context);
};
goog.inherits(drive.ds.sync.cache.ClientDumpelloCachePopulator,
    drive.ds.sync.cache.DumpelloCachePopulator);


/** @override */
drive.ds.sync.cache.ClientDumpelloCachePopulator.prototype.getDumpello =
    function() {
  // Note: On getDumpello we do nothing and wait for the client to load the
  // initial dumpello.
};


/** @override */
drive.ds.sync.cache.ClientDumpelloCachePopulator.prototype.isGenoaRequired =
    function() {
  return false;
};


/**
 * Loads the initial dumpello.
 * @param {string} initialDumpello The initial dumpello as a json string.
 */
drive.ds.sync.cache.ClientDumpelloCachePopulator.prototype.loadInitialDumpello =
    function(initialDumpello) {
  var success = this.processResponse(initialDumpello);

  this.dispatchEvent(success ?
      drive.ds.sync.cache.CachePopulator.EventType.COMPLETE :
      drive.ds.sync.cache.CachePopulator.EventType.ERROR);
};

//javascript/apps/drive/dataservice/sync/query/queryeventtype.js
goog.provide('drive.ds.sync.query.QueryEventType');

goog.require('goog.events');


/**
 * Query runner related event types.
 * @enum {string}
 */
drive.ds.sync.query.QueryEventType = {
  /**
   * Event indicates that an additional Genoa query has been processed and
   * updates pushed to the cache.
   */
  CHANGED: goog.events.getUniqueId('changed'),

  /**
   * Event indicates that this query has completed by either reaching the
   * desired max items or finished exhaustively requerying with the
   * nextPageToken.
   */
  COMPLETED: goog.events.getUniqueId('completed'),

  /**
   * Event indicates that an error is encountered performing the query.
   */
  ERROR: goog.events.getUniqueId('error')
};

//javascript/apps/drive/dataservice/sync/response/responseerrorparser.js
goog.provide('drive.ds.sync.response.ResponseErrorParser');

goog.require('drive.ds.Error');

/**
 * Parses the given response for an error.
 * @param {!Object} response The response from the Genoa API.
 * @return {drive.ds.Error} An instance of drive.ds.Error if an error is
 *     detected, null otherwise.
 */
drive.ds.sync.response.ResponseErrorParser.parse = function(response) {
  // Check for errors from the Genoa API.
  var responseError = response['error'];
  if (responseError) {
    var error = new drive.ds.Error();
    error.setType(drive.ds.Error.Type.RUNTIME);
    // TODO(paulcheong): 'errorDetail' here is to handle XHR responses from
    // a server endpoint for activities. Remove once moved to Genoa.
    error.setMessage(response['errorDetail'] ||
        (responseError['code'] + ' ' + responseError['message']));

    var errors = responseError['errors'] || responseError['data'];
    if (errors && errors.length > 0) {
      error.setDetail(errors[0]['debugInfo']);
    }

    return error;
  }
  return null;
};

//javascript/apps/drive/dataservice/sync/query/queryerrorevent.js
goog.provide('drive.ds.sync.query.QueryErrorEvent');

goog.require('drive.ds.sync.query.QueryEventType');
goog.require('goog.events.Event');



/**
 * An event dispatched when an error occurs performing the query.
 * @param {!drive.ds.Error} error The query error.
 * @param {number} retryCount The retry count.
 * @extends {goog.events.Event}
 * @constructor
 * @const
 */
drive.ds.sync.query.QueryErrorEvent = function(error, retryCount) {
  goog.base(this, drive.ds.sync.query.QueryEventType.ERROR);

  /** @type {!drive.ds.Error} The query error. */
  this.error = error;

  /**
   * How many times this query has been retried.
   * @type {number}
   */
  this.retryCount = retryCount;

};
goog.inherits(drive.ds.sync.query.QueryErrorEvent, goog.events.Event);

//javascript/apps/drive/dataservice/sync/query/queryrunner.js
goog.provide('drive.ds.sync.query.QueryRunner');

goog.require('drive.ds.sync.ExponentialBackoff');
goog.require('drive.ds.sync.api.Files');
goog.require('drive.ds.sync.query.QueryErrorEvent');
goog.require('drive.ds.sync.query.QueryEventType');
goog.require('drive.ds.sync.response.ResponseErrorParser');
goog.require('goog.array');
goog.require('goog.async.Deferred');
goog.require('goog.events.EventTarget');



/**
 * A query runner responsible for running a particular query against Genoa and
 * updating the cache with it. Performs paging logic against Genoa to try to get
 * up to the request number of items back. The cache is updated on each
 * query against Genoa if new data is returned.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {goog.events.EventTarget}
 * @constructor
 * @const
 * @struct
 * @suppress {checkStructDictInheritance}
 */
drive.ds.sync.query.QueryRunner = function(request, context) {
  goog.base(this);

  /** @private {!drive.ds.ItemQueryRequest} The item query request. */
  this.request_ = request;

  /** @private {!drive.ds.sync.Context} The app context. */
  this.context_ = context;

  /** @private {boolean} Whether the query has been run before. */
  this.hasRun_ = false;

  /** @private {string} The next page token. */
  this.nextPageToken_ = '';

  /** @private {number} The maximum number of items to get. */
  this.maxItems_ = 0;

  /** @private {!Array.<string>} List of IDs that matched the query. */
  this.ids_ = [];

  /**
   * Whether this process is currently fetching more data.
   * @private {boolean}
   */
  this.fetching_ = false;

  /** @private {!drive.ds.sync.ExponentialBackoff} */
  this.nextRetry_ = new drive.ds.sync.ExponentialBackoff();
};
goog.inherits(drive.ds.sync.query.QueryRunner, goog.events.EventTarget);


/**
 * Checks whether there is more data to be fetched by this particular query
 * request.
 * @return {boolean} Whether there is more data to be fetched from Genoa.
 */
drive.ds.sync.query.QueryRunner.prototype.hasMoreItems = function() {
  return !this.hasRun_ || this.nextPageToken_ != '';
};


/**
 * Updates the max items. This also initiates queries against Genoa as needed to
 * fetch data to reach the new desired max items.
 * @param {number} maxItems The max number of items to retrieve.
 * @return {!goog.async.Deferred.<undefined>} Will fire when this function is
 *     done loading more data.
 */
drive.ds.sync.query.QueryRunner.prototype.setMaxItemsAndRun =
    function(maxItems) {
  this.maxItems_ = Math.max(this.maxItems_, maxItems);

  if (this.ids_.length < this.maxItems_ && !this.fetching_ &&
      this.hasMoreItems()) {
    return this.getMoreItems_();
  } else {
    // TODO(omerkling): Return the currently running deferred if we are
    // already fetching data.
    return goog.async.Deferred.succeed();
  }
};


/**
 * @return {!Array.<string>} A list of ids of items that matched this request.
 */
drive.ds.sync.query.QueryRunner.prototype.getIds = function() {
  return goog.array.clone(this.ids_);
};


/**
 * Sends a request to fetch additional data from Genoa and pushes the data to
 * the cache.
 * @return {!goog.async.Deferred.<undefined>} Deferred that will be fired when
 *     items have finished loading.
 * @private
 */
drive.ds.sync.query.QueryRunner.prototype.getMoreItems_ = function() {
  this.hasRun_ = true;
  this.fetching_ = true;

  var deferred = new goog.async.Deferred();
  drive.ds.sync.api.Files.search(this.request_,
      goog.bind(this.handleResponse_, this, deferred),
      this.context_.getFields(), this.nextPageToken_);
  deferred.addCallback(this.handleMoreItems_, this);
  deferred.addErrback(this.handleError_, this);

  // This deferred will block if handleMoreItems_ returns a deferred.
  return deferred;
};


/**
 * Parses the items and next page token from the request.
 * @param {!goog.async.Deferred.<!Array.<!drive.ds.Item>>} deferred The deferred
 *     result object.
 * @param {!Object} response The response from Genoa.
 * @private
 */
drive.ds.sync.query.QueryRunner.prototype.handleResponse_ =
    function(deferred, response) {
  var error = drive.ds.sync.response.ResponseErrorParser.parse(response);
  if (error) {
    deferred.errback(error);
  } else {
    var responseProto = this.context_.getResponseParser().parseItems(response);
    var items = responseProto.getItemList();
    this.nextPageToken_ =
        this.context_.getResponseParser().parseNextPageToken(response);
    deferred.callback(items);
  }
};


/**
 * Handle more items returned from Genoa. We update the cache with the latest
 * items, then requery against Genoa for more as needed.
 * @param {!Array.<!drive.ds.Item>} items The list of matching items.
 * @return {!goog.async.Deferred.<undefined>|undefined} Undefined if all items
 *     have been fetched.
 * @private
 */
drive.ds.sync.query.QueryRunner.prototype.handleMoreItems_ =
    function(items) {
  this.nextRetry_.reset();
  this.context_.getCache().bulkImport(items);
  for (var i = 0; i < items.length; i++) {
    this.ids_.push(items[i].getId());
  }

  if (this.ids_.length < this.maxItems_ && this.nextPageToken_) {
    this.dispatchEvent(drive.ds.sync.query.QueryEventType.CHANGED);
    return this.getMoreItems_();
  } else {
    this.fetching_ = false;
    this.dispatchEvent(drive.ds.sync.query.QueryEventType.COMPLETED);
    return undefined;
  }
};


/**
 * Handles an error response from querying against Genoa.
 * @param {!drive.ds.Error} error Error from Genoa.
 * @private
 */
drive.ds.sync.query.QueryRunner.prototype.handleError_ = function(error) {
  this.nextRetry_.backoff();
  // TODO(towong) Check error and only do retry on intermittent errors.
  // Permanent errors should dispatch an ERROR event.
  goog.global.setTimeout(goog.bind(this.getMoreItems_, this),
      this.nextRetry_.getValue());

  this.dispatchEvent(new drive.ds.sync.query.QueryErrorEvent(
      error, this.nextRetry_.getBackoffCount() - 1));
};


/**
 * @return {boolean} Whether the query is still fetching.
 */
drive.ds.sync.query.QueryRunner.prototype.isFetching = function() {
  return this.fetching_;
};

//javascript/apps/drive/dataservice/sync/cache/foldercachepopulationstrategy.js
goog.provide('drive.ds.sync.cache.FolderCachePopulationStrategy');

goog.require('drive.ds.ItemQueryRequest');
goog.require('drive.ds.MimeTypeSpec');
goog.require('drive.ds.sync.FolderUtil');
goog.require('drive.ds.sync.cache.CachePopulationStrategy');



/**
 * A cache populator strategy that queries for all the users folders. This
 * helps populate the cache with folders so we can answer the HAS_CHILD_FOLDER
 * query.
 * Note(towong): This is a stop gap solution until we either get the
 * HAS_CHILD_FOLDER bit from Genoa or Dumpello fully populates the cache for us.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!drive.ds.sync.query.QueryManager} queryManager The query manager.
 * @extends {drive.ds.sync.cache.CachePopulationStrategy}
 * @constructor
 */
drive.ds.sync.cache.FolderCachePopulationStrategy = function(
    context, queryManager) {
  goog.base(this, context, queryManager);

  /**
   * Whether the query runner has been retrieved.
   * @private {boolean}
   */
  this.retrieved_ = false;
};
goog.inherits(drive.ds.sync.cache.FolderCachePopulationStrategy,
    drive.ds.sync.cache.CachePopulationStrategy);


/** @override */
drive.ds.sync.cache.FolderCachePopulationStrategy.prototype.getNextRunner =
    function() {
  var queryRunner = null;

  if (this.hasMoreRunners()) {
    var mimeTypeSpec = new drive.ds.MimeTypeSpec();
    mimeTypeSpec.setValue(drive.ds.sync.FolderUtil.MIME_TYPE);

    var request = new drive.ds.ItemQueryRequest();
    request.setMimeTypeList([mimeTypeSpec]);
    request.setTrashed(false);

    this.retrieved_ = true;
    queryRunner = this.getQueryManager().getQueryRunner(request);
  }

  return queryRunner;
};


/** @override */
drive.ds.sync.cache.FolderCachePopulationStrategy.prototype.hasMoreRunners =
    function() {
  return !this.retrieved_;
};


/** @override */
drive.ds.sync.cache.FolderCachePopulationStrategy.prototype.getMaxItems =
    function() {
  // We return some large number so that this fetches all the folders in the
  // user's corpus.
  return 100000;
};

//javascript/apps/drive/dataservice/sync/cache/mydrivecachepopulationstrategy.js
goog.provide('drive.ds.sync.cache.MyDriveCachePopulationStrategy');

goog.require('drive.ds.ItemQueryRequest');
goog.require('drive.ds.MimeTypeSpec');
goog.require('drive.ds.ParentSpec');
goog.require('drive.ds.SortSpec');
goog.require('drive.ds.sync.FolderUtil');
goog.require('drive.ds.sync.cache.CachePopulationStrategy');
goog.require('drive.ds.sync.query.QueryEventType');
goog.require('drive.ds.sync.query.QueryRunner');
goog.require('goog.array');
goog.require('goog.events.EventHandler');
goog.require('goog.structs.Queue');



/**
 * A cache population strategy that works by querying for the contents of
 * the user Drive by performing a partial breadth first search starting with the
 * root.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!drive.ds.sync.query.QueryManager} queryManager The query manager.
 * @extends {drive.ds.sync.cache.CachePopulationStrategy}
 * @constructor
 */
drive.ds.sync.cache.MyDriveCachePopulationStrategy =
    function(context, queryManager) {
  goog.base(this, context, queryManager);

  /** @private {!goog.events.EventHandler} */
  this.eventHandler_ = new goog.events.EventHandler();
  this.registerDisposable(this.eventHandler_);

  /**
   * A list of parents that have been queried before.
   * @private {!Array.<string>}
   */
  this.parents_ = ['root'];

  /**
   * A FIFO queue of parents to process.
   * @private {!goog.structs.Queue.<string>}
   */
  this.queue_ = new goog.structs.Queue();
  this.queue_.enqueue('root');
};
goog.inherits(drive.ds.sync.cache.MyDriveCachePopulationStrategy,
    drive.ds.sync.cache.CachePopulationStrategy);


/** @override */
drive.ds.sync.cache.MyDriveCachePopulationStrategy.prototype.getNextRunner =
    function() {
  var queryRunner = null;

  if (this.hasMoreRunners()) {
    var parentId = /** @type {string} */ (this.queue_.dequeue());
    var request = this.findByParentIdRequest_(parentId);
    queryRunner = this.getQueryManager().getQueryRunner(request);

    // Attach handler to figure out new folders and enqueue them.
    this.eventHandler_.listenOnce(queryRunner,
        drive.ds.sync.query.QueryEventType.COMPLETED,
        goog.bind(this.handleChildrenLoaded_, this, parentId));
  }

  return queryRunner;
};


/** @override */
drive.ds.sync.cache.MyDriveCachePopulationStrategy.prototype.hasMoreRunners =
    function() {
  return this.queue_.getCount() > 0;
};


/**
 * Handles a request completed. The child folders of the parent are added to the
 * queue if they haven't been queried before.
 * @param {string} parentId The parent id of the find by parent id request.
 * @private
 */
drive.ds.sync.cache.MyDriveCachePopulationStrategy.prototype.
    handleChildrenLoaded_ = function(parentId) {
  var request = this.findFoldersByParentIdRequest_(parentId);
  this.getContext().getCache().query(request, -1).
      addCallback(goog.bind(this.processFolders_, this));
};


/**
 * Processes the result of the folder query, adding folders we haven't processed
 * yet to the queue.
 * @param {!drive.ds.ItemQueryResponse} response The query response.
 * @private
 */
drive.ds.sync.cache.MyDriveCachePopulationStrategy.prototype.processFolders_ =
    function(response) {
  var folders = response.getItemList();
  for (var i = 0; i < folders.length; i++) {
    var folderId = folders[i].getId();

    // Enqueue the folder for exploration if we haven't performed a get children
    // by parent id on it before.
    if (!goog.array.contains(this.parents_, folderId)) {
      this.parents_.push(folderId);
      this.queue_.enqueue(folderId);
    }
  }

  if (folders.length) {
    this.dispatchEvent(
        drive.ds.sync.cache.CachePopulationStrategy.EventType.CHANGED);
  }
};


/**
 * Creates a find by parent id request.
 * @param {string} parentId The parent id.
 * @return {!drive.ds.ItemQueryRequest} The item query request.
 * @private
 */
drive.ds.sync.cache.MyDriveCachePopulationStrategy.prototype.
    findByParentIdRequest_ = function(parentId) {
  var parentSpec = new drive.ds.ParentSpec();
  parentSpec.setValue(parentId);

  var sortSpec = new drive.ds.SortSpec();
  sortSpec.setType(drive.ds.SortSpec.Type.TITLE);

  var request = new drive.ds.ItemQueryRequest();
  request.setTrashed(false);
  request.setParentList([parentSpec]);
  request.setSort(sortSpec);

  return request;
};


/**
 * Creates a find folders by parent id request.
 * @param {string} parentId The parent id.
 * @return {!drive.ds.ItemQueryRequest} The item query request.
 * @private
 */
drive.ds.sync.cache.MyDriveCachePopulationStrategy.prototype.
    findFoldersByParentIdRequest_ = function(parentId) {
  var request = this.findByParentIdRequest_(parentId);
  var mimeTypeSpec = new drive.ds.MimeTypeSpec();
  mimeTypeSpec.setValue(drive.ds.sync.FolderUtil.MIME_TYPE);
  request.setMimeTypeList([mimeTypeSpec]);
  return request;
};

//javascript/apps/drive/dataservice/sync/cache/sharedwithmepopulationstrategy.js
goog.provide('drive.ds.sync.cache.SharedWithMeCachePopulationStrategy');

goog.require('drive.ds.DateSpec');
goog.require('drive.ds.ItemQueryRequest');
goog.require('drive.ds.sync.cache.CachePopulationStrategy');



/**
 * A cache population strategy that queries for recently shared with me
 * items.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!drive.ds.sync.query.QueryManager} queryManager The query manager.
 * @extends {drive.ds.sync.cache.CachePopulationStrategy}
 * @constructor
 */
drive.ds.sync.cache.SharedWithMeCachePopulationStrategy = function(
    context, queryManager) {
  goog.base(this, context, queryManager);

  /**
   * Whether the query runner has been retrieved.
   * @private {boolean}
   */
  this.retrieved_ = false;
};
goog.inherits(drive.ds.sync.cache.SharedWithMeCachePopulationStrategy,
    drive.ds.sync.cache.CachePopulationStrategy);


/** @override */
drive.ds.sync.cache.SharedWithMeCachePopulationStrategy.prototype.
    getNextRunner = function() {
  var queryRunner = null;

  if (this.hasMoreRunners()) {
    // Note: Querying by shared with me date not supported by Genoa, we use
    // modified date as a reasonable heuristic for finding matches.
    var modifiedDate = new drive.ds.DateSpec();
    modifiedDate.setOperator(drive.ds.DateSpec.Operator.GREATER_THAN);
    modifiedDate.setDateMillis(Number(new Date() - 30 * 24 * 60 * 60 * 1000));

    var request = new drive.ds.ItemQueryRequest();
    request.setSharedWithMe(true);
    request.setModifiedDateList([modifiedDate]);
    request.setTrashed(false);

    this.retrieved_ = true;
    queryRunner = this.getQueryManager().getQueryRunner(request);
  }

  return queryRunner;
};


/** @override */
drive.ds.sync.cache.SharedWithMeCachePopulationStrategy.prototype.
    hasMoreRunners = function() {
  return !this.retrieved_;
};

//javascript/apps/drive/dataservice/sync/cache/prefetchcachepopulator.js
goog.provide('drive.ds.sync.cache.PrefetchCachePopulator');

goog.require('drive.ds.sync.cache.CachePopulationStrategy');
goog.require('drive.ds.sync.cache.CachePopulator');
goog.require('drive.ds.sync.cache.FolderCachePopulationStrategy');
goog.require('drive.ds.sync.cache.MyDriveCachePopulationStrategy');
goog.require('drive.ds.sync.cache.SharedWithMeCachePopulationStrategy');
goog.require('drive.ds.sync.query.QueryEventType');
goog.require('drive.ds.sync.query.QueryRunner');
goog.require('goog.events.EventHandler');
goog.require('goog.structs.Queue');



/**
 * A cache populator that fills the cache by prefetching data for common drive
 * queries. The drive queries are provided by cache population strategies and
 * this class is responsible for deciding which strategies to run as capacity
 * becomes available.
 * TODO(towong): Fire a COMPLETE event on completion.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!drive.ds.sync.query.QueryManager} queryManager The query manager.
 * @extends {drive.ds.sync.cache.CachePopulator}
 * @constructor
 */
drive.ds.sync.cache.PrefetchCachePopulator = function(context, queryManager) {
  goog.base(this);

  /**
   * The event handler.
   * @private {!goog.events.EventHandler}
   */
  this.eventHandler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.eventHandler_);

  /**
   * The app context
   * @private {!drive.ds.sync.Context}
   */
  this.context_ = context;

  /**
   * The query manager.
   * @private {!drive.ds.sync.query.QueryManager}
   */
  this.queryManager_ = queryManager;

  /**
   * A FIFO queue of cache populators to process.
   * @private {!goog.structs.Queue.<
   *     !drive.ds.sync.cache.CachePopulationStrategy>}
   */
  this.queue_ = new goog.structs.Queue();

  /**
   * The count of currently running query runners.
   * @private {number}
   */
  this.running_ = 0;
};
goog.inherits(drive.ds.sync.cache.PrefetchCachePopulator,
    drive.ds.sync.cache.CachePopulator);


/**
 * The maximum number of query runners that can run at the same time.
 * @private {number}
 */
drive.ds.sync.cache.PrefetchCachePopulator.MAX_RUNNERS_ = 8;


/** @override */
drive.ds.sync.cache.PrefetchCachePopulator.prototype.run = function() {
  var myDriveStrategy = new drive.ds.sync.cache.MyDriveCachePopulationStrategy(
      this.context_, this.queryManager_);
  this.registerDisposable(myDriveStrategy);

  var folderStrategy = new drive.ds.sync.cache.FolderCachePopulationStrategy(
      this.context_, this.queryManager_);
  this.registerDisposable(folderStrategy);

  var sharedWithMeStrategy = new drive.ds.sync.cache.
      SharedWithMeCachePopulationStrategy(this.context_, this.queryManager_);
  this.registerDisposable(sharedWithMeStrategy);

  // Add listeners for any cache population strategies that might have been
  // updated.
  this.eventHandler_.listen(myDriveStrategy,
      drive.ds.sync.cache.CachePopulationStrategy.EventType.CHANGED,
      goog.bind(this.handleStrategyChanged_, this, myDriveStrategy));

  this.queue_.enqueue(myDriveStrategy);
  this.queue_.enqueue(sharedWithMeStrategy);
  this.queue_.enqueue(folderStrategy);

  this.processQueue_();
};


/**
 * Process the queue of cache population strategies by popping a strategy off
 * the queue to get the next query runner to run if there is available capacity.
 * If the strategy still has additional query runners, we re-queue the strategy.
 * @private
 */
drive.ds.sync.cache.PrefetchCachePopulator.prototype.processQueue_ =
    function() {
  if (this.running_ < drive.ds.sync.cache.PrefetchCachePopulator.MAX_RUNNERS_ &&
      this.queue_.getCount()) {
    // Run next query runner.
    var strategy = this.queue_.dequeue();
    var queryRunner = strategy.getNextRunner();

    if (queryRunner) {
      queryRunner.setMaxItemsAndRun(strategy.getMaxItems());
      this.running_++;

      this.eventHandler_.listen(queryRunner,
          drive.ds.sync.query.QueryEventType.COMPLETED,
          goog.bind(this.handleQueryRunnerCompleted_, this));

      // Enqueue strategy if there are more query runners.
      if (strategy.hasMoreRunners()) {
        this.queue_.enqueue(strategy);
      }
    }

    // Try to process more if available.
    if (this.queue_.getCount()) {
      this.processQueue_();
    }
  }
};


/**
 * Handles a strategy changed event. Check if the strategy has more
 * runners and requeues it as needed.
 * @param {!drive.ds.sync.cache.CachePopulationStrategy} strategy The cache
 *     population strategy to check.
 * @private
 */
drive.ds.sync.cache.PrefetchCachePopulator.prototype.handleStrategyChanged_ =
    function(strategy) {
  if (!this.queue_.contains(strategy) && strategy.hasMoreRunners()) {
    this.queue_.enqueue(strategy);
    this.processQueue_();
  }
};


/**
 * Handles query runner completion.
 * @private
 */
drive.ds.sync.cache.PrefetchCachePopulator.prototype.
    handleQueryRunnerCompleted_ = function() {
  this.running_--;

  // Attempt to process another cache population strategy with newly freed
  // capacity.
  this.processQueue_();
};


/** @override */
drive.ds.sync.cache.PrefetchCachePopulator.prototype.disposeInternal =
    function() {
  goog.base(this, 'disposeInternal');

  this.queue_.clear();
  delete this.queue_;
};

//javascript/apps/drive/dataservice/sync/cache/remotedumpellocachepopulator.js
goog.provide('drive.ds.sync.cache.RemoteDumpelloCachePopulator');

goog.require('drive.ds.sync.cache.CachePopulator');
goog.require('drive.ds.sync.cache.DumpelloCachePopulator');
goog.require('goog.Uri');
goog.require('goog.debug.Logger');
goog.require('goog.events.EventHandler');
goog.require('goog.net.EventType');
goog.require('goog.net.XhrIo');
goog.require('goog.net.XmlHttp');
goog.require('goog.string');



/**
 * A cache populator that loads a metadata dump by making an XHR request to
 * Explorer to generate a Dumpello.
 *
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.cache.DumpelloCachePopulator}
 * @constructor
 */
drive.ds.sync.cache.RemoteDumpelloCachePopulator = function(context) {
  goog.base(this, context);

  // This property is false in compiled mode anyway,
  // but in uncompiled mode, turning this off makes Deferreds _much_ faster
  // to construct.  Uncomment this to get this behavior--can't leave this on
  // because the closure compiler complains.
  // TODO(ericzhang): Figure out if there's a better way to do this.
  // goog.async.Deferred.LONG_STACK_TRACES = false;

  /**
   * XHR handler.
   * @private {!goog.net.XhrIo}
   */
  this.xhrIo_ = new goog.net.XhrIo();
  this.registerDisposable(this.xhrIo_);

  /** @protected {!goog.debug.Logger} */
  this.logger = goog.debug.Logger.getLogger(
      'drive.ds.sync.cache.RemoteDumpelloCachePopulator');

  /** @private {!goog.events.EventHandler} */
  this.eventHandler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.eventHandler_);

  // Add listeners to handle XhrIo completion/ready.
  this.eventHandler_.listen(this.xhrIo_,
      goog.net.EventType.READY_STATE_CHANGE, this.handleXhrReadyState_);
  this.eventHandler_.listen(this.xhrIo_,
      goog.net.EventType.ERROR, this.handleXhrError_);
};
goog.inherits(drive.ds.sync.cache.RemoteDumpelloCachePopulator,
    drive.ds.sync.cache.DumpelloCachePopulator);


/**
 * The XSSI prefix to strip.  We also jam in the start of the item array
 * to simplify the parsing logic.
 * @private {string}
 */
drive.ds.sync.cache.RemoteDumpelloCachePopulator.XSSI_PREFIX_ = ')]}\'\n';


/**
 * Current seek index in response text.
 * @type {number}
 * @private
 */
drive.ds.sync.cache.RemoteDumpelloCachePopulator.prototype.currentIndex_ = 0;


/** @override */
drive.ds.sync.cache.RemoteDumpelloCachePopulator.prototype.getDumpello =
    function() {
  // Note that the Dumpello endpoint will either return a file containing the
  // dumpello or an empty response if the number of items in the user's corpus
  // exceeds the maximum that the client is willing to handle.

  var uri = goog.Uri.parse('/du');

  var limit = this.context.getConfig().getDumpelloMaxItems();
  if (limit > 0) {
    uri.setParameterValue('limit', limit);
  }

  var session = this.context.getConfig().getGaiaSessionId();
  if (goog.isDefAndNotNull(session)) {
    uri.setParameterValue('authuser', session);
  }

  var dumpelloIncludeChanges =
      this.context.getConfig().getDumpelloIncludeChanges();
  uri.setParameterValue('applychangelog', dumpelloIncludeChanges);

  this.xhrIo_.send(uri.toString(), 'GET', '', {'X-Json-Requested': 'true'});
};


/** @override */
drive.ds.sync.cache.RemoteDumpelloCachePopulator.prototype.isGenoaRequired =
    function() {
  return false;
};


/**
 * Handles an XHR error.
 * @private
 */
drive.ds.sync.cache.RemoteDumpelloCachePopulator.prototype.handleXhrError_ =
    function() {
  this.logger.info('Error loading dumpello cache ' + this.xhrIo_.getStatus());
  this.dispatchEvent(drive.ds.sync.cache.CachePopulator.EventType.ERROR);
};


/**
 * Handles XHR ready state changes.
 * @private
 */
drive.ds.sync.cache.RemoteDumpelloCachePopulator.prototype.
    handleXhrReadyState_ = function() {
  // TODO(ericzhang): Consider streaming in the data with websockets
  // or something.
  if (this.xhrIo_.isSuccess() &&
      this.xhrIo_.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE) {
    this.logger.info('Loading dumpello content, current size ' +
        this.xhrIo_.getResponseText().length);

    var success = this.processXhrResponse_();
    if (success) {
      this.dispatchEvent(drive.ds.sync.cache.CachePopulator.EventType.COMPLETE);
    } else {
      // Fire an ERROR event on empty dumpello.
      this.dispatchEvent(drive.ds.sync.cache.CachePopulator.EventType.ERROR);
    }
  }
};


/**
 * Processes the XHR response.
 *
 * Adapted from
 * https://cs.corp.google.com/#google3/javascript/apps/docs/app/servermodelfetcher.js
 *
 * @return {boolean} Whether the response was processed successfully.
 * @private
 */
drive.ds.sync.cache.RemoteDumpelloCachePopulator.prototype.processXhrResponse_ =
    function() {
  // Get the response and find the next separator.
  var response = this.xhrIo_.getResponseText();

  // Asserts that the JSON safety prefix is at the beginning.
  if (this.currentIndex_ == 0) {
    var xssiPrefix =
        drive.ds.sync.cache.RemoteDumpelloCachePopulator.XSSI_PREFIX_;
    if (response && response.length >= xssiPrefix.length) {
      if (goog.string.startsWith(response, xssiPrefix)) {
        response = response.substring(xssiPrefix.length);
      } else {
        return false;
      }
    } else {
      return false;
    }
  }

  return this.processResponse(response);
};

//javascript/apps/drive/dataservice/sync/cache/cachepopulatormanager.js
goog.provide('drive.ds.sync.cache.CachePopulatorManager');

goog.require('drive.ds.sync.SyncedConfig');
goog.require('drive.ds.sync.cache.CachePopulator');
goog.require('drive.ds.sync.cache.ClientDumpelloCachePopulator');
goog.require('drive.ds.sync.cache.PrefetchCachePopulator');
goog.require('drive.ds.sync.cache.RemoteDumpelloCachePopulator');
goog.require('goog.asserts');
goog.require('goog.events');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');
goog.require('goog.structs.Queue');



/**
 * A cache populator manager that determines how to populate the cache with
 * data. Generates a set of cache populators based on the synced config. Once
 * started the manager will run an available cache populator until either one
 * has succeeded, or all the cache populators have failed.
 *
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!drive.ds.sync.query.QueryManager} queryManager The query manager.
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.cache.CachePopulatorManager = function(context, queryManager) {
  goog.base(this);

  /** @private {!drive.ds.sync.Context} */
  this.context_ = context;

  /** @private {!drive.ds.sync.query.QueryManager} */
  this.queryManager_ = queryManager;

  /** @private {!goog.events.EventHandler} */
  this.handler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.handler_);

  /**
   * A queue of available cache populators.
   * @private {!goog.structs.Queue.<!drive.ds.sync.cache.CachePopulator>}
   */
  this.populatorQueue_ = new goog.structs.Queue();

  /** @private {boolean} */
  this.waitingForGenoa_ = false;

  /** @private {boolean} */
  this.genoaLoaded_ = false;

  /** @private {drive.ds.sync.cache.CachePopulator} */
  this.runningPopulator_ = null;
};
goog.inherits(drive.ds.sync.cache.CachePopulatorManager,
    goog.events.EventTarget);


/**
 * Cache populator manager related events.
 * @enum {string}
 */
drive.ds.sync.cache.CachePopulatorManager.EventType = {
  // Event fired once a cache populator has finished running. No additional
  // cache populators will run.
  COMPLETE: goog.events.getUniqueId('complete'),

  // Event fired when all cache populators have failed.
  ERROR: goog.events.getUniqueId('error')
};


/**
 * Sets up the cache populator managers that are available based on the synced
 * config.
 */
drive.ds.sync.cache.CachePopulatorManager.prototype.initialize = function() {
  // If we're using IndexedDb and we have a last change id, this manager does
  // nothing and immediately returns.
  if (this.isIndexedDbReady_()) {
    return;
  }

  var populator = null;

  if (this.context_.getConfig().getUseDumpello()) {
    populator = this.context_.getConfig().getDumpelloClientProvided() ?
        new drive.ds.sync.cache.ClientDumpelloCachePopulator(this.context_) :
        new drive.ds.sync.cache.RemoteDumpelloCachePopulator(this.context_);
    this.populatorQueue_.enqueue(populator);
  }

  // Note explorer is unique in that they require a full cache, which is only
  // possible via dumpello.
  if (this.context_.getConfig().getFirstPartyClientId() !=
      drive.ds.sync.SyncedConfig.FirstPartyClientId.EXPLORER) {
    populator = new drive.ds.sync.cache.PrefetchCachePopulator(
        this.context_, this.queryManager_);
    this.populatorQueue_.enqueue(populator);
  }
};


/**
 * Loads the initial dumpello.
 * @param {string} initialDumpello The initial dumpello as a json string.
 */
drive.ds.sync.cache.CachePopulatorManager.prototype.loadInitialDumpello =
    function(initialDumpello) {
  goog.asserts.assert(this.runningPopulator_ instanceof
      drive.ds.sync.cache.ClientDumpelloCachePopulator,
      'ClientDumpelloCachePopulator not active!');

  /** @type {!drive.ds.sync.cache.ClientDumpelloCachePopulator} */
  (this.runningPopulator_).loadInitialDumpello(initialDumpello);
};


/**
 * Runs the cache populator manager.
 */
drive.ds.sync.cache.CachePopulatorManager.prototype.run = function() {
  // If we're using IndexedDb and we have a last change id, just dispatch
  // COMPLETE event.
  if (this.isIndexedDbReady_()) {
    this.dispatchEvent(
        drive.ds.sync.cache.CachePopulatorManager.EventType.COMPLETE);
    return;
  }

  this.runNext_();
};


/**
 * Marks genoa as loaded and runs cache populators as needed.
 */
drive.ds.sync.cache.CachePopulatorManager.prototype.markGenoaLoaded =
    function() {
  this.genoaLoaded_ = true;

  if (this.waitingForGenoa_) {
    this.runNext_();
  }
};


/**
 * @return {boolean} Whether IndexedDb is enabled and a last change id is
 *     available.
 * @private
 */
drive.ds.sync.cache.CachePopulatorManager.prototype.isIndexedDbReady_ =
    function() {
  return this.context_.getConfig().getUseIndexedDb() &&
      goog.isDefAndNotNull(this.context_.getMetadataStore().getLastChangeId());
};


/**
 * Runs the next cache populator manager.
 * @private
 */
drive.ds.sync.cache.CachePopulatorManager.prototype.runNext_ = function() {
  if (this.populatorQueue_.getCount()) {
    if (!this.populatorQueue_.peek().isGenoaRequired() || this.genoaLoaded_) {
      var populator = /** @type {!drive.ds.sync.cache.CachePopulator} */
          (this.populatorQueue_.dequeue());
      this.runningPopulator_ = populator;

      // Add listeners to handle completion or error.
      this.handler_.listenOnce(populator,
          drive.ds.sync.cache.CachePopulator.EventType.COMPLETE,
          goog.bind(this.handlePopulatorSuccess_, this));
      this.handler_.listenOnce(populator,
          drive.ds.sync.cache.CachePopulator.EventType.ERROR,
          goog.bind(this.handlePopulatorError_, this));

      populator.run();
    } else {
      this.waitingForGenoa_ = true;
    }
  }
};


/**
 * Handles a cache populator success. Dispatch a success event.
 * @private
 */
drive.ds.sync.cache.CachePopulatorManager.prototype.handlePopulatorSuccess_ =
    function() {
  this.handler_.removeAll();
  this.runningPopulator_ = null;

  this.dispatchEvent(
      drive.ds.sync.cache.CachePopulatorManager.EventType.COMPLETE);
};


/**
 * Handles a cache populator error.
 * @private
 */
drive.ds.sync.cache.CachePopulatorManager.prototype.handlePopulatorError_ =
    function() {
  this.handler_.removeAll();
  this.runningPopulator_ = null;

  if (this.populatorQueue_.getCount()) {
    this.runNext_();
  } else {
    this.dispatchEvent(
        drive.ds.sync.cache.CachePopulatorManager.EventType.ERROR);
  }
};

//javascript/apps/drive/dataservice/sync/cache/querycache.js
goog.provide('drive.ds.sync.cache.QueryCache');



/**
 * An abstract class representing a cache for queries that can be answered from
 * the item cache.
 * @constructor.
 */
drive.ds.sync.cache.QueryCache = function() { };


/**
 * Determines if the given query can be answered by the cache.
 * @param {!drive.ds.ItemQueryRequest} query The query to check.
 * @return {boolean} Whether the query can be answered by the cache.
 */
drive.ds.sync.cache.QueryCache.prototype.containsQuery = goog.abstractMethod;


/**
 * Gets the item limit for the query.
 * You must check whether the query can be answered by the cache before calling
 * this function.  If this query cannot be answered, then this function
 * will throw an exception.  If this query has no item limit, 0 is returned.
 * @param {!drive.ds.ItemQueryRequest} query The query to get the limit for.
 * @return {?number} The item limit fo the query.
 */
drive.ds.sync.cache.QueryCache.prototype.getQueryLimit = goog.abstractMethod;


/**
 * Puts or updates a query in the cache.  The query is defensively copied.
 * @param {!drive.ds.DumpelloQuery} query The query to add to the cache.
 */
drive.ds.sync.cache.QueryCache.prototype.put = goog.abstractMethod;


/**
 * @return {boolean} True if we know that we have the full corpus cached.
 */
drive.ds.sync.cache.QueryCache.prototype.hasFullCorpus = goog.abstractMethod;


/**
 * Applies item changes to the queries in the query cache, adjusting
 * result counts for each query as needed.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!Array.<!drive.ds.Item>} insertedItems The list of items that
 *     were inserted.
 * @param {!Array.<!drive.ds.Item>} deletedItems The list of items that
 *     were deleted.
 */
drive.ds.sync.cache.QueryCache.prototype.applyChanges = goog.abstractMethod;


/**
 * Puts a set of queries into the cache.  Queries are defensively copied.
 * @param {!Array.<!drive.ds.DumpelloQuery>} queries The list of queries to add.
 */
drive.ds.sync.cache.QueryCache.prototype.bulkImport = goog.abstractMethod;


/**
 * Exports a list of all the queries in the cache.
 * @return {!Array.<!drive.ds.DumpelloQuery>} The list of queries.
 */
drive.ds.sync.cache.QueryCache.prototype.bulkExport = goog.abstractMethod;


//javascript/apps/drive/dataservice/sync/cache/fullcorpusquerycache.js
goog.provide('drive.ds.sync.cache.FullCorpusQueryCache');

goog.require('drive.ds.sync.cache.QueryCache');



/**
 * A no-op query cache that indicates that all queries are answerable from the
 * cache.
 * @extends {drive.ds.sync.cache.QueryCache}
 * @constructor
 */
drive.ds.sync.cache.FullCorpusQueryCache = function() {
  goog.base(this);
};
goog.inherits(drive.ds.sync.cache.FullCorpusQueryCache,
    drive.ds.sync.cache.QueryCache);


/** @override */
drive.ds.sync.cache.FullCorpusQueryCache.prototype.containsQuery =
    function(query) {
  return true;
};


/** @override */
drive.ds.sync.cache.FullCorpusQueryCache.prototype.getQueryLimit =
    function(query) {
  return null;
};


/** @override */
drive.ds.sync.cache.FullCorpusQueryCache.prototype.put = function(query) {};


/** @override */
drive.ds.sync.cache.FullCorpusQueryCache.prototype.hasFullCorpus = function() {
  return true;
};


/** @override */
drive.ds.sync.cache.FullCorpusQueryCache.prototype.applyChanges =
    function(context, insertedItems, deletedItems) {};


/** @override */
drive.ds.sync.cache.FullCorpusQueryCache.prototype.bulkImport =
    function(queries) {
};


/** @override */
drive.ds.sync.cache.FullCorpusQueryCache.prototype.bulkExport =
    function() {
  return [];
};

//javascript/apps/drive/dataservice/errorutil.js
goog.provide('drive.ds.ErrorUtil');

goog.require('goog.string');


/** @type {string} Field name for the data service error in a Js Error. */
drive.ds.ErrorUtil.JS_ERROR_DSE_FIELD_NAME = 'dataServiceError';


/**
 * Builds an error to be returned to the client.
 * @param {!drive.ds.Error} error Error from data service.
 * @param {boolean} returnJsError Whether to return a native Javascript error.
 * @param {Error=} opt_jsError Javascript error to return if returnJsError is
 *     true.
 * @return {!Error|!drive.ds.Error} Either an Error or a drive.ds.Error
 *     depending on the request.
 */
drive.ds.ErrorUtil.buildError =
    function(error, returnJsError, opt_jsError) {
  if (returnJsError) {
    var returnError = opt_jsError || new Error();
    if (goog.string.isEmptySafe(returnError.message)) {
      returnError.message = error.getMessage() || '';
    }
    returnError[drive.ds.ErrorUtil.JS_ERROR_DSE_FIELD_NAME] = error;
    return returnError;
  } else {
    return error;
  }
};


/**
 * @param {!Error|!drive.ds.Error} error Error from data service.
 * @return {drive.ds.Error} If the given error is a native Javascript error,
 *     returns the data service error inside it if it exists, null otherwise. If
 *     the given error is a drive.ds.Error, it's returned.
 */
drive.ds.ErrorUtil.getError = function(error) {
  return error instanceof drive.ds.Error ? error : (
      error[drive.ds.ErrorUtil.JS_ERROR_DSE_FIELD_NAME] ?
      error[drive.ds.ErrorUtil.JS_ERROR_DSE_FIELD_NAME] : null);
};

//javascript/apps/drive/dataservice/livelist.js
/**
 * @fileoverview The interface for a live list of results that fulfill a
 * given query. The list supports events for changes that are processed
 * asynchronously.
 */

goog.provide('drive.ds.LiveList');
goog.provide('drive.ds.LiveList.ErrorEvent');

goog.require('drive.ds.ErrorUtil');
goog.require('drive.ds.Status');
goog.require('goog.events');



/**
 * Interface for a live list implementation. Results are not static because the
 * queries are asynchronous. Initially the results will be empty, as
 * results are returned or changes are received from local or remote store,
 * events are propogated to indiate that the results have changes so clients can
 * get the most recent data.
 * @extends {goog.disposable.IDisposable}
 * @extends {goog.events.Listenable}
 * @interface
 * @template DATA,DELTA_DATA
 */
drive.ds.LiveList = function() {};


/**
 * Events for notifying clients of live list changes.
 * @enum {string}
 */
drive.ds.LiveList.EventType = {
  /**
   * Event to notify that the result set has been updated. Clients should call
   * getData()/getDeltaData() to obtain the updated result set.
   */
  CHANGED: goog.events.getUniqueId('changed'),

  /**
   * Event to notify that an error has occurred while requesting data from
   * Drive.
   */
  ERROR: goog.events.getUniqueId('error')
};


/**
 * Activates this live list. An initial request to populate data is sent to
 * initialize the data as needed, events are fired to indicate changes in the
 * underlying data.
 */
drive.ds.LiveList.prototype.activate = function() {};


/**
 * Deacivates the live list. Events are no longer fired to indicate changes in
 * the underlying data.
 */
drive.ds.LiveList.prototype.deactivate = function() {};


/**
 * Gets the current results for this query. As results are processed
 * asynchronously, this call will always get the latest results available.
 * Clients should check the response status for errors.
 * @return {DATA} The current results for a query.
 */
drive.ds.LiveList.prototype.getData = function() {};


/**
 * Gets the latest set of deltas for this query since the last time getData or
 * getDeltaData was called. In the case of a success response, clients must
 * apply all the delta data in the specified order to get their current list of
 * items up to date. Clients should check the response status for errors.
 * @return {DELTA_DATA} The delta data since the last
 *     time getData/getDeltaData was called.
 */
drive.ds.LiveList.prototype.getDeltaData = function() {};


/**
 * Checks whether there are additional data that will fulfill the query.
 * @return {boolean} Whether there are additional items that will fulfill the
 *     query.
 */
drive.ds.LiveList.prototype.hasMoreData = function() {};


/**
 * Increments the maximum number of results that the client is interested in.
 * <p>
 * The live list fires events as additional results that fullfill the query are
 * available. Clients can optionally check the deferred object to determine
 * when the updated max items number has been reached.
 * @param {number=} opt_increment The optional number of additional results
 *     that the client is interested in.
 * @return {!goog.async.Deferred} Deferred that will fire when the data is
 *     finished loading.
 */
drive.ds.LiveList.prototype.incrementMaxCount =
    function(opt_increment) {};



/**
 * An event dispatched when an error occurs performing the query.
 * @param {!drive.ds.Error} error Error from data service.
 * @param {number} retryCount The retry count.
 * @param {boolean} returnJsError Whether to wrap the error in a native Error
 *     object.
 * @param {Error=} opt_jsError Javascript error to return if returnJsError is
 *     true.
 * @extends {goog.events.Event}
 * @constructor
 */
drive.ds.LiveList.ErrorEvent =
    function(error, retryCount, returnJsError, opt_jsError) {
  goog.base(this, drive.ds.LiveList.EventType.ERROR);
  /**
   * Native Javascript Error if returnJsError is true, drive.ds.Error otherwise.
   * @type {!Error|!drive.ds.Error}
   */
  this.error = drive.ds.ErrorUtil.buildError(error, returnJsError, opt_jsError);

  /**
   * The number of times this query has been retried, since last success.
   * @type {number}
   */
  this.retryCount = retryCount;

  /**
   * The status in the last query response.
   * TODO(paulcheong): Remove once Tesla is ready.
   * @deprecated Use this.error instead.
   * @type {drive.ds.Status}
   */
  this.status = drive.ds.Status.GENERIC_ERROR;

  /**
   * The error message.
   * TODO(paulcheong): Remove once Tesla is ready.
   * @deprecated Use this.error instead.
   * @type {?string}
   */
  this.errorMessage = '';

};
goog.inherits(drive.ds.LiveList.ErrorEvent, goog.events.Event);

//javascript/apps/drive/dataservice/sync/response/responsehandler.js
/**
 * @fileoverview Query response handlers responsible for handling complete query
 *     response from the drive api.
 */

goog.provide('drive.ds.sync.response.ResponseHandler');

goog.require('drive.ds.Error');
goog.require('drive.ds.LiveList');
goog.require('drive.ds.sync.response.ResponseErrorParser');
goog.require('goog.json');


/**
 * Handles a response with multiple items.
 * TODO(towong) Add unit tests.
 * @param {!goog.async.Deferred} deferredResult The deferred result.
 * @param {!drive.ds.sync.response.ResponseParser} responseParser The response
 *     parser.
 * @param {!Object} response The response from the drive api.
 */
drive.ds.sync.response.ResponseHandler.handleItemsResponse =
    function(deferredResult, responseParser, response) {
  var responseProto = responseParser.parseItems(response);
  if (responseProto.getErrorMessage()) {
    deferredResult.errback(responseProto);
  } else {
    deferredResult.callback(responseProto);
  }
};


/**
 * Handles a response with a max change id and a list of changes.
 * @param {!goog.async.Deferred} deferredResult The deferred result.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!Object} response The response from the drive api.
 */
drive.ds.sync.response.ResponseHandler.handleChangesResponse =
    function(deferredResult, context, response) {
  var responseProto = context.getResponseParser().parseChanges(response);
  if (responseProto.getStatus() != drive.ds.Status.SUCCESS) {
    deferredResult.errback(responseProto);
  } else {
    deferredResult.callback(responseProto);
  }
};


/**
 * Handles a revision response.
 * @param {!goog.async.Deferred} deferredResult The deferred result.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!Object} response The response from the drive api.
 */
drive.ds.sync.response.ResponseHandler.handleRevisionsResponse =
    function(deferredResult, context, response) {
  var revisionProto = context.getResponseParser().parseRevisions(response);
  if (revisionProto.getStatus() == drive.ds.Status.SUCCESS) {
    deferredResult.callback(revisionProto);
  } else {
    deferredResult.errback(revisionProto);
  }
};


/**
 * Handles a permissions response.
 * @param {!goog.async.Deferred} deferredResult The deferred result.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!Object} response The response from the drive api.
 */
drive.ds.sync.response.ResponseHandler.handlePermissionsResponse =
    function(deferredResult, context, response) {
  var permissionProto = context.getResponseParser().parsePermissions(response);
  if (permissionProto.getStatus() == drive.ds.Status.SUCCESS) {
    deferredResult.callback(permissionProto);
  } else {
    deferredResult.errback(permissionProto);
  }
};


/**
 * Handles an activity response.
 * @param {!goog.async.Deferred} deferredResult The deferred result.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!goog.events.Event} e The event from the Explorer xhr request.
 */
drive.ds.sync.response.ResponseHandler.handleActivitiesResponse =
    function(deferredResult, context, e) {
  var xhr = /** @type {!goog.net.XhrIo} */ (e.target);
  var parser = context.getResponseParser();

  if (xhr.isSuccess()) {
    var json = parser.parseProtectedJson(xhr.getResponseText());
    var response = /** @type {Object} */ (goog.json.unsafeParse(json));

    if (response) {
      var error = drive.ds.sync.response.ResponseErrorParser.parse(response);
      if (error) {
        // Even if the XHR request succeeds, the server may still return an
        // error.
        var errorEvent = new drive.ds.LiveList.ErrorEvent(error, 0,
            context.getConfig().getReturnJsErrors());
        deferredResult.errback(errorEvent);
      } else {
        var activitiesProto = parser.parseActivities(response);
        deferredResult.callback(activitiesProto);
      }
    }
  } else {
    var error = new drive.ds.Error();
    error.setType(drive.ds.Error.Type.RUNTIME);
    error.setMessage(xhr.getStatusText());
    var errorEvent = new drive.ds.LiveList.ErrorEvent(error, 0,
        context.getConfig().getReturnJsErrors());
    deferredResult.errback(errorEvent);
  }
};

//javascript/closure/db/error.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Error classes for the IndexedDB wrapper.
 *
 * @author bsep@google.com (Bret Sepulveda)
 */


goog.provide('goog.db.Error');
goog.provide('goog.db.Error.ErrorCode');
goog.provide('goog.db.Error.ErrorName');
goog.provide('goog.db.Error.VersionChangeBlockedError');

goog.require('goog.debug.Error');



/**
 * A database error. Since the stack trace can be unhelpful in an asynchronous
 * context, the error provides a message about where it was produced.
 *
 * @param {number|!DOMError} error The DOMError instance returned by the
 *     browser for Chrome22+, or an error code for previous versions.
 * @param {string} context A description of where the error occured.
 * @param {string=} opt_message Additional message.
 * @constructor
 * @extends {goog.debug.Error}
 * @final
 */
goog.db.Error = function(error, context, opt_message) {
  var errorCode = null;
  var internalError = null;
  if (goog.isNumber(error)) {
    errorCode = error;
    internalError = {name: goog.db.Error.getName(errorCode)};
  } else {
    internalError = error;
    errorCode = goog.db.Error.getCode(error.name);
  }

  /**
   * The code for this error.
   *
   * @type {number}
   */
  this.code = errorCode;

  /**
   * The DOMException as returned by the browser.
   *
   * @type {!DOMError}
   * @private
   */
  this.error_ = /** @type {!DOMError} */ (internalError);

  var msg = 'Error ' + context + ': ' + this.getName();
  if (opt_message) {
    msg += ', ' + opt_message;
  }
  goog.base(this, msg);
};
goog.inherits(goog.db.Error, goog.debug.Error);


/**
 * @return {string} The name of the error.
 */
goog.db.Error.prototype.getName = function()  {
  return this.error_.name;
};



/**
 * A specific kind of database error. If a Version Change is unable to proceed
 * due to other open database connections, it will block and this error will be
 * thrown.
 *
 * @constructor
 * @extends {goog.debug.Error}
 * @final
 */
goog.db.Error.VersionChangeBlockedError = function() {
  goog.base(this, 'Version change blocked');
};
goog.inherits(goog.db.Error.VersionChangeBlockedError, goog.debug.Error);


/**
 * Synthetic error codes for database errors, for use when IndexedDB
 * support is not available. This numbering differs in practice
 * from the browser implementations, but it is not meant to be reliable:
 * this object merely ensures that goog.db.Error is loadable on platforms
 * that do not support IndexedDB.
 *
 * @enum {number}
 * @private
 */
goog.db.Error.DatabaseErrorCode_ = {
  UNKNOWN_ERR: 1,
  NON_TRANSIENT_ERR: 2,
  NOT_FOUND_ERR: 3,
  CONSTRAINT_ERR: 4,
  DATA_ERR: 5,
  NOT_ALLOWED_ERR: 6,
  TRANSACTION_INACTIVE_ERR: 7,
  ABORT_ERR: 8,
  READ_ONLY_ERR: 9,
  TRANSIENT_ERR: 11,
  TIMEOUT_ERR: 10,
  QUOTA_ERR: 11,
  INVALID_ACCESS_ERR: 12,
  INVALID_STATE_ERR: 13
};


/**
 * Error codes for database errors.
 * @see http://www.w3.org/TR/IndexedDB/#idl-def-IDBDatabaseException
 *
 * @enum {number}
 */
goog.db.Error.ErrorCode = {
  UNKNOWN_ERR: (goog.global.IDBDatabaseException ||
      goog.global.webkitIDBDatabaseException ||
      goog.db.Error.DatabaseErrorCode_).UNKNOWN_ERR,
  NON_TRANSIENT_ERR: (goog.global.IDBDatabaseException ||
      goog.global.webkitIDBDatabaseException ||
      goog.db.Error.DatabaseErrorCode_).NON_TRANSIENT_ERR,
  NOT_FOUND_ERR: (goog.global.IDBDatabaseException ||
      goog.global.webkitIDBDatabaseException ||
      goog.db.Error.DatabaseErrorCode_).NOT_FOUND_ERR,
  CONSTRAINT_ERR: (goog.global.IDBDatabaseException ||
      goog.global.webkitIDBDatabaseException ||
      goog.db.Error.DatabaseErrorCode_).CONSTRAINT_ERR,
  DATA_ERR: (goog.global.IDBDatabaseException ||
      goog.global.webkitIDBDatabaseException ||
      goog.db.Error.DatabaseErrorCode_).DATA_ERR,
  NOT_ALLOWED_ERR: (goog.global.IDBDatabaseException ||
      goog.global.webkitIDBDatabaseException ||
      goog.db.Error.DatabaseErrorCode_).NOT_ALLOWED_ERR,
  TRANSACTION_INACTIVE_ERR: (goog.global.IDBDatabaseException ||
      goog.global.webkitIDBDatabaseException ||
      goog.db.Error.DatabaseErrorCode_).TRANSACTION_INACTIVE_ERR,
  ABORT_ERR: (goog.global.IDBDatabaseException ||
      goog.global.webkitIDBDatabaseException ||
      goog.db.Error.DatabaseErrorCode_).ABORT_ERR,
  READ_ONLY_ERR: (goog.global.IDBDatabaseException ||
      goog.global.webkitIDBDatabaseException ||
      goog.db.Error.DatabaseErrorCode_).READ_ONLY_ERR,
  TIMEOUT_ERR: (goog.global.IDBDatabaseException ||
      goog.global.webkitIDBDatabaseException ||
      goog.db.Error.DatabaseErrorCode_).TIMEOUT_ERR,
  QUOTA_ERR: (goog.global.IDBDatabaseException ||
      goog.global.webkitIDBDatabaseException ||
      goog.db.Error.DatabaseErrorCode_).QUOTA_ERR,
  INVALID_ACCESS_ERR: (goog.global.DOMException ||
      goog.db.Error.DatabaseErrorCode_).INVALID_ACCESS_ERR,
  INVALID_STATE_ERR: (goog.global.DOMException ||
      goog.db.Error.DatabaseErrorCode_).INVALID_STATE_ERR
};


/**
 * Translates an error code into a more useful message.
 *
 * @param {number} code Error code.
 * @return {string} A debug message.
 */
goog.db.Error.getMessage = function(code) {
  switch (code) {
    case goog.db.Error.ErrorCode.UNKNOWN_ERR:
      return 'Unknown error';
    case goog.db.Error.ErrorCode.NON_TRANSIENT_ERR:
      return 'Invalid operation';
    case goog.db.Error.ErrorCode.NOT_FOUND_ERR:
      return 'Required database object not found';
    case goog.db.Error.ErrorCode.CONSTRAINT_ERR:
      return 'Constraint unsatisfied';
    case goog.db.Error.ErrorCode.DATA_ERR:
      return 'Invalid data';
    case goog.db.Error.ErrorCode.NOT_ALLOWED_ERR:
      return 'Operation disallowed';
    case goog.db.Error.ErrorCode.TRANSACTION_INACTIVE_ERR:
      return 'Transaction not active';
    case goog.db.Error.ErrorCode.ABORT_ERR:
      return 'Request aborted';
    case goog.db.Error.ErrorCode.READ_ONLY_ERR:
      return 'Modifying operation not allowed in a read-only transaction';
    case goog.db.Error.ErrorCode.TIMEOUT_ERR:
      return 'Transaction timed out';
    case goog.db.Error.ErrorCode.QUOTA_ERR:
      return 'Database storage space quota exceeded';
    case goog.db.Error.ErrorCode.INVALID_ACCESS_ERR:
      return 'Invalid operation';
    case goog.db.Error.ErrorCode.INVALID_STATE_ERR:
      return 'Invalid state';
    default:
      return 'Unrecognized exception with code ' + code;
  }
};


/**
 * Names of all possible errors as returned from the browser.
 * @see http://www.w3.org/TR/IndexedDB/#exceptions
 * @enum {string}
 */
goog.db.Error.ErrorName = {
  ABORT_ERR: 'AbortError',
  CONSTRAINT_ERR: 'ConstraintError',
  DATA_CLONE_ERR: 'DataCloneError',
  DATA_ERR: 'DataError',
  INVALID_ACCESS_ERR: 'InvalidAccessError',
  INVALID_STATE_ERR: 'InvalidStateError',
  NOT_FOUND_ERR: 'NotFoundError',
  QUOTA_EXCEEDED_ERR: 'QuotaExceededError',
  READ_ONLY_ERR: 'ReadOnlyError',
  SYNTAX_ERROR: 'SyntaxError',
  TIMEOUT_ERR: 'TimeoutError',
  TRANSACTION_INACTIVE_ERR: 'TransactionInactiveError',
  UNKNOWN_ERR: 'UnknownError',
  VERSION_ERR: 'VersionError'
};


/**
 * Translates an error name to an error code. This is purely kept for backwards
 * compatibility with Chrome21.
 *
 * @param {string} name The name of the erorr.
 * @return {number} The error code corresponding to the error.
 */
goog.db.Error.getCode = function(name) {
  switch (name) {
    case goog.db.Error.ErrorName.UNKNOWN_ERR:
      return goog.db.Error.ErrorCode.UNKNOWN_ERR;
    case goog.db.Error.ErrorName.NOT_FOUND_ERR:
      return goog.db.Error.ErrorCode.NOT_FOUND_ERR;
    case goog.db.Error.ErrorName.CONSTRAINT_ERR:
      return goog.db.Error.ErrorCode.CONSTRAINT_ERR;
    case goog.db.Error.ErrorName.DATA_ERR:
      return goog.db.Error.ErrorCode.DATA_ERR;
    case goog.db.Error.ErrorName.TRANSACTION_INACTIVE_ERR:
      return goog.db.Error.ErrorCode.TRANSACTION_INACTIVE_ERR;
    case goog.db.Error.ErrorName.ABORT_ERR:
      return goog.db.Error.ErrorCode.ABORT_ERR;
    case goog.db.Error.ErrorName.READ_ONLY_ERR:
      return goog.db.Error.ErrorCode.READ_ONLY_ERR;
    case goog.db.Error.ErrorName.TIMEOUT_ERR:
      return goog.db.Error.ErrorCode.TIMEOUT_ERR;
    case goog.db.Error.ErrorName.QUOTA_EXCEEDED_ERR:
      return goog.db.Error.ErrorCode.QUOTA_ERR;
    case goog.db.Error.ErrorName.INVALID_ACCESS_ERR:
      return goog.db.Error.ErrorCode.INVALID_ACCESS_ERR;
    case goog.db.Error.ErrorName.INVALID_STATE_ERR:
      return goog.db.Error.ErrorCode.INVALID_STATE_ERR;
    default:
      return goog.db.Error.ErrorCode.UNKNOWN_ERR;
  }
};


/**
 * Converts an error code used by the old spec, to an error name used by the
 * latest spec.
 * @see http://www.w3.org/TR/IndexedDB/#exceptions
 *
 * @param {!goog.db.Error.ErrorCode|number} code The error code to convert.
 * @return {!goog.db.Error.ErrorName} The corresponding name of the error.
 */
goog.db.Error.getName = function(code) {
  switch (code) {
    case goog.db.Error.ErrorCode.UNKNOWN_ERR:
      return goog.db.Error.ErrorName.UNKNOWN_ERR;
    case goog.db.Error.ErrorCode.NOT_FOUND_ERR:
      return goog.db.Error.ErrorName.NOT_FOUND_ERR;
    case goog.db.Error.ErrorCode.CONSTRAINT_ERR:
      return goog.db.Error.ErrorName.CONSTRAINT_ERR;
    case goog.db.Error.ErrorCode.DATA_ERR:
      return goog.db.Error.ErrorName.DATA_ERR;
    case goog.db.Error.ErrorCode.TRANSACTION_INACTIVE_ERR:
      return goog.db.Error.ErrorName.TRANSACTION_INACTIVE_ERR;
    case goog.db.Error.ErrorCode.ABORT_ERR:
      return goog.db.Error.ErrorName.ABORT_ERR;
    case goog.db.Error.ErrorCode.READ_ONLY_ERR:
      return goog.db.Error.ErrorName.READ_ONLY_ERR;
    case goog.db.Error.ErrorCode.TIMEOUT_ERR:
      return goog.db.Error.ErrorName.TIMEOUT_ERR;
    case goog.db.Error.ErrorCode.QUOTA_ERR:
      return goog.db.Error.ErrorName.QUOTA_EXCEEDED_ERR;
    case goog.db.Error.ErrorCode.INVALID_ACCESS_ERR:
      return goog.db.Error.ErrorName.INVALID_ACCESS_ERR;
    case goog.db.Error.ErrorCode.INVALID_STATE_ERR:
      return goog.db.Error.ErrorName.INVALID_STATE_ERR;
    default:
      return goog.db.Error.ErrorName.UNKNOWN_ERR;
  }
};


/**
 * Constructs an goog.db.Error instance from an IDBRequest. This abstraction is
 * necessary to provide backwards compatibility with Chrome21.
 *
 * @param {!IDBRequest} request The request that failed.
 * @param {string} message The error message to add to err if it's wrapped.
 * @return {!goog.db.Error} The error that caused the failure.
 */
goog.db.Error.fromRequest = function(request, message) {
  if ('error' in request) {
    // Chrome 21 and before.
    return new goog.db.Error(request.error, message);
  } else if ('name' in request) {
    // Chrome 22+.
    var errorName = goog.db.Error.getName(request.errorCode);
    return new goog.db.Error(
        /**@type {!DOMError} */ ({name: errorName}), message);
  } else {
    return new goog.db.Error(/** @type {!DOMError} */ (
        {name: goog.db.Error.ErrorName.UNKNOWN_ERR}), message);
  }
};


/**
 * Constructs an goog.db.Error instance from an DOMException. This abstraction
 * is necessary to provide backwards compatibility with Chrome21.
 *
 * @param {!IDBDatabaseException} ex The exception that was thrown.
 * @param {string} message The error message to add to err if it's wrapped.
 * @return {!goog.db.Error} The error that caused the failure.
 * @suppress {invalidCasts} The cast from IDBDatabaseException to DOMError
 *     is invalid and will not compile.
 */
goog.db.Error.fromException = function(ex, message) {
  if ('name' in ex) {
    // Chrome 21 and before.
    return new goog.db.Error(/** @type {!DOMError} */ (ex), message);
  } else if ('code' in ex) {
    // Chrome 22+.
    var errorName = goog.db.Error.getName(ex.code);
    return new goog.db.Error(
        /** @type {!DOMError} */ ({name: errorName}), message);
  } else {
    return new goog.db.Error(/** @type {!DOMError} */ (
        {name: goog.db.Error.ErrorName.UNKNOWN_ERR}), message);
  }
};

//javascript/closure/db/cursor.js
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Wrapper for a IndexedDB cursor.
 *
 * @author ikilpatrick@google.com (Ian Kilpatrick)
 */


goog.provide('goog.db.Cursor');

goog.require('goog.async.Deferred');
goog.require('goog.db.Error');
goog.require('goog.debug');
goog.require('goog.events.EventTarget');



/**
 * Creates a new IDBCursor wrapper object. Should not be created directly,
 * access cursor through object store.
 * @see goog.db.ObjectStore#openCursor
 *
 * @constructor
 * @extends {goog.events.EventTarget}
 * @final
 */
goog.db.Cursor = function() {
  goog.base(this);
};
goog.inherits(goog.db.Cursor, goog.events.EventTarget);


/**
 * Underlying IndexedDB cursor object.
 *
 * @type {IDBCursor}
 * @private
 */
goog.db.Cursor.prototype.cursor_ = null;


/**
 * Advances the cursor to the next position along its direction. When new data
 * is available, the NEW_DATA event will be fired. If the cursor has reached the
 * end of the range it will fire the COMPLETE event. If opt_key is specified it
 * will advance to the key it matches in its direction.
 *
 * This wraps the native #continue method on the underlying object.
 *
 * @param {IDBKeyType=} opt_key The optional key to advance to.
 */
goog.db.Cursor.prototype.next = function(opt_key) {
  if (opt_key) {
    this.cursor_['continue'](opt_key);
  } else {
    this.cursor_['continue']();
  }
};


/**
 * Updates the value at the current position of the cursor in the object store.
 * If the cursor points to a value that has just been deleted, a new value is
 * created.
 *
 * @param {*} value The value to be stored.
 * @return {!goog.async.Deferred} The resulting deferred request.
 */
goog.db.Cursor.prototype.update = function(value) {
  var msg = 'updating via cursor with value ';
  var d = new goog.async.Deferred();
  var request;

  try {
    request = this.cursor_.update(value);
  } catch (err) {
    msg += goog.debug.deepExpose(value);
    d.errback(goog.db.Error.fromException(err, msg));
    return d;
  }
  request.onsuccess = function(ev) {
    d.callback();
  };
  request.onerror = function(ev) {
    msg += goog.debug.deepExpose(value);
    d.errback(goog.db.Error.fromRequest(ev.target, msg));
  };
  return d;
};


/**
 * Deletes the value at the cursor's position, without changing the cursor's
 * position. Once the value is deleted, the cursor's value is set to null.
 *
 * @return {!goog.async.Deferred} The resulting deferred request.
 */
goog.db.Cursor.prototype.remove = function() {
  var msg = 'deleting via cursor';
  var d = new goog.async.Deferred();
  var request;

  try {
    request = this.cursor_['delete']();
  } catch (err) {
    d.errback(goog.db.Error.fromException(err, msg));
    return d;
  }
  request.onsuccess = function(ev) {
    d.callback();
  };
  request.onerror = function(ev) {
    d.errback(goog.db.Error.fromRequest(ev.target, msg));
  };
  return d;
};


/**
 * @return {*} The value for the value at the cursor's position. Undefined
 *     if no current value, or null if value has just been deleted.
 */
goog.db.Cursor.prototype.getValue = function() {
  return this.cursor_['value'];
};


/**
 * @return {IDBKeyType} The key for the value at the cursor's position. If
 *     the cursor is outside its range, this is undefined.
 */
goog.db.Cursor.prototype.getKey = function() {
  return this.cursor_.key;
};


/**
 * Opens a value cursor from IDBObjectStore or IDBIndex over the specified key
 * range. Returns a cursor object which is able to iterate over the given range.
 * @param {!(IDBObjectStore|IDBIndex)} source Data source to open cursor.
 * @param {!goog.db.KeyRange=} opt_range The key range. If undefined iterates
 *     over the whole data source.
 * @param {!goog.db.Cursor.Direction=} opt_direction The direction. If undefined
 *     moves in a forward direction with duplicates.
 * @return {!goog.db.Cursor} The cursor.
 * @throws {goog.db.Error} If there was a problem opening the cursor.
 */
goog.db.Cursor.openCursor = function(source, opt_range, opt_direction) {
  var cursor = new goog.db.Cursor();
  var request;

  try {
    var range = opt_range ? opt_range.range() : null;
    if (opt_direction) {
      request = source.openCursor(range, opt_direction);
    } else {
      request = source.openCursor(range);
    }
  } catch (ex) {
    cursor.dispose();
    throw goog.db.Error.fromException(ex, source.name);
  }
  request.onsuccess = function(e) {
    cursor.cursor_ = e.target.result || null;
    if (cursor.cursor_) {
      cursor.dispatchEvent(goog.db.Cursor.EventType.NEW_DATA);
    } else {
      cursor.dispatchEvent(goog.db.Cursor.EventType.COMPLETE);
    }
  };
  request.onerror = function(e) {
    cursor.dispatchEvent(goog.db.Cursor.EventType.ERROR);
  };
  return cursor;
};


/**
 * Possible cursor directions.
 * @see http://www.w3.org/TR/IndexedDB/#idl-def-IDBCursor
 *
 * @enum {string}
 */
goog.db.Cursor.Direction = {
  NEXT: 'next',
  NEXT_NO_DUPLICATE: 'nextunique',
  PREV: 'prev',
  PREV_NO_DUPLICATE: 'prevunique'
};


/**
 * Event types that the cursor can dispatch. COMPLETE events are dispatched when
 * a cursor is depleted of values, a NEW_DATA event if there is new data
 * available, and ERROR if an error occurred.
 *
 * @enum {string}
 */
goog.db.Cursor.EventType = {
  COMPLETE: 'c',
  ERROR: 'e',
  NEW_DATA: 'n'
};

//javascript/closure/db/index.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Wrapper for an IndexedDB index.
 *
 * @author bsep@google.com (Bret Sepulveda)
 */


goog.provide('goog.db.Index');

goog.require('goog.async.Deferred');
goog.require('goog.db.Cursor');
goog.require('goog.db.Error');
goog.require('goog.debug');



/**
 * Creates an IDBIndex wrapper object. Indexes are associated with object
 * stores and provide methods for looking up objects based on their non-key
 * properties. Should not be created directly, access through the object store
 * it belongs to.
 * @see goog.db.ObjectStore#getIndex
 *
 * @param {!IDBIndex} index Underlying IDBIndex object.
 * @constructor
 * @final
 */
goog.db.Index = function(index) {
  /**
   * Underlying IndexedDB index object.
   *
   * @type {!IDBIndex}
   * @private
   */
  this.index_ = index;
};


/**
 * @return {string} Name of the index.
 */
goog.db.Index.prototype.getName = function() {
  return this.index_.name;
};


/**
 * @return {string} Key path of the index.
 */
goog.db.Index.prototype.getKeyPath = function() {
  return this.index_.keyPath;
};


/**
 * @return {boolean} True if the index enforces that there is only one object
 *     for each unique value it indexes on.
 */
goog.db.Index.prototype.isUnique = function() {
  return this.index_.unique;
};


/**
 * Helper function for get and getKey.
 *
 * @param {string} fn Function name to call on the index to get the request.
 * @param {string} msg Message to give to the error.
 * @param {IDBKeyType} key The key to look up in the index.
 * @return {!goog.async.Deferred} The resulting deferred object.
 * @private
 */
goog.db.Index.prototype.get_ = function(fn, msg, key) {
  var d = new goog.async.Deferred();
  var request;
  try {
    request = this.index_[fn](key);
  } catch (err) {
    msg += ' with key ' + goog.debug.deepExpose(key);
    d.errback(goog.db.Error.fromException(err, msg));
    return d;
  }
  request.onsuccess = function(ev) {
    d.callback(ev.target.result);
  };
  request.onerror = function(ev) {
    msg += ' with key ' + goog.debug.deepExpose(key);
    d.errback(goog.db.Error.fromRequest(ev.target, msg));
  };
  return d;
};


/**
 * Fetches a single object from the object store. Even if there are multiple
 * objects that match the given key, this method will get only one of them.
 *
 * @param {IDBKeyType} key Key to look up in the index.
 * @return {!goog.async.Deferred} The deferred object for the given record.
 */
goog.db.Index.prototype.get = function(key) {
  return this.get_('get', 'getting from index ' + this.getName(), key);
};


/**
 * Looks up a single object from the object store and gives back the key that
 * it's listed under in the object store. Even if there are multiple records
 * that match the given key, this method returns the first.
 *
 * @param {IDBKeyType} key Key to look up in the index.
 * @return {!goog.async.Deferred} The deferred key for the record that matches
 *     the key.
 */
goog.db.Index.prototype.getKey = function(key) {
  return this.get_('getKey', 'getting key from index ' + this.getName(), key);
};


/**
 * Helper function for getAll and getAllKeys.
 *
 * @param {string} fn Function name to call on the index to get the request.
 * @param {string} msg Message to give to the error.
 * @param {IDBKeyType=} opt_key Key to look up in the index.
 * @return {!goog.async.Deferred} The resulting deferred array of objects.
 * @private
 */
goog.db.Index.prototype.getAll_ = function(fn, msg, opt_key) {
  // This is the most common use of IDBKeyRange. If more specific uses of
  // cursors are needed then a full wrapper should be created.
  var IDBKeyRange = goog.global.IDBKeyRange || goog.global.webkitIDBKeyRange;
  var d = new goog.async.Deferred();
  var request;
  try {
    if (opt_key) {
      request = this.index_[fn](IDBKeyRange.only(opt_key));
    } else {
      request = this.index_[fn]();
    }
  } catch (err) {
    if (opt_key) {
      msg += ' for key ' + goog.debug.deepExpose(opt_key);
    }
    d.errback(goog.db.Error.fromException(err, msg));
    return d;
  }
  var result = [];
  request.onsuccess = function(ev) {
    var cursor = ev.target.result;
    if (cursor) {
      result.push(cursor.value);
      cursor['continue']();
    } else {
      d.callback(result);
    }
  };
  request.onerror = function(ev) {
    if (opt_key) {
      msg += ' for key ' + goog.debug.deepExpose(opt_key);
    }
    d.errback(goog.db.Error.fromRequest(ev.target, msg));
  };
  return d;
};


/**
 * Gets all indexed objects. If the key is provided, gets all indexed objects
 * that match the key instead.
 *
 * @param {IDBKeyType=} opt_key Key to look up in the index.
 * @return {!goog.async.Deferred} A deferred array of objects that match the
 *     key.
 */
goog.db.Index.prototype.getAll = function(opt_key) {
  return this.getAll_(
      'openCursor',
      'getting all from index ' + this.getName(),
      opt_key);
};


/**
 * Gets the keys to look up all the indexed objects. If the key is provided,
 * gets all records for objects that match the key instead.
 *
 * @param {IDBKeyType=} opt_key Key to look up in the index.
 * @return {!goog.async.Deferred} A deferred array of keys for objects that
 *     match the key.
 */
goog.db.Index.prototype.getAllKeys = function(opt_key) {
  return this.getAll_(
      'openKeyCursor',
      'getting all keys from index ' + this.getName(),
      opt_key);
};


/**
 * Opens a cursor over the specified key range. Returns a cursor object which is
 * able to iterate over the given range.
 *
 * Example usage:
 *
 * <code>
 *  var cursor = index.openCursor(goog.db.Range.bound('a', 'c'));
 *
 *  var key = goog.events.listen(
 *      cursor, goog.db.Cursor.EventType.NEW_DATA,
 *      function() {
 *        // Do something with data.
 *        cursor.next();
 *      });
 *
 *  goog.events.listenOnce(
 *      cursor, goog.db.Cursor.EventType.COMPLETE,
 *      function() {
 *        // Clean up listener, and perform a finishing operation on the data.
 *        goog.events.unlistenByKey(key);
 *      });
 * </code>
 *
 * @param {!goog.db.KeyRange=} opt_range The key range. If undefined iterates
 *     over the whole object store.
 * @param {!goog.db.Cursor.Direction=} opt_direction The direction. If undefined
 *     moves in a forward direction with duplicates.
 * @return {!goog.db.Cursor} The cursor.
 * @throws {goog.db.Error} If there was a problem opening the cursor.
 */
goog.db.Index.prototype.openCursor = function(opt_range, opt_direction) {
  return goog.db.Cursor.openCursor(this.index_, opt_range, opt_direction);
};

//javascript/closure/db/objectstore.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Wrapper for an IndexedDB object store.
 *
 * @author bsep@google.com (Bret Sepulveda)
 */


goog.provide('goog.db.ObjectStore');

goog.require('goog.async.Deferred');
goog.require('goog.db.Cursor');
goog.require('goog.db.Error');
goog.require('goog.db.Index');
goog.require('goog.debug');
goog.require('goog.events');



/**
 * Creates an IDBObjectStore wrapper object. Object stores have methods for
 * storing and retrieving records, and are accessed through a transaction
 * object. They also have methods for creating indexes associated with the
 * object store. They can only be created when setting the version of the
 * database. Should not be created directly, access object stores through
 * transactions.
 * @see goog.db.IndexedDb#setVersion
 * @see goog.db.Transaction#objectStore
 *
 * @param {!IDBObjectStore} store The backing IndexedDb object.
 * @constructor
 *
 * TODO(arthurhsu): revisit msg in exception and errors in this class. In newer
 *     Chrome (v22+) the error/request come with a DOM error string that is
 *     already very descriptive.
 * @final
 */
goog.db.ObjectStore = function(store) {
  /**
   * Underlying IndexedDB object store object.
   *
   * @type {!IDBObjectStore}
   * @private
   */
  this.store_ = store;
};


/**
 * @return {string} The name of the object store.
 */
goog.db.ObjectStore.prototype.getName = function() {
  return this.store_.name;
};


/**
 * Helper function for put and add.
 *
 * @param {string} fn Function name to call on the object store.
 * @param {string} msg Message to give to the error.
 * @param {*} value Value to insert into the object store.
 * @param {IDBKeyType=} opt_key The key to use.
 * @return {!goog.async.Deferred} The resulting deferred request.
 * @private
 */
goog.db.ObjectStore.prototype.insert_ = function(fn, msg, value, opt_key) {
  // TODO(bsep): refactor wrapping an IndexedDB request in a Deferred by
  // creating a higher-level abstraction for it (mostly affects here and
  // goog.db.Index)
  var d = new goog.async.Deferred();
  var request;
  try {
    // put or add with (value, undefined) throws an error, so we need to check
    // for undefined ourselves
    if (opt_key) {
      request = this.store_[fn](value, opt_key);
    } else {
      request = this.store_[fn](value);
    }
  } catch (ex) {
    msg += goog.debug.deepExpose(value);
    if (opt_key) {
      msg += ', with key ' + goog.debug.deepExpose(opt_key);
    }
    d.errback(goog.db.Error.fromException(ex, msg));
    return d;
  }
  request.onsuccess = function(ev) {
    d.callback();
  };
  var self = this;
  request.onerror = function(ev) {
    msg += goog.debug.deepExpose(value);
    if (opt_key) {
      msg += ', with key ' + goog.debug.deepExpose(opt_key);
    }
    d.errback(goog.db.Error.fromRequest(ev.target, msg));
  };
  return d;
};


/**
 * Adds an object to the object store. Replaces existing objects with the
 * same key.
 *
 * @param {*} value The value to put.
 * @param {IDBKeyType=} opt_key The key to use. Cannot be used if the
 *     keyPath was specified for the object store. If the keyPath was not
 *     specified but autoIncrement was not enabled, it must be used.
 * @return {!goog.async.Deferred} The deferred put request.
 */
goog.db.ObjectStore.prototype.put = function(value, opt_key) {
  return this.insert_(
      'put',
      'putting into ' + this.getName() + ' with value',
      value,
      opt_key);
};


/**
 * Adds an object to the object store. Requires that there is no object with
 * the same key already present.
 *
 * @param {*} value The value to add.
 * @param {IDBKeyType=} opt_key The key to use. Cannot be used if the
 *     keyPath was specified for the object store. If the keyPath was not
 *     specified but autoIncrement was not enabled, it must be used.
 * @return {!goog.async.Deferred} The deferred add request.
 */
goog.db.ObjectStore.prototype.add = function(value, opt_key) {
  return this.insert_(
      'add',
      'adding into ' + this.getName() + ' with value ',
      value,
      opt_key);
};


/**
 * Removes an object from the store. No-op if there is no object present with
 * the given key.
 *
 * @param {IDBKeyType} key The key to remove objects under.
 * @return {!goog.async.Deferred} The deferred remove request.
 */
goog.db.ObjectStore.prototype.remove = function(key) {
  var d = new goog.async.Deferred();
  var request;
  try {
    request = this.store_['delete'](key);
  } catch (err) {
    var msg = 'removing from ' + this.getName() + ' with key ' +
        goog.debug.deepExpose(key);
    d.errback(goog.db.Error.fromException(err, msg));
    return d;
  }
  request.onsuccess = function(ev) {
    d.callback();
  };
  var self = this;
  request.onerror = function(ev) {
    var msg = 'removing from ' + self.getName() + ' with key ' +
        goog.debug.deepExpose(key);
    d.errback(goog.db.Error.fromRequest(ev.target, msg));
  };
  return d;
};


/**
 * Gets an object from the store. If no object is present with that key
 * the result is {@code undefined}.
 *
 * @param {IDBKeyType} key The key to look up.
 * @return {!goog.async.Deferred} The deferred get request.
 */
goog.db.ObjectStore.prototype.get = function(key) {
  var d = new goog.async.Deferred();
  var request;
  try {
    request = this.store_.get(key);
  } catch (err) {
    var msg = 'getting from ' + this.getName() + ' with key ' +
        goog.debug.deepExpose(key);
    d.errback(goog.db.Error.fromException(err, msg));
    return d;
  }
  request.onsuccess = function(ev) {
    d.callback(ev.target.result);
  };
  var self = this;
  request.onerror = function(ev) {
    var msg = 'getting from ' + self.getName() + ' with key ' +
        goog.debug.deepExpose(key);
    d.errback(goog.db.Error.fromRequest(ev.target, msg));
  };
  return d;
};


/**
 * Gets all objects from the store and returns them as an array.
 *
 * @param {!goog.db.KeyRange=} opt_range The key range. If undefined iterates
 *     over the whole object store.
 * @param {!goog.db.Cursor.Direction=} opt_direction The direction. If undefined
 *     moves in a forward direction with duplicates.
 * @return {!goog.async.Deferred} The deferred getAll request.
 */
goog.db.ObjectStore.prototype.getAll = function(opt_range, opt_direction) {
  var d = new goog.async.Deferred();
  var cursor;
  try {
    cursor = this.openCursor(opt_range, opt_direction);
  } catch (err) {
    d.errback(err);
    return d;
  }

  var result = [];
  var key = goog.events.listen(
      cursor, goog.db.Cursor.EventType.NEW_DATA, function() {
        result.push(cursor.getValue());
        cursor.next();
      });

  goog.events.listenOnce(cursor, [
    goog.db.Cursor.EventType.ERROR,
    goog.db.Cursor.EventType.COMPLETE
  ], function(evt) {
    cursor.dispose();
    if (evt.type == goog.db.Cursor.EventType.COMPLETE) {
      d.callback(result);
    } else {
      d.errback();
    }
  });
  return d;
};


/**
 * Opens a cursor over the specified key range. Returns a cursor object which is
 * able to iterate over the given range.
 *
 * Example usage:
 *
 * <code>
 *  var cursor = objectStore.openCursor(goog.db.Range.bound('a', 'c'));
 *
 *  var key = goog.events.listen(
 *      cursor, goog.db.Cursor.EventType.NEW_DATA, function() {
 *    // Do something with data.
 *    cursor.next();
 *  });
 *
 *  goog.events.listenOnce(
 *      cursor, goog.db.Cursor.EventType.COMPLETE, function() {
 *    // Clean up listener, and perform a finishing operation on the data.
 *    goog.events.unlistenByKey(key);
 *  });
 * </code>
 *
 * @param {!goog.db.KeyRange=} opt_range The key range. If undefined iterates
 *     over the whole object store.
 * @param {!goog.db.Cursor.Direction=} opt_direction The direction. If undefined
 *     moves in a forward direction with duplicates.
 * @return {!goog.db.Cursor} The cursor.
 * @throws {goog.db.Error} If there was a problem opening the cursor.
 */
goog.db.ObjectStore.prototype.openCursor = function(opt_range, opt_direction) {
  return goog.db.Cursor.openCursor(this.store_, opt_range, opt_direction);
};


/**
 * Deletes all objects from the store.
 *
 * @return {!goog.async.Deferred} The deferred clear request.
 */
goog.db.ObjectStore.prototype.clear = function() {
  var msg = 'clearing store ' + this.getName();
  var d = new goog.async.Deferred();
  var request;
  try {
    request = this.store_.clear();
  } catch (err) {
    d.errback(goog.db.Error.fromException(err, msg));
    return d;
  }
  request.onsuccess = function(ev) {
    d.callback();
  };
  request.onerror = function(ev) {
    d.errback(goog.db.Error.fromRequest(ev.target, msg));
  };
  return d;
};


/**
 * Creates an index in this object store. Can only be called inside the callback
 * for the Deferred returned from goog.db.IndexedDb#setVersion.
 *
 * @param {string} name Name of the index to create.
 * @param {string} keyPath Attribute to index on.
 * @param {!Object=} opt_parameters Optional parameters object. The only
 *     available option is unique, which defaults to false. If unique is true,
 *     the index will enforce that there is only ever one object in the object
 *     store for each unique value it indexes on.
 * @return {goog.db.Index} The newly created, wrapped index.
 * @throws {goog.db.Error} In case of an error creating the index.
 */
goog.db.ObjectStore.prototype.createIndex = function(
    name, keyPath, opt_parameters) {
  try {
    return new goog.db.Index(this.store_.createIndex(
        name, keyPath, opt_parameters));
  } catch (ex) {
    var msg = 'creating new index ' + name + ' with key path ' + keyPath;
    throw goog.db.Error.fromException(ex, msg);
  }
};


/**
 * Gets an index.
 *
 * @param {string} name Name of the index to fetch.
 * @return {goog.db.Index} The requested wrapped index.
 * @throws {goog.db.Error} In case of an error getting the index.
 */
goog.db.ObjectStore.prototype.getIndex = function(name) {
  try {
    return new goog.db.Index(this.store_.index(name));
  } catch (ex) {
    var msg = 'getting index ' + name;
    throw goog.db.Error.fromException(ex, msg);
  }
};


/**
 * Deletes an index from the object store. Can only be called inside the
 * callback for the Deferred returned from goog.db.IndexedDb#setVersion.
 *
 * @param {string} name Name of the index to delete.
 * @throws {goog.db.Error} In case of an error deleting the index.
 */
goog.db.ObjectStore.prototype.deleteIndex = function(name) {
  try {
    this.store_.deleteIndex(name);
  } catch (ex) {
    var msg = 'deleting index ' + name;
    throw goog.db.Error.fromException(ex, msg);
  }
};


/**
 * Gets number of records within a key range.
 *
 * @param {!goog.db.KeyRange=} opt_range The key range. If undefined, this will
 *     count all records in the object store.
 * @return {!goog.async.Deferred} The deferred number of records.
 */
goog.db.ObjectStore.prototype.count = function(opt_range) {
  var request;
  var d = new goog.async.Deferred();

  try {
    var range = opt_range ? opt_range.range() : null;
    request = this.store_.count(range);
  } catch (ex) {
    d.errback(goog.db.Error.fromException(ex, this.getName()));
  }
  request.onsuccess = function(ev) {
    d.callback(ev.target.result);
  };
  request.onerror = function(ev) {
    d.errback(goog.db.Error.fromRequest(ev.target, this.getName()));
  };
  return d;
};


//javascript/closure/db/transaction.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Wrapper for an IndexedDB transaction.
 *
 * @author bsep@google.com (Bret Sepulveda)
 */


goog.provide('goog.db.Transaction');
goog.provide('goog.db.Transaction.TransactionMode');

goog.require('goog.async.Deferred');
goog.require('goog.db.Error');
goog.require('goog.db.ObjectStore');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');



/**
 * Creates a new transaction. Transactions contain methods for accessing object
 * stores and are created from the database object. Should not be created
 * directly, open a database and call createTransaction on it.
 * @see goog.db.IndexedDb#createTransaction
 *
 * @param {!IDBTransaction} tx IndexedDB transaction to back this wrapper.
 * @param {!goog.db.IndexedDb} db The database that this transaction modifies.
 * @constructor
 * @extends {goog.events.EventTarget}
 * @final
 */
goog.db.Transaction = function(tx, db) {
  goog.base(this);

  /**
   * Underlying IndexedDB transaction object.
   *
   * @type {!IDBTransaction}
   * @private
   */
  this.tx_ = tx;

  /**
   * The database that this transaction modifies.
   *
   * @type {!goog.db.IndexedDb}
   * @private
   */
  this.db_ = db;

  /**
   * Event handler for this transaction.
   *
   * @type {!goog.events.EventHandler}
   * @private
   */
  this.eventHandler_ = new goog.events.EventHandler(this);

  // TODO(bsep): remove these casts once the externs file is updated to
  // correctly reflect that IDBTransaction extends EventTarget
  this.eventHandler_.listen(
      /** @type {EventTarget} */ (this.tx_),
      'complete',
      goog.bind(
          this.dispatchEvent,
          this,
          goog.db.Transaction.EventTypes.COMPLETE));
  this.eventHandler_.listen(
      /** @type {EventTarget} */ (this.tx_),
      'abort',
      goog.bind(
          this.dispatchEvent,
          this,
          goog.db.Transaction.EventTypes.ABORT));
  this.eventHandler_.listen(
      /** @type {EventTarget} */ (this.tx_),
      'error',
      this.dispatchError_);
};
goog.inherits(goog.db.Transaction, goog.events.EventTarget);


/**
 * Dispatches an error event based on the given event, wrapping the error
 * if necessary.
 *
 * @param {Event} ev The error event given to the underlying IDBTransaction.
 * @private
 */
goog.db.Transaction.prototype.dispatchError_ = function(ev) {
  if (ev.target instanceof goog.db.Error) {
    this.dispatchEvent({
      type: goog.db.Transaction.EventTypes.ERROR,
      target: ev.target
    });
  } else {
    this.dispatchEvent({
      type: goog.db.Transaction.EventTypes.ERROR,
      target: goog.db.Error.fromRequest(
          /** @type {!IDBRequest} */ (ev.target), 'in transaction')
    });
  }
};


/**
 * Event types the Transaction can dispatch. COMPLETE events are dispatched
 * when the transaction is committed. If a transaction is aborted it dispatches
 * both an ABORT event and an ERROR event with the ABORT_ERR code. Error events
 * are dispatched on any error.
 *
 * @enum {string}
 */
goog.db.Transaction.EventTypes = {
  COMPLETE: 'complete',
  ABORT: 'abort',
  ERROR: 'error'
};


/**
 * @return {goog.db.Transaction.TransactionMode} The transaction's mode.
 */
goog.db.Transaction.prototype.getMode = function() {
  return /** @type {goog.db.Transaction.TransactionMode} */ (this.tx_.mode);
};


/**
 * @return {!goog.db.IndexedDb} The database that this transaction modifies.
 */
goog.db.Transaction.prototype.getDatabase = function() {
  return this.db_;
};


/**
 * Opens an object store to do operations on in this transaction. The requested
 * object store must be one that is in this transaction's scope.
 * @see goog.db.IndexedDb#createTransaction
 *
 * @param {string} name The name of the requested object store.
 * @return {!goog.db.ObjectStore} The wrapped object store.
 * @throws {goog.db.Error} In case of error getting the object store.
 */
goog.db.Transaction.prototype.objectStore = function(name) {
  try {
    return new goog.db.ObjectStore(this.tx_.objectStore(name));
  } catch (ex) {
    throw goog.db.Error.fromException(ex, 'getting object store ' + name);
  }
};


/**
 * @return {!goog.async.Deferred} A deferred that will fire once the
 *     transaction is complete. It fires the errback chain if an error occurs
 *     in the transaction, or if it is aborted.
 */
goog.db.Transaction.prototype.wait = function() {
  var d = new goog.async.Deferred();
  goog.events.listenOnce(
      this, goog.db.Transaction.EventTypes.COMPLETE, goog.bind(d.callback, d));
  goog.events.listenOnce(
      this, goog.db.Transaction.EventTypes.ABORT, function() {
        d.errback(new goog.db.Error(goog.db.Error.ErrorCode.ABORT_ERR,
            'waiting for transaction to complete'));
      });
  goog.events.listenOnce(
      this, goog.db.Transaction.EventTypes.ERROR, function(e) {
        d.errback(e.target);
      });

  var db = this.getDatabase();
  return d.addCallback(function() {
    return db;
  });
};


/**
 * Aborts this transaction. No pending operations will be applied to the
 * database. Dispatches an ABORT event.
 */
goog.db.Transaction.prototype.abort = function() {
  this.tx_.abort();
};


/** @override */
goog.db.Transaction.prototype.disposeInternal = function() {
  goog.base(this, 'disposeInternal');
  this.eventHandler_.dispose();
};


/**
 * The three possible transaction modes.
 * @see http://www.w3.org/TR/IndexedDB/#idl-def-IDBTransaction
 *
 * @enum {string}
 */
goog.db.Transaction.TransactionMode = {
  READ_ONLY: 'readonly',
  READ_WRITE: 'readwrite',
  VERSION_CHANGE: 'versionchange'
};

//javascript/closure/db/indexeddb.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Wrapper for an IndexedDB database.
 *
 * @author bsep@google.com (Bret Sepulveda)
 */


goog.provide('goog.db.IndexedDb');

goog.require('goog.async.Deferred');
goog.require('goog.db.Error');
goog.require('goog.db.Error.VersionChangeBlockedError');
goog.require('goog.db.ObjectStore');
goog.require('goog.db.Transaction');
goog.require('goog.db.Transaction.TransactionMode');
goog.require('goog.events.Event');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');



/**
 * Creates an IDBDatabase wrapper object. The database object has methods for
 * setting the version to change the structure of the database and for creating
 * transactions to get or modify the stored records. Should not be created
 * directly, call {@link goog.db.openDatabase} to set up the connection.
 *
 * @param {!IDBDatabase} db Underlying IndexedDB database object.
 * @constructor
 * @extends {goog.events.EventTarget}
 * @final
 */
goog.db.IndexedDb = function(db) {
  goog.base(this);

  /**
   * Underlying IndexedDB database object.
   *
   * @type {!IDBDatabase}
   * @private
   */
  this.db_ = db;

  /**
   * Internal event handler that listens to IDBDatabase events.
   * @type {!goog.events.EventHandler}
   * @private
   */
  this.eventHandler_ = new goog.events.EventHandler(this);

  this.eventHandler_.listen(
      this.db_,
      goog.db.IndexedDb.EventType.ABORT,
      goog.bind(
          this.dispatchEvent,
          this,
          goog.db.IndexedDb.EventType.ABORT));
  this.eventHandler_.listen(
      this.db_,
      goog.db.IndexedDb.EventType.ERROR,
      this.dispatchError_);
  this.eventHandler_.listen(
      this.db_,
      goog.db.IndexedDb.EventType.VERSION_CHANGE,
      this.dispatchVersionChange_);
};
goog.inherits(goog.db.IndexedDb, goog.events.EventTarget);


/**
 * True iff the database connection is open.
 *
 * @type {boolean}
 * @private
 */
goog.db.IndexedDb.prototype.open_ = true;


/**
 * Dispatches a wrapped error event based on the given event.
 *
 * @param {Event} ev The error event given to the underlying IDBDatabase.
 * @private
 */
goog.db.IndexedDb.prototype.dispatchError_ = function(ev) {
  this.dispatchEvent({
    type: goog.db.IndexedDb.EventType.ERROR,
    errorCode: /** @type {IDBRequest} */ (ev.target).errorCode
  });
};


/**
 * Dispatches a wrapped version change event based on the given event.
 *
 * @param {Event} ev The version change event given to the underlying
 *     IDBDatabase.
 * @private
 */
goog.db.IndexedDb.prototype.dispatchVersionChange_ = function(ev) {
  this.dispatchEvent(new goog.db.IndexedDb.VersionChangeEvent(
      ev.oldVersion, ev.newVersion));
};


/**
 * Closes the database connection. Metadata queries can still be made after this
 * method is called, but otherwise this wrapper should not be used further.
 */
goog.db.IndexedDb.prototype.close = function() {
  if (this.open_) {
    this.db_.close();
    this.open_ = false;
  }
};


/**
 * @return {boolean} Whether a connection is open and the database can be used.
 */
goog.db.IndexedDb.prototype.isOpen = function() {
  return this.open_;
};


/**
 * @return {string} The name of this database.
 */
goog.db.IndexedDb.prototype.getName = function() {
  return this.db_.name;
};


/**
 * @return {string} The current database version.
 */
goog.db.IndexedDb.prototype.getVersion = function() {
  return this.db_.version;
};


/**
 * @return {DOMStringList} List of object stores in this database.
 */
goog.db.IndexedDb.prototype.getObjectStoreNames = function() {
  return this.db_.objectStoreNames;
};


/**
 * Creates an object store in this database. Can only be called inside a
 * {@link goog.db.UpgradeNeededCallback} or the callback for the Deferred
 * returned from #setVersion.
 *
 * @param {string} name Name for the new object store.
 * @param {Object=} opt_params Options object. The available options are:
 *     keyPath, which is a string and determines what object attribute
 *     to use as the key when storing objects in this object store; and
 *     autoIncrement, which is a boolean, which defaults to false and determines
 *     whether the object store should automatically generate keys for stored
 *     objects. If keyPath is not provided and autoIncrement is false, then all
 *     insert operations must provide a key as a parameter.
 * @return {goog.db.ObjectStore} The newly created object store.
 * @throws {goog.db.Error} If there's a problem creating the object store.
 */
goog.db.IndexedDb.prototype.createObjectStore = function(name, opt_params) {
  try {
    return new goog.db.ObjectStore(this.db_.createObjectStore(
        name, opt_params));
  } catch (ex) {
    throw goog.db.Error.fromException(ex, 'creating object store ' + name);
  }
};


/**
 * Deletes an object store. Can only be called inside a
 * {@link goog.db.UpgradeNeededCallback} or the callback for the Deferred
 * returned from #setVersion.
 *
 * @param {string} name Name of the object store to delete.
 * @throws {goog.db.Error} If there's a problem deleting the object store.
 */
goog.db.IndexedDb.prototype.deleteObjectStore = function(name) {
  try {
    this.db_.deleteObjectStore(name);
  } catch (ex) {
    throw goog.db.Error.fromException(ex, 'deleting object store ' + name);
  }
};


/**
 * Updates the version of the database and returns a Deferred transaction.
 * The database's structure can be changed inside this Deferred's callback, but
 * nowhere else. This means adding or deleting object stores, and adding or
 * deleting indexes. The version change will not succeed unless there are no
 * other connections active for this database anywhere. A new database
 * connection should be opened after the version change is finished to pick
 * up changes.
 *
 * This is deprecated, and only supported on Chrome prior to version 25. New
 * applications should use the version parameter to {@link goog.db.openDatabase}
 * instead.
 *
 * @param {string} version The new version of the database.
 * @return {!goog.async.Deferred} The deferred transaction for changing the
 *     version.
 */
goog.db.IndexedDb.prototype.setVersion = function(version) {
  var self = this;
  var d = new goog.async.Deferred();
  var request = this.db_.setVersion(version);
  request.onsuccess = function(ev) {
    // the transaction is in the result field (the transaction field is null
    // for version change requests)
    d.callback(new goog.db.Transaction(ev.target.result, self));
  };
  request.onerror = function(ev) {
    // If a version change is blocked, onerror and onblocked may both fire.
    // Check d.hasFired() to avoid an AlreadyCalledError.
    if (!d.hasFired()) {
      d.errback(goog.db.Error.fromRequest(ev.target, 'setting version'));
    }
  };
  request.onblocked = function(ev) {
    // If a version change is blocked, onerror and onblocked may both fire.
    // Check d.hasFired() to avoid an AlreadyCalledError.
    if (!d.hasFired()) {
      d.errback(new goog.db.Error.VersionChangeBlockedError());
    }
  };
  return d;
};


/**
 * Creates a new transaction.
 *
 * @param {!Array.<string>} storeNames A list of strings that contains the
 *     transaction's scope, the object stores that this transaction can operate
 *     on.
 * @param {goog.db.Transaction.TransactionMode=} opt_mode The mode of the
 *     transaction. If not present, the default is READ_ONLY. For VERSION_CHANGE
 *     transactions call {@link goog.db.IndexedDB#setVersion} instead.
 * @return {!goog.db.Transaction} The wrapper for the newly created transaction.
 * @throws {goog.db.Error} If there's a problem creating the transaction.
 */
goog.db.IndexedDb.prototype.createTransaction = function(storeNames, opt_mode) {
  try {
    // IndexedDB on Chrome 22+ requires that opt_mode not be passed rather than
    // be explicitly passed as undefined.
    var transaction = opt_mode ?
        this.db_.transaction(storeNames, opt_mode) :
        this.db_.transaction(storeNames);
    return new goog.db.Transaction(transaction, this);
  } catch (ex) {
    throw goog.db.Error.fromException(ex, 'creating transaction');
  }
};


/** @override */
goog.db.IndexedDb.prototype.disposeInternal = function() {
  goog.base(this, 'disposeInternal');
  this.eventHandler_.dispose();
};


/**
 * Event types fired by a database.
 *
 * @enum {string} The event types for the web socket.
 */
goog.db.IndexedDb.EventType = {

  /**
   * Fired when a transaction is aborted and the event bubbles to its database.
   */
  ABORT: 'abort',

  /**
   * Fired when a transaction has an error.
   */
  ERROR: 'error',

  /**
   * Fired when someone (possibly in another window) is attempting to modify the
   * structure of the database. Since a change can only be made when there are
   * no active database connections, this usually means that the database should
   * be closed so that the other client can make its changes.
   */
  VERSION_CHANGE: 'versionchange'
};



/**
 * Event representing a (possibly attempted) change in the database structure.
 *
 * At time of writing, no Chrome versions support oldVersion or newVersion. See
 * http://crbug.com/153122.
 *
 * @param {number} oldVersion The previous version of the database.
 * @param {number} newVersion The version the database is being or has been
 *     updated to.
 * @constructor
 * @extends {goog.events.Event}
 * @final
 */
goog.db.IndexedDb.VersionChangeEvent = function(oldVersion, newVersion) {
  goog.base(this, goog.db.IndexedDb.EventType.VERSION_CHANGE);

  /**
   * The previous version of the database.
   * @type {number}
   */
  this.oldVersion = oldVersion;

  /**
   * The version the database is being or has been updated to.
   * @type {number}
   */
  this.newVersion = newVersion;
};
goog.inherits(goog.db.IndexedDb.VersionChangeEvent, goog.events.Event);

//javascript/closure/db/db.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Wrappers for the HTML5 IndexedDB. The wrappers export nearly
 * the same interface as the standard API, but return goog.async.Deferred
 * objects instead of request objects and use Closure events. The wrapper works
 * and has been tested on Chrome version 22+. It may work on older Chrome
 * versions, but they aren't explicitly supported.
 *
 * Example usage:
 *
 *  <code>
 *  goog.db.openDatabase('mydb', 1, function(ev, db, tx) {
 *    db.createObjectStore('mystore');
 *  }).addCallback(function(db) {
 *    var putTx = db.createTransaction(
 *        [],
 *        goog.db.Transaction.TransactionMode.READ_WRITE);
 *    var store = putTx.objectStore('mystore');
 *    store.put('value', 'key');
 *    goog.listen(putTx, goog.db.Transaction.EventTypes.COMPLETE, function() {
 *      var getTx = db.createTransaction([]);
 *      var request = getTx.objectStore('mystore').get('key');
 *      request.addCallback(function(result) {
 *        ...
 *      });
 *  });
 *  </code>
 *
 * @author bsep@google.com (Bret Sepulveda)
 */


goog.provide('goog.db');

goog.require('goog.async.Deferred');
goog.require('goog.db.Error');
goog.require('goog.db.IndexedDb');
goog.require('goog.db.Transaction');


/**
 * The IndexedDB factory object.
 *
 * @type {IDBFactory}
 * @private
 */
goog.db.indexedDb_ = goog.global.indexedDB || goog.global.mozIndexedDB ||
    goog.global.webkitIndexedDB || goog.global.moz_indexedDB;


/**
 * A callback that's called if a blocked event is received. When a database is
 * supposed to be deleted or upgraded (i.e. versionchange), and there are open
 * connections to this database, a block event will be fired to prevent the
 * operations from going through until all such open connections are closed.
 * This callback can be used to notify users that they should close other tabs
 * that have open connections, or to close the connections manually. Databases
 * can also listen for the {@link goog.db.IndexedDb.EventType.VERSION_CHANGE}
 * event to automatically close themselves when they're blocking such
 * operations.
 *
 * This is passed a VersionChangeEvent that has the version of the database
 * before it was deleted, and "null" as the new version.
 *
 * @typedef {function(!goog.db.IndexedDb.VersionChangeEvent)}
 */
goog.db.BlockedCallback;


/**
 * A callback that's called when opening a database whose internal version is
 * lower than the version passed to {@link goog.db.openDatabase}.
 *
 * This callback is passed three arguments: a VersionChangeEvent with both the
 * old version and the new version of the database; the database that's being
 * opened, for which you can create and delete object stores; and the version
 * change transaction, with which you can abort the version change.
 *
 * Note that the transaction is not active, which means that it can't be used to
 * make changes to the database. However, since there is a transaction running,
 * you can't create another one via {@link goog.db.IndexedDb.createTransaction}.
 * This means that it's not possible to manipulate the database other than
 * creating or removing object stores in this callback.
 *
 * @typedef {function(!goog.db.IndexedDb.VersionChangeEvent,
 *                    !goog.db.IndexedDb,
 *                    !goog.db.Transaction)}
 */
goog.db.UpgradeNeededCallback;


/**
 * Opens a database connection and wraps it.
 *
 * @param {string} name The name of the database to open.
 * @param {number=} opt_version The expected version of the database. If this is
 *     larger than the actual version, opt_onUpgradeNeeded will be called
 *     (possibly after opt_onBlocked; see {@link goog.db.BlockedCallback}). If
 *     this is passed, opt_onUpgradeNeeded must be passed as well.
 * @param {goog.db.UpgradeNeededCallback=} opt_onUpgradeNeeded Called if
 *     opt_version is greater than the old version of the database. If
 *     opt_version is passed, this must be passed as well.
 * @param {goog.db.BlockedCallback=} opt_onBlocked Called if there are active
 *     connections to the database.
 * @return {!goog.async.Deferred} The deferred database object.
 */
goog.db.openDatabase = function(name, opt_version, opt_onUpgradeNeeded,
                                opt_onBlocked) {
  goog.asserts.assert(
      goog.isDef(opt_version) == goog.isDef(opt_onUpgradeNeeded),
      'opt_version must be passed to goog.db.openDatabase if and only if ' +
          'opt_onUpgradeNeeded is also passed');

  var d = new goog.async.Deferred();
  var openRequest = opt_version ?
      goog.db.indexedDb_.open(name, opt_version) :
      goog.db.indexedDb_.open(name);
  openRequest.onsuccess = function(ev) {
    var db = new goog.db.IndexedDb(ev.target.result);
    d.callback(db);
  };
  openRequest.onerror = function(ev) {
    var msg = 'opening database ' + name;
    d.errback(goog.db.Error.fromRequest(ev.target, msg));
  };
  openRequest.onupgradeneeded = function(ev) {
    if (!opt_onUpgradeNeeded) return;
    var db = new goog.db.IndexedDb(ev.target.result);
    opt_onUpgradeNeeded(
        new goog.db.IndexedDb.VersionChangeEvent(ev.oldVersion, ev.newVersion),
        db,
        new goog.db.Transaction(ev.target.transaction, db));
  };
  openRequest.onblocked = function(ev) {
    if (opt_onBlocked) {
      opt_onBlocked(new goog.db.IndexedDb.VersionChangeEvent(
          ev.oldVersion, ev.newVersion));
    }
  };
  return d;
};


/**
 * Deletes a database once all open connections have been closed.
 *
 * @param {string} name The name of the database to delete.
 * @param {goog.db.BlockedCallback=} opt_onBlocked Called if there are active
 *     connections to the database.
 * @return {goog.async.Deferred} A deferred object that will fire once the
 *     database is deleted.
 */
goog.db.deleteDatabase = function(name, opt_onBlocked) {
  var d = new goog.async.Deferred();
  var deleteRequest = goog.db.indexedDb_.deleteDatabase(name);
  deleteRequest.onsuccess = function(ev) {
    d.callback();
  };
  deleteRequest.onerror = function(ev) {
    var msg = 'deleting database ' + name;
    d.errback(goog.db.Error.fromRequest(ev.target, msg));
  };
  deleteRequest.onblocked = function(ev) {
    if (opt_onBlocked) {
      opt_onBlocked(new goog.db.IndexedDb.VersionChangeEvent(
          ev.oldVersion, ev.newVersion));
    }
  };
  return d;
};

//third_party/javascript/closure/mochikit/async/deferredlist.js
// Copyright 2005 Bob Ippolito. All Rights Reserved.
// Modifications Copyright 2009 The Closure Library Authors.
// All Rights Reserved.

/**
 * Portions of this code are from MochiKit, received by The Closure
 * Library Authors under the MIT license. All other code is Copyright
 * 2005-2009 The Closure Library Authors. All Rights Reserved.
 */

/**
 * @fileoverview Class for tracking multiple asynchronous operations and
 * handling the results. The DeferredList object here is patterned after the
 * DeferredList object in the Twisted python networking framework.
 *
 * Based on the MochiKit code.
 *
 * See: http://twistedmatrix.com/projects/core/documentation/howto/defer.html
 *
 * @author brenneman@google.com (Shawn Brenneman)
 */

goog.provide('goog.async.DeferredList');

goog.require('goog.async.Deferred');



/**
 * Constructs an object that waits on the results of multiple asynchronous
 * operations and marshals the results. It is itself a <code>Deferred</code>,
 * and may have an execution sequence of callback functions added to it. Each
 * <code>DeferredList</code> instance is single use and may be fired only once.
 *
 * The default behavior of a <code>DeferredList</code> is to wait for a success
 * or error result from every <code>Deferred</code> in its input list. Once
 * every result is available, the <code>DeferredList</code>'s execution sequence
 * is fired with a list of <code>[success, result]</code> array pairs, where
 * <code>success</code> is a boolean indicating whether <code>result</code> was
 * the product of a callback or errback. The list's completion criteria and
 * result list may be modified by setting one or more of the boolean options
 * documented below.
 *
 * <code>Deferred</code> instances passed into a <code>DeferredList</code> are
 * independent, and may have additional callbacks and errbacks added to their
 * execution sequences after they are passed as inputs to the list.
 *
 * @param {!Array.<!goog.async.Deferred>} list An array of deferred results to
 *     wait for.
 * @param {boolean=} opt_fireOnOneCallback Whether to stop waiting as soon as
 *     one input completes successfully. In this case, the
 *     <code>DeferredList</code>'s callback chain will be called with a two
 *     element array, <code>[index, result]</code>, where <code>index</code>
 *     identifies which input <code>Deferred</code> produced the successful
 *     <code>result</code>.
 * @param {boolean=} opt_fireOnOneErrback Whether to stop waiting as soon as one
 *     input reports an error. The failing result is passed to the
 *     <code>DeferredList</code>'s errback sequence.
 * @param {boolean=} opt_consumeErrors When true, any errors fired by a
 *     <code>Deferred</code> in the input list will be captured and replaced
 *     with a succeeding null result. Any callbacks added to the
 *     <code>Deferred</code> after its use in the <code>DeferredList</code> will
 *     receive null instead of the error.
 * @param {Function=} opt_canceler A function that will be called if the
 *     <code>DeferredList</code> is canceled. @see goog.async.Deferred#cancel
 * @param {Object=} opt_defaultScope The default scope to invoke callbacks or
 *     errbacks in.
 * @constructor
 * @extends {goog.async.Deferred}
 */
goog.async.DeferredList = function(
    list, opt_fireOnOneCallback, opt_fireOnOneErrback, opt_consumeErrors,
    opt_canceler, opt_defaultScope) {

  goog.base(this, opt_canceler, opt_defaultScope);

  /**
   * The list of Deferred objects to wait for.
   * @const {!Array.<!goog.async.Deferred>}
   * @private
   */
  this.list_ = list;

  /**
   * The stored return values of the Deferred objects.
   * @const {!Array}
   * @private
   */
  this.deferredResults_ = [];

  /**
   * Whether to fire on the first successful callback instead of waiting for
   * every Deferred to complete.
   * @const {boolean}
   * @private
   */
  this.fireOnOneCallback_ = !!opt_fireOnOneCallback;

  /**
   * Whether to fire on the first error result received instead of waiting for
   * every Deferred to complete.
   * @const {boolean}
   * @private
   */
  this.fireOnOneErrback_ = !!opt_fireOnOneErrback;

  /**
   * Whether to stop error propagation on the input Deferred objects. If the
   * DeferredList sees an error from one of the Deferred inputs, the error will
   * be captured, and the Deferred will be returned to success state with a null
   * return value.
   * @const {boolean}
   * @private
   */
  this.consumeErrors_ = !!opt_consumeErrors;

  /**
   * The number of input deferred objects that have fired.
   * @private {number}
   */
  this.numFinished_ = 0;

  for (var i = 0; i < list.length; i++) {
    var d = list[i];
    d.addCallbacks(goog.bind(this.handleCallback_, this, i, true),
                   goog.bind(this.handleCallback_, this, i, false));
  }

  if (list.length == 0 && !this.fireOnOneCallback_) {
    this.callback(this.deferredResults_);
  }
};
goog.inherits(goog.async.DeferredList, goog.async.Deferred);


/**
 * Registers the result from an input deferred callback or errback. The result
 * is returned and may be passed to additional handlers in the callback chain.
 *
 * @param {number} index The index of the firing deferred object in the input
 *     list.
 * @param {boolean} success Whether the result is from a callback or errback.
 * @param {*} result The result of the callback or errback.
 * @return {*} The result, to be handled by the next handler in the deferred's
 *     callback chain (if any). If consumeErrors is set, an error result is
 *     replaced with null.
 * @private
 */
goog.async.DeferredList.prototype.handleCallback_ = function(
    index, success, result) {

  this.numFinished_++;
  this.deferredResults_[index] = [success, result];

  if (!this.hasFired()) {
    if (this.fireOnOneCallback_ && success) {
      this.callback([index, result]);
    } else if (this.fireOnOneErrback_ && !success) {
      this.errback(result);
    } else if (this.numFinished_ == this.list_.length) {
      this.callback(this.deferredResults_);
    }
  }

  if (this.consumeErrors_ && !success) {
    result = null;
  }

  return result;
};


/** @override */
goog.async.DeferredList.prototype.errback = function(res) {
  goog.base(this, 'errback', res);

  // On error, cancel any pending requests.
  for (var i = 0; i < this.list_.length; i++) {
    this.list_[i].cancel();
  }
};


/**
 * Creates a <code>DeferredList</code> that gathers results from multiple
 * <code>Deferred</code> inputs. If all inputs succeed, the callback is fired
 * with the list of results as a flat array. If any input fails, the list's
 * errback is fired immediately with the offending error, and all other pending
 * inputs are canceled.
 *
 * @param {!Array.<!goog.async.Deferred>} list The list of <code>Deferred</code>
 *     inputs to wait for.
 * @return {!goog.async.Deferred} The deferred list of results from the inputs
 *     if they all succeed, or the error result of the first input to fail.
 */
goog.async.DeferredList.gatherResults = function(list) {
  return new goog.async.DeferredList(list, false, true).
      addCallback(function(results) {
        var output = [];
        for (var i = 0; i < results.length; i++) {
          output[i] = results[i][1];
        }
        return output;
      });
};

//javascript/apps/drive/dataservice/sync/cache/indexeddbcache.js
goog.provide('drive.ds.sync.cache.IndexedDbCache');

goog.require('drive.ds.Dumpello');
goog.require('drive.ds.Item');
goog.require('drive.ds.ItemQueryRequest');
goog.require('drive.ds.ItemQueryResponse');
goog.require('drive.ds.Status');
goog.require('drive.ds.sync.Field');
goog.require('drive.ds.sync.api.Files');
goog.require('drive.ds.sync.cache.Cache');
goog.require('drive.ds.sync.response.ResponseHandler');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.async.Deferred');
goog.require('goog.async.DeferredList');
goog.require('goog.db');
goog.require('goog.db.Cursor');
goog.require('goog.db.Transaction');
goog.require('goog.events.EventHandler');



/**
 * An cache of drive items stored in a local IndexedDB.  This allows us to
 * reuse the cache across sessions instead of having to repopulate it
 * for every page load.
 *
 * TODO(ericzhang): This does not currently differentiate between users and
 * also does not clear the cache on logout.  Figure out a strategy for this.
 * Furthermore, consider improving space efficiency with some of the cellodex
 * optimizations.
 * TODO(towong): Calculate the HAS_CHILD_FOLDER field.
 *
 * @param {!Array.<!drive.ds.Field>} fields The complete set of fields
 *     that the client could potentially need.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item config.
 * @param {!drive.ds.sync.cache.MetadataStore} metadataStore The locally stored
 *     metadata for this cache.
 * @param {!drive.ds.sync.response.ResponseParser} responseParser The response
 *     parser.
 * @extends {drive.ds.sync.cache.Cache}
 * @constructor
 */
drive.ds.sync.cache.IndexedDbCache = function(
    fields, config, metadataStore, responseParser) {
  goog.base(this, fields, config, metadataStore, responseParser);

  /** @private {goog.db.IndexedDb} The IndexedDB backing this cache. */
  this.db_ = null;
};
goog.inherits(drive.ds.sync.cache.IndexedDbCache, drive.ds.sync.cache.Cache);


/**
 * The indexed db name.
 * @private {string}
 */
drive.ds.sync.cache.IndexedDbCache.DATABASE_NAME_ = 'cello';


/**
 * The current version of the IndexedDB.
 * @private {number}
 */
drive.ds.sync.cache.IndexedDbCache.DATABASE_VERSION_ = 1;


/**
 * The name of the main 'items' object store.
 * @private {string}
 */
drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_ = 'items';


/** @override */
drive.ds.sync.cache.IndexedDbCache.prototype.initialize = function() {
  var errorHandler = goog.bind(this.handleInitError_, this);
  var deferred = goog.db.openDatabase(
      drive.ds.sync.cache.IndexedDbCache.DATABASE_NAME_,
      drive.ds.sync.cache.IndexedDbCache.DATABASE_VERSION_,
      goog.bind(this.upgradeDatabase_, this),
      errorHandler /* opt_onBlocked */);
  deferred.addCallback(goog.bind(this.handleDatabaseOpened_, this));
  deferred.addErrback(errorHandler);
};


/** @override */
drive.ds.sync.cache.IndexedDbCache.prototype.getById = function(id) {
  var tx = this.db_.createTransaction(
      [drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_]);
  var store = tx.objectStore(drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_);

  return this.deferredDeserialize_(store.get(id));
};


/** @override */
drive.ds.sync.cache.IndexedDbCache.prototype.query = function(request, limit) {
  // TODO(mccollumj): This will only work if the cache is fully populated with
  // the user's corpus. Build a strategy for determining if a query is
  // satisfiable even with a partially full cache.

  if (!this.isRequestSupported(request)) {
    var response = new drive.ds.ItemQueryResponse();
    response.setStatus(drive.ds.Status.UNSUPPORTED);
    return goog.async.Deferred.succeed(response);
  }

  return this.doQuery_(
      request, goog.bind(this.accumulateQueryData_, this), limit);
};


/** @override */
drive.ds.sync.cache.IndexedDbCache.prototype.queryByIds =
    function(request, ids, limit) {
  return this.doQuery_(request,
      goog.bind(this.accumulateQueryByIdData_, this, ids), limit);
};


/** @override */
drive.ds.sync.cache.IndexedDbCache.prototype.bulkExport = function() {
  var handler = new goog.events.EventHandler(this);
  var items = [];

  // Open a cursor and accumulate query results.
  var tx = this.db_.createTransaction(
      [drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_]);
  var store = tx.objectStore(drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_);
  var cursor = store.openCursor();
  handler.listen(cursor, goog.db.Cursor.EventType.NEW_DATA,
      goog.bind(this.accumulateExportData_, this, cursor, items));

  // Construct a deferred object to return the accumulated results.
  var result = new goog.async.Deferred();

  // Listen on cursor events so we can fire the deferred when the query
  // either completes or fails.
  handler.listenOnce(cursor, goog.db.Cursor.EventType.COMPLETE,
      goog.partial(this.handleExportComplete_, items, result, handler));
  handler.listenOnce(cursor, goog.db.Cursor.EventType.ERROR,
      goog.partial(this.handleExportError_, result, handler));

  return result;
};


/** @override */
drive.ds.sync.cache.IndexedDbCache.prototype.bulkExportPermissions =
    function() {
  // TODO(towong): Handle exporting user permissions.
  return [];
};


/** @override */
drive.ds.sync.cache.IndexedDbCache.prototype.bulkImport = function(
    items, opt_permissions) {
  // TODO(towong): Handle caching for user permissions.

  var deferredPuts = [];
  // TODO(towong): Optimize filter fields by applying here first.
  for (var i = 0; i < items.length; i++) {
    deferredPuts.push(this.put(items[i]));
  }
  var result = new goog.async.DeferredList(deferredPuts,
      false /* opt_fireOnOneCallback */, true /* opt_fireOnOneErrback */);
  return result;
};


/** @override */
drive.ds.sync.cache.IndexedDbCache.prototype.requestPermissions =
    function(itemIds) {
  throw Error('Currently unsupported!');
};


/** @override */
drive.ds.sync.cache.IndexedDbCache.prototype.put = function(item) {
  goog.asserts.assert(item.getId() != null,
      'Attempted to insert an item without an id.');

  var itemCopy = item.cloneMessage();
  drive.ds.sync.Field.filterFields(this.getFields(), [itemCopy]);
  var putItem = itemCopy.serialize();

  var tx = this.db_.createTransaction(
      [drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_],
      goog.db.Transaction.TransactionMode.READ_WRITE);
  var store = tx.objectStore(drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_);
  store.put(putItem, /** @type {string} */ (item.getId()));
  var deferred = tx.wait();
  deferred.addCallback(goog.bind(this.queueChangeEvent, this));
  return deferred;
};


/** @override */
drive.ds.sync.cache.IndexedDbCache.prototype.remove = function(id) {
  var tx = this.db_.createTransaction(
      [drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_],
      goog.db.Transaction.TransactionMode.READ_WRITE);
  var store = tx.objectStore(drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_);
  store.remove(id);
  var deferred = tx.wait();
  deferred.addCallback(goog.bind(this.queueChangeEvent, this));
  return deferred;
};


/**
 * Clears the cache for unit tests.
 * @return {!goog.async.Deferred} The deferred clear.
 */
drive.ds.sync.cache.IndexedDbCache.prototype.clearForTesting = function() {
  var tx = this.db_.createTransaction(
      [drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_],
      goog.db.Transaction.TransactionMode.READ_WRITE);
  var store = tx.objectStore(drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_);
  return store.clear();
};


/**
 * Creates the database if it doesn't exist.
 * @param {!goog.db.IndexedDb.VersionChangeEvent} evt The version change event.
 * @param {!goog.db.IndexedDb} db The IndexedDB.
 * @param {!goog.db.Transaction} tx The current transaction.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.upgradeDatabase_ =
    function(evt, db, tx) {
  // Clear the old object store on version changes.
  // TODO(ericzhang): Do something smarter here.
  if (db.getObjectStoreNames().contains(
      drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_)) {
    db.deleteObjectStore(drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_);
    this.getMetadataStore().setLastChangeId(null);
    // TODO(ericzhang): We probably don't need to clear this, but right now
    // the code assumes that 'cache initialized' means both the root ID AND
    // the root item are available, which won't be the case on db upgrade
    // at the moment.  Clearing this forces the root ID query to execute
    // before the cache is considered initialized.
    this.setRootId('');
  }

  db.createObjectStore(drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_);
};


/**
 * Saves the opened database and dispatch an event that initialization has
 * completed successfully.
 * @param {!goog.db.IndexedDb} db The opened database.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.handleDatabaseOpened_ =
    function(db) {
  this.db_ = db;

  var rootId = this.getRootId();
  if (!rootId) {
    var deferred = new goog.async.Deferred();
    var request = new drive.ds.ItemQueryRequest();
    request.setId('root');
    drive.ds.sync.api.Files.search(request, goog.partial(
        drive.ds.sync.response.ResponseHandler.handleItemsResponse,
        deferred, this.responseParser),
        this.getFields());
    deferred.addCallback(goog.bind(this.handleRootItem_, this));
    deferred.addErrback(goog.bind(this.handleInitError_, this));
  } else {
    this.setRootItemId_(rootId);
  }
};


/**
 * Sets the root item id.  This is the last step in cache initialization, so
 * this also fires a 'cache initialized' event.
 * @param {string} id The root item ID.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.setRootItemId_ = function(id) {
  this.setRootId(id);
  this.setInitialized();
};


/**
 * Handles the root item query response and sets the ID for the 'root' item
 * in the cache.
 * @param {!drive.ds.ItemQueryResponse} response The query response.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.handleRootItem_ =
    function(response) {
  var item = goog.asserts.assert(response.getItemList()[0]);
  this.put(item);
  var rootId = item.getId();
  this.setRootId(rootId);
  this.setRootItemId_(rootId);
};


/**
 * Retries the root initialization.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.handleInitError_ = function() {
  // TODO
};


/**
 * Executes a query against the indexed DB, using the provided query function
 * to accumulate results.
 * @param {drive.ds.ItemQueryRequest} request The query request.  Can be null.
 * @param {function(!goog.db.Cursor, !drive.ds.ItemQueryRequest,
 *     !Array.<!drive.ds.Item>)} queryFunction The function to use
 *     for handling NEW_DATA callbacks from the db cursor.
 *     The function should take the database cursor, the request,
 *     and an array of Items to push results into.
 *     On each execution, the function can get the next value from the
 *     cursor and determine whether or not the item satisfies the query.
 *     It should also advance the db cursor.
 * @param {number} limit The desired number of items, -1 for all items.
 * @return {!goog.async.Deferred} The deferred result.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.doQuery_ =
    function(request, queryFunction, limit) {
  var handler = new goog.events.EventHandler(this);
  var items = [];

  // Open a cursor and accumulate query results.
  var tx = this.db_.createTransaction(
      [drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_]);
  var store = tx.objectStore(drive.ds.sync.cache.IndexedDbCache.OBJECT_STORE_);
  var cursor = store.openCursor();
  handler.listen(cursor, goog.db.Cursor.EventType.NEW_DATA,
      goog.partial(queryFunction, cursor, request, items));

  // Construct a deferred object to return the accumulated results.
  var result = new goog.async.Deferred();

  // Listen on cursor events so we can fire the deferred when the query
  // either completes or fails.
  handler.listenOnce(cursor, goog.db.Cursor.EventType.COMPLETE,
      goog.partial(this.handleQueryComplete_,
          request, items, result, handler, limit));
  handler.listenOnce(cursor, goog.db.Cursor.EventType.ERROR,
      goog.partial(this.handleQueryError_, result, handler));

  return result;
};


/**
 * Adds data from db cursor to the 'results' array.
 * @param {!goog.db.Cursor} cursor The database cursor.
 * @param {!Array.<!drive.ds.Item>} results The query results.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.accumulateExportData_ =
    function(cursor, results) {
  var item = this.deserializeItem_(/** @type {?string} */ (cursor.getValue()));
  results.push(item);
  cursor.next();
};


/**
 * Processes new data from the db cursor.  Checks the items against the
 * request criteria and adds them to the 'results' array if they match.
 * @param {!goog.db.Cursor} cursor The database cursor.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!Array.<!drive.ds.Item>} results The query results.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.accumulateQueryData_ =
    function(cursor, request, results) {
  var item = this.deserializeItem_(/** @type {?string} */ (cursor.getValue()));
  if (item &&
      this.meetsIdSpec(request, item) &&
      this.meetsTitleSpec(request, item) &&
      this.meetsMimeTypeSpec(request, item) &&
      this.meetsModifiedDateSpec(request, item) &&
      this.meetsViewedDateSpec(request, item) &&
      this.meetsTrashedSpec(request, item) &&
      this.meetsStarredSpec(request, item) &&
      this.meetsHiddenSpec(request, item) &&
      this.meetsParentSpec(request, item) &&
      this.meetsOwnerSpec(request, item) &&
      this.meetsSharedWithMeSpec(request, item)) {
    results.push(item);
  }
  cursor.next();
};


/**
 * Processes new data from the db cursor.  Checks the items against the
 * list of provided IDs and adds them to the 'results' array if they match.
 * NOTE(ericzhang): the 'request' parameter is unused here, but we include it
 * in order to match the interface expected by doQuery_.
 * @param {!Array.<string>} ids The list of ids.
 * @param {!goog.db.Cursor} cursor The database cursor.
 * @param {!drive.ds.ItemQueryRequest} request The query request.
 * @param {!Array.<!drive.ds.Item>} results The query results.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.accumulateQueryByIdData_ =
    function(ids, cursor, request, results) {
  var item = this.deserializeItem_(/** @type {?string} */ (cursor.getValue()));
  if (item && goog.array.contains(ids, item.getId())) {
    results.push(item.cloneMessage());
  }
  cursor.next();
};


/**
 * Returns a deferred object that waits on the results of the input deferred
 * and deserializes it.
 * @param {!goog.async.Deferred} deferred The deferred serialized item proto
 *     to wait on.
 * @return {!goog.async.Deferred.<drive.ds.Item>} A deferred object that
 *     returns a deserialized Item object.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.deferredDeserialize_ =
    function(deferred) {
  var result = new goog.async.Deferred();
  deferred.addCallback(function(itemData) {
    result.callback(this.deserializeItem_(itemData));
  }, this);
  deferred.addErrback(function(error) {
    result.errback(error);
  });
  return result;
};


/**
 * Deserialize the item string from the datastore.
 * @param {?string} itemStr The string representing the item.
 * @return {drive.ds.Item} The Item jspb object.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.deserializeItem_ =
    function(itemStr) {
  if (!itemStr) {
    return null;
  }
  var itemArray = /** @type {Array} */ (JSON.parse(itemStr));
  return new drive.ds.Item(itemArray);
};


/**
 * Handles the export completion.
 * @param {!Array.<!drive.ds.Item>} items The query results.
 * @param {!goog.async.Deferred.<!drive.ds.Dumpello>} deferred The deferred
 *     object that is waiting on the exported items and permissions.
 * @param {!goog.events.EventHandler} handler The event handler for processing
 *     query events.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.handleExportComplete_ =
    function(items, deferred, handler) {
  handler.removeAll();

  var dumpello = new drive.ds.Dumpello();
  dumpello.setItemList(items);
  // TODO(towong): Populate the dumpello permissions.

  deferred.callback(dumpello);
};


/**
 * Handles a query error.
 * @param {!goog.async.Deferred} deferred The deferred object that is waiting
 *     on the results of this query.
 * @param {!goog.events.EventHandler} handler The event handler for processing
 *     query events.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.handleExportError_ =
    function(deferred, handler) {
  handler.removeAll();
  deferred.errback();
};


/**
 * Handles the completion of an item query.  Constructs an ItemQueryResponse
 * with the results of the query and sets its completion status.
 * @param {drive.ds.ItemQueryRequest} request The query request.
 * @param {!Array.<!drive.ds.Item>} items The query results.
 * @param {!goog.async.Deferred.<!drive.ds.ItemQueryResponse>} deferred The
 *     deferred object that is waiting on the results of this query.
 * @param {!goog.events.EventHandler} handler The event handler for processing
 *     query events.
 * @param {number} limit The desired number of items, -1 for all items.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.handleQueryComplete_ =
    function(request, items, deferred, handler, limit) {
  handler.removeAll();

  var response = new drive.ds.ItemQueryResponse();
  this.sortAndTruncate(request, items, limit);
  if (request) {
    this.fieldPruning(request, items);
  }
  response.setStatus(drive.ds.Status.SUCCESS);
  response.setItemList(items);
  deferred.callback(response);
};


/**
 * Handles a query error.
 * @param {!goog.async.Deferred.<!drive.ds.ItemQueryResponse>} deferred The
 *     deferred object that is waiting on the results of this query.
 * @param {!goog.events.EventHandler} handler The event handler for processing
 *     query events.
 * @private
 */
drive.ds.sync.cache.IndexedDbCache.prototype.handleQueryError_ =
    function(deferred, handler) {
  handler.removeAll();
  deferred.errback();
};

//javascript/closure/storage/mechanism/errorcode.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines error codes to be thrown by storage mechanisms.
 *
 * @author azzie@google.com (Marcin Marszalek)
 */

goog.provide('goog.storage.mechanism.ErrorCode');


/**
 * Errors thrown by storage mechanisms.
 * @enum {string}
 */
goog.storage.mechanism.ErrorCode = {
  INVALID_VALUE: 'Storage mechanism: Invalid value was encountered',
  QUOTA_EXCEEDED: 'Storage mechanism: Quota exceeded',
  STORAGE_DISABLED: 'Storage mechanism: Storage disabled'
};

//javascript/closure/storage/mechanism/mechanism.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Abstract interface for storing and retrieving data using
 * some persistence mechanism.
 *
 * @author azzie@google.com (Marcin Marszalek)
 */

goog.provide('goog.storage.mechanism.Mechanism');



/**
 * Basic interface for all storage mechanisms.
 *
 * @constructor
 */
goog.storage.mechanism.Mechanism = function() {};


/**
 * Set a value for a key.
 *
 * @param {string} key The key to set.
 * @param {string} value The string to save.
 */
goog.storage.mechanism.Mechanism.prototype.set = goog.abstractMethod;


/**
 * Get the value stored under a key.
 *
 * @param {string} key The key to get.
 * @return {?string} The corresponding value, null if not found.
 */
goog.storage.mechanism.Mechanism.prototype.get = goog.abstractMethod;


/**
 * Remove a key and its value.
 *
 * @param {string} key The key to remove.
 */
goog.storage.mechanism.Mechanism.prototype.remove = goog.abstractMethod;

//javascript/closure/storage/mechanism/iterablemechanism.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Interface for storing, retieving and scanning data using some
 * persistence mechanism.
 *
 * @author azzie@google.com (Marcin Marszalek)
 */

goog.provide('goog.storage.mechanism.IterableMechanism');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.iter');
goog.require('goog.iter.Iterator');
goog.require('goog.storage.mechanism.Mechanism');



/**
 * Interface for all iterable storage mechanisms.
 *
 * @constructor
 * @extends {goog.storage.mechanism.Mechanism}
 */
goog.storage.mechanism.IterableMechanism = function() {
  goog.base(this);
};
goog.inherits(goog.storage.mechanism.IterableMechanism,
              goog.storage.mechanism.Mechanism);


/**
 * Get the number of stored key-value pairs.
 *
 * Could be overridden in a subclass, as the default implementation is not very
 * efficient - it iterates over all keys.
 *
 * @return {number} Number of stored elements.
 */
goog.storage.mechanism.IterableMechanism.prototype.getCount = function() {
  var count = 0;
  goog.iter.forEach(this.__iterator__(true), function(key) {
    goog.asserts.assertString(key);
    count++;
  });
  return count;
};


/**
 * Returns an iterator that iterates over the elements in the storage. Will
 * throw goog.iter.StopIteration after the last element.
 *
 * @param {boolean=} opt_keys True to iterate over the keys. False to iterate
 *     over the values.  The default value is false.
 * @return {!goog.iter.Iterator} The iterator.
 */
goog.storage.mechanism.IterableMechanism.prototype.__iterator__ =
    goog.abstractMethod;


/**
 * Remove all key-value pairs.
 *
 * Could be overridden in a subclass, as the default implementation is not very
 * efficient - it iterates over all keys.
 */
goog.storage.mechanism.IterableMechanism.prototype.clear = function() {
  var keys = goog.iter.toArray(this.__iterator__(true));
  var selfObj = this;
  goog.array.forEach(keys, function(key) {
    selfObj.remove(key);
  });
};

//javascript/closure/storage/mechanism/html5webstorage.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Base class that implements functionality common
 * across both session and local web storage mechanisms.
 *
 * @author azzie@google.com (Marcin Marszalek)
 * @author czacharias@google.com (Chris Zacharias)
 * @author rakar@google.com (Rajesh Jagannathan)
 */

goog.provide('goog.storage.mechanism.HTML5WebStorage');

goog.require('goog.asserts');
goog.require('goog.iter.Iterator');
goog.require('goog.iter.StopIteration');
goog.require('goog.storage.mechanism.ErrorCode');
goog.require('goog.storage.mechanism.IterableMechanism');



/**
 * Provides a storage mechanism that uses HTML5 Web storage.
 *
 * @param {Storage} storage The Web storage object.
 * @constructor
 * @extends {goog.storage.mechanism.IterableMechanism}
 */
goog.storage.mechanism.HTML5WebStorage = function(storage) {
  goog.base(this);

  /**
   * The web storage object (window.localStorage or window.sessionStorage).
   * @private {Storage}
   */
  this.storage_ = storage;
};
goog.inherits(goog.storage.mechanism.HTML5WebStorage,
              goog.storage.mechanism.IterableMechanism);


/**
 * The key used to check if the storage instance is available.
 * @private {string}
 * @const
 */
goog.storage.mechanism.HTML5WebStorage.STORAGE_AVAILABLE_KEY_ = '__sak';


/**
 * Determines whether or not the mechanism is available.
 * It works only if the provided web storage object exists and is enabled.
 *
 * @return {boolean} True if the mechanism is available.
 */
goog.storage.mechanism.HTML5WebStorage.prototype.isAvailable = function() {
  if (!this.storage_) {
    return false;
  }
  /** @preserveTry */
  try {
    // setItem will throw an exception if we cannot access WebStorage (e.g.,
    // Safari in private mode).
    this.storage_.setItem(
        goog.storage.mechanism.HTML5WebStorage.STORAGE_AVAILABLE_KEY_, '1');
    this.storage_.removeItem(
        goog.storage.mechanism.HTML5WebStorage.STORAGE_AVAILABLE_KEY_);
    return true;
  } catch (e) {
    return false;
  }
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.set = function(key, value) {
  /** @preserveTry */
  try {
    // May throw an exception if storage quota is exceeded.
    this.storage_.setItem(key, value);
  } catch (e) {
    // In Safari Private mode, conforming to the W3C spec, invoking
    // Storage.prototype.setItem will allways throw a QUOTA_EXCEEDED_ERR
    // exception.  Since it's impossible to verify if we're in private browsing
    // mode, we throw a different exception if the storage is empty.
    if (this.storage_.length == 0) {
      throw goog.storage.mechanism.ErrorCode.STORAGE_DISABLED;
    } else {
      throw goog.storage.mechanism.ErrorCode.QUOTA_EXCEEDED;
    }
  }
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.get = function(key) {
  // According to W3C specs, values can be of any type. Since we only save
  // strings, any other type is a storage error. If we returned nulls for
  // such keys, i.e., treated them as non-existent, this would lead to a
  // paradox where a key exists, but it does not when it is retrieved.
  // http://www.w3.org/TR/2009/WD-webstorage-20091029/#the-storage-interface
  var value = this.storage_.getItem(key);
  if (!goog.isString(value) && !goog.isNull(value)) {
    throw goog.storage.mechanism.ErrorCode.INVALID_VALUE;
  }
  return value;
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.remove = function(key) {
  this.storage_.removeItem(key);
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.getCount = function() {
  return this.storage_.length;
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.__iterator__ = function(
    opt_keys) {
  var i = 0;
  var storage = this.storage_;
  var newIter = new goog.iter.Iterator();
  newIter.next = function() {
    if (i >= storage.length) {
      throw goog.iter.StopIteration;
    }
    var key = goog.asserts.assertString(storage.key(i++));
    if (opt_keys) {
      return key;
    }
    var value = storage.getItem(key);
    // The value must exist and be a string, otherwise it is a storage error.
    if (!goog.isString(value)) {
      throw goog.storage.mechanism.ErrorCode.INVALID_VALUE;
    }
    return value;
  };
  return newIter;
};


/** @override */
goog.storage.mechanism.HTML5WebStorage.prototype.clear = function() {
  this.storage_.clear();
};


/**
 * Gets the key for a given key index. If an index outside of
 * [0..this.getCount()) is specified, this function returns null.
 * @param {number} index A key index.
 * @return {?string} A storage key, or null if the specified index is out of
 *     range.
 */
goog.storage.mechanism.HTML5WebStorage.prototype.key = function(index) {
  return this.storage_.key(index);
};

//javascript/closure/storage/mechanism/html5localstorage.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides data persistence using HTML5 local storage
 * mechanism. Local storage must be available under window.localStorage,
 * see: http://www.w3.org/TR/webstorage/#the-localstorage-attribute.
 *
 * @author azzie@google.com (Marcin Marszalek)
 * @author czacharias@google.com (Chris Zacharias)
 */

goog.provide('goog.storage.mechanism.HTML5LocalStorage');

goog.require('goog.storage.mechanism.HTML5WebStorage');



/**
 * Provides a storage mechanism that uses HTML5 local storage.
 *
 * @constructor
 * @extends {goog.storage.mechanism.HTML5WebStorage}
 */
goog.storage.mechanism.HTML5LocalStorage = function() {
  var storage = null;
  /** @preserveTry */
  try {
    // May throw an exception in cases where the local storage object
    // is visible but access to it is disabled.
    storage = window.localStorage || null;
  } catch (e) {}
  goog.base(this, storage);
};
goog.inherits(goog.storage.mechanism.HTML5LocalStorage,
              goog.storage.mechanism.HTML5WebStorage);

//javascript/closure/storage/mechanism/html5sessionstorage.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides data persistence using HTML5 session storage
 * mechanism. Session storage must be available under window.sessionStorage,
 * see: http://www.w3.org/TR/webstorage/#the-sessionstorage-attribute.
 *
 * @author rakar@google.com (Rajesh Jagannathan)
 */

goog.provide('goog.storage.mechanism.HTML5SessionStorage');

goog.require('goog.storage.mechanism.HTML5WebStorage');



/**
 * Provides a storage mechanism that uses HTML5 session storage.
 *
 * @constructor
 * @extends {goog.storage.mechanism.HTML5WebStorage}
 */
goog.storage.mechanism.HTML5SessionStorage = function() {
  var storage = null;
  /** @preserveTry */
  try {
    // May throw an exception in cases where the session storage object is
    // visible but access to it is disabled. For example, accessing the file
    // in local mode in Firefox throws 'Operation is not supported' exception.
    storage = window.sessionStorage || null;
  } catch (e) {}
  goog.base(this, storage);
};
goog.inherits(goog.storage.mechanism.HTML5SessionStorage,
              goog.storage.mechanism.HTML5WebStorage);

//javascript/closure/storage/mechanism/ieuserdata.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides data persistence using IE userData mechanism.
 * UserData uses proprietary Element.addBehavior(), Element.load(),
 * Element.save(), and Element.XMLDocument() methods, see:
 * http://msdn.microsoft.com/en-us/library/ms531424(v=vs.85).aspx.
 *
 * @author azzie@google.com (Marcin Marszalek)
 * @author czacharias@google.com (Chris Zacharias)
 * @author teh@google.com (Taylor Hughes)
 */

goog.provide('goog.storage.mechanism.IEUserData');

goog.require('goog.asserts');
goog.require('goog.iter.Iterator');
goog.require('goog.iter.StopIteration');
goog.require('goog.storage.mechanism.ErrorCode');
goog.require('goog.storage.mechanism.IterableMechanism');
goog.require('goog.structs.Map');
goog.require('goog.userAgent');



/**
 * Provides a storage mechanism using IE userData.
 *
 * @param {string} storageKey The key (store name) to store the data under.
 * @param {string=} opt_storageNodeId The ID of the associated HTML element,
 *     one will be created if not provided.
 * @constructor
 * @extends {goog.storage.mechanism.IterableMechanism}
 * @final
 */
goog.storage.mechanism.IEUserData = function(storageKey, opt_storageNodeId) {
  goog.base(this);

  // Tested on IE6, IE7 and IE8. It seems that IE9 introduces some security
  // features which make persistent (loaded) node attributes invisible from
  // JavaScript.
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
    if (!goog.storage.mechanism.IEUserData.storageMap_) {
      goog.storage.mechanism.IEUserData.storageMap_ = new goog.structs.Map();
    }
    this.storageNode_ = /** @type {Element} */ (
        goog.storage.mechanism.IEUserData.storageMap_.get(storageKey));
    if (!this.storageNode_) {
      if (opt_storageNodeId) {
        this.storageNode_ = document.getElementById(opt_storageNodeId);
      } else {
        this.storageNode_ = document.createElement('userdata');
        // This is a special IE-only method letting us persist data.
        this.storageNode_['addBehavior']('#default#userData');
        document.body.appendChild(this.storageNode_);
      }
      goog.storage.mechanism.IEUserData.storageMap_.set(
          storageKey, this.storageNode_);
    }
    this.storageKey_ = storageKey;

    /** @preserveTry */
    try {
      // Availability check.
      this.loadNode_();
    } catch (e) {
      this.storageNode_ = null;
    }
  }
};
goog.inherits(goog.storage.mechanism.IEUserData,
              goog.storage.mechanism.IterableMechanism);


/**
 * Encoding map for characters which are not encoded by encodeURIComponent().
 * See encodeKey_ documentation for encoding details.
 *
 * @type {!Object}
 * @const
 */
goog.storage.mechanism.IEUserData.ENCODE_MAP = {
  '.': '.2E',
  '!': '.21',
  '~': '.7E',
  '*': '.2A',
  '\'': '.27',
  '(': '.28',
  ')': '.29',
  '%': '.'
};


/**
 * Global storageKey to storageNode map, so we save on reloading the storage.
 *
 * @type {goog.structs.Map}
 * @private
 */
goog.storage.mechanism.IEUserData.storageMap_ = null;


/**
 * The document element used for storing data.
 *
 * @type {Element}
 * @private
 */
goog.storage.mechanism.IEUserData.prototype.storageNode_ = null;


/**
 * The key to store the data under.
 *
 * @type {?string}
 * @private
 */
goog.storage.mechanism.IEUserData.prototype.storageKey_ = null;


/**
 * Encodes anything other than [-a-zA-Z0-9_] using a dot followed by hex,
 * and prefixes with underscore to form a valid and safe HTML attribute name.
 *
 * We use URI encoding to do the initial heavy lifting, then escape the
 * remaining characters that we can't use. Since a valid attribute name can't
 * contain the percent sign (%), we use a dot (.) as an escape character.
 *
 * @param {string} key The key to be encoded.
 * @return {string} The encoded key.
 * @private
 */
goog.storage.mechanism.IEUserData.encodeKey_ = function(key) {
  // encodeURIComponent leaves - _ . ! ~ * ' ( ) unencoded.
  return '_' + encodeURIComponent(key).replace(/[.!~*'()%]/g, function(c) {
    return goog.storage.mechanism.IEUserData.ENCODE_MAP[c];
  });
};


/**
 * Decodes a dot-encoded and character-prefixed key.
 * See encodeKey_ documentation for encoding details.
 *
 * @param {string} key The key to be decoded.
 * @return {string} The decoded key.
 * @private
 */
goog.storage.mechanism.IEUserData.decodeKey_ = function(key) {
  return decodeURIComponent(key.replace(/\./g, '%')).substr(1);
};


/**
 * Determines whether or not the mechanism is available.
 *
 * @return {boolean} True if the mechanism is available.
 */
goog.storage.mechanism.IEUserData.prototype.isAvailable = function() {
  return !!this.storageNode_;
};


/** @override */
goog.storage.mechanism.IEUserData.prototype.set = function(key, value) {
  this.storageNode_.setAttribute(
      goog.storage.mechanism.IEUserData.encodeKey_(key), value);
  this.saveNode_();
};


/** @override */
goog.storage.mechanism.IEUserData.prototype.get = function(key) {
  // According to Microsoft, values can be strings, numbers or booleans. Since
  // we only save strings, any other type is a storage error. If we returned
  // nulls for such keys, i.e., treated them as non-existent, this would lead
  // to a paradox where a key exists, but it does not when it is retrieved.
  // http://msdn.microsoft.com/en-us/library/ms531348(v=vs.85).aspx
  var value = this.storageNode_.getAttribute(
      goog.storage.mechanism.IEUserData.encodeKey_(key));
  if (!goog.isString(value) && !goog.isNull(value)) {
    throw goog.storage.mechanism.ErrorCode.INVALID_VALUE;
  }
  return value;
};


/** @override */
goog.storage.mechanism.IEUserData.prototype.remove = function(key) {
  this.storageNode_.removeAttribute(
      goog.storage.mechanism.IEUserData.encodeKey_(key));
  this.saveNode_();
};


/** @override */
goog.storage.mechanism.IEUserData.prototype.getCount = function() {
  return this.getNode_().attributes.length;
};


/** @override */
goog.storage.mechanism.IEUserData.prototype.__iterator__ = function(opt_keys) {
  var i = 0;
  var attributes = this.getNode_().attributes;
  var newIter = new goog.iter.Iterator();
  newIter.next = function() {
    if (i >= attributes.length) {
      throw goog.iter.StopIteration;
    }
    var item = goog.asserts.assert(attributes[i++]);
    if (opt_keys) {
      return goog.storage.mechanism.IEUserData.decodeKey_(item.nodeName);
    }
    var value = item.nodeValue;
    // The value must exist and be a string, otherwise it is a storage error.
    if (!goog.isString(value)) {
      throw goog.storage.mechanism.ErrorCode.INVALID_VALUE;
    }
    return value;
  };
  return newIter;
};


/** @override */
goog.storage.mechanism.IEUserData.prototype.clear = function() {
  var node = this.getNode_();
  for (var left = node.attributes.length; left > 0; left--) {
    node.removeAttribute(node.attributes[left - 1].nodeName);
  }
  this.saveNode_();
};


/**
 * Loads the underlying storage node to the state we saved it to before.
 *
 * @private
 */
goog.storage.mechanism.IEUserData.prototype.loadNode_ = function() {
  // This is a special IE-only method on Elements letting us persist data.
  this.storageNode_['load'](this.storageKey_);
};


/**
 * Saves the underlying storage node.
 *
 * @private
 */
goog.storage.mechanism.IEUserData.prototype.saveNode_ = function() {
  /** @preserveTry */
  try {
    // This is a special IE-only method on Elements letting us persist data.
    // Do not try to assign this.storageNode_['save'] to a variable, it does
    // not work. May throw an exception when the quota is exceeded.
    this.storageNode_['save'](this.storageKey_);
  } catch (e) {
    throw goog.storage.mechanism.ErrorCode.QUOTA_EXCEEDED;
  }
};


/**
 * Returns the storage node.
 *
 * @return {Element} Storage DOM Element.
 * @private
 */
goog.storage.mechanism.IEUserData.prototype.getNode_ = function() {
  // This is a special IE-only property letting us browse persistent data.
  var doc = /** @type {Document} */ (this.storageNode_['XMLDocument']);
  return doc.documentElement;
};

//javascript/closure/storage/mechanism/prefixedmechanism.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Wraps an iterable storage mechanism and creates artificial
 * namespaces using a prefix in the global namespace.
 *
 * @author azzie@google.com (Marcin Marszalek)
 */

goog.provide('goog.storage.mechanism.PrefixedMechanism');

goog.require('goog.iter.Iterator');
goog.require('goog.storage.mechanism.IterableMechanism');



/**
 * Wraps an iterable storage mechanism and creates artificial namespaces.
 *
 * @param {!goog.storage.mechanism.IterableMechanism} mechanism Underlying
 *     iterable storage mechanism.
 * @param {string} prefix Prefix for creating an artificial namespace.
 * @constructor
 * @extends {goog.storage.mechanism.IterableMechanism}
 * @final
 */
goog.storage.mechanism.PrefixedMechanism = function(mechanism, prefix) {
  goog.base(this);
  this.mechanism_ = mechanism;
  this.prefix_ = prefix + '::';
};
goog.inherits(goog.storage.mechanism.PrefixedMechanism,
              goog.storage.mechanism.IterableMechanism);


/**
 * The mechanism to be prefixed.
 *
 * @type {goog.storage.mechanism.IterableMechanism}
 * @private
 */
goog.storage.mechanism.PrefixedMechanism.prototype.mechanism_ = null;


/**
 * The prefix for creating artificial namespaces.
 *
 * @type {string}
 * @private
 */
goog.storage.mechanism.PrefixedMechanism.prototype.prefix_ = '';


/** @override */
goog.storage.mechanism.PrefixedMechanism.prototype.set = function(key, value) {
  this.mechanism_.set(this.prefix_ + key, value);
};


/** @override */
goog.storage.mechanism.PrefixedMechanism.prototype.get = function(key) {
  return this.mechanism_.get(this.prefix_ + key);
};


/** @override */
goog.storage.mechanism.PrefixedMechanism.prototype.remove = function(key) {
  this.mechanism_.remove(this.prefix_ + key);
};


/** @override */
goog.storage.mechanism.PrefixedMechanism.prototype.__iterator__ = function(
    opt_keys) {
  var subIter = this.mechanism_.__iterator__(true);
  var selfObj = this;
  var newIter = new goog.iter.Iterator();
  newIter.next = function() {
    var key = /** @type {string} */ (subIter.next());
    while (key.substr(0, selfObj.prefix_.length) != selfObj.prefix_) {
      key = /** @type {string} */ (subIter.next());
    }
    return opt_keys ? key.substr(selfObj.prefix_.length) :
                      selfObj.mechanism_.get(key);
  };
  return newIter;
};

//javascript/closure/storage/mechanism/mechanismfactory.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides factory methods for selecting the best storage
 * mechanism, depending on availability and needs.
 *
 * @author azzie@google.com (Marcin Marszalek)
 */

goog.provide('goog.storage.mechanism.mechanismfactory');

goog.require('goog.storage.mechanism.HTML5LocalStorage');
goog.require('goog.storage.mechanism.HTML5SessionStorage');
goog.require('goog.storage.mechanism.IEUserData');
goog.require('goog.storage.mechanism.IterableMechanism');
goog.require('goog.storage.mechanism.PrefixedMechanism');


/**
 * The key to shared userData storage.
 * @type {string}
 */
goog.storage.mechanism.mechanismfactory.USER_DATA_SHARED_KEY =
    'UserDataSharedStore';


/**
 * Returns the best local storage mechanism, or null if unavailable.
 * Local storage means that the database is placed on user's computer.
 * The key-value database is normally shared between all the code paths
 * that request it, so using an optional namespace is recommended. This
 * provides separation and makes key collisions unlikely.
 *
 * @param {string=} opt_namespace Restricts the visibility to given namespace.
 * @return {goog.storage.mechanism.IterableMechanism} Created mechanism or null.
 */
goog.storage.mechanism.mechanismfactory.create = function(opt_namespace) {
  return goog.storage.mechanism.mechanismfactory.createHTML5LocalStorage(
      opt_namespace) ||
      goog.storage.mechanism.mechanismfactory.createIEUserData(opt_namespace);
};


/**
 * Returns an HTML5 local storage mechanism, or null if unavailable.
 * Since the HTML5 local storage does not support namespaces natively,
 * and the key-value database is shared between all the code paths
 * that request it, it is recommended that an optional namespace is
 * used to provide key separation employing a prefix.
 *
 * @param {string=} opt_namespace Restricts the visibility to given namespace.
 * @return {goog.storage.mechanism.IterableMechanism} Created mechanism or null.
 */
goog.storage.mechanism.mechanismfactory.createHTML5LocalStorage = function(
    opt_namespace) {
  var storage = new goog.storage.mechanism.HTML5LocalStorage();
  if (storage.isAvailable()) {
    return opt_namespace ? new goog.storage.mechanism.PrefixedMechanism(
        storage, opt_namespace) : storage;
  }
  return null;
};


/**
 * Returns an HTML5 session storage mechanism, or null if unavailable.
 * Since the HTML5 session storage does not support namespaces natively,
 * and the key-value database is shared between all the code paths
 * that request it, it is recommended that an optional namespace is
 * used to provide key separation employing a prefix.
 *
 * @param {string=} opt_namespace Restricts the visibility to given namespace.
 * @return {goog.storage.mechanism.IterableMechanism} Created mechanism or null.
 */
goog.storage.mechanism.mechanismfactory.createHTML5SessionStorage = function(
    opt_namespace) {
  var storage = new goog.storage.mechanism.HTML5SessionStorage();
  if (storage.isAvailable()) {
    return opt_namespace ? new goog.storage.mechanism.PrefixedMechanism(
        storage, opt_namespace) : storage;
  }
  return null;
};


/**
 * Returns an IE userData local storage mechanism, or null if unavailable.
 * Using an optional namespace is recommended to provide separation and
 * avoid key collisions.
 *
 * @param {string=} opt_namespace Restricts the visibility to given namespace.
 * @return {goog.storage.mechanism.IterableMechanism} Created mechanism or null.
 */
goog.storage.mechanism.mechanismfactory.createIEUserData = function(
    opt_namespace) {
  var storage = new goog.storage.mechanism.IEUserData(opt_namespace ||
      goog.storage.mechanism.mechanismfactory.USER_DATA_SHARED_KEY);
  if (storage.isAvailable()) {
    return storage;
  }
  return null;
};

//javascript/closure/storage/errorcode.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines errors to be thrown by the storage.
 *
 * @author azzie@google.com (Marcin Marszalek)
 */

goog.provide('goog.storage.ErrorCode');


/**
 * Errors thrown by the storage.
 * @enum {string}
 */
goog.storage.ErrorCode = {
  INVALID_VALUE: 'Storage: Invalid value was encountered',
  DECRYPTION_ERROR: 'Storage: The value could not be decrypted'
};

//javascript/closure/storage/storage.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides a convenient API for data persistence using a selected
 * data storage mechanism.
 *
 * @author azzie@google.com (Marcin Marszalek)
 * @author teh@google.com (Taylor Hughes)
 * @author czacharias@google.com (Chris Zacharias)
 */

goog.provide('goog.storage.Storage');

goog.require('goog.json');
goog.require('goog.json.Serializer');
goog.require('goog.storage.ErrorCode');



/**
 * The base implementation for all storage APIs.
 *
 * @param {!goog.storage.mechanism.Mechanism} mechanism The underlying
 *     storage mechanism.
 * @constructor
 */
goog.storage.Storage = function(mechanism) {
  /**
   * The mechanism used to persist key-value pairs.
   *
   * @protected {goog.storage.mechanism.Mechanism}
   */
  this.mechanism = mechanism;

  /**
   * The JSON serializer used to serialize values.
   *
   * @private {!goog.json.Serializer}
   */
  this.serializer_ = new goog.json.Serializer();
};


/**
 * Sets an item in the data storage.
 *
 * @param {string} key The key to set.
 * @param {*} value The value to serialize to a string and save.
 */
goog.storage.Storage.prototype.set = function(key, value) {
  if (!goog.isDef(value)) {
    this.mechanism.remove(key);
    return;
  }
  this.mechanism.set(key, this.serializer_.serialize(value));
};


/**
 * Gets an item from the data storage.
 *
 * @param {string} key The key to get.
 * @return {*} Deserialized value or undefined if not found.
 */
goog.storage.Storage.prototype.get = function(key) {
  var json;
  try {
    json = this.mechanism.get(key);
  } catch (e) {
    // If, for any reason, the value returned by a mechanism's get method is not
    // a string, an exception is thrown.  In this case, we must fail gracefully
    // instead of propagating the exception to clients.  See b/8095488 for
    // details.
    return undefined;
  }
  if (goog.isNull(json)) {
    return undefined;
  }
  /** @preserveTry */
  try {
    return goog.json.parse(json);
  } catch (e) {
    throw goog.storage.ErrorCode.INVALID_VALUE;
  }
};


/**
 * Removes an item from the data storage.
 *
 * @param {string} key The key to remove.
 */
goog.storage.Storage.prototype.remove = function(key) {
  this.mechanism.remove(key);
};

//javascript/apps/drive/dataservice/sync/cache/metadatastore.js
goog.provide('drive.ds.sync.cache.MetadataStore');



/**
 * A store of client-side metadata for the synced item service.
 * @constructor
 */
drive.ds.sync.cache.MetadataStore = function() {
};


/** @return {goog.math.Long} Get the last processed change ID. */
drive.ds.sync.cache.MetadataStore.prototype.getLastChangeId =
    goog.abstractMethod;


/**
 * Set the last processed change ID, pass in null to clear.
 * @param {goog.math.Long} changeId The change ID to set, or null to remove
 *     value.
 */
drive.ds.sync.cache.MetadataStore.prototype.setLastChangeId =
    goog.abstractMethod;


/** @return {string} Get the user's root item ID. */
drive.ds.sync.cache.MetadataStore.prototype.getRootId = goog.abstractMethod;


/**
 * Set the user's root item ID, pass in null to clear.
 * @param {string} rootId The root ID to set, or null to remove value.
 */
drive.ds.sync.cache.MetadataStore.prototype.setRootId = goog.abstractMethod;

//javascript/apps/drive/dataservice/sync/cache/indexeddbmetadatastore.js
goog.provide('drive.ds.sync.cache.IndexedDbMetadataStore');

goog.require('drive.ds.sync.cache.MetadataStore');
goog.require('goog.asserts');
goog.require('goog.math.Long');
goog.require('goog.storage.Storage');
goog.require('goog.storage.mechanism.mechanismfactory');



/**
 * A store of client-side metadata backed by indexed db.
 * @extends {drive.ds.sync.cache.MetadataStore}
 * @constructor
 */
drive.ds.sync.cache.IndexedDbMetadataStore = function() {
  /**
   * The local storage mechanism to fetch and save metadata.
   * @private {!goog.storage.Storage}
   */
  this.localStorage_ = new goog.storage.Storage(
      goog.asserts.assert(goog.storage.mechanism.mechanismfactory.create(
          drive.ds.sync.cache.IndexedDbMetadataStore.NAMESPACE_)));
};
goog.inherits(drive.ds.sync.cache.IndexedDbMetadataStore,
    drive.ds.sync.cache.MetadataStore);


/** @private {string} The namespace to use for this metadata store's keys. */
drive.ds.sync.cache.IndexedDbMetadataStore.NAMESPACE_ = 'cello';


/**
 * A enumeration of all the metadata keys stored by this class.
 * @enum {string}
 * @private
 */
drive.ds.sync.cache.IndexedDbMetadataStore.Keys_ = {
  LAST_CHANGE_ID: 'lastChangeId',
  ROOT_ID: 'rootId'
};


/** @override */
drive.ds.sync.cache.IndexedDbMetadataStore.prototype.getLastChangeId =
    function() {
  var changeIdStr = /** @type {?string} */ (this.localStorage_.get(
      drive.ds.sync.cache.IndexedDbMetadataStore.Keys_.LAST_CHANGE_ID));
  return changeIdStr ? goog.math.Long.fromString(changeIdStr) : null;
};


/** @override */
drive.ds.sync.cache.IndexedDbMetadataStore.prototype.setLastChangeId =
    function(changeId) {
  this.set_(drive.ds.sync.cache.IndexedDbMetadataStore.Keys_.LAST_CHANGE_ID,
      (changeId ? changeId.toString() : ''));
};


/** @override */
drive.ds.sync.cache.IndexedDbMetadataStore.prototype.getRootId = function() {
  return /** @type {string} */ (this.localStorage_.get(
      drive.ds.sync.cache.IndexedDbMetadataStore.Keys_.ROOT_ID) || '');
};


/** @override */
drive.ds.sync.cache.IndexedDbMetadataStore.prototype.setRootId =
    function(rootId) {
  this.set_(
      drive.ds.sync.cache.IndexedDbMetadataStore.Keys_.ROOT_ID, rootId);
};


/**
 * Sets a key/value pair to the indexed db instance.
 * @param {!drive.ds.sync.cache.IndexedDbMetadataStore.Keys_} key The key.
 * @param {string} value The value to set, empty to clear.
 * @private
 */
drive.ds.sync.cache.IndexedDbMetadataStore.prototype.set_ =
    function(key, value) {
  value ? this.localStorage_.set(key, value) : this.localStorage_.remove(key);
};

//javascript/apps/drive/dataservice/sync/sort/permissionsorter.js
goog.provide('drive.ds.sync.sort.PermissionSorter');

goog.require('drive.ds.Permission');
goog.require('drive.ds.Role');
goog.require('goog.array');



/**
 * An permission specific sorter.
 * @constructor
 */
drive.ds.sync.sort.PermissionSorter = function() { };


/** @private {!Object.<!drive.ds.Role, number>} Map of role to precedence. */
drive.ds.sync.sort.PermissionSorter.ROLE_PRECEDENCE_;


/**
 * Map of type to precedence.
 * @private {!Object.<!drive.ds.Permission.Type, number>}
 */
drive.ds.sync.sort.PermissionSorter.TYPE_PRECEDENCE_;


// Populates the precedence information.
(function() {
  var role = {};
  role[drive.ds.Role.OWNER] = 0;
  role[drive.ds.Role.WRITER] = 1;
  role[drive.ds.Role.COMMENTER] = 2;
  role[drive.ds.Role.READER] = 3;
  drive.ds.sync.sort.PermissionSorter.ROLE_PRECEDENCE_ = role;

  var type = {};
  type[drive.ds.Permission.Type.USER] = 0;
  type[drive.ds.Permission.Type.GROUP] = 1;
  type[drive.ds.Permission.Type.DASHER_DOMAIN] = 2;
  type[drive.ds.Permission.Type.ANYONE] = 3;
  drive.ds.sync.sort.PermissionSorter.TYPE_PRECEDENCE_ = type;
})();


/**
 * Sort a set of permissions in the order:
 * - Role (Owner > Writer > Commenter > Reader)
 * - Type (User > Group > Domain > Anyone)
 * - Obfuscated Gaia Id.
 * @param {!Array.<!drive.ds.Permission>} permissions The permissions to sort.
 */
drive.ds.sync.sort.PermissionSorter.prototype.sort = function(permissions) {
  goog.array.sort(permissions, goog.bind(this.compare_, this));
};


/**
 * Comparator for sorting two permissions by role, type, and gaia id.
 * @param {!drive.ds.Permission} permission1 The first permission.
 * @param {!drive.ds.Permission} permission2 The second permission.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second. Inverted if
 *     we are performing descending sort.
 * @private
 */
drive.ds.sync.sort.PermissionSorter.prototype.compare_ =
    function(permission1, permission2) {
  // Sort by role.
  var result = this.compareRole_(permission1, permission2);
  if (result != 0) {
    return result;
  }

  // Sort by type.
  result = this.compareType_(permission1, permission2);
  if (result != 0) {
    return result;
  }

  // Sort by id.
  return this.compareId_(permission1, permission2);
};


/**
 * Compare two permissions by role, ordered by: Owner, Writer, Commenter,
 * Reader.
 * @param {!drive.ds.Permission} permission1 The first permission.
 * @param {!drive.ds.Permission} permission2 The second permission.
 * @return {number} A negative number, zero, or a positive number if the first
 *     permission is of greater, equal, or lower precedence than the second
 *     permission.
 * @private
 */
drive.ds.sync.sort.PermissionSorter.prototype.compareRole_ =
    function(permission1, permission2) {
  var precedence = drive.ds.sync.sort.PermissionSorter.ROLE_PRECEDENCE_;
  var role1 = precedence[permission1.getRole()];
  var role2 = precedence[permission2.getRole()];
  return goog.array.defaultCompare(role1, role2);
};


/**
 * Compare two permissions by type, ordered by: User, Group, Domain, Anyone.
 * @param {!drive.ds.Permission} permission1 The first permission.
 * @param {!drive.ds.Permission} permission2 The second permission.
 * @return {number} A negative number, zero, or a positive number if the first
 *     permission is of greater, equal, or lower precedence than the second
 *     permission.
 * @private
 */
drive.ds.sync.sort.PermissionSorter.prototype.compareType_ =
    function(permission1, permission2) {
  var precedence = drive.ds.sync.sort.PermissionSorter.TYPE_PRECEDENCE_;
  var type1 = precedence[permission1.getType()];
  var type2 = precedence[permission2.getType()];
  return goog.array.defaultCompare(type1, type2);
};


/**
 * Compare two permissions by gaia id.
 * @param {!drive.ds.Permission} permission1 The first permission.
 * @param {!drive.ds.Permission} permission2 The second permission.
 * @return {number} A negative number, zero, or a positive number if the first
 *     permission has a lower, equal, or greater obfuscated gaia id than the
 *     second permission.
 * @private
 */
drive.ds.sync.sort.PermissionSorter.prototype.compareId_ =
    function(permission1, permission2) {
  var id1 = permission1.getId();
  var id2 = permission2.getId();
  return goog.array.defaultCompare(id1, id2);
};

//javascript/apps/drive/dataservice/sync/cache/permissioncache.js
goog.provide('drive.ds.sync.cache.PermissionCache');



/**
 * An abstract class representing a cache for drive permissions. This cache is
 * expected to be collocated with the item cache and accessed only by the
 * cache.
 * TODO(towong): Add some sort of reference tracking and removal for old
 *     permission entries.
 * @constructor.
 */
drive.ds.sync.cache.PermissionCache = function() { };


/**
 * Retrieves a permission from the cache. Note that the retrieved permission is
 * defensively copied.
 * @param {string} id The permission id to find.
 * @return {drive.ds.Permission} The permission object, or null if not found.
 */
drive.ds.sync.cache.PermissionCache.prototype.getById = goog.abstractMethod;


/**
 * Puts a permission into the cache if the permission doesn't exist yet. If the
 * permission exists already, we update the cached permission with missing
 * fields as needed. Note that the stored permission is defensively copied.
 * @param {!drive.ds.Permission} The permission object to add.
 */
drive.ds.sync.cache.PermissionCache.prototype.put = goog.abstractMethod;


/**
 * Puts a set of permissions into the cache if the permission doesn't exist yet.
 * If a permission exists already, we update the cached permission with missing
 * fields as needed. Note that the stored permission is defensively copied.
 * @param {!Array.<!drive.ds.Permission>} The list of permissions to add.
 */
drive.ds.sync.cache.PermissionCache.prototype.bulkImport = goog.abstractMethod;


/**
 * Exports a list of all the permissions in the cache, permissions are
 * defensively cloned.
 * @return {!Array.<!drive.ds.Permission>} The list of user permissions.
 */
drive.ds.sync.cache.PermissionCache.prototype.bulkExport = goog.abstractMethod;


//javascript/apps/drive/dataservice/sync/cache/inmemorypermissioncache.js
goog.provide('drive.ds.sync.cache.InMemoryPermissionCache');

goog.require('drive.ds.sync.cache.PermissionCache');
goog.require('drive.ds.sync.stat.StatMonitor');
goog.require('goog.object');



/**
 * An in-memory cache of permissions.
 * @extends {drive.ds.sync.cache.PermissionCache}
 * @constructor
 */
drive.ds.sync.cache.InMemoryPermissionCache = function() {
  goog.base(this);

  /**
   * Map of permission id to permissions.
   * @private {!Object.<!drive.ds.Permission>}
   */
  this.permissions_ = {};

  drive.ds.sync.stat.StatMonitor.getInstance().registerMap(
      'Cached Permissions', this.permissions_);
};
goog.inherits(drive.ds.sync.cache.InMemoryPermissionCache,
    drive.ds.sync.cache.PermissionCache);


/** @override */
drive.ds.sync.cache.InMemoryPermissionCache.prototype.getById = function(id) {
  return this.permissions_[id] ? this.permissions_[id].cloneMessage() : null;
};


/** @override */
drive.ds.sync.cache.InMemoryPermissionCache.prototype.put =
    function(permission) {
  var cachedPermission = this.permissions_[permission.getId()];

  if (cachedPermission) {
    // Existing permission, update fields as needed.
    if (permission.getType()) {
      cachedPermission.setType(permission.getType());
    }

    if (permission.getName()) {
      cachedPermission.setName(permission.getName());
    }

    if (permission.getPhotoUrl()) {
      cachedPermission.setPhotoUrl(permission.getPhotoUrl());
    }

    if (permission.getIsMe()) {
      cachedPermission.setIsMe(permission.getIsMe());
    }
  } else {
    // New permission, add to the cache.
    var clonedPermission = permission.cloneMessage();
    clonedPermission.clearRole();
    this.permissions_[permission.getId()] = clonedPermission;
  }
};


/** @override */
drive.ds.sync.cache.InMemoryPermissionCache.prototype.bulkImport =
    function(permissions) {
  for (var i = 0; i < permissions.length; i++) {
    this.put(permissions[i]);
  }
};


/** @override */
drive.ds.sync.cache.InMemoryPermissionCache.prototype.bulkExport =
    function() {
  var permissions = [];
  goog.object.forEach(this.permissions_, function(permission, index) {
    permissions.push(permission);
  });

  return permissions;
};

//javascript/apps/drive/dataservice/sync/cache/inmemorycache.js
goog.provide('drive.ds.sync.cache.InMemoryCache');

goog.require('drive.ds.Field');
goog.require('drive.ds.ItemQueryRequest');
goog.require('drive.ds.ItemQueryResponse');
goog.require('drive.ds.Permission');
goog.require('drive.ds.Status');
goog.require('drive.ds.sync.ExponentialBackoff');
goog.require('drive.ds.sync.Field');
goog.require('drive.ds.sync.FolderUtil');
goog.require('drive.ds.sync.api.Files');
goog.require('drive.ds.sync.api.Permissions');
goog.require('drive.ds.sync.cache.Cache');
goog.require('drive.ds.sync.cache.CacheOptimizer');
goog.require('drive.ds.sync.cache.InMemoryPermissionCache');
goog.require('drive.ds.sync.response.ResponseHandler');
goog.require('drive.ds.sync.sort.PermissionSorter');
goog.require('drive.ds.sync.stat.StatMonitor');
goog.require('drive.ds.sync.stat.Stopwatch');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.async.Deferred');
goog.require('goog.object');



/**
 * An in-memory cache of drive items.
 * @param {!Array.<!drive.ds.Field>} fields The complete set of fields
 *     that the client could potentially need.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item config.
 * @param {!drive.ds.sync.cache.MetadataStore} metadataStore The metadata store
 *     for this cache.
 * @param {!drive.ds.sync.response.ResponseParser} responseParser The response
 *     parser.
 * @extends {drive.ds.sync.cache.Cache}
 * @constructor
 */
drive.ds.sync.cache.InMemoryCache = function(
    fields, config, metadataStore, responseParser) {
  goog.base(this, fields, config, metadataStore, responseParser);

  /** @private {!Object.<string, drive.ds.Item>} */
  this.items_ = {};

  /** @private {boolean} Whether we should track child folders counts. */
  this.trackChildFolders_ =
      goog.array.contains(fields, drive.ds.Field.HAS_CHILD_FOLDER);

  if (this.trackChildFolders_) {
    /**
     * Map of folder id to child folders count. An entry will only be present
     * for children.
     * @private {!Object.<string, number>}
     */
    this.folderToChildFoldersCount_ = {};
  }

  /** @private {!drive.ds.sync.cache.InMemoryPermissionCache} */
  this.permissionCache_ =
      new drive.ds.sync.cache.InMemoryPermissionCache();

  /** @private {!drive.ds.sync.cache.CacheOptimizer} */
  this.cacheOptimizer_ = new drive.ds.sync.cache.CacheOptimizer(
      fields, this.permissionCache_, config);

  /**
   * The stopwatch for performance timing.
   * @private {!drive.ds.sync.stat.Stopwatch}
   */
  this.stopwatch_ = new drive.ds.sync.stat.Stopwatch();

  /** @private {!drive.ds.sync.ExponentialBackoff} */
  this.nextRetry_ = new drive.ds.sync.ExponentialBackoff();

  /** @private {!drive.ds.sync.sort.PermissionSorter} A permission sorter. */
  this.permissionSorter_ = new drive.ds.sync.sort.PermissionSorter();

  drive.ds.sync.stat.StatMonitor.getInstance().registerMap(
      'Cached Items', this.items_);
};
goog.inherits(drive.ds.sync.cache.InMemoryCache, drive.ds.sync.cache.Cache);


/** @private {number} The number of top users. */
drive.ds.sync.cache.InMemoryCache.NUM_TOP_USERS_ = 5;


/** @override */
drive.ds.sync.cache.InMemoryCache.prototype.initialize = function() {
  if (!this.getRootId()) {
    // TODO(towong): Move this to a CacheInitializer object.
    var deferred = new goog.async.Deferred();
    var request = new drive.ds.ItemQueryRequest();
    request.setId('root');
    drive.ds.sync.api.Files.search(request, goog.partial(
        drive.ds.sync.response.ResponseHandler.handleItemsResponse,
        deferred, this.responseParser),
        this.getFields());
    deferred.addCallback(goog.bind(this.handleInitSuccess_, this));
    deferred.addErrback(goog.bind(this.handleInitError_, this));
  }
};


/** @override */
drive.ds.sync.cache.InMemoryCache.prototype.getById = function(id) {
  var item = this.items_[id];
  return goog.async.Deferred.succeed(item ? item.cloneMessage() : null);
};


/** @override */
drive.ds.sync.cache.InMemoryCache.prototype.query = function(request, limit) {
  this.stopwatch_.start();

  // ID request is a special case that we should handle with queryByIds.
  var id = request.getId();
  if (id) {
    return this.queryByIds(
        request, [id == 'root' ? this.getRootId() : id], limit);
  }

  // TODO(mccollumj): This will only work if the cache is fully populated with
  // the user's corpus. Build a strategy for determining if a query is
  // satisfiable even with a partially full cache.

  var result = new drive.ds.ItemQueryResponse();

  if (!this.isRequestSupported(request)) {
    result.setStatus(drive.ds.Status.UNSUPPORTED);
    return goog.async.Deferred.succeed(result);
  }

  var itemList = [];
  goog.object.forEach(this.items_, function(item, index, items) {
    if (this.meetsRequestSpec(request, item)) {
      itemList.push(item);
    }
  }, this);

  itemList = this.postProcess_(request, itemList, limit);

  result.setStatus(drive.ds.Status.SUCCESS);
  result.setItemList(itemList);

  this.stopwatch_.stop();
  this.getLogger().info(
      'Query took ' + this.stopwatch_.getElapsedTimeMillis() + 'ms');

  return goog.async.Deferred.succeed(result);
};


/** @override */
drive.ds.sync.cache.InMemoryCache.prototype.queryByIds =
    function(request, ids, limit) {
  var result = new drive.ds.ItemQueryResponse();

  var itemList = [];
  for (var i = 0; i < ids.length; i++) {
    var item = this.items_[ids[i]];
    if (item) {
      itemList.push(item);
    }
  }

  itemList = this.postProcess_(request, itemList, limit);

  result.setStatus(drive.ds.Status.SUCCESS);
  result.setItemList(itemList);

  return goog.async.Deferred.succeed(result);
};


/**
 * Given a list of items, applies post processing to ready the list of items to
 * return to the client. We apply:  sorting, truncating, cloning, add calculated
 * fields, and field pruning. This function optimizes to perform expensive
 * operations like cloning as late as possible. Mutable operations are only
 * performed after cloning has been done.
 * @param {drive.ds.ItemQueryRequest} request The query request.  Can be null.
 * @param {!Array.<!drive.ds.Item>} itemList The list of matching items.
 * @param {number} limit The desired number of items, -1 for all items.
 * @return {!Array.<!drive.ds.Item>} Post processed list of items.
 * @private
 */
drive.ds.sync.cache.InMemoryCache.prototype.postProcess_ = function(
    request, itemList, limit) {
  this.sortAndTruncate(request, itemList, limit);

  // Mutable operations should only occur after the items have been cloned.
  var processedItemList = [];
  for (var i = 0; i < itemList.length; i++) {
    var item = itemList[i].cloneMessage();
    this.cacheOptimizer_.addOpenUrl(item);
    this.cacheOptimizer_.addThumbnailUrl(item);
    this.cacheOptimizer_.addPermissions(item);
    this.cacheOptimizer_.addDownloadFields(item);
    this.addHasChildFolder_(item);
    processedItemList.push(item);
  }
  if (request) {
    this.fieldPruning(request, processedItemList);
  }
  return processedItemList;
};


/** @override */
drive.ds.sync.cache.InMemoryCache.prototype.bulkExport = function() {
  var items = [];
  goog.object.forEach(this.items_, function(item, index) {
    items.push(item);
  });
  return goog.async.Deferred.succeed(items);
};


/** @override */
drive.ds.sync.cache.InMemoryCache.prototype.bulkExportPermissions = function() {
  return this.permissionCache_.bulkExport();
};


/** @override */
drive.ds.sync.cache.InMemoryCache.prototype.bulkImport = function(
    items, opt_permissions) {
  if (opt_permissions) {
    this.permissionCache_.bulkImport(opt_permissions);
  }

  drive.ds.sync.Field.filterFields(this.getFields(), items);
  for (var i = 0; i < items.length; i++) {
    this.putInternal_(items[i]);
  }

  this.queueChangeEvent();
  return goog.async.Deferred.succeed(true);
};


/** @override */
drive.ds.sync.cache.InMemoryCache.prototype.requestPermissions = function(ids) {
  for (var i = 0; i < ids.length; i++) {
    var id = ids[i];
    drive.ds.sync.api.Permissions.list(id,
        goog.bind(this.handlePermissionResponse_, this, id));
  }
};


/**
 * Processes a permissions response from Genoa for a given item.
 * @param {string} id The id of the item the permission applies to.
 * @param {!Object} response The response from the drive api.
 * @private
 */
drive.ds.sync.cache.InMemoryCache.prototype.handlePermissionResponse_ =
    function(id, response) {
  var permissionsResponse = this.responseParser.parsePermissions(response);
  var permissions = permissionsResponse.getPermissionList();

  if (!this.items_[id]) {
    return;
  }

  // TODO(towong): This logic should move to the response parser once Genoa
  // provides permissions information.
  var userList = [];
  var visibilityList = [];
  for (var i = 0; i < permissions.length; i++) {
    var permission = permissions[i];
    var type = permission.getType();

    if (type == drive.ds.Permission.Type.USER ||
        type == drive.ds.Permission.Type.GROUP) {
      userList.push(permission);
    } else {
      visibilityList.push(permission);
    }
  }

  // Sort and truncate, we only store the first NUM_TOP_USERS.
  this.permissionSorter_.sort(userList);
  userList = goog.array.slice(
      userList, 0, drive.ds.sync.cache.InMemoryCache.NUM_TOP_USERS_);

  // Store permission fields on the item.
  this.items_[id].setTotalUserCount(permissions.length - visibilityList.length);
  this.items_[id].setUserList(userList);
  this.items_[id].setVisibilityList(visibilityList);

  this.cacheOptimizer_.putPermissions(
      /** @type {!drive.ds.Item} */ (this.items_[id]));
};


/** @override */
drive.ds.sync.cache.InMemoryCache.prototype.put = function(item) {
  // TODO(towong): Deal with put conflicts from multiple sources.
  var putItem = item.cloneMessage();
  drive.ds.sync.Field.filterFields(this.getFields(), [putItem]);
  this.putInternal_(/** @type {!drive.ds.Item} */(putItem));

  this.queueChangeEvent();
  return goog.async.Deferred.succeed(true);
};


/**
 * Internal, shared method to put items into the cache.  Assumes items
 * do not need to be cloned or filtered.
 * @param {!drive.ds.Item} item The item to cache.
 * @private
 */
drive.ds.sync.cache.InMemoryCache.prototype.putInternal_ = function(item) {
  var id = /** @type {!string} */ (item.getId());
  goog.asserts.assert(id != null, 'Attempted to insert an item without an id.');

  // TODO(towong): Remove this once Genoa provides a permissions list with a
  // files.list/changes.list call.
  // We re-use the previous permissions on the item to ensure that permissions
  // don't get plastered when an item changes.
  if (this.items_[id]) {
    var prevItem = this.items_[id];
    item.setUserList(prevItem.getUserList());
    item.setVisibilityList(prevItem.getVisibilityList());
    item.setTotalUserCount(prevItem.getTotalUserCount());
  }

  // TODO(towong): Deal with put conflicts from multiple sources.
  if (this.trackChildFolders_ && drive.ds.sync.FolderUtil.isFolder(item)) {
    this.updateFoldersCount_(this.items_[id] ?
        this.items_[id].getParentList() : [], item.getParentList());
  }
  this.items_[id] = item;

  this.cacheOptimizer_.putPermissions(item);
};


/** @override */
drive.ds.sync.cache.InMemoryCache.prototype.remove = function(id) {
  if (this.trackChildFolders_ &&
      drive.ds.sync.FolderUtil.isFolder(this.items_[id])) {
    this.updateFoldersCount_(this.items_[id].getParentList(), []);
  }

  goog.object.remove(this.items_, id);
  this.queueChangeEvent();

  return goog.async.Deferred.succeed(true);
};


/**
 * Adds a HAS_CHILD_FOLDER field as needed.
 * @param {!drive.ds.Item} item The item to set the has child folder field on.
 * @return {!drive.ds.Item} The item for chaining.
 * @private
 */
drive.ds.sync.cache.InMemoryCache.prototype.addHasChildFolder_ =
    function(item) {
  if (this.trackChildFolders_ && drive.ds.sync.FolderUtil.isFolder(item)) {
    var folderCount = this.folderToChildFoldersCount_[item.getId()];
    item.setHasChildFolder(folderCount ? true : false);
  }
  return item;
};


/**
 * Given a set of before and after parents, update the counts of children that
 * each parent has. In the case of a new item, pass in an empty array for before
 * parents. In the case of a remove item, pass in an empty array for after
 * parents.
 * @param {!Array.<string>} prevParents A list of prev parents for an item, or
 *     an empty array in the case of a new item.
 * @param {!Array.<string>} newParents A list of new parents for an item, or an
 *     empty array in the case of a remove.
 * @private
 */
drive.ds.sync.cache.InMemoryCache.prototype.updateFoldersCount_ =
    function(prevParents, newParents) {
  for (var i = 0; i < prevParents.length; i++) {
    this.decrementFolderCount_(prevParents[i]);
  }
  for (var i = 0; i < newParents.length; i++) {
    this.incrementFolderCount_(newParents[i]);
  }
};


/**
 * Increment a child folder count, creates a zero counter if none exists before
 * this call was made.
 * @param {string} parentId The parent id to increment the child folder count
 *     for.
 * @private
 */
drive.ds.sync.cache.InMemoryCache.prototype.incrementFolderCount_ =
    function(parentId) {
  if (!goog.isNumber(this.folderToChildFoldersCount_[parentId])) {
    this.folderToChildFoldersCount_[parentId] = 0;
  }
  this.folderToChildFoldersCount_[parentId]++;
};


/**
 * Decrement a child folder count, creates a zero counter if none exists before
 * this call was made.
 * @param {string} parentId The parent id to decrement the child folder count
 *     for.
 * @private
 */
drive.ds.sync.cache.InMemoryCache.prototype.decrementFolderCount_ =
    function(parentId) {
  if (!this.folderToChildFoldersCount_[parentId]) {
    this.folderToChildFoldersCount_[parentId] = 0;
  } else {
    this.folderToChildFoldersCount_[parentId]--;
  }
};


/**
 * Sets the root information and dispatch an event that intiailization has
 * completed successfully.
 * @param {!drive.ds.ItemQueryResponse} response The item query response.
 * @private
 */
drive.ds.sync.cache.InMemoryCache.prototype.handleInitSuccess_ =
    function(response) {
  var item = response.getItemList()[0];
  this.setRootId(item.getId());
  this.put(item);
  this.setInitialized();
};


/**
 * Retries the root initialization.
 * @private
 */
drive.ds.sync.cache.InMemoryCache.prototype.handleInitError_ = function() {
  this.nextRetry_.backoff();
  goog.global.setTimeout(goog.bind(this.initialize, this),
      this.nextRetry_.getValue());
};

//javascript/apps/drive/dataservice/sync/cache/inmemorymetadatastore.js
goog.provide('drive.ds.sync.cache.InMemoryMetadataStore');

goog.require('drive.ds.sync.cache.MetadataStore');



/**
 * A store of client-side metadata backed by an in-memory datastore.
 * @extends {drive.ds.sync.cache.MetadataStore}
 * @constructor
 */
drive.ds.sync.cache.InMemoryMetadataStore = function() {
  /** @private {goog.math.Long} */
  this.lastChangeId_ = null;

  /** @private {string} */
  this.rootId_ = '';
};
goog.inherits(drive.ds.sync.cache.InMemoryMetadataStore,
    drive.ds.sync.cache.MetadataStore);


/** @override */
drive.ds.sync.cache.InMemoryMetadataStore.prototype.getLastChangeId =
    function() {
  return this.lastChangeId_;
};


/** @override */
drive.ds.sync.cache.InMemoryMetadataStore.prototype.setLastChangeId =
    function(lastChangeId) {
  this.lastChangeId_ = lastChangeId;
};


/** @override */
drive.ds.sync.cache.InMemoryMetadataStore.prototype.getRootId = function() {
  return this.rootId_;
};


/** @override */
drive.ds.sync.cache.InMemoryMetadataStore.prototype.setRootId =
    function(rootId) {
  this.rootId_ = rootId;
};

//javascript/apps/drive/dataservice/sync/cache/inmemoryquerycache.js
goog.provide('drive.ds.sync.cache.InMemoryQueryCache');

goog.require('drive.ds.sync.cache.QueryCache');
goog.require('drive.ds.sync.sort.ItemSorter');
goog.require('goog.asserts');
goog.require('jspb.Message');



/**
 * An in-memory cache of queries that can be answered by the item cache.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item config.
 * @extends {drive.ds.sync.cache.QueryCache}
 * @constructor
 */
drive.ds.sync.cache.InMemoryQueryCache = function(config) {
  goog.base(this);

  /** @private {!Array.<!drive.ds.DumpelloQuery>} List of answerable queries. */
  this.queries_ = [];

  /**
   * The sorter to use for applying changes to the cached queries.
   * @private {!drive.ds.sync.sort.ItemSorter}
   */
  this.sorter_ = new drive.ds.sync.sort.ItemSorter(config);
};
goog.inherits(drive.ds.sync.cache.InMemoryQueryCache,
    drive.ds.sync.cache.QueryCache);


/** @override */
drive.ds.sync.cache.InMemoryQueryCache.prototype.containsQuery =
    function(query) {
  return this.indexOf_(query) >= 0;
};


/** @override */
drive.ds.sync.cache.InMemoryQueryCache.prototype.getQueryLimit =
    function(query) {
  var index = this.indexOf_(query);
  if (index < 0) {
    throw Error('Query not found in cache.  ' +
        'Did you forget to call "containsQuery"?');
  }
  return this.queries_[index].getMinResultSize();
};


/** @override */
drive.ds.sync.cache.InMemoryQueryCache.prototype.put = function(dumpelloQuery) {
  var index = this.indexOf_(dumpelloQuery.getQuery());
  if (index < 0) {
    this.queries_.push(dumpelloQuery.cloneMessage());
  } else {
    this.queries_[index] = dumpelloQuery.cloneMessage();
  }
};


/**
 * Gets the index of the DumpelloQuery from the cache given an ItemQueryRequest.
 * Returns -1 if not found.
 * @param {!drive.ds.ItemQueryRequest} query The query to lookup.
 * @return {number} The index of the DumpelloQuery matching the
 *     ItemQueryRequest, or -1 if not found.
 * @private
 */
drive.ds.sync.cache.InMemoryQueryCache.prototype.indexOf_ = function(query) {
  for (var i = 0; i < this.queries_.length; i++) {
    var dumpelloQuery = this.queries_[i];
    if (jspb.Message.equals(dumpelloQuery.getQuery(), query)) {
      return i;
    }
  }
  return -1;
};


/** @override */
drive.ds.sync.cache.InMemoryQueryCache.prototype.hasFullCorpus = function() {
  return false;
};


/** @override */
drive.ds.sync.cache.InMemoryQueryCache.prototype.applyChanges =
    function(context, insertedItems, deletedItems) {
  this.applyChanges_(context, insertedItems, false);
  this.applyChanges_(context, deletedItems, true);
};


/**
 * Applies changed items to the cached queries to keep the result sizes
 * up to date.  This checks each item against the query to see if it
 * comes before or after the last item in the query, incrementing or
 * decremented the result size as needed.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!Array.<!drive.ds.Item>} items The list of items to apply.
 * @param {boolean} deletion Whether the applied items are being deleted
 *     or inserted.
 * @private
 */
drive.ds.sync.cache.InMemoryQueryCache.prototype.applyChanges_ =
    function(context, items, deletion) {
  var cache = context.getCache();

  for (var i = 0; i < this.queries_.length; i++) {
    var dumpelloQuery = this.queries_[i];
    if (dumpelloQuery.getMinResultSize() == null) {
      // No need to adjust for queries that are fully cached.
      continue;
    }

    var query = dumpelloQuery.getQuery();
    for (var j = 0; j < items.length; j++) {
      var item = items[j];
      if (cache.meetsRequestSpec(query, item) &&
          this.sorter_.compare(query, item,
              goog.asserts.assert(dumpelloQuery.getLastItem())) <= 0) {
        dumpelloQuery.setMinResultSize(
            dumpelloQuery.getMinResultSize() + (deletion ? -1 : 1));
      }
    }
  }
};


/** @override */
drive.ds.sync.cache.InMemoryQueryCache.prototype.bulkImport =
    function(queries) {
  for (var i = 0; i < queries.length; i++) {
    this.put(queries[i]);
  }
};


/** @override */
drive.ds.sync.cache.InMemoryQueryCache.prototype.bulkExport =
    function() {
  var queries = [];
  for (var i = 0; i < this.queries_.length; i++) {
    queries.push(this.queries_[i]);
  }

  return queries;
};

//javascript/apps/drive/dataservice/sync/cache/useraccountcache.js
goog.provide('drive.ds.sync.cache.UserAccountCache');

goog.require('drive.ds.Status');
goog.require('drive.ds.sync.ExponentialBackoff');
goog.require('drive.ds.sync.api.About');
goog.require('goog.events');
goog.require('goog.events.EventTarget');



/**
 * An abstract class representing a cache for the user account information.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.cache.UserAccountCache = function(context) {
  goog.base(this);

  /** @private {boolean} Whether the cache has been initialized. */
  this.initialized_ = false;

  /** @private {!drive.ds.sync.Context} */
  this.context_ = context;

  /** @private {!drive.ds.sync.ExponentialBackoff} */
  this.nextRetry_ = new drive.ds.sync.ExponentialBackoff();
};
goog.inherits(drive.ds.sync.cache.UserAccountCache, goog.events.EventTarget);


/**
 * User account cache related event types.
 * @enum {string}
 */
drive.ds.sync.cache.UserAccountCache.EventType = {
  INITIALIZED: goog.events.getUniqueId('initialized')
};


/**
 * Initializes the user account cache. By default this queries Genoa for the
 * latest user account information, implementations can override this as needed
 * (eg. load from IndexDB cache).
 */
drive.ds.sync.cache.UserAccountCache.prototype.initialize = function() {
  this.loadFromApi();
};


/**
 * Queries Genoa for the latest user account information.
 * TODO(towong): Need some way to detect user account updates.
 * @protected
 */
drive.ds.sync.cache.UserAccountCache.prototype.loadFromApi = function() {
  drive.ds.sync.api.About.get(goog.bind(this.handleResponse_, this));
};


/**
 * Handles the response of a user account request.
 * @param {!Object} response The response from the drive api.
 * @private
 */
drive.ds.sync.cache.UserAccountCache.prototype.handleResponse_ =
    function(response) {
  var userAccountResponse =
      this.context_.getResponseParser().parseAccount(response);

  userAccountResponse.getStatus() == drive.ds.Status.SUCCESS ?
      this.handleUserAccountLoaded_(userAccountResponse.getAccount()) :
      this.handleUserAccountError_();
};


/**
 * Handles updating the user account.
 * @param {drive.ds.Account} account A user account.
 * @private
 */
drive.ds.sync.cache.UserAccountCache.prototype.handleUserAccountLoaded_ =
    function(account) {
  if (account) {
    this.put(account);
  }
  this.setInitialized();
};


/**
 * Handles an error on loading the user account.
 * @private
 */
drive.ds.sync.cache.UserAccountCache.prototype.handleUserAccountError_ =
    function() {
  this.nextRetry_.backoff();
  goog.global.setTimeout(goog.bind(this.loadFromApi, this),
      this.nextRetry_.getValue());
};


/**
 * Marks the cache as initialized.
 */
drive.ds.sync.cache.UserAccountCache.prototype.setInitialized = function() {
  this.initialized_ = true;
  this.dispatchEvent(
      drive.ds.sync.cache.UserAccountCache.EventType.INITIALIZED);
};


/**
 * @return {boolean} Whether this cache has been initialized.
 */
drive.ds.sync.cache.UserAccountCache.prototype.getInitialized = function() {
  return this.initialized_;
};


/**
 * Retrieves the user's account information.
 * @return {!drive.ds.UserAccountResponse} The user's account information.
 */
drive.ds.sync.cache.UserAccountCache.prototype.getAccount = goog.abstractMethod;


/**
 * Puts a user account into the user account cache.
 * @param {!drive.ds.Account} userAccount The user account to put into
 *     the cache.
 * @protected
 */
drive.ds.sync.cache.UserAccountCache.prototype.put = goog.abstractMethod;

//javascript/apps/drive/dataservice/sync/cache/inmemoryuseraccountcache.js
goog.provide('drive.ds.sync.cache.InMemoryUserAccountCache');

goog.require('drive.ds.Status');
goog.require('drive.ds.UserAccountResponse');
goog.require('drive.ds.sync.cache.UserAccountCache');



/**
 * An in-memory cache of a user's account information.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.cache.UserAccountCache}
 * @constructor
 */
drive.ds.sync.cache.InMemoryUserAccountCache = function(context) {
  goog.base(this, context);

  /** @private {drive.ds.Account} */
  this.account_ = null;
};
goog.inherits(drive.ds.sync.cache.InMemoryUserAccountCache,
    drive.ds.sync.cache.UserAccountCache);


/** @override */
drive.ds.sync.cache.InMemoryUserAccountCache.prototype.getAccount = function() {
  // TODO(haluk): Add error handling?
  var result = new drive.ds.UserAccountResponse();
  result.setStatus(drive.ds.Status.SUCCESS);
  result.setAccount(this.account_);
  return result;
};


/** @override */
drive.ds.sync.cache.InMemoryUserAccountCache.prototype.put = function(account) {
  this.account_ = account.cloneMessage();
};

//javascript/closure/math/range.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing a numeric range.
 * @author pupius@google.com (Daniel Pupius)
 */


goog.provide('goog.math.Range');



/**
 * A number range.
 * @param {number} a One end of the range.
 * @param {number} b The other end of the range.
 * @constructor
 */
goog.math.Range = function(a, b) {
  /**
   * The lowest value in the range.
   * @type {number}
   */
  this.start = a < b ? a : b;

  /**
   * The highest value in the range.
   * @type {number}
   */
  this.end = a < b ? b : a;
};


/**
 * @return {!goog.math.Range} A clone of this Range.
 */
goog.math.Range.prototype.clone = function() {
  return new goog.math.Range(this.start, this.end);
};


/**
 * @return {number} Length of the range.
 */
goog.math.Range.prototype.getLength = function() {
  return this.end - this.start;
};


/**
 * Extends this range to include the given point.
 * @param {number} point
 */
goog.math.Range.prototype.includePoint = function(point) {
  this.start = Math.min(this.start, point);
  this.end = Math.max(this.end, point);
};


/**
 * Extends this range to include the given range.
 * @param {!goog.math.Range} range
 */
goog.math.Range.prototype.includeRange = function(range) {
  this.start = Math.min(this.start, range.start);
  this.end = Math.max(this.end, range.end);
};


if (goog.DEBUG) {
  /**
   * Returns a string representing the range.
   * @return {string} In the form [-3.5, 8.13].
   * @override
   */
  goog.math.Range.prototype.toString = function() {
    return '[' + this.start + ', ' + this.end + ']';
  };
}


/**
 * Compares ranges for equality.
 * @param {goog.math.Range} a A Range.
 * @param {goog.math.Range} b A Range.
 * @return {boolean} True iff both the starts and the ends of the ranges are
 *     equal, or if both ranges are null.
 */
goog.math.Range.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.start == b.start && a.end == b.end;
};


/**
 * Given two ranges on the same dimension, this method returns the intersection
 * of those ranges.
 * @param {goog.math.Range} a A Range.
 * @param {goog.math.Range} b A Range.
 * @return {goog.math.Range} A new Range representing the intersection of two
 *     ranges, or null if there is no intersection. Ranges are assumed to
 *     include their end points, and the intersection can be a point.
 */
goog.math.Range.intersection = function(a, b) {
  var c0 = Math.max(a.start, b.start);
  var c1 = Math.min(a.end, b.end);
  return (c0 <= c1) ? new goog.math.Range(c0, c1) : null;
};


/**
 * Given two ranges on the same dimension, determines whether they intersect.
 * @param {goog.math.Range} a A Range.
 * @param {goog.math.Range} b A Range.
 * @return {boolean} Whether they intersect.
 */
goog.math.Range.hasIntersection = function(a, b) {
  return Math.max(a.start, b.start) <= Math.min(a.end, b.end);
};


/**
 * Given two ranges on the same dimension, this returns a range that covers
 * both ranges.
 * @param {goog.math.Range} a A Range.
 * @param {goog.math.Range} b A Range.
 * @return {!goog.math.Range} A new Range representing the bounding
 *     range.
 */
goog.math.Range.boundingRange = function(a, b) {
  return new goog.math.Range(Math.min(a.start, b.start),
                             Math.max(a.end, b.end));
};


/**
 * Given two ranges, returns true if the first range completely overlaps the
 * second.
 * @param {goog.math.Range} a The first Range.
 * @param {goog.math.Range} b The second Range.
 * @return {boolean} True if b is contained inside a, false otherwise.
 */
goog.math.Range.contains = function(a, b) {
  return a.start <= b.start && a.end >= b.end;
};


/**
 * Given a range and a point, returns true if the range contains the point.
 * @param {goog.math.Range} range The range.
 * @param {number} p The point.
 * @return {boolean} True if p is contained inside range, false otherwise.
 */
goog.math.Range.containsPoint = function(range, p) {
  return range.start <= p && range.end >= p;
};

//javascript/apps/drive/mediatype/mediatype.js
/**
 * @fileoverview Package-Private. An enumeration of media types.
 */

goog.provide('drive.mediatype.MediaType');

goog.require('goog.math.Range');


/**
 * An enumeration of media types. Note that id's are grouped by similar media
 * types.
 * @enum {number}
 */
drive.mediatype.MediaType = {
  // Unknown types starting from id 1.
  // Next Available Number: 7
  UNKNOWN: 1,
  APP_UNKNOWN: 2,
  AUDIO_UNKNOWN: 3,
  IMAGE_UNKNOWN: 4,
  TEXT_UNKNOWN: 5,
  VIDEO_UNKNOWN: 6,

  // Application types starting from id 701.
  // Next Available Number: 770
  APP_ACAD: 701,
  APP_DXF: 702,
  APP_EPUB_ZIP: 703,
  APP_ILLUSTRATOR: 762,
  APP_JAVASCRIPT: 741,
  APP_MSEXCEL: 768,
  APP_MSPOWERPOINT: 767,
  APP_MSWORD: 704,
  APP_MSWORD_ME: 758,
  APP_OCTET_STREAM: 705,
  APP_PDF: 706,
  APP_PHOTOSHOP: 744,
  APP_PKCS7_SIGNATURE: 707,
  APP_POSTSCRIPT: 708,
  APP_RTF: 709,
  APP_V_ANDROID_PACKAGE: 710,
  APP_V_GOOG_DOCUMENT: 711,
  APP_V_GOOG_DRAWING: 712,
  APP_V_GOOG_FOLDER: 745,
  APP_V_GOOG_FORM: 713,
  APP_V_GOOG_FREEBIRD: 746,
  APP_V_GOOG_FUSIONTABLE: 764,
  APP_V_GOOG_KIX: 747,
  APP_V_GOOG_PRESENTATION: 714,
  APP_V_GOOG_PUNCH: 748,
  APP_V_GOOG_RITZ: 765,
  APP_V_GOOG_SCRIPT: 766,
  APP_V_GOOG_SITES: 763,
  APP_V_GOOG_SPREADSHEET: 715,
  APP_V_GOOG_EARTH: 716,
  APP_V_GOOG_VIDEO: 742,
  APP_V_MS_EXCEL: 717,
  APP_V_MS_EXCEL_BME: 749,
  APP_V_MS_EXCEL_ME: 750,
  APP_V_MS_POWERPOINT: 718,
  APP_V_MS_POWERPOINT_PME: 751,
  APP_V_MS_POWERPOINT_SME: 752,
  APP_V_MS_POWERPOINT_TME: 753,
  APP_V_MS_PROJECT: 719,
  APP_V_MS_WORD: 769,
  APP_V_MS_WORKS: 720,
  APP_V_MS_XPSDOCUMENT: 721,
  APP_V_OASIS_OD_DOCUMENT: 757,
  APP_V_OASIS_OD_GRAPHICS: 761,
  APP_V_OASIS_OD_SPREADSHEET: 722,
  APP_V_OASIS_OD_PRESENTATION: 760,
  APP_V_OO_SPREADSHEET_SHEET: 759,
  APP_V_OO_DOCUMENT: 723,
  APP_V_OO_DOCUMENT_TEMPLATE: 756,
  APP_V_OO_PRESENTATION: 724,
  APP_V_OO_PRESENTATION_SLIDESHOW: 754,
  APP_V_OO_PRESENTATION_TEMPLATE: 755,
  APP_V_VISIO: 725,
  APP_X_7Z_COMPRESSED: 726,
  APP_X_FONT_TTF: 727,
  APP_X_GZIP: 728,
  APP_X_HTTPD_PHP: 729,
  APP_X_IWORK_KEYNOTE: 730,
  APP_X_IWORK_NUMBERS: 731,
  APP_X_IWORK_PAGES: 732,
  APP_X_JAVASCRIPT: 743,
  APP_X_LZH: 733,
  APP_X_MS_PUBLISHER: 734,
  APP_X_MS_SHORTCUT: 735,
  APP_X_MS_WMZ: 736,
  APP_X_RAR_COMPRESSED: 737,
  APP_X_SHOCKWAVE_FLASH: 738,
  APP_X_TEX: 739,
  APP_ZIP: 740,

  // Audio types starting from id 101.
  // Next Available Number: 110
  AUDIO_3GP: 107,
  AUDIO_MIDI: 101,
  AUDIO_MP4A_LATM: 102,
  AUDIO_MPEG: 103,
  AUDIO_MPEG_3: 104,
  AUDIO_OGG: 108,
  AUDIO_X_MS_WMA: 105,
  AUDIO_X_WAV: 106,
  AUDIO_WAV: 109,

  // Message types starting from id 201.
  // Next Available Number: 202
  CHEMICAL_X_GAMESS_INPUT: 201,

  // Image types starting from id 301.
  // Next Available Number: 328
  IMAGE_BMP: 301,
  IMAGE_GIF: 302,
  IMAGE_JPEG: 303,
  IMAGE_PNG: 304,
  IMAGE_SVG_XML: 309,
  IMAGE_TIFF: 305,
  IMAGE_V_ADOBE_PHOTOSHOP: 326,
  IMAGE_V_DWG: 306,
  IMAGE_V_MICROSOFT_ICON: 327,
  IMAGE_X_ADOBE_DNG: 310,
  IMAGE_X_CANON_CR2: 311,
  IMAGE_X_CANON_CRW: 312,
  IMAGE_X_CORELDRAW: 307,
  IMAGE_X_FUJI_RAF: 313,
  IMAGE_X_KODAK_KDC: 314,
  IMAGE_X_MINOLTA_MRW: 315,
  IMAGE_X_MS_BMP: 316,
  IMAGE_X_NIKON_NEF: 317,
  IMAGE_X_NIKON_NRW: 318,
  IMAGE_X_OLYMPUS_ORF: 319,
  IMAGE_X_PANASONIC_RW2: 320,
  IMAGE_X_PENTAX_PEF: 321,
  IMAGE_X_PHOTOSHOP: 308,
  IMAGE_X_RAW: 322,
  IMAGE_X_SONY_SR2: 323,
  IMAGE_X_SONY_SRF: 324,
  IMAGE_WEBP: 325,

  // Message types starting from id 401.
  // Next Available Number: 402
  MESSAGE_RFC822: 401,

  // Text types starting from id 501.
  // Next Available Number: 519
  TEXT_CALENDAR: 501,
  TEXT_CSS: 502,
  TEXT_CSV: 503,
  TEXT_ECMASCRIPT: 515,
  TEXT_HTML: 504,
  TEXT_JAVASCRIPT: 516,
  TEXT_PLAIN: 505,
  TEXT_X_C: 506,
  TEXT_X_C_HDR: 517,
  TEXT_X_C_PLUS_PLUS: 507,
  TEXT_X_C_PLUS_PLUS_HDR: 518,
  TEXT_X_HWP: 508,
  TEXT_X_JAVA: 509,
  TEXT_X_JAVA_SRC: 510,
  TEXT_X_OBJCSRC: 511,
  TEXT_X_SQL: 512,
  TEXT_X_VCARD: 513,
  TEXT_XML: 514,

  // Video types starting from id 601.
  // Next Available Number: 622
  VIDEO_3GPP: 601,
  VIDEO_AVI: 602,
  VIDEO_DV: 619,
  VIDEO_FLV: 603,
  VIDEO_MP2P: 618,
  VIDEO_MP2T: 617,
  VIDEO_MP4: 604,
  VIDEO_MPEG: 605,
  VIDEO_MPV: 616,
  VIDEO_OGG: 615,
  VIDEO_QUICKTIME: 606,
  VIDEO_WEBM: 614,
  VIDEO_X_DV: 613,
  VIDEO_X_FLV: 607,
  VIDEO_X_M4V: 610,
  VIDEO_X_MATROSKA: 612,
  VIDEO_X_MS_ASF: 611,
  VIDEO_X_MS_WMV: 608,
  VIDEO_X_MSVIDEO: 609,
  VIDEO_X_SHOCKWAVE_FLASH: 620,
  VIDEO_X_YOUTUBE: 621
};


/**
 * An enumeration of ranges encompassing the ids for each type.
 * @enum {goog.math.Range}
 */
drive.mediatype.MediaType.Range = {
  UNKNOWN: new goog.math.Range(1, 100),
  APP: new goog.math.Range(701, 1000),
  AUDIO: new goog.math.Range(101, 200),
  CHEMICAL: new goog.math.Range(201, 300),
  IMAGE: new goog.math.Range(301, 400),
  MESSAGE: new goog.math.Range(401, 500),
  TEXT: new goog.math.Range(501, 600),
  VIDEO: new goog.math.Range(601, 700)
};

//javascript/apps/drive/mediatype/mediatypedecoder.js
/**
 * @fileoverview Decodes media types in to their enumeration.
 */

goog.provide('drive.mediatype.MediaTypeDecoder');

goog.require('drive.mediatype.MediaType');
goog.require('goog.object');



goog.scope(function() {

var MediaType = drive.mediatype.MediaType;



/**
 * Converts media types into a valid {@code drive.mediatype.MediaType}
 *    enumeration.
 * Package-private: Use {@code drive.mediatype.Info}.
 * @constructor
 */
drive.mediatype.MediaTypeDecoder = function() { };
goog.addSingletonGetter(drive.mediatype.MediaTypeDecoder);


/**
 * @param {string} type The media type (mime-type).
 * @return {!drive.mediatype.MediaType}
 */
drive.mediatype.MediaTypeDecoder.prototype.decode = function(type) {
  // Remove parameters as needed and split on '/'.
  var splitType = type.indexOf(';') == -1 ?
      type.split('/', 2) :
      type.substring(0, type.indexOf(';')).split('/', 2);
  if (splitType.length != 2) {
    return MediaType.UNKNOWN;
  }

  var mediaType = splitType[0];
  var subType = splitType[1];

  switch (mediaType) {
    case 'application':
      return drive.mediatype.MediaTypeDecoder.APP_TYPE_MAP_[subType] ?
          drive.mediatype.MediaTypeDecoder.APP_TYPE_MAP_[subType] :
          MediaType.APP_UNKNOWN;
    case 'audio':
      return drive.mediatype.MediaTypeDecoder.AUDIO_TYPE_MAP_[subType] ?
          drive.mediatype.MediaTypeDecoder.AUDIO_TYPE_MAP_[subType] :
          MediaType.AUDIO_UNKNOWN;
    case 'image':
      return drive.mediatype.MediaTypeDecoder.IMAGE_TYPE_MAP_[subType] ?
          drive.mediatype.MediaTypeDecoder.IMAGE_TYPE_MAP_[subType] :
          MediaType.IMAGE_UNKNOWN;
    case 'text':
      return drive.mediatype.MediaTypeDecoder.TEXT_TYPE_MAP_[subType] ?
          drive.mediatype.MediaTypeDecoder.TEXT_TYPE_MAP_[subType] :
          MediaType.TEXT_UNKNOWN;
    case 'video':
      return drive.mediatype.MediaTypeDecoder.VIDEO_TYPE_MAP_[subType] ?
          drive.mediatype.MediaTypeDecoder.VIDEO_TYPE_MAP_[subType] :
          MediaType.VIDEO_UNKNOWN;
    default:
      return drive.mediatype.MediaTypeDecoder.OTHER_TYPE_MAP_[type] ?
          drive.mediatype.MediaTypeDecoder.OTHER_TYPE_MAP_[type] :
          MediaType.UNKNOWN;
  }
};


/**
 * Gets the mimetype for a particular media type id. Note that no
 * parameter information is attached to the media type id, so a doing an
 * encode(decode(TYPE)) where TYPE has a parameter will return a mimetype
 * without the parameter.
 * @param {!drive.mediatype.MediaType} type The media type id.
 * @return {string} type The media type (mime-type).
 */
drive.mediatype.MediaTypeDecoder.prototype.encode = function(type) {
  var map = this.findMap_(type);
  var mediaType = this.findMediaType_(map);
  var subType = this.findSubType_(map, type);
  return mediaType ? mediaType + '/' + subType : subType;
};


/**
 * Finds the map that corresponds to the given media type id.
 * @param {!drive.mediatype.MediaType} type The media type id.
 * @return {Object.<string, !drive.mediatype.MediaType>} The map if it contains
 *     the id.
 * @private
 */
drive.mediatype.MediaTypeDecoder.prototype.findMap_ = function(type) {
  var maps = [
    drive.mediatype.MediaTypeDecoder.APP_TYPE_MAP_,
    drive.mediatype.MediaTypeDecoder.AUDIO_TYPE_MAP_,
    drive.mediatype.MediaTypeDecoder.IMAGE_TYPE_MAP_,
    drive.mediatype.MediaTypeDecoder.TEXT_TYPE_MAP_,
    drive.mediatype.MediaTypeDecoder.VIDEO_TYPE_MAP_
  ];

  var encoderMap;
  for (var i = 0; i < maps.length; i++) {
    var map = maps[i];
    if (goog.object.containsValue(map, type)) {
      return map;
    }
  }
  return drive.mediatype.MediaTypeDecoder.OTHER_TYPE_MAP_;
};


/**
 * Finds the mediatype corresponds to the media type decoder map.
 * @param {Object.<string, !drive.mediatype.MediaType>} map Map of subtypes to
 *     media type ids.
 * @return {string} The subtype.
 * @private
 */
drive.mediatype.MediaTypeDecoder.prototype.findMediaType_ = function(map) {
  if (map == drive.mediatype.MediaTypeDecoder.APP_TYPE_MAP_) {
    return 'application';
  } else if (map == drive.mediatype.MediaTypeDecoder.AUDIO_TYPE_MAP_) {
    return 'audio';
  } else if (map == drive.mediatype.MediaTypeDecoder.IMAGE_TYPE_MAP_) {
    return 'image';
  } else if (map == drive.mediatype.MediaTypeDecoder.TEXT_TYPE_MAP_) {
    return 'text';
  } else if (map == drive.mediatype.MediaTypeDecoder.VIDEO_TYPE_MAP_) {
    return 'video';
  }
  return '';
};


/**
 * @param {Object.<string, !drive.mediatype.MediaType>} map Map of subtypes to
 *     media type ids.
 * @param {!drive.mediatype.MediaType} type The media type id.
 * @return {string} The subtype.
 * @private
 */
drive.mediatype.MediaTypeDecoder.prototype.findSubType_ = function(map, type) {
  var key = goog.object.findKey(map, function(value) {
    return value == type;
  });
  return key || '';
};


/**
 * A map of application subtypes to {@code drive.mediatype.MediaType}.
 * @private {Object.<string, !drive.mediatype.MediaType>}
 */
drive.mediatype.MediaTypeDecoder.APP_TYPE_MAP_ = {
  'acad': MediaType.APP_ACAD,
  'dxf': MediaType.APP_DXF,
  'epub+zip': MediaType.APP_EPUB_ZIP,
  'illustrator': MediaType.APP_ILLUSTRATOR,
  'javascript': MediaType.APP_JAVASCRIPT,
  'msexcel': MediaType.APP_MSEXCEL,
  'mspowerpoint': MediaType.APP_MSPOWERPOINT,
  'msword': MediaType.APP_MSWORD,
  'octet-stream': MediaType.APP_OCTET_STREAM,
  'pdf': MediaType.APP_PDF,
  'photoshop': MediaType.APP_PHOTOSHOP,
  'pkcs7-signature': MediaType.APP_PKCS7_SIGNATURE,
  'postscript': MediaType.APP_POSTSCRIPT,
  'rtf': MediaType.APP_RTF,
  'vnd.android.package-archive': MediaType.APP_V_ANDROID_PACKAGE,
  'vnd.google-apps.document': MediaType.APP_V_GOOG_DOCUMENT,
  'vnd.google-apps.drawing': MediaType.APP_V_GOOG_DRAWING,
  'vnd.google-apps.folder': MediaType.APP_V_GOOG_FOLDER,
  'vnd.google-apps.form': MediaType.APP_V_GOOG_FORM,
  'vnd.google-apps.freebird': MediaType.APP_V_GOOG_FREEBIRD,
  'vnd.google-apps.fusiontable': MediaType.APP_V_GOOG_FUSIONTABLE,
  'vnd.google-apps.kix': MediaType.APP_V_GOOG_KIX,
  'vnd.google-apps.presentation': MediaType.APP_V_GOOG_PRESENTATION,
  'vnd.google-apps.punch': MediaType.APP_V_GOOG_PUNCH,
  'vnd.google-apps.ritz': MediaType.APP_V_GOOG_RITZ,
  'vnd.google-apps.script': MediaType.APP_V_GOOG_SCRIPT,
  'vnd.google-apps.sites': MediaType.APP_V_GOOG_SITES,
  'vnd.google-apps.spreadsheet': MediaType.APP_V_GOOG_SPREADSHEET,
  'vnd.google-apps.video': MediaType.APP_V_GOOG_VIDEO,
  'vnd.google-earth.kmz': MediaType.APP_V_GOOG_EARTH,
  'vnd.ms-excel': MediaType.APP_V_MS_EXCEL,
  'vnd.ms-excel.sheet.binary.macroEnabled.12': MediaType.APP_V_MS_EXCEL_BME,
  'vnd.ms-excel.sheet.macroEnabled.12': MediaType.APP_V_MS_EXCEL_ME,
  'vnd.ms-powerpoint': MediaType.APP_V_MS_POWERPOINT,
  'vnd.ms-powerpoint.presentation.macroEnabled.12':
      MediaType.APP_V_MS_POWERPOINT_PME,
  'vnd.ms-powerpoint.slideshow.macroEnabled.12':
      MediaType.APP_V_MS_POWERPOINT_SME,
  'vnd.ms-powerpoint.template.macroEnabled.12':
      MediaType.APP_V_MS_POWERPOINT_TME,
  'vnd.ms-project': MediaType.APP_V_MS_PROJECT,
  'vnd.ms-word': MediaType.APP_V_MS_WORD,
  'vnd.ms-word.document.macroEnabled.12': MediaType.APP_MSWORD_ME,
  'vnd.ms-works': MediaType.APP_V_MS_WORKS,
  'vnd.ms-xpsdocument': MediaType.APP_V_MS_XPSDOCUMENT,
  'vnd.oasis.opendocument.graphics': MediaType.APP_V_OASIS_OD_GRAPHICS,
  'vnd.oasis.opendocument.presentation': MediaType.APP_V_OASIS_OD_PRESENTATION,
  'vnd.oasis.opendocument.spreadsheet': MediaType.APP_V_OASIS_OD_SPREADSHEET,
  'vnd.oasis.opendocument.text': MediaType.APP_V_OASIS_OD_DOCUMENT,
  'vnd.openxmlformats-officedocument.presentationml.presentation':
      MediaType.APP_V_OO_PRESENTATION,
  'vnd.openxmlformats-officedocument.presentationml.slideshow':
      MediaType.APP_V_OO_PRESENTATION_SLIDESHOW,
  'vnd.openxmlformats-officedocument.presentationml.template':
      MediaType.APP_V_OO_PRESENTATION_TEMPLATE,
  'vnd.openxmlformats-officedocument.spreadsheetml.sheet':
      MediaType.APP_V_OO_SPREADSHEET_SHEET,
  'vnd.openxmlformats-officedocument.wordprocessingml.document':
      MediaType.APP_V_OO_DOCUMENT,
  'vnd.openxmlformats-officedocument.wordprocessingml.template':
      MediaType.APP_V_OO_DOCUMENT_TEMPLATE,
  'vnd.visio': MediaType.APP_V_VISIO,
  'x-7z-compressed': MediaType.APP_X_7Z_COMPRESSED,
  'x-font-ttf': MediaType.APP_X_FONT_TTF,
  'x-gzip': MediaType.APP_X_GZIP,
  'x-httpd-php': MediaType.APP_X_HTTPD_PHP,
  'x-iwork-keynote-sffkey': MediaType.APP_X_IWORK_KEYNOTE,
  'x-iwork-numbers-sffnumbers': MediaType.APP_X_IWORK_NUMBERS,
  'x-iwork-pages-sffpages': MediaType.APP_X_IWORK_PAGES,
  'x-javascript': MediaType.APP_X_JAVASCRIPT,
  'x-lzh': MediaType.APP_X_LZH,
  'x-ms-publisher': MediaType.APP_X_MS_PUBLISHER,
  'x-ms-shortcut': MediaType.APP_X_MS_SHORTCUT,
  'x-ms-wmz': MediaType.APP_X_MS_WMZ,
  'x-rar-compressed': MediaType.APP_X_RAR_COMPRESSED,
  'x-shockwave-flash': MediaType.APP_X_SHOCKWAVE_FLASH,
  'x-tex': MediaType.APP_X_TEX,
  'zip': MediaType.APP_ZIP
};


/**
 * A map of audio subtypes to {@code drive.mediatype.MediaType}.
 * @private {Object.<string, !drive.mediatype.MediaType>}
 */
drive.mediatype.MediaTypeDecoder.AUDIO_TYPE_MAP_ = {
  '3gp': MediaType.AUDIO_3GP,
  'midi': MediaType.AUDIO_MIDI,
  'mp4a-latm': MediaType.AUDIO_MP4A_LATM,
  'mpeg': MediaType.AUDIO_MPEG,
  'mpeg3': MediaType.AUDIO_MPEG_3,
  'ogg': MediaType.AUDIO_OGG,
  'x-ms-wma': MediaType.AUDIO_X_MS_WMA,
  'x-wav': MediaType.AUDIO_X_WAV,
  'wav': MediaType.AUDIO_WAV
};


/**
 * A map of types to {@code drive.mediatype.MediaType}. This should be used
 * for all types that are not application, audio, image, text, or video.
 * @private {Object.<string, !drive.mediatype.MediaType>}
 */
drive.mediatype.MediaTypeDecoder.OTHER_TYPE_MAP_ = {
  'chemical/x-gamess-input': MediaType.CHEMICAL_X_GAMESS_INPUT,
  'message/rfc822': MediaType.MESSAGE_RFC822
};


/**
 * A map of image subtypes to {@code drive.mediatype.MediaType}.
 * @private {Object.<string, !drive.mediatype.MediaType>}
 */
drive.mediatype.MediaTypeDecoder.IMAGE_TYPE_MAP_ = {
  'bmp': MediaType.IMAGE_BMP,
  'gif': MediaType.IMAGE_GIF,
  'jpeg': MediaType.IMAGE_JPEG,
  'png': MediaType.IMAGE_PNG,
  'svg+xml': MediaType.IMAGE_SVG_XML,
  'tiff': MediaType.IMAGE_TIFF,
  'vnd.adobe.photoshop': MediaType.IMAGE_V_ADOBE_PHOTOSHOP,
  'vnd.dwg': MediaType.IMAGE_V_DWG,
  'vnd.microsoft.icon': MediaType.IMAGE_V_MICROSOFT_ICON,
  'x-adobe-dng': MediaType.IMAGE_X_ADOBE_DNG,
  'x-canon-cr2': MediaType.IMAGE_X_CANON_CR2,
  'x-canon-crw': MediaType.IMAGE_X_CANON_CRW,
  'x-coreldraw': MediaType.IMAGE_X_CORELDRAW,
  'x-fuji-raf': MediaType.IMAGE_X_FUJI_RAF,
  'x-kodak-kdc': MediaType.IMAGE_X_KODAK_KDC,
  'x-minolta-mrw': MediaType.IMAGE_X_MINOLTA_MRW,
  'x-nikon-nef': MediaType.IMAGE_X_NIKON_NEF,
  'x-nikon-nrw': MediaType.IMAGE_X_NIKON_NRW,
  'x-olympus-orf': MediaType.IMAGE_X_OLYMPUS_ORF,
  'x-panasonic-rw2': MediaType.IMAGE_X_PANASONIC_RW2,
  'x-pentax-pef': MediaType.IMAGE_X_PENTAX_PEF,
  'x-photoshop': MediaType.IMAGE_X_PHOTOSHOP,
  'x-ms-bmp': MediaType.IMAGE_X_MS_BMP,
  'x-sony-sr2': MediaType.IMAGE_X_SONY_SR2,
  'x-sony-srf': MediaType.IMAGE_X_SONY_SRF,
  'x-raw': MediaType.IMAGE_X_RAW,
  'webp': MediaType.IMAGE_WEBP
};


/**
 * A map of text subtypes to {@code drive.mediatype.MediaType}.
 * @private {Object.<string, !drive.mediatype.MediaType>}
 */
drive.mediatype.MediaTypeDecoder.TEXT_TYPE_MAP_ = {
  'calendar': MediaType.TEXT_CALENDAR,
  'css': MediaType.TEXT_CSS,
  'csv': MediaType.TEXT_CSV,
  'ecmascript': MediaType.TEXT_ECMASCRIPT,
  'html': MediaType.TEXT_HTML,
  'javascript': MediaType.TEXT_JAVASCRIPT,
  'plain': MediaType.TEXT_PLAIN,
  'x-c++hdr': MediaType.TEXT_X_C_PLUS_PLUS_HDR,
  'x-c++src': MediaType.TEXT_X_C_PLUS_PLUS,
  'x-chdr': MediaType.TEXT_X_C_HDR,
  'x-csrc': MediaType.TEXT_X_C,
  'x-hwp': MediaType.TEXT_X_HWP,
  'x-java': MediaType.TEXT_X_JAVA,
  'x-java-source': MediaType.TEXT_X_JAVA_SRC,
  'x-objcsrc': MediaType.TEXT_X_OBJCSRC,
  'x-sql': MediaType.TEXT_X_SQL,
  'x-vcard': MediaType.TEXT_X_VCARD,
  'xml': MediaType.TEXT_XML
};


/**
 * A map of video subtypes to {@code drive.mediatype.MediaType}.
 * @private {Object.<string, !drive.mediatype.MediaType>}
 */
drive.mediatype.MediaTypeDecoder.VIDEO_TYPE_MAP_ = {
  '3gpp': MediaType.VIDEO_3GPP,
  'avi': MediaType.VIDEO_AVI,
  'dv': MediaType.VIDEO_DV,
  'flv': MediaType.VIDEO_FLV,
  'mp2p': MediaType.VIDEO_MP2P,
  'mp2t': MediaType.VIDEO_MP2T,
  'mp4': MediaType.VIDEO_MP4,
  'mpeg': MediaType.VIDEO_MPEG,
  'mpv': MediaType.VIDEO_MPV,
  'ogg': MediaType.VIDEO_OGG,
  'quicktime': MediaType.VIDEO_QUICKTIME,
  'webm': MediaType.VIDEO_WEBM,
  'x-dv': MediaType.VIDEO_X_DV,
  'x-flv': MediaType.VIDEO_X_FLV,
  'x-m4v': MediaType.VIDEO_X_M4V,
  'x-matroska': MediaType.VIDEO_X_MATROSKA,
  'x-ms-asf': MediaType.VIDEO_X_MS_ASF,
  'x-ms-wmv': MediaType.VIDEO_X_MS_WMV,
  'x-msvideo': MediaType.VIDEO_X_MSVIDEO,
  'x-shockwave-flash': MediaType.VIDEO_X_SHOCKWAVE_FLASH,
  'x-youtube': MediaType.VIDEO_X_YOUTUBE
};

});  // goog.scope

//javascript/apps/drive/dataservice/sync/cache/mimetypemapper.js
/**
 * @fileoverview Helper class for encoding/decoding between mimetype and
 * mediatype ids.
 */

goog.provide('drive.ds.sync.cache.MimeTypeMapper');

goog.require('drive.mediatype.MediaType');
goog.require('drive.mediatype.MediaTypeDecoder');
goog.require('goog.string');


/**
 * Takes a mimetype and maps it to a mediatype id. If no matching mediatype id
 * is available the mimetype is returned back. If the mimetype has a parameter
 * return the original mimetype as well.
 * @param {string} mimeType The mimetype to decode.
 * @return {string} The mediatype id in string form if available, otherwise the
 *     original mimetype gets returned.
 */
drive.ds.sync.cache.MimeTypeMapper.decode = function(mimeType) {
  if (goog.string.contains(mimeType, ';')) {
    return mimeType;
  }

  var mediaType =
      drive.mediatype.MediaTypeDecoder.getInstance().decode(mimeType);
  return drive.ds.sync.cache.MimeTypeMapper.isUnknown_(mediaType) ?
      mimeType : String(mediaType);
};


/**
 * Takes a mediatype id or a mimetype and converts it to a mimetype.
 * @param {string} type The mediatype id in string form or a mimetype.
 * @return {string} The mime type for the item.
 */
drive.ds.sync.cache.MimeTypeMapper.encode = function(type) {
  var mediaType = Number(type);

  if (isNaN(mediaType)) {
    return type;
  }
  return drive.mediatype.MediaTypeDecoder.getInstance().encode(
      /** @type {drive.mediatype.MediaType} */ (mediaType));
};


/**
 * Whether the mediatype is unknown
 * @param {!drive.mediatype.MediaType} mediaType The media type.
 * @return {boolean} Whether the mediaType is unknown.
 * @private
 */
drive.ds.sync.cache.MimeTypeMapper.isUnknown_ = function(mediaType) {
  return mediaType == drive.mediatype.MediaType.APP_UNKNOWN ||
      mediaType == drive.mediatype.MediaType.AUDIO_UNKNOWN ||
      mediaType == drive.mediatype.MediaType.IMAGE_UNKNOWN ||
      mediaType == drive.mediatype.MediaType.TEXT_UNKNOWN ||
      mediaType == drive.mediatype.MediaType.VIDEO_UNKNOWN ||
      mediaType == drive.mediatype.MediaType.UNKNOWN;
};

//javascript/apps/drive/dataservice/sync/change/changemanager.js
goog.provide('drive.ds.sync.change.ChangeManager');

goog.require('drive.ds.Error');
goog.require('drive.ds.sync.ExponentialBackoff');
goog.require('drive.ds.sync.api.Change');
goog.require('drive.ds.sync.response.ResponseHandler');
goog.require('goog.async.Deferred');
goog.require('goog.events');
goog.require('goog.events.EventTarget');
goog.require('goog.math.Long');



/**
 * A change manager for processing changes logs. The change manager will attempt
 * to start processing changes once the largest change id from Genoa has been
 * retrieved. When dumpello is enabled, the processing will wait on that to load
 * as well.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.change.ChangeManager = function(context) {
  goog.base(this);

  /** @private {!drive.ds.sync.Context} The app context. */
  this.context_ = context;

  /**
   * Whether dumpello has been loaded. This flag is only checked if dumpello is
   * enabled.
   * @private {boolean}
   */
  this.dumpelloLoaded_ = false;

  /** @private {!goog.math.Long} The largest Genoa change id. */
  this.largestGenoaChangeId_ = goog.math.Long.fromNumber(-1);

  /** @private {!drive.ds.sync.ExponentialBackoff} */
  this.nextRetry_ = new drive.ds.sync.ExponentialBackoff();

  /** @private {number} */
  this.numRetries_ = 0;
};
goog.inherits(drive.ds.sync.change.ChangeManager, goog.events.EventTarget);


/**
 * Change manager related events.
 * @enum {string}
 */
drive.ds.sync.change.ChangeManager.EventType = {
  // Event indicates that the change manager has started processing change log
  // events.
  PROCESSING: goog.events.getUniqueId('processing')
};


/** @private {number} Maximum number of retries to get the largest timestamp. */
drive.ds.sync.change.ChangeManager.MAX_NUM_RETRIES_ = 3;


/** @return {!drive.ds.sync.Context} The app context. */
drive.ds.sync.change.ChangeManager.prototype.getContext = function() {
  return this.context_;
};


/**
 * @return {!goog.math.Long} The largest genoa change id, or -1 if not yet set.
 */
drive.ds.sync.change.ChangeManager.prototype.getLargestGenoaChangeId =
    function() {
  return this.largestGenoaChangeId_;
};


/**
 * Performs initialization of the change manager.
 * @return {!goog.async.Deferred} The Deferred object with which this
 *     initialization will report success or failure.
 */
drive.ds.sync.change.ChangeManager.prototype.initialize = function() {
  var deferred = new goog.async.Deferred();
  var commandDeferred = new goog.async.Deferred();

  commandDeferred.addCallbacks(
      goog.bind(this.handleInitSuccess_, this, deferred),
      goog.bind(this.handleInitError_, this, deferred));

  drive.ds.sync.api.Change.getMaxChangeId(goog.bind(
      drive.ds.sync.response.ResponseHandler.handleChangesResponse,
      this, commandDeferred, this.context_));

  return deferred;
};


/**
 * Handles successful initialization, saves the change id and tries to start
 * processing.
 * @param {!goog.async.Deferred} deferred Deferred object to report success
 *     with.
 * @param {!drive.ds.ListChangesResponse} response The latest changes
 *     response with the largest change id set.
 * @private
 */
drive.ds.sync.change.ChangeManager.prototype.handleInitSuccess_ =
    function(deferred, response) {
  this.largestGenoaChangeId_ = goog.math.Long.fromNumber(
      response.getLargestChangeId() || 0);

  deferred.callback();
  this.tryStartProcessing_();
};


/**
 * Handles failed initialization, performs a retry at a later time.
 * @param {!goog.async.Deferred} deferred Deferred object to report failure
 *     with.
 * @param {!drive.ds.ListChangesResponse} response The latest changes
 *     response with the error set.
 * @private
 */
drive.ds.sync.change.ChangeManager.prototype.handleInitError_ =
    function(deferred, response) {
  this.nextRetry_.backoff();
  if (this.numRetries_ >=
      drive.ds.sync.change.ChangeManager.MAX_NUM_RETRIES_) {
    var error = new drive.ds.Error();
    error.setType(drive.ds.Error.Type.LOAD);
    error.setMessage('Failed to obtain the largest timestamp');
    deferred.errback(error);
  } else {
    this.numRetries_++;
    goog.global.setTimeout(goog.bind(this.initialize, this),
        this.nextRetry_.getValue());
  }
};


/**
 * Marks that the dumpello as loaded.
 */
drive.ds.sync.change.ChangeManager.prototype.markDumpelloLoaded = function() {
  if (!this.dumpelloLoaded_) {
    this.dumpelloLoaded_ = true;

    this.tryStartProcessing_();
  }
};


/**
 * Tries to start change log processing.
 * @private
 */
drive.ds.sync.change.ChangeManager.prototype.tryStartProcessing_ = function() {
  var dumpelloEnabled = this.context_.getConfig().getUseDumpello();
  var dumpelloReady = !dumpelloEnabled ||
      (dumpelloEnabled && this.dumpelloLoaded_);
  var genoaIdReady = this.largestGenoaChangeId_.greaterThan(
      goog.math.Long.fromNumber(-1));

  if (dumpelloReady && genoaIdReady) {
    this.start();
  }
};


/**
 * Starts change processing.
 * @protected
 */
drive.ds.sync.change.ChangeManager.prototype.start = goog.abstractMethod;

//javascript/apps/drive/dataservice/sync/change/changeprocessor.js
goog.provide('drive.ds.sync.change.ChangeProcessor');

goog.require('drive.ds.ListChangesRequest');
goog.require('drive.ds.sync.api.Change');
goog.require('drive.ds.sync.response.ResponseHandler');
goog.require('goog.asserts');
goog.require('goog.async.Deferred');
goog.require('goog.events');
goog.require('goog.events.Event');
goog.require('goog.events.EventTarget');
goog.require('goog.math.Long');



/**
 * An abstract class defining a change processor for detecting changes and
 * applying them to the cache. Get changes uses the Genoa api to get the changes
 * since a given change id. Implementations are responsible for determining when
 * changes are available for processing.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.change.ChangeProcessor = function(context) {
  goog.base(this);

  /** @private {!drive.ds.sync.Context} The app context. */
  this.context_ = context;

  /** @private {!drive.ds.sync.cache.MetadataStore} The metadata store. */
  this.metadataStore_ = this.context_.getMetadataStore();

  /** @private {!goog.math.Long} The largest processed change id. */
  this.processedChangeId_ = goog.math.Long.fromNumber(0);

  /**
   * The target change id to get changes up to. Get changes will requery until
   * the processedChangedId_ has reached this value.
   * @private {goog.math.Long}
   */
  this.targetChangeId_ = goog.math.Long.fromNumber(0);

  /**
   * Whether there is a pending change log request to Genoa that we are waiting
   * for a response to.
   * @private
   */
  this.running_ = false;

  /**
   * Whether this change processor is active and processing change requests.
   * @private {boolean}
   */
  this.active_ = false;

  /** @private {number} Number of changes processed. */
  this.changes_ = 0;
};
goog.inherits(drive.ds.sync.change.ChangeProcessor, goog.events.EventTarget);


/**
 * Change processor event types.
 * @enum {string}
 */
drive.ds.sync.change.ChangeProcessor.EventType = {
  // Event indicates that a getChanges cycle has completed.
  COMPLETE: goog.events.getUniqueId('complete'),

  // Event indicates that an error occured while processing getChanges.
  ERROR: goog.events.getUniqueId('error')
};


/**
 * @return {!drive.ds.sync.Context} The app context.
 * @protected
 */
drive.ds.sync.change.ChangeProcessor.prototype.getContext = function() {
  return this.context_;
};


/**
 * @return {boolean} Whether this change processor is active.
 * @protected
 */
drive.ds.sync.change.ChangeProcessor.prototype.getActive = function() {
  return this.active_;
};


/**
 * Performs any initialization required for the processor, does nothing by
 * default.
 */
drive.ds.sync.change.ChangeProcessor.prototype.initialize = function() { };


/**
 * @return {!goog.math.Long} The largest processed change id.
 */
drive.ds.sync.change.ChangeProcessor.prototype.getProcessedChangeId =
    function() {
  return this.processedChangeId_;
};


/**
 * @param {goog.math.Long} processedChangeId The largest processed change id.
 */
drive.ds.sync.change.ChangeProcessor.prototype.setProcessedChangeId =
    function(processedChangeId) {
  if (processedChangeId.greaterThan(this.processedChangeId_)) {
    this.processedChangeId_ = processedChangeId;
    this.metadataStore_.setLastChangeId(processedChangeId);
  }
};


/**
 * @param {goog.math.Long} targetChangeId The target change id to get changes up
 *     to.
 */
drive.ds.sync.change.ChangeProcessor.prototype.setTargetChangeId =
    function(targetChangeId) {
  if (targetChangeId.greaterThan(this.targetChangeId_)) {
    this.targetChangeId_ = targetChangeId;
  }
};


/**
 * Gets a list of changes from Genoa since the largest processed change id.
 * Limits to one running change log request at a time.
 * @param {goog.math.Long=} opt_maxChangeId Optional change id to process up to.
 * @protected
 */
drive.ds.sync.change.ChangeProcessor.prototype.getChanges =
    function(opt_maxChangeId) {
  if (!this.running_ && this.active_) {
    this.running_ = true;

    var deferred = new goog.async.Deferred();
    deferred.addCallbacks(
        goog.bind(this.handleGetChangesSuccess_, this, opt_maxChangeId),
        goog.bind(this.handleError_, this));

    var request = new drive.ds.ListChangesRequest();
    request.setStartChangeId(this.processedChangeId_.toNumber() + 1);
    request.setFieldList(this.context_.getFields());

    drive.ds.sync.api.Change.getChanges(request, goog.bind(
        drive.ds.sync.response.ResponseHandler.handleChangesResponse,
        this, deferred, this.context_));
  }
};


/**
 * Handles successful changes response, processing the latest set of changes. If
 * there are additional changes to fetch, we re-query the change log
 * immediately.
 * @param {goog.math.Long|undefined} maxChangeId Optional change id to process
 *     up to. Note we define the optional parameter before non-optional
 *     parmeters because the deferred passes in the response object which
 *     becomes the last parameter to this function.
 * @param {!drive.ds.ListChangesResponse} changeResponse The latest changes
 *     response with the largest change id set and the latest set of changes.
 * @private
 */
drive.ds.sync.change.ChangeProcessor.prototype.handleGetChangesSuccess_ =
    function(maxChangeId, changeResponse) {
  if (this.active_) {
    var changes = changeResponse.getItemChangeList();
    var changedIds = [];
    for (var i = 0; i < changes.length; i++) {
      changedIds.push(changes[i].getItemId());
    }

    var deferred = this.context_.getCache().queryByIds(null, changedIds, -1);
    deferred.addCallbacks(
        goog.bind(this.processChanges_, this, maxChangeId, changeResponse),
        goog.bind(this.handleError_, this));
  } else {
    this.running_ = false;
  }
};


/**
 * Process changes based on the new item values (in the ChangeResponse)
 * and the old item values (in the ItemQueryResponse).  This applies
 * the changes to the item cache, update the cached queries in the query
 * cache, and requeries for more changes if we haven't reached our target
 * change ID.
 * @param {goog.math.Long|undefined} maxChangeId Optional change id to process
 *     up to. Note we define the optional parameter before non-optional
 *     parmeters because the deferred passes in the response object which
 *     becomes the last parameter to this function.
 * @param {!drive.ds.ListChangesResponse} changeResponse The latest changes
 *     response with the largest change id set and the latest set of changes.
 * @param {!drive.ds.ItemQueryResponse} changedItemsResponse The old item
 *     values that are being changed.  This will only include the values for
 *     deletions and changes; inserted items are not included here for obvious
 *     reasons.
 * @private
 */
drive.ds.sync.change.ChangeProcessor.prototype.processChanges_ =
    function(maxChangeId, changeResponse, changedItemsResponse) {
  this.running_ = false;

  if (this.active_) {
    var itemMap = {};
    var items = changedItemsResponse.getItemList();
    for (var i = 0; i < items.length; i++) {
      itemMap[items[i].getId()] = items[i];
    }

    this.applyChanges_(changeResponse.getItemChangeList(), itemMap,
        maxChangeId ? maxChangeId : null);
    this.getMoreChangesIfNeeded_(maxChangeId, changeResponse);
  }
};


/**
 * Applies a list of ItemChange protos to the cache.
 * @param {!Array.<!drive.ds.ItemChange>} changes List of changes to apply.
 * @param {!Object.<string, !drive.ds.Item>} itemMap A map of item ids to their
 *     pre-change item.  This allows us to compare item versions during the
 *     cache update.
 * @param {goog.math.Long=} opt_maxChangeId Optional change id to process up to.
 * @private
 */
drive.ds.sync.change.ChangeProcessor.prototype.applyChanges_ =
    function(changes, itemMap, opt_maxChangeId) {

  // Split the changes list into deletions and insertions.
  // Note that changed items will appear in both the insertion and deletion
  // list with different version of the item.
  var insertedItems = [];
  var deletedItems = [];
  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];

    // If we've reached the max change id we should process, stop processing.
    if (opt_maxChangeId && opt_maxChangeId.lessThan(goog.math.Long.fromNumber(
        /** @type {number} */ (change.getChangeId())))) {
      break;
    }
    this.changes_++;

    var changedItem = itemMap[goog.asserts.assert(change.getItemId())];
    if (changedItem) {
      deletedItems.push(changedItem);
    }
    if (!change.getDeleted()) {
      insertedItems.push(change.getItem());
    }
  }

  // Apply the changes to the query cache.
  this.context_.getQueryCache().applyChanges(
      this.context_, insertedItems, deletedItems);

  // Apply the changes to the item cache.
  var cache = this.context_.getCache();
  for (var i = 0; i < deletedItems.length; i++) {
    cache.remove(deletedItems[i].getId());
  }
  for (var i = 0; i < insertedItems.length; i++) {
    cache.put(insertedItems[i]);
  }
};


/**
 * Gets the next batch of changes if we didn't get all the changes
 *     in this batch.
 * @param {goog.math.Long|undefined} maxChangeId Optional change id to process
 *     up to. Note we define the optional parameter before non-optional
 *     parmeters because the deferred passes in the response object which
 *     becomes the last parameter to this function.
 * @param {!drive.ds.ListChangesResponse} response The latest changes
 *     response with the largest change id set and the latest set of changes.
 * @private
 */
drive.ds.sync.change.ChangeProcessor.prototype.getMoreChangesIfNeeded_ =
    function(maxChangeId, response) {
  // Note that the next change id is only available when there are additional
  // changes to process from Genoa.
  var largestChangeId = goog.math.Long.fromNumber(
      response.getLargestChangeId() || 0);
  var processedChangeId = response.getNextChangeId() ?
      goog.math.Long.fromNumber(
          /** @type {number} */ (response.getNextChangeId())) :
      largestChangeId;

  // If there's a max change id we only process up to that number.
  this.setTargetChangeId(
      maxChangeId && maxChangeId.lessThan(largestChangeId) ?
      maxChangeId : largestChangeId);
  this.setProcessedChangeId(
      maxChangeId && maxChangeId.lessThan(processedChangeId) ?
      maxChangeId : processedChangeId);

  if (this.processedChangeId_.lessThan(this.targetChangeId_)) {
    this.getChanges(maxChangeId);
  } else {
    this.dispatchEvent(
        new drive.ds.sync.change.ChangeProcessor.ChangeEvent(
            processedChangeId, this.changes_));
    this.changes_ = 0;
  }
};


/**
 * Handles failure on change processing. Dispatch an error event to indicate
 * that a failure was detected.
 * @private
 */
drive.ds.sync.change.ChangeProcessor.prototype.handleError_ = function() {
  this.running_ = false;

  // Dispatch event to indicate error with push notifications.
  this.dispatchEvent(drive.ds.sync.change.ChangeProcessor.EventType.ERROR);
};


/**
 * Activates the change processor. By default this just marks the change
 * processor as active.
 */
drive.ds.sync.change.ChangeProcessor.prototype.start = function() {
  this.active_ = true;
};


/**
 * Stops the change processor. By default this just marks the change processor
 * as inactive.
 */
drive.ds.sync.change.ChangeProcessor.prototype.stop = function() {
  this.active_ = false;
};



/**
 * An event dispatched when changes are successfully processed.
 * @param {!goog.math.Long} processedChangeId The largest change id processed.
 * @param {number} changes The number of changes processed.
 * @extends {goog.events.Event}
 * @constructor
 * @const
 */
drive.ds.sync.change.ChangeProcessor.ChangeEvent =
    function(processedChangeId, changes) {
  goog.base(this, drive.ds.sync.change.ChangeProcessor.EventType.COMPLETE);

  /** @type {!goog.math.Long} The largest change id processed. */
  this.processedChangeId = processedChangeId;

  /** @type {number} The number of changes processed. */
  this.changes = changes;
};
goog.inherits(drive.ds.sync.change.ChangeProcessor.ChangeEvent,
    goog.events.Event);

//javascript/apps/drive/dataservice/sync/change/rangechangeprocessor.js
goog.provide('drive.ds.sync.change.RangeChangeProcessor');

goog.require('drive.ds.sync.change.ChangeProcessor');



/**
 * A change processor that fetches changes between a given start and end range.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!goog.math.Long} start The start change id.
 * @param {!goog.math.Long} end The end change id.
 * @extends {drive.ds.sync.change.ChangeProcessor}
 * @constructor
 */
drive.ds.sync.change.RangeChangeProcessor = function(context, start, end) {
  goog.base(this, context);

  /** @private {!goog.math.Long} */
  this.start_ = start;

  /** @private {!goog.math.Long} */
  this.end_ = end;
};
goog.inherits(drive.ds.sync.change.RangeChangeProcessor,
    drive.ds.sync.change.ChangeProcessor);


/** @override */
drive.ds.sync.change.RangeChangeProcessor.prototype.start = function() {
  goog.base(this, 'start');

  this.setProcessedChangeId(this.start_);
  this.getChanges(this.end_);
};

//javascript/apps/drive/dataservice/sync/change/clientchangemanager.js
goog.provide('drive.ds.sync.change.ClientChangeManager');

goog.require('drive.ds.sync.change.ChangeManager');
goog.require('drive.ds.sync.change.ChangeProcessor');
goog.require('drive.ds.sync.change.RangeChangeProcessor');
goog.require('goog.events.EventHandler');
goog.require('goog.structs.Queue');



/**
 * A client change manager that handles change logs from a client. This manager
 * uses a combination of Dumpello with change log updates from the client. This
 * change log processor waits until the Dumpello is fully loaded before it
 * begins processing change log updates from Genoa to catch up to the latest
 * change id. Once this is complete, this processor begins processing updates
 * from the client. Any updates that arrive from the client before Dumpello and
 * Genoa logs are processed are queued up for processing.
 *
 * Note(towong): This change processor should be only used for Expello for the
 * purposes for processing browser channel change logs. This should be removed
 * once we no longer need it.
 *
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.change.ChangeManager}
 * @constructor
 */
drive.ds.sync.change.ClientChangeManager = function(context) {
  goog.base(this, context);

  /** @private {!goog.structs.Queue.<!drive.ds.ListChangesResponse>} */
  this.changeQueue_ = new goog.structs.Queue();

  /** @private {boolean} */
  this.readyToProcessClientChanges_ = false;

  /** @private {!goog.events.EventHandler} */
  this.handler_ = new goog.events.EventHandler();
  this.registerDisposable(this.handler_);
};
goog.inherits(drive.ds.sync.change.ClientChangeManager,
    drive.ds.sync.change.ChangeManager);


/** @override */
drive.ds.sync.change.ClientChangeManager.prototype.start = function() {
  // At this point Dumpello is loaded and we have the largest change id from
  // Genoa. Create a change processor that fetches all the changes between the
  // Dumpello change id and the largest change id from Genoa.
  var startId = this.getContext().getMetadataStore().getLastChangeId();
  var endId = this.getLargestGenoaChangeId();
  var processor = new drive.ds.sync.change.RangeChangeProcessor(
      this.getContext(), startId || endId, endId);
  processor.start();

  // Listen for change log processing completion so we can start processing
  // client changes.
  this.handler_.listenOnce(processor,
      drive.ds.sync.change.ChangeProcessor.EventType.COMPLETE,
      goog.bind(this.handleGenoaProcessed_, this));
};


/**
 * Handles Genoa change log processing completion. Begin processing client
 * change logs.
 * @private
 */
drive.ds.sync.change.ClientChangeManager.prototype.handleGenoaProcessed_ =
    function() {
  this.readyToProcessClientChanges_ = true;

  // Dispatch event to indicate that this change manager has started processing
  // client change log events.
  // Note: We do this after catch-up Genoa change logs have been processed
  // because this is used to determine when to let our clients know to start
  // sending us requests. For Expello we need to ensure that the cache is up to
  // date before clients can send us requests.
  this.dispatchEvent(drive.ds.sync.change.ChangeManager.EventType.PROCESSING);

  this.processChanges_();
};


/**
 * Adds an ItemChangeResponse to be processed. Attempts to process the item
 * if possible.
 * @param {!drive.ds.ListChangesResponse} changesResponse Response object
 *     containing a list of changes to apply.
 */
drive.ds.sync.change.ClientChangeManager.prototype.addChange =
    function(changesResponse) {
  this.changeQueue_.enqueue(changesResponse);
  this.processChanges_();
};


/**
 * Processes the queue for changes if possible.
 * @private
 */
drive.ds.sync.change.ClientChangeManager.prototype.processChanges_ =
    function() {
  if (this.readyToProcessClientChanges_ && this.changeQueue_.getCount()) {
    var changesResponse = this.changeQueue_.dequeue();
    this.applyChanges(changesResponse.getItemChangeList());

    if (this.changeQueue_.getCount()) {
      this.processChanges_();
    }
  }
};


/**
 * Applies a list of ItemChange protos to the cache.
 * @param {!Array.<!drive.ds.ItemChange>} changes list of changes to apply.
 * @protected
 */
drive.ds.sync.change.ClientChangeManager.prototype.applyChanges =
    function(changes) {
  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];
    if (change.getDeleted()) {
      var id = /** @type {string} */ (change.getItemId());
      this.getContext().getCache().remove(id);
    } else {
      var item = /** @type {!drive.ds.Item} */ (change.getItem());
      this.getContext().getCache().put(item);
    }
  }
};


//javascript/apps/drive/dataservice/sync/change/pollingchangeprocessor.js
goog.provide('drive.ds.sync.change.PollingChangeProcessor');

goog.require('drive.ds.sync.change.ChangeProcessor');



/**
 * A change processor that gets updates via regular polling against the Genoa
 * API.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.change.ChangeProcessor}
 * @constructor
 */
drive.ds.sync.change.PollingChangeProcessor = function(context) {
  goog.base(this, context);
};
goog.inherits(drive.ds.sync.change.PollingChangeProcessor,
    drive.ds.sync.change.ChangeProcessor);


/**
 * Amount of time in milliseconds to wait between polling.
 * @private {number}
 */
drive.ds.sync.change.PollingChangeProcessor.POLLING_INTERVAL_MS_ = 10000;


/** @override */
drive.ds.sync.change.PollingChangeProcessor.prototype.start = function() {
  goog.base(this, 'start');

  this.poll_();
};


/**
 * Polls for the next set of changes from Genoa.
 * @private
 */
drive.ds.sync.change.PollingChangeProcessor.prototype.poll_ = function() {
  this.getChanges();

  if (this.getActive()) {
    goog.global.setTimeout(goog.bind(this.poll_, this),
        drive.ds.sync.change.PollingChangeProcessor.POLLING_INTERVAL_MS_);
  }
};

//javascript/closure/math/coordinate.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing two-dimensional positions.
 * @author pupius@google.com (Daniel Pupius)
 */


goog.provide('goog.math.Coordinate');

goog.require('goog.math');



/**
 * Class for representing coordinates and positions.
 * @param {number=} opt_x Left, defaults to 0.
 * @param {number=} opt_y Top, defaults to 0.
 * @constructor
 */
goog.math.Coordinate = function(opt_x, opt_y) {
  /**
   * X-value
   * @type {number}
   */
  this.x = goog.isDef(opt_x) ? opt_x : 0;

  /**
   * Y-value
   * @type {number}
   */
  this.y = goog.isDef(opt_y) ? opt_y : 0;
};


/**
 * Returns a new copy of the coordinate.
 * @return {!goog.math.Coordinate} A clone of this coordinate.
 */
goog.math.Coordinate.prototype.clone = function() {
  return new goog.math.Coordinate(this.x, this.y);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing the coordinate.
   * @return {string} In the form (50, 73).
   * @override
   */
  goog.math.Coordinate.prototype.toString = function() {
    return '(' + this.x + ', ' + this.y + ')';
  };
}


/**
 * Compares coordinates for equality.
 * @param {goog.math.Coordinate} a A Coordinate.
 * @param {goog.math.Coordinate} b A Coordinate.
 * @return {boolean} True iff the coordinates are equal, or if both are null.
 */
goog.math.Coordinate.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.x == b.x && a.y == b.y;
};


/**
 * Returns the distance between two coordinates.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {number} The distance between {@code a} and {@code b}.
 */
goog.math.Coordinate.distance = function(a, b) {
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy);
};


/**
 * Returns the magnitude of a coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @return {number} The distance between the origin and {@code a}.
 */
goog.math.Coordinate.magnitude = function(a) {
  return Math.sqrt(a.x * a.x + a.y * a.y);
};


/**
 * Returns the angle from the origin to a coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @return {number} The angle, in degrees, clockwise from the positive X
 *     axis to {@code a}.
 */
goog.math.Coordinate.azimuth = function(a) {
  return goog.math.angle(0, 0, a.x, a.y);
};


/**
 * Returns the squared distance between two coordinates. Squared distances can
 * be used for comparisons when the actual value is not required.
 *
 * Performance note: eliminating the square root is an optimization often used
 * in lower-level languages, but the speed difference is not nearly as
 * pronounced in JavaScript (only a few percent.)
 *
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {number} The squared distance between {@code a} and {@code b}.
 */
goog.math.Coordinate.squaredDistance = function(a, b) {
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return dx * dx + dy * dy;
};


/**
 * Returns the difference between two coordinates as a new
 * goog.math.Coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {!goog.math.Coordinate} A Coordinate representing the difference
 *     between {@code a} and {@code b}.
 */
goog.math.Coordinate.difference = function(a, b) {
  return new goog.math.Coordinate(a.x - b.x, a.y - b.y);
};


/**
 * Returns the sum of two coordinates as a new goog.math.Coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {!goog.math.Coordinate} A Coordinate representing the sum of the two
 *     coordinates.
 */
goog.math.Coordinate.sum = function(a, b) {
  return new goog.math.Coordinate(a.x + b.x, a.y + b.y);
};


/**
 * Rounds the x and y fields to the next larger integer values.
 * @return {!goog.math.Coordinate} This coordinate with ceil'd fields.
 */
goog.math.Coordinate.prototype.ceil = function() {
  this.x = Math.ceil(this.x);
  this.y = Math.ceil(this.y);
  return this;
};


/**
 * Rounds the x and y fields to the next smaller integer values.
 * @return {!goog.math.Coordinate} This coordinate with floored fields.
 */
goog.math.Coordinate.prototype.floor = function() {
  this.x = Math.floor(this.x);
  this.y = Math.floor(this.y);
  return this;
};


/**
 * Rounds the x and y fields to the nearest integer values.
 * @return {!goog.math.Coordinate} This coordinate with rounded fields.
 */
goog.math.Coordinate.prototype.round = function() {
  this.x = Math.round(this.x);
  this.y = Math.round(this.y);
  return this;
};


/**
 * Translates this box by the given offsets. If a {@code goog.math.Coordinate}
 * is given, then the x and y values are translated by the coordinate's x and y.
 * Otherwise, x and y are translated by {@code tx} and {@code opt_ty}
 * respectively.
 * @param {number|goog.math.Coordinate} tx The value to translate x by or the
 *     the coordinate to translate this coordinate by.
 * @param {number=} opt_ty The value to translate y by.
 * @return {!goog.math.Coordinate} This coordinate after translating.
 */
goog.math.Coordinate.prototype.translate = function(tx, opt_ty) {
  if (tx instanceof goog.math.Coordinate) {
    this.x += tx.x;
    this.y += tx.y;
  } else {
    this.x += tx;
    if (goog.isNumber(opt_ty)) {
      this.y += opt_ty;
    }
  }
  return this;
};


/**
 * Scales this coordinate by the given scale factors. The x and y values are
 * scaled by {@code sx} and {@code opt_sy} respectively.  If {@code opt_sy}
 * is not given, then {@code sx} is used for both x and y.
 * @param {number} sx The scale factor to use for the x dimension.
 * @param {number=} opt_sy The scale factor to use for the y dimension.
 * @return {!goog.math.Coordinate} This coordinate after scaling.
 */
goog.math.Coordinate.prototype.scale = function(sx, opt_sy) {
  var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
  this.x *= sx;
  this.y *= sy;
  return this;
};

//javascript/closure/math/size.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing two-dimensional sizes.
 * @author pupius@google.com (Dan Pupius)
 * @author brenneman@google.com (Shawn Brenneman)
 */


goog.provide('goog.math.Size');



/**
 * Class for representing sizes consisting of a width and height. Undefined
 * width and height support is deprecated and results in compiler warning.
 * @param {number} width Width.
 * @param {number} height Height.
 * @constructor
 */
goog.math.Size = function(width, height) {
  /**
   * Width
   * @type {number}
   */
  this.width = width;

  /**
   * Height
   * @type {number}
   */
  this.height = height;
};


/**
 * Compares sizes for equality.
 * @param {goog.math.Size} a A Size.
 * @param {goog.math.Size} b A Size.
 * @return {boolean} True iff the sizes have equal widths and equal
 *     heights, or if both are null.
 */
goog.math.Size.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.width == b.width && a.height == b.height;
};


/**
 * @return {!goog.math.Size} A new copy of the Size.
 */
goog.math.Size.prototype.clone = function() {
  return new goog.math.Size(this.width, this.height);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing size.
   * @return {string} In the form (50 x 73).
   * @override
   */
  goog.math.Size.prototype.toString = function() {
    return '(' + this.width + ' x ' + this.height + ')';
  };
}


/**
 * @return {number} The longer of the two dimensions in the size.
 */
goog.math.Size.prototype.getLongest = function() {
  return Math.max(this.width, this.height);
};


/**
 * @return {number} The shorter of the two dimensions in the size.
 */
goog.math.Size.prototype.getShortest = function() {
  return Math.min(this.width, this.height);
};


/**
 * @return {number} The area of the size (width * height).
 */
goog.math.Size.prototype.area = function() {
  return this.width * this.height;
};


/**
 * @return {number} The perimeter of the size (width + height) * 2.
 */
goog.math.Size.prototype.perimeter = function() {
  return (this.width + this.height) * 2;
};


/**
 * @return {number} The ratio of the size's width to its height.
 */
goog.math.Size.prototype.aspectRatio = function() {
  return this.width / this.height;
};


/**
 * @return {boolean} True if the size has zero area, false if both dimensions
 *     are non-zero numbers.
 */
goog.math.Size.prototype.isEmpty = function() {
  return !this.area();
};


/**
 * Clamps the width and height parameters upward to integer values.
 * @return {!goog.math.Size} This size with ceil'd components.
 */
goog.math.Size.prototype.ceil = function() {
  this.width = Math.ceil(this.width);
  this.height = Math.ceil(this.height);
  return this;
};


/**
 * @param {!goog.math.Size} target The target size.
 * @return {boolean} True if this Size is the same size or smaller than the
 *     target size in both dimensions.
 */
goog.math.Size.prototype.fitsInside = function(target) {
  return this.width <= target.width && this.height <= target.height;
};


/**
 * Clamps the width and height parameters downward to integer values.
 * @return {!goog.math.Size} This size with floored components.
 */
goog.math.Size.prototype.floor = function() {
  this.width = Math.floor(this.width);
  this.height = Math.floor(this.height);
  return this;
};


/**
 * Rounds the width and height parameters to integer values.
 * @return {!goog.math.Size} This size with rounded components.
 */
goog.math.Size.prototype.round = function() {
  this.width = Math.round(this.width);
  this.height = Math.round(this.height);
  return this;
};


/**
 * Scales this size by the given scale factors. The width and height are scaled
 * by {@code sx} and {@code opt_sy} respectively.  If {@code opt_sy} is not
 * given, then {@code sx} is used for both the width and height.
 * @param {number} sx The scale factor to use for the width.
 * @param {number=} opt_sy The scale factor to use for the height.
 * @return {!goog.math.Size} This Size object after scaling.
 */
goog.math.Size.prototype.scale = function(sx, opt_sy) {
  var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
  this.width *= sx;
  this.height *= sy;
  return this;
};


/**
 * Uniformly scales the size to fit inside the dimensions of a given size. The
 * original aspect ratio will be preserved.
 *
 * This function assumes that both Sizes contain strictly positive dimensions.
 * @param {!goog.math.Size} target The target size.
 * @return {!goog.math.Size} This Size object, after optional scaling.
 */
goog.math.Size.prototype.scaleToFit = function(target) {
  var s = this.aspectRatio() > target.aspectRatio() ?
      target.width / this.width :
      target.height / this.height;

  return this.scale(s);
};

//javascript/closure/dom/browserfeature.js
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Browser capability checks for the dom package.
 *
 * @author zhyder@google.com (Zohair Hyder)
 */


goog.provide('goog.dom.BrowserFeature');

goog.require('goog.userAgent');


/**
 * Enum of browser capabilities.
 * @enum {boolean}
 */
goog.dom.BrowserFeature = {
  /**
   * Whether attributes 'name' and 'type' can be added to an element after it's
   * created. False in Internet Explorer prior to version 9.
   */
  CAN_ADD_NAME_OR_TYPE_ATTRIBUTES: !goog.userAgent.IE ||
      goog.userAgent.isDocumentModeOrHigher(9),

  /**
   * Whether we can use element.children to access an element's Element
   * children. Available since Gecko 1.9.1, IE 9. (IE<9 also includes comment
   * nodes in the collection.)
   */
  CAN_USE_CHILDREN_ATTRIBUTE: !goog.userAgent.GECKO && !goog.userAgent.IE ||
      goog.userAgent.IE && goog.userAgent.isDocumentModeOrHigher(9) ||
      goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9.1'),

  /**
   * Opera, Safari 3, and Internet Explorer 9 all support innerText but they
   * include text nodes in script and style tags. Not document-mode-dependent.
   */
  CAN_USE_INNER_TEXT: (
      goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9')),

  /**
   * MSIE, Opera, and Safari>=4 support element.parentElement to access an
   * element's parent if it is an Element.
   */
  CAN_USE_PARENT_ELEMENT_PROPERTY: goog.userAgent.IE || goog.userAgent.OPERA ||
      goog.userAgent.WEBKIT,

  /**
   * Whether NoScope elements need a scoped element written before them in
   * innerHTML.
   * MSDN: http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx#1
   */
  INNER_HTML_NEEDS_SCOPED_ELEMENT: goog.userAgent.IE
};

//javascript/closure/dom/classes.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for adding, removing and setting classes.  Prefer
 * {@link goog.dom.classlist} over these utilities since goog.dom.classlist
 * conforms closer to the semantics of Element.classList, is faster (uses
 * native methods rather than parsing strings on every call) and compiles
 * to smaller code as a result.
 *
 * Note: these utilities are meant to operate on HTMLElements and
 * will not work on elements with differing interfaces (such as SVGElements).
 *
 * @author pupius@google.com (Daniel Pupius)
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.dom.classes');

goog.require('goog.array');


/**
 * Sets the entire class name of an element.
 * @param {Node} element DOM node to set class of.
 * @param {string} className Class name(s) to apply to element.
 */
goog.dom.classes.set = function(element, className) {
  element.className = className;
};


/**
 * Gets an array of class names on an element
 * @param {Node} element DOM node to get class of.
 * @return {!Array} Class names on {@code element}. Some browsers add extra
 *     properties to the array. Do not depend on any of these!
 */
goog.dom.classes.get = function(element) {
  var className = element.className;
  // Some types of elements don't have a className in IE (e.g. iframes).
  // Furthermore, in Firefox, className is not a string when the element is
  // an SVG element.
  return goog.isString(className) && className.match(/\S+/g) || [];
};


/**
 * Adds a class or classes to an element. Does not add multiples of class names.
 * @param {Node} element DOM node to add class to.
 * @param {...string} var_args Class names to add.
 * @return {boolean} Whether class was added (or all classes were added).
 */
goog.dom.classes.add = function(element, var_args) {
  var classes = goog.dom.classes.get(element);
  var args = goog.array.slice(arguments, 1);
  var expectedCount = classes.length + args.length;
  goog.dom.classes.add_(classes, args);
  goog.dom.classes.set(element, classes.join(' '));
  return classes.length == expectedCount;
};


/**
 * Removes a class or classes from an element.
 * @param {Node} element DOM node to remove class from.
 * @param {...string} var_args Class name(s) to remove.
 * @return {boolean} Whether all classes in {@code var_args} were found and
 *     removed.
 */
goog.dom.classes.remove = function(element, var_args) {
  var classes = goog.dom.classes.get(element);
  var args = goog.array.slice(arguments, 1);
  var newClasses = goog.dom.classes.getDifference_(classes, args);
  goog.dom.classes.set(element, newClasses.join(' '));
  return newClasses.length == classes.length - args.length;
};


/**
 * Helper method for {@link goog.dom.classes.add} and
 * {@link goog.dom.classes.addRemove}. Adds one or more classes to the supplied
 * classes array.
 * @param {Array.<string>} classes All class names for the element, will be
 *     updated to have the classes supplied in {@code args} added.
 * @param {Array.<string>} args Class names to add.
 * @private
 */
goog.dom.classes.add_ = function(classes, args) {
  for (var i = 0; i < args.length; i++) {
    if (!goog.array.contains(classes, args[i])) {
      classes.push(args[i]);
    }
  }
};


/**
 * Helper method for {@link goog.dom.classes.remove} and
 * {@link goog.dom.classes.addRemove}. Calculates the difference of two arrays.
 * @param {!Array.<string>} arr1 First array.
 * @param {!Array.<string>} arr2 Second array.
 * @return {!Array.<string>} The first array without the elements of the second
 *     array.
 * @private
 */
goog.dom.classes.getDifference_ = function(arr1, arr2) {
  return goog.array.filter(arr1, function(item) {
    return !goog.array.contains(arr2, item);
  });
};


/**
 * Switches a class on an element from one to another without disturbing other
 * classes. If the fromClass isn't removed, the toClass won't be added.
 * @param {Node} element DOM node to swap classes on.
 * @param {string} fromClass Class to remove.
 * @param {string} toClass Class to add.
 * @return {boolean} Whether classes were switched.
 */
goog.dom.classes.swap = function(element, fromClass, toClass) {
  var classes = goog.dom.classes.get(element);

  var removed = false;
  for (var i = 0; i < classes.length; i++) {
    if (classes[i] == fromClass) {
      goog.array.splice(classes, i--, 1);
      removed = true;
    }
  }

  if (removed) {
    classes.push(toClass);
    goog.dom.classes.set(element, classes.join(' '));
  }

  return removed;
};


/**
 * Adds zero or more classes to an element and removes zero or more as a single
 * operation. Unlike calling {@link goog.dom.classes.add} and
 * {@link goog.dom.classes.remove} separately, this is more efficient as it only
 * parses the class property once.
 *
 * If a class is in both the remove and add lists, it will be added. Thus,
 * you can use this instead of {@link goog.dom.classes.swap} when you have
 * more than two class names that you want to swap.
 *
 * @param {Node} element DOM node to swap classes on.
 * @param {?(string|Array.<string>)} classesToRemove Class or classes to
 *     remove, if null no classes are removed.
 * @param {?(string|Array.<string>)} classesToAdd Class or classes to add, if
 *     null no classes are added.
 */
goog.dom.classes.addRemove = function(element, classesToRemove, classesToAdd) {
  var classes = goog.dom.classes.get(element);
  if (goog.isString(classesToRemove)) {
    goog.array.remove(classes, classesToRemove);
  } else if (goog.isArray(classesToRemove)) {
    classes = goog.dom.classes.getDifference_(classes, classesToRemove);
  }

  if (goog.isString(classesToAdd) &&
      !goog.array.contains(classes, classesToAdd)) {
    classes.push(classesToAdd);
  } else if (goog.isArray(classesToAdd)) {
    goog.dom.classes.add_(classes, classesToAdd);
  }

  goog.dom.classes.set(element, classes.join(' '));
};


/**
 * Returns true if an element has a class.
 * @param {Node} element DOM node to test.
 * @param {string} className Class name to test for.
 * @return {boolean} Whether element has the class.
 */
goog.dom.classes.has = function(element, className) {
  return goog.array.contains(goog.dom.classes.get(element), className);
};


/**
 * Adds or removes a class depending on the enabled argument.
 * @param {Node} element DOM node to add or remove the class on.
 * @param {string} className Class name to add or remove.
 * @param {boolean} enabled Whether to add or remove the class (true adds,
 *     false removes).
 */
goog.dom.classes.enable = function(element, className, enabled) {
  if (enabled) {
    goog.dom.classes.add(element, className);
  } else {
    goog.dom.classes.remove(element, className);
  }
};


/**
 * Removes a class if an element has it, and adds it the element doesn't have
 * it.  Won't affect other classes on the node.
 * @param {Node} element DOM node to toggle class on.
 * @param {string} className Class to toggle.
 * @return {boolean} True if class was added, false if it was removed
 *     (in other words, whether element has the class after this function has
 *     been called).
 */
goog.dom.classes.toggle = function(element, className) {
  var add = !goog.dom.classes.has(element, className);
  goog.dom.classes.enable(element, className, add);
  return add;
};

//javascript/closure/dom/tagname.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines the goog.dom.TagName enum.  This enumerates
 * all HTML tag names specified in either the the W3C HTML 4.01 index of
 * elements or the HTML5 draft specification.
 *
 * References:
 * http://www.w3.org/TR/html401/index/elements.html
 * http://dev.w3.org/html5/spec/section-index.html
 *
 * @author baker@google.com (Greg Baker)
 */
goog.provide('goog.dom.TagName');


/**
 * Enum of all html tag names specified by the W3C HTML4.01 and HTML5
 * specifications.
 * @enum {string}
 */
goog.dom.TagName = {
  A: 'A',
  ABBR: 'ABBR',
  ACRONYM: 'ACRONYM',
  ADDRESS: 'ADDRESS',
  APPLET: 'APPLET',
  AREA: 'AREA',
  ARTICLE: 'ARTICLE',
  ASIDE: 'ASIDE',
  AUDIO: 'AUDIO',
  B: 'B',
  BASE: 'BASE',
  BASEFONT: 'BASEFONT',
  BDI: 'BDI',
  BDO: 'BDO',
  BIG: 'BIG',
  BLOCKQUOTE: 'BLOCKQUOTE',
  BODY: 'BODY',
  BR: 'BR',
  BUTTON: 'BUTTON',
  CANVAS: 'CANVAS',
  CAPTION: 'CAPTION',
  CENTER: 'CENTER',
  CITE: 'CITE',
  CODE: 'CODE',
  COL: 'COL',
  COLGROUP: 'COLGROUP',
  COMMAND: 'COMMAND',
  DATA: 'DATA',
  DATALIST: 'DATALIST',
  DD: 'DD',
  DEL: 'DEL',
  DETAILS: 'DETAILS',
  DFN: 'DFN',
  DIALOG: 'DIALOG',
  DIR: 'DIR',
  DIV: 'DIV',
  DL: 'DL',
  DT: 'DT',
  EM: 'EM',
  EMBED: 'EMBED',
  FIELDSET: 'FIELDSET',
  FIGCAPTION: 'FIGCAPTION',
  FIGURE: 'FIGURE',
  FONT: 'FONT',
  FOOTER: 'FOOTER',
  FORM: 'FORM',
  FRAME: 'FRAME',
  FRAMESET: 'FRAMESET',
  H1: 'H1',
  H2: 'H2',
  H3: 'H3',
  H4: 'H4',
  H5: 'H5',
  H6: 'H6',
  HEAD: 'HEAD',
  HEADER: 'HEADER',
  HGROUP: 'HGROUP',
  HR: 'HR',
  HTML: 'HTML',
  I: 'I',
  IFRAME: 'IFRAME',
  IMG: 'IMG',
  INPUT: 'INPUT',
  INS: 'INS',
  ISINDEX: 'ISINDEX',
  KBD: 'KBD',
  KEYGEN: 'KEYGEN',
  LABEL: 'LABEL',
  LEGEND: 'LEGEND',
  LI: 'LI',
  LINK: 'LINK',
  MAP: 'MAP',
  MARK: 'MARK',
  MATH: 'MATH',
  MENU: 'MENU',
  META: 'META',
  METER: 'METER',
  NAV: 'NAV',
  NOFRAMES: 'NOFRAMES',
  NOSCRIPT: 'NOSCRIPT',
  OBJECT: 'OBJECT',
  OL: 'OL',
  OPTGROUP: 'OPTGROUP',
  OPTION: 'OPTION',
  OUTPUT: 'OUTPUT',
  P: 'P',
  PARAM: 'PARAM',
  PRE: 'PRE',
  PROGRESS: 'PROGRESS',
  Q: 'Q',
  RP: 'RP',
  RT: 'RT',
  RUBY: 'RUBY',
  S: 'S',
  SAMP: 'SAMP',
  SCRIPT: 'SCRIPT',
  SECTION: 'SECTION',
  SELECT: 'SELECT',
  SMALL: 'SMALL',
  SOURCE: 'SOURCE',
  SPAN: 'SPAN',
  STRIKE: 'STRIKE',
  STRONG: 'STRONG',
  STYLE: 'STYLE',
  SUB: 'SUB',
  SUMMARY: 'SUMMARY',
  SUP: 'SUP',
  SVG: 'SVG',
  TABLE: 'TABLE',
  TBODY: 'TBODY',
  TD: 'TD',
  TEXTAREA: 'TEXTAREA',
  TFOOT: 'TFOOT',
  TH: 'TH',
  THEAD: 'THEAD',
  TIME: 'TIME',
  TITLE: 'TITLE',
  TR: 'TR',
  TRACK: 'TRACK',
  TT: 'TT',
  U: 'U',
  UL: 'UL',
  VAR: 'VAR',
  VIDEO: 'VIDEO',
  WBR: 'WBR'
};

//javascript/closure/dom/dom.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating the browser's Document Object Model
 * Inspiration taken *heavily* from mochikit (http://mochikit.com/).
 *
 * You can use {@link goog.dom.DomHelper} to create new dom helpers that refer
 * to a different document object.  This is useful if you are working with
 * frames or multiple windows.
 *
 * @author pupius@google.com (Daniel Pupius)
 * @author arv@google.com (Erik Arvidsson)
 */


// TODO(arv): Rename/refactor getTextContent and getRawTextContent. The problem
// is that getTextContent should mimic the DOM3 textContent. We should add a
// getInnerText (or getText) which tries to return the visible text, innerText.


goog.provide('goog.dom');
goog.provide('goog.dom.Appendable');
goog.provide('goog.dom.DomHelper');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom.BrowserFeature');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classes');
goog.require('goog.functions');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Size');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * quirks mode.
 */
goog.define('goog.dom.ASSUME_QUIRKS_MODE', false);


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * standards compliance mode.
 */
goog.define('goog.dom.ASSUME_STANDARDS_MODE', false);


/**
 * Whether we know the compatibility mode at compile time.
 * @type {boolean}
 * @private
 */
goog.dom.COMPAT_MODE_KNOWN_ =
    goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;


/**
 * Gets the DomHelper object for the document where the element resides.
 * @param {(Node|Window)=} opt_element If present, gets the DomHelper for this
 *     element.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.getDomHelper = function(opt_element) {
  return opt_element ?
      new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) :
      (goog.dom.defaultDomHelper_ ||
          (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper()));
};


/**
 * Cached default DOM helper.
 * @type {goog.dom.DomHelper}
 * @private
 */
goog.dom.defaultDomHelper_;


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.getDocument = function() {
  return document;
};


/**
 * Gets an element from the current document by element id.
 *
 * If an Element is passed in, it is returned.
 *
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.getElement = function(element) {
  return goog.dom.getElementHelper_(document, element);
};


/**
 * Gets an element by id from the given document (if present).
 * If an element is given, it is returned.
 * @param {!Document} doc
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The resulting element.
 * @private
 */
goog.dom.getElementHelper_ = function(doc, element) {
  return goog.isString(element) ?
      doc.getElementById(element) :
      element;
};


/**
 * Gets an element by id, asserting that the element is found.
 *
 * This is used when an element is expected to exist, and should fail with
 * an assertion error if it does not (if assertions are enabled).
 *
 * @param {string} id Element ID.
 * @return {!Element} The element with the given ID, if it exists.
 */
goog.dom.getRequiredElement = function(id) {
  return goog.dom.getRequiredElementHelper_(document, id);
};


/**
 * Helper function for getRequiredElementHelper functions, both static and
 * on DomHelper.  Asserts the element with the given id exists.
 * @param {!Document} doc
 * @param {string} id
 * @return {!Element} The element with the given ID, if it exists.
 * @private
 */
goog.dom.getRequiredElementHelper_ = function(doc, id) {
  // To prevent users passing in Elements as is permitted in getElement().
  goog.asserts.assertString(id);
  var element = goog.dom.getElementHelper_(doc, id);
  element = goog.asserts.assertElement(element,
      'No element found with id: ' + id);
  return element;
};


/**
 * Alias for getElement.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.getElement} instead.
 */
goog.dom.$ = goog.dom.getElement;


/**
 * Looks up elements by both tag and class name, using browser native functions
 * ({@code querySelectorAll}, {@code getElementsByTagName} or
 * {@code getElementsByClassName}) where possible. This function
 * is a useful, if limited, way of collecting a list of DOM elements
 * with certain characteristics.  {@code goog.dom.query} offers a
 * more powerful and general solution which allows matching on CSS3
 * selector expressions, but at increased cost in code size. If all you
 * need is particular tags belonging to a single class, this function
 * is fast and sleek.
 *
 * @see {goog.dom.query}
 *
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {
  return goog.dom.getElementsByTagNameAndClass_(document, opt_tag, opt_class,
                                                opt_el);
};


/**
 * Returns an array of all the elements with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } The items found with the class name provided.
 */
goog.dom.getElementsByClass = function(className, opt_el) {
  var parent = opt_el || document;
  if (goog.dom.canUseQuerySelector_(parent)) {
    return parent.querySelectorAll('.' + className);
  } else if (parent.getElementsByClassName) {
    return parent.getElementsByClassName(className);
  }
  return goog.dom.getElementsByTagNameAndClass_(
      document, '*', className, opt_el);
};


/**
 * Returns the first element with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return {Element} The first item with the class name provided.
 */
goog.dom.getElementByClass = function(className, opt_el) {
  var parent = opt_el || document;
  var retVal = null;
  if (goog.dom.canUseQuerySelector_(parent)) {
    retVal = parent.querySelector('.' + className);
  } else {
    retVal = goog.dom.getElementsByClass(className, opt_el)[0];
  }
  return retVal || null;
};


/**
 * Ensures an element with the given className exists, and then returns the
 * first element with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {!Element|!Document=} opt_root Optional element or document to look
 *     in.
 * @return {!Element} The first item with the class name provided.
 * @throws {goog.asserts.AssertionError} Thrown if no element is found.
 */
goog.dom.getRequiredElementByClass = function(className, opt_root) {
  var retValue = goog.dom.getElementByClass(className, opt_root);
  return goog.asserts.assert(retValue,
      'No element found with className: ' + className);
};


/**
 * Prefer the standardized (http://www.w3.org/TR/selectors-api/), native and
 * fast W3C Selectors API.
 * @param {!(Element|Document)} parent The parent document object.
 * @return {boolean} whether or not we can use parent.querySelector* APIs.
 * @private
 */
goog.dom.canUseQuerySelector_ = function(parent) {
  return !!(parent.querySelectorAll && parent.querySelector);
};


/**
 * Helper for {@code getElementsByTagNameAndClass}.
 * @param {!Document} doc The document to get the elements in.
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 * @private
 */
goog.dom.getElementsByTagNameAndClass_ = function(doc, opt_tag, opt_class,
                                                  opt_el) {
  var parent = opt_el || doc;
  var tagName = (opt_tag && opt_tag != '*') ? opt_tag.toUpperCase() : '';

  if (goog.dom.canUseQuerySelector_(parent) &&
      (tagName || opt_class)) {
    var query = tagName + (opt_class ? '.' + opt_class : '');
    return parent.querySelectorAll(query);
  }

  // Use the native getElementsByClassName if available, under the assumption
  // that even when the tag name is specified, there will be fewer elements to
  // filter through when going by class than by tag name
  if (opt_class && parent.getElementsByClassName) {
    var els = parent.getElementsByClassName(opt_class);

    if (tagName) {
      var arrayLike = {};
      var len = 0;

      // Filter for specific tags if requested.
      for (var i = 0, el; el = els[i]; i++) {
        if (tagName == el.nodeName) {
          arrayLike[len++] = el;
        }
      }
      arrayLike.length = len;

      return arrayLike;
    } else {
      return els;
    }
  }

  var els = parent.getElementsByTagName(tagName || '*');

  if (opt_class) {
    var arrayLike = {};
    var len = 0;
    for (var i = 0, el; el = els[i]; i++) {
      var className = el.className;
      // Check if className has a split function since SVG className does not.
      if (typeof className.split == 'function' &&
          goog.array.contains(className.split(/\s+/), opt_class)) {
        arrayLike[len++] = el;
      }
    }
    arrayLike.length = len;
    return arrayLike;
  } else {
    return els;
  }
};


/**
 * Alias for {@code getElementsByTagNameAndClass}.
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 * @deprecated Use {@link goog.dom.getElementsByTagNameAndClass} instead.
 */
goog.dom.$$ = goog.dom.getElementsByTagNameAndClass;


/**
 * Sets multiple properties on a node.
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 */
goog.dom.setProperties = function(element, properties) {
  goog.object.forEach(properties, function(val, key) {
    if (key == 'style') {
      element.style.cssText = val;
    } else if (key == 'class') {
      element.className = val;
    } else if (key == 'for') {
      element.htmlFor = val;
    } else if (key in goog.dom.DIRECT_ATTRIBUTE_MAP_) {
      element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);
    } else if (goog.string.startsWith(key, 'aria-') ||
        goog.string.startsWith(key, 'data-')) {
      element.setAttribute(key, val);
    } else {
      element[key] = val;
    }
  });
};


/**
 * Map of attributes that should be set using
 * element.setAttribute(key, val) instead of element[key] = val.  Used
 * by goog.dom.setProperties.
 *
 * @type {Object}
 * @private
 */
goog.dom.DIRECT_ATTRIBUTE_MAP_ = {
  'cellpadding': 'cellPadding',
  'cellspacing': 'cellSpacing',
  'colspan': 'colSpan',
  'frameborder': 'frameBorder',
  'height': 'height',
  'maxlength': 'maxLength',
  'role': 'role',
  'rowspan': 'rowSpan',
  'type': 'type',
  'usemap': 'useMap',
  'valign': 'vAlign',
  'width': 'width'
};


/**
 * Gets the dimensions of the viewport.
 *
 * Gecko Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of document.
 *
 * Gecko Backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * IE6/7 Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of document element.
 *
 * IE5 + IE6/7 Backwards compatible mode:
 * docEl.clientWidth  0.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight 0.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * Opera 9 Standards and backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * WebKit:
 * Safari 2
 * docEl.clientHeight Same as scrollHeight.
 * docEl.clientWidth  Same as innerWidth.
 * win.innerWidth     Width of viewport excluding scrollbar.
 * win.innerHeight    Height of the viewport including scrollbar.
 * frame.innerHeight  Height of the viewport exluding scrollbar.
 *
 * Safari 3 (tested in 522)
 *
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * docEl.clientHeight Height of viewport excluding scrollbar in strict mode.
 * body.clientHeight  Height of viewport excluding scrollbar in quirks mode.
 *
 * @param {Window=} opt_window Optional window element to test.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.getViewportSize = function(opt_window) {
  // TODO(arv): This should not take an argument
  return goog.dom.getViewportSize_(opt_window || window);
};


/**
 * Helper for {@code getViewportSize}.
 * @param {Window} win The window to get the view port size for.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 * @private
 */
goog.dom.getViewportSize_ = function(win) {
  var doc = win.document;
  var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;
  return new goog.math.Size(el.clientWidth, el.clientHeight);
};


/**
 * Calculates the height of the document.
 *
 * @return {number} The height of the current document.
 */
goog.dom.getDocumentHeight = function() {
  return goog.dom.getDocumentHeight_(window);
};


/**
 * Calculates the height of the document of the given window.
 *
 * Function code copied from the opensocial gadget api:
 *   gadgets.window.adjustHeight(opt_height)
 *
 * @private
 * @param {Window} win The window whose document height to retrieve.
 * @return {number} The height of the document of the given window.
 */
goog.dom.getDocumentHeight_ = function(win) {
  // NOTE(eae): This method will return the window size rather than the document
  // size in webkit quirks mode.
  var doc = win.document;
  var height = 0;

  if (doc) {
    // Calculating inner content height is hard and different between
    // browsers rendering in Strict vs. Quirks mode.  We use a combination of
    // three properties within document.body and document.documentElement:
    // - scrollHeight
    // - offsetHeight
    // - clientHeight
    // These values differ significantly between browsers and rendering modes.
    // But there are patterns.  It just takes a lot of time and persistence
    // to figure out.

    // Get the height of the viewport
    var vh = goog.dom.getViewportSize_(win).height;
    var body = doc.body;
    var docEl = doc.documentElement;
    if (goog.dom.isCss1CompatMode_(doc) && docEl.scrollHeight) {
      // In Strict mode:
      // The inner content height is contained in either:
      //    document.documentElement.scrollHeight
      //    document.documentElement.offsetHeight
      // Based on studying the values output by different browsers,
      // use the value that's NOT equal to the viewport height found above.
      height = docEl.scrollHeight != vh ?
          docEl.scrollHeight : docEl.offsetHeight;
    } else {
      // In Quirks mode:
      // documentElement.clientHeight is equal to documentElement.offsetHeight
      // except in IE.  In most browsers, document.documentElement can be used
      // to calculate the inner content height.
      // However, in other browsers (e.g. IE), document.body must be used
      // instead.  How do we know which one to use?
      // If document.documentElement.clientHeight does NOT equal
      // document.documentElement.offsetHeight, then use document.body.
      var sh = docEl.scrollHeight;
      var oh = docEl.offsetHeight;
      if (docEl.clientHeight != oh) {
        sh = body.scrollHeight;
        oh = body.offsetHeight;
      }

      // Detect whether the inner content height is bigger or smaller
      // than the bounding box (viewport).  If bigger, take the larger
      // value.  If smaller, take the smaller value.
      if (sh > vh) {
        // Content is larger
        height = sh > oh ? sh : oh;
      } else {
        // Content is smaller
        height = sh < oh ? sh : oh;
      }
    }
  }

  return height;
};


/**
 * Gets the page scroll distance as a coordinate object.
 *
 * @param {Window=} opt_window Optional window element to test.
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 * @deprecated Use {@link goog.dom.getDocumentScroll} instead.
 */
goog.dom.getPageScroll = function(opt_window) {
  var win = opt_window || goog.global || window;
  return goog.dom.getDomHelper(win.document).getDocumentScroll();
};


/**
 * Gets the document scroll distance as a coordinate object.
 *
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 */
goog.dom.getDocumentScroll = function() {
  return goog.dom.getDocumentScroll_(document);
};


/**
 * Helper for {@code getDocumentScroll}.
 *
 * @param {!Document} doc The document to get the scroll for.
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 * @private
 */
goog.dom.getDocumentScroll_ = function(doc) {
  var el = goog.dom.getDocumentScrollElement_(doc);
  var win = goog.dom.getWindow_(doc);
  if (goog.userAgent.IE && goog.userAgent.isVersionOrHigher('10') &&
      win.pageYOffset != el.scrollTop) {
    // The keyboard on IE10 touch devices shifts the page using the pageYOffset
    // without modifying scrollTop. For this case, we want the body scroll
    // offsets.
    return new goog.math.Coordinate(el.scrollLeft, el.scrollTop);
  }
  return new goog.math.Coordinate(win.pageXOffset || el.scrollLeft,
      win.pageYOffset || el.scrollTop);
};


/**
 * Gets the document scroll element.
 * @return {Element} Scrolling element.
 */
goog.dom.getDocumentScrollElement = function() {
  return goog.dom.getDocumentScrollElement_(document);
};


/**
 * Helper for {@code getDocumentScrollElement}.
 * @param {!Document} doc The document to get the scroll element for.
 * @return {Element} Scrolling element.
 * @private
 */
goog.dom.getDocumentScrollElement_ = function(doc) {
  // WebKit needs body.scrollLeft in both quirks mode and strict mode. We also
  // default to the documentElement if the document does not have a body (e.g.
  // a SVG document).
  if (!goog.userAgent.WEBKIT && goog.dom.isCss1CompatMode_(doc)) {
    return doc.documentElement;
  }
  return doc.body || doc.documentElement;
};


/**
 * Gets the window object associated with the given document.
 *
 * @param {Document=} opt_doc  Document object to get window for.
 * @return {!Window} The window associated with the given document.
 */
goog.dom.getWindow = function(opt_doc) {
  // TODO(arv): This should not take an argument.
  return opt_doc ? goog.dom.getWindow_(opt_doc) : window;
};


/**
 * Helper for {@code getWindow}.
 *
 * @param {!Document} doc  Document object to get window for.
 * @return {!Window} The window associated with the given document.
 * @private
 */
goog.dom.getWindow_ = function(doc) {
  return doc.parentWindow || doc.defaultView;
};


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom('div', null, createDom('p'), createDom('p'));</code>
 * would return a div with two child paragraphs
 *
 * @param {string} tagName Tag to create.
 * @param {(Object|Array.<string>|string)=} opt_attributes If object, then a map
 *     of name-value pairs for attributes. If a string, then this is the
 *     className of the new element. If an array, the elements will be joined
 *     together as the className of the new element.
 * @param {...(Object|string|Array|NodeList)} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array or NodeList,i
 *     its elements will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 */
goog.dom.createDom = function(tagName, opt_attributes, var_args) {
  return goog.dom.createDom_(document, arguments);
};


/**
 * Helper for {@code createDom}.
 * @param {!Document} doc The document to create the DOM in.
 * @param {!Arguments} args Argument object passed from the callers. See
 *     {@code goog.dom.createDom} for details.
 * @return {!Element} Reference to a DOM node.
 * @private
 */
goog.dom.createDom_ = function(doc, args) {
  var tagName = args[0];
  var attributes = args[1];

  // Internet Explorer is dumb: http://msdn.microsoft.com/workshop/author/
  //                            dhtml/reference/properties/name_2.asp
  // Also does not allow setting of 'type' attribute on 'input' or 'button'.
  if (!goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES && attributes &&
      (attributes.name || attributes.type)) {
    var tagNameArr = ['<', tagName];
    if (attributes.name) {
      tagNameArr.push(' name="', goog.string.htmlEscape(attributes.name),
                      '"');
    }
    if (attributes.type) {
      tagNameArr.push(' type="', goog.string.htmlEscape(attributes.type),
                      '"');

      // Clone attributes map to remove 'type' without mutating the input.
      var clone = {};
      goog.object.extend(clone, attributes);

      // JSCompiler can't see how goog.object.extend added this property,
      // because it was essentially added by reflection.
      // So it needs to be quoted.
      delete clone['type'];

      attributes = clone;
    }
    tagNameArr.push('>');
    tagName = tagNameArr.join('');
  }

  var element = doc.createElement(tagName);

  if (attributes) {
    if (goog.isString(attributes)) {
      element.className = attributes;
    } else if (goog.isArray(attributes)) {
      goog.dom.classes.add.apply(null, [element].concat(attributes));
    } else {
      goog.dom.setProperties(element, attributes);
    }
  }

  if (args.length > 2) {
    goog.dom.append_(doc, element, args, 2);
  }

  return element;
};


/**
 * Appends a node with text or other nodes.
 * @param {!Document} doc The document to create new nodes in.
 * @param {!Node} parent The node to append nodes to.
 * @param {!Arguments} args The values to add. See {@code goog.dom.append}.
 * @param {number} startIndex The index of the array to start from.
 * @private
 */
goog.dom.append_ = function(doc, parent, args, startIndex) {
  function childHandler(child) {
    // TODO(pupius): More coercion, ala MochiKit?
    if (child) {
      parent.appendChild(goog.isString(child) ?
          doc.createTextNode(child) : child);
    }
  }

  for (var i = startIndex; i < args.length; i++) {
    var arg = args[i];
    // TODO(attila): Fix isArrayLike to return false for a text node.
    if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) {
      // If the argument is a node list, not a real array, use a clone,
      // because forEach can't be used to mutate a NodeList.
      goog.array.forEach(goog.dom.isNodeList(arg) ?
          goog.array.toArray(arg) : arg,
          childHandler);
    } else {
      childHandler(arg);
    }
  }
};


/**
 * Alias for {@code createDom}.
 * @param {string} tagName Tag to create.
 * @param {(string|Object)=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...(Object|string|Array|NodeList)} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array, its
 *     children will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 * @deprecated Use {@link goog.dom.createDom} instead.
 */
goog.dom.$dom = goog.dom.createDom;


/**
 * Creates a new element.
 * @param {string} name Tag name.
 * @return {!Element} The new element.
 */
goog.dom.createElement = function(name) {
  return document.createElement(name);
};


/**
 * Creates a new text node.
 * @param {number|string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.createTextNode = function(content) {
  return document.createTextNode(String(content));
};


/**
 * Create a table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean=} opt_fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 */
goog.dom.createTable = function(rows, columns, opt_fillWithNbsp) {
  return goog.dom.createTable_(document, rows, columns, !!opt_fillWithNbsp);
};


/**
 * Create a table.
 * @param {!Document} doc Document object to use to create the table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean} fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 * @private
 */
goog.dom.createTable_ = function(doc, rows, columns, fillWithNbsp) {
  var rowHtml = ['<tr>'];
  for (var i = 0; i < columns; i++) {
    rowHtml.push(fillWithNbsp ? '<td>&nbsp;</td>' : '<td></td>');
  }
  rowHtml.push('</tr>');
  rowHtml = rowHtml.join('');
  var totalHtml = ['<table>'];
  for (i = 0; i < rows; i++) {
    totalHtml.push(rowHtml);
  }
  totalHtml.push('</table>');

  var elem = doc.createElement(goog.dom.TagName.DIV);
  elem.innerHTML = totalHtml.join('');
  return /** @type {!Element} */ (elem.removeChild(elem.firstChild));
};


/**
 * Converts an HTML string into a document fragment. The string must be
 * sanitized in order to avoid cross-site scripting. For example
 * {@code goog.dom.htmlToDocumentFragment('&lt;img src=x onerror=alert(0)&gt;')}
 * triggers an alert in all browsers, even if the returned document fragment
 * is thrown away immediately.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting document fragment.
 */
goog.dom.htmlToDocumentFragment = function(htmlString) {
  return goog.dom.htmlToDocumentFragment_(document, htmlString);
};


/**
 * Helper for {@code htmlToDocumentFragment}.
 *
 * @param {!Document} doc The document.
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting document fragment.
 * @private
 */
goog.dom.htmlToDocumentFragment_ = function(doc, htmlString) {
  var tempDiv = doc.createElement('div');
  if (goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT) {
    tempDiv.innerHTML = '<br>' + htmlString;
    tempDiv.removeChild(tempDiv.firstChild);
  } else {
    tempDiv.innerHTML = htmlString;
  }
  if (tempDiv.childNodes.length == 1) {
    return /** @type {!Node} */ (tempDiv.removeChild(tempDiv.firstChild));
  } else {
    var fragment = doc.createDocumentFragment();
    while (tempDiv.firstChild) {
      fragment.appendChild(tempDiv.firstChild);
    }
    return fragment;
  }
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @return {boolean} True if in CSS1-compatible mode.
 */
goog.dom.isCss1CompatMode = function() {
  return goog.dom.isCss1CompatMode_(document);
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @param {Document} doc The document to check.
 * @return {boolean} True if in CSS1-compatible mode.
 * @private
 */
goog.dom.isCss1CompatMode_ = function(doc) {
  if (goog.dom.COMPAT_MODE_KNOWN_) {
    return goog.dom.ASSUME_STANDARDS_MODE;
  }

  return doc.compatMode == 'CSS1Compat';
};


/**
 * Determines if the given node can contain children, intended to be used for
 * HTML generation.
 *
 * IE natively supports node.canHaveChildren but has inconsistent behavior.
 * Prior to IE8 the base tag allows children and in IE9 all nodes return true
 * for canHaveChildren.
 *
 * In practice all non-IE browsers allow you to add children to any node, but
 * the behavior is inconsistent:
 *
 * <pre>
 *   var a = document.createElement('br');
 *   a.appendChild(document.createTextNode('foo'));
 *   a.appendChild(document.createTextNode('bar'));
 *   console.log(a.childNodes.length);  // 2
 *   console.log(a.innerHTML);  // Chrome: "", IE9: "foobar", FF3.5: "foobar"
 * </pre>
 *
 * For more information, see:
 * http://dev.w3.org/html5/markup/syntax.html#syntax-elements
 *
 * TODO(pupius): Rename shouldAllowChildren() ?
 *
 * @param {Node} node The node to check.
 * @return {boolean} Whether the node can contain children.
 */
goog.dom.canHaveChildren = function(node) {
  if (node.nodeType != goog.dom.NodeType.ELEMENT) {
    return false;
  }
  switch (node.tagName) {
    case goog.dom.TagName.APPLET:
    case goog.dom.TagName.AREA:
    case goog.dom.TagName.BASE:
    case goog.dom.TagName.BR:
    case goog.dom.TagName.COL:
    case goog.dom.TagName.COMMAND:
    case goog.dom.TagName.EMBED:
    case goog.dom.TagName.FRAME:
    case goog.dom.TagName.HR:
    case goog.dom.TagName.IMG:
    case goog.dom.TagName.INPUT:
    case goog.dom.TagName.IFRAME:
    case goog.dom.TagName.ISINDEX:
    case goog.dom.TagName.KEYGEN:
    case goog.dom.TagName.LINK:
    case goog.dom.TagName.NOFRAMES:
    case goog.dom.TagName.NOSCRIPT:
    case goog.dom.TagName.META:
    case goog.dom.TagName.OBJECT:
    case goog.dom.TagName.PARAM:
    case goog.dom.TagName.SCRIPT:
    case goog.dom.TagName.SOURCE:
    case goog.dom.TagName.STYLE:
    case goog.dom.TagName.TRACK:
    case goog.dom.TagName.WBR:
      return false;
  }
  return true;
};


/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.appendChild = function(parent, child) {
  parent.appendChild(child);
};


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.append = function(parent, var_args) {
  goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1);
};


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 */
goog.dom.removeChildren = function(node) {
  // Note: Iterations over live collections can be slow, this is the fastest
  // we could find. The double parenthesis are used to prevent JsCompiler and
  // strict warnings.
  var child;
  while ((child = node.firstChild)) {
    node.removeChild(child);
  }
};


/**
 * Inserts a new node before an existing reference node (i.e. as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.insertSiblingBefore = function(newNode, refNode) {
  if (refNode.parentNode) {
    refNode.parentNode.insertBefore(newNode, refNode);
  }
};


/**
 * Inserts a new node after an existing reference node (i.e. as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 */
goog.dom.insertSiblingAfter = function(newNode, refNode) {
  if (refNode.parentNode) {
    refNode.parentNode.insertBefore(newNode, refNode.nextSibling);
  }
};


/**
 * Insert a child at a given index. If index is larger than the number of child
 * nodes that the parent currently has, the node is inserted as the last child
 * node.
 * @param {Element} parent The element into which to insert the child.
 * @param {Node} child The element to insert.
 * @param {number} index The index at which to insert the new child node. Must
 *     not be negative.
 */
goog.dom.insertChildAt = function(parent, child, index) {
  // Note that if the second argument is null, insertBefore
  // will append the child at the end of the list of children.
  parent.insertBefore(child, parent.childNodes[index] || null);
};


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.removeNode = function(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
};


/**
 * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.replaceNode = function(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
};


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * Does nothing if the element is not in the document.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children; or undefined, if the element was not in the document
 *     to begin with.
 */
goog.dom.flattenElement = function(element) {
  var child, parent = element.parentNode;
  if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT) {
    // Use IE DOM method (supported by Opera too) if available
    if (element.removeNode) {
      return /** @type {Element} */ (element.removeNode(false));
    } else {
      // Move all children of the original node up one level.
      while ((child = element.firstChild)) {
        parent.insertBefore(child, element);
      }

      // Detach the original element.
      return /** @type {Element} */ (goog.dom.removeNode(element));
    }
  }
};


/**
 * Returns an array containing just the element children of the given element.
 * @param {Element} element The element whose element children we want.
 * @return {!(Array|NodeList)} An array or array-like list of just the element
 *     children of the given element.
 */
goog.dom.getChildren = function(element) {
  // We check if the children attribute is supported for child elements
  // since IE8 misuses the attribute by also including comments.
  if (goog.dom.BrowserFeature.CAN_USE_CHILDREN_ATTRIBUTE &&
      element.children != undefined) {
    return element.children;
  }
  // Fall back to manually filtering the element's child nodes.
  return goog.array.filter(element.childNodes, function(node) {
    return node.nodeType == goog.dom.NodeType.ELEMENT;
  });
};


/**
 * Returns the first child node that is an element.
 * @param {Node} node The node to get the first child element of.
 * @return {Element} The first child node of {@code node} that is an element.
 */
goog.dom.getFirstElementChild = function(node) {
  if (node.firstElementChild != undefined) {
    return /** @type {Element} */(node).firstElementChild;
  }
  return goog.dom.getNextElementNode_(node.firstChild, true);
};


/**
 * Returns the last child node that is an element.
 * @param {Node} node The node to get the last child element of.
 * @return {Element} The last child node of {@code node} that is an element.
 */
goog.dom.getLastElementChild = function(node) {
  if (node.lastElementChild != undefined) {
    return /** @type {Element} */(node).lastElementChild;
  }
  return goog.dom.getNextElementNode_(node.lastChild, false);
};


/**
 * Returns the first next sibling that is an element.
 * @param {Node} node The node to get the next sibling element of.
 * @return {Element} The next sibling of {@code node} that is an element.
 */
goog.dom.getNextElementSibling = function(node) {
  if (node.nextElementSibling != undefined) {
    return /** @type {Element} */(node).nextElementSibling;
  }
  return goog.dom.getNextElementNode_(node.nextSibling, true);
};


/**
 * Returns the first previous sibling that is an element.
 * @param {Node} node The node to get the previous sibling element of.
 * @return {Element} The first previous sibling of {@code node} that is
 *     an element.
 */
goog.dom.getPreviousElementSibling = function(node) {
  if (node.previousElementSibling != undefined) {
    return /** @type {Element} */(node).previousElementSibling;
  }
  return goog.dom.getNextElementNode_(node.previousSibling, false);
};


/**
 * Returns the first node that is an element in the specified direction,
 * starting with {@code node}.
 * @param {Node} node The node to get the next element from.
 * @param {boolean} forward Whether to look forwards or backwards.
 * @return {Element} The first element.
 * @private
 */
goog.dom.getNextElementNode_ = function(node, forward) {
  while (node && node.nodeType != goog.dom.NodeType.ELEMENT) {
    node = forward ? node.nextSibling : node.previousSibling;
  }

  return /** @type {Element} */ (node);
};


/**
 * Returns the next node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The next node in the DOM tree, or null if this was the last
 *     node.
 */
goog.dom.getNextNode = function(node) {
  if (!node) {
    return null;
  }

  if (node.firstChild) {
    return node.firstChild;
  }

  while (node && !node.nextSibling) {
    node = node.parentNode;
  }

  return node ? node.nextSibling : null;
};


/**
 * Returns the previous node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The previous node in the DOM tree, or null if this was the
 *     first node.
 */
goog.dom.getPreviousNode = function(node) {
  if (!node) {
    return null;
  }

  if (!node.previousSibling) {
    return node.parentNode;
  }

  node = node.previousSibling;
  while (node && node.lastChild) {
    node = node.lastChild;
  }

  return node;
};


/**
 * Whether the object looks like a DOM node.
 * @param {?} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.isNodeLike = function(obj) {
  return goog.isObject(obj) && obj.nodeType > 0;
};


/**
 * Whether the object looks like an Element.
 * @param {?} obj The object being tested for Element likeness.
 * @return {boolean} Whether the object looks like an Element.
 */
goog.dom.isElement = function(obj) {
  return goog.isObject(obj) && obj.nodeType == goog.dom.NodeType.ELEMENT;
};


/**
 * Returns true if the specified value is a Window object. This includes the
 * global window for HTML pages, and iframe windows.
 * @param {?} obj Variable to test.
 * @return {boolean} Whether the variable is a window.
 */
goog.dom.isWindow = function(obj) {
  return goog.isObject(obj) && obj['window'] == obj;
};


/**
 * Returns an element's parent, if it's an Element.
 * @param {Element} element The DOM element.
 * @return {Element} The parent, or null if not an Element.
 */
goog.dom.getParentElement = function(element) {
  if (goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY) {
    var isIe9 = goog.userAgent.IE &&
        goog.userAgent.isVersionOrHigher('9') &&
        !goog.userAgent.isVersionOrHigher('10');
    // SVG elements in IE9 can't use the parentElement property.
    // goog.global['SVGElement'] is not defined in IE9 quirks mode.
    if (!(isIe9 && goog.global['SVGElement'] &&
        element instanceof goog.global['SVGElement'])) {
      return element.parentElement;
    }
  }
  var parent = element.parentNode;
  return goog.dom.isElement(parent) ? /** @type {!Element} */ (parent) : null;
};


/**
 * Whether a node contains another node.
 * @param {Node} parent The node that should contain the other node.
 * @param {Node} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendent node.
 */
goog.dom.contains = function(parent, descendant) {
  // We use browser specific methods for this if available since it is faster
  // that way.

  // IE DOM
  if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) {
    return parent == descendant || parent.contains(descendant);
  }

  // W3C DOM Level 3
  if (typeof parent.compareDocumentPosition != 'undefined') {
    return parent == descendant ||
        Boolean(parent.compareDocumentPosition(descendant) & 16);
  }

  // W3C DOM Level 1
  while (descendant && parent != descendant) {
    descendant = descendant.parentNode;
  }
  return descendant == parent;
};


/**
 * Compares the document order of two nodes, returning 0 if they are the same
 * node, a negative number if node1 is before node2, and a positive number if
 * node2 is before node1.  Note that we compare the order the tags appear in the
 * document so in the tree <b><i>text</i></b> the B node is considered to be
 * before the I node.
 *
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} 0 if the nodes are the same node, a negative number if node1
 *     is before node2, and a positive number if node2 is before node1.
 */
goog.dom.compareNodeOrder = function(node1, node2) {
  // Fall out quickly for equality.
  if (node1 == node2) {
    return 0;
  }

  // Use compareDocumentPosition where available
  if (node1.compareDocumentPosition) {
    // 4 is the bitmask for FOLLOWS.
    return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;
  }

  // Special case for document nodes on IE 7 and 8.
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
    if (node1.nodeType == goog.dom.NodeType.DOCUMENT) {
      return -1;
    }
    if (node2.nodeType == goog.dom.NodeType.DOCUMENT) {
      return 1;
    }
  }

  // Process in IE using sourceIndex - we check to see if the first node has
  // a source index or if its parent has one.
  if ('sourceIndex' in node1 ||
      (node1.parentNode && 'sourceIndex' in node1.parentNode)) {
    var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;
    var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;

    if (isElement1 && isElement2) {
      return node1.sourceIndex - node2.sourceIndex;
    } else {
      var parent1 = node1.parentNode;
      var parent2 = node2.parentNode;

      if (parent1 == parent2) {
        return goog.dom.compareSiblingOrder_(node1, node2);
      }

      if (!isElement1 && goog.dom.contains(parent1, node2)) {
        return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);
      }


      if (!isElement2 && goog.dom.contains(parent2, node1)) {
        return goog.dom.compareParentsDescendantNodeIe_(node2, node1);
      }

      return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) -
             (isElement2 ? node2.sourceIndex : parent2.sourceIndex);
    }
  }

  // For Safari, we compare ranges.
  var doc = goog.dom.getOwnerDocument(node1);

  var range1, range2;
  range1 = doc.createRange();
  range1.selectNode(node1);
  range1.collapse(true);

  range2 = doc.createRange();
  range2.selectNode(node2);
  range2.collapse(true);

  return range1.compareBoundaryPoints(goog.global['Range'].START_TO_END,
      range2);
};


/**
 * Utility function to compare the position of two nodes, when
 * {@code textNode}'s parent is an ancestor of {@code node}.  If this entry
 * condition is not met, this function will attempt to reference a null object.
 * @param {Node} textNode The textNode to compare.
 * @param {Node} node The node to compare.
 * @return {number} -1 if node is before textNode, +1 otherwise.
 * @private
 */
goog.dom.compareParentsDescendantNodeIe_ = function(textNode, node) {
  var parent = textNode.parentNode;
  if (parent == node) {
    // If textNode is a child of node, then node comes first.
    return -1;
  }
  var sibling = node;
  while (sibling.parentNode != parent) {
    sibling = sibling.parentNode;
  }
  return goog.dom.compareSiblingOrder_(sibling, textNode);
};


/**
 * Utility function to compare the position of two nodes known to be non-equal
 * siblings.
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} -1 if node1 is before node2, +1 otherwise.
 * @private
 */
goog.dom.compareSiblingOrder_ = function(node1, node2) {
  var s = node2;
  while ((s = s.previousSibling)) {
    if (s == node1) {
      // We just found node1 before node2.
      return -1;
    }
  }

  // Since we didn't find it, node1 must be after node2.
  return 1;
};


/**
 * Find the deepest common ancestor of the given nodes.
 * @param {...Node} var_args The nodes to find a common ancestor of.
 * @return {Node} The common ancestor of the nodes, or null if there is none.
 *     null will only be returned if two or more of the nodes are from different
 *     documents.
 */
goog.dom.findCommonAncestor = function(var_args) {
  var i, count = arguments.length;
  if (!count) {
    return null;
  } else if (count == 1) {
    return arguments[0];
  }

  var paths = [];
  var minLength = Infinity;
  for (i = 0; i < count; i++) {
    // Compute the list of ancestors.
    var ancestors = [];
    var node = arguments[i];
    while (node) {
      ancestors.unshift(node);
      node = node.parentNode;
    }

    // Save the list for comparison.
    paths.push(ancestors);
    minLength = Math.min(minLength, ancestors.length);
  }
  var output = null;
  for (i = 0; i < minLength; i++) {
    var first = paths[0][i];
    for (var j = 1; j < count; j++) {
      if (first != paths[j][i]) {
        return output;
      }
    }
    output = first;
  }
  return output;
};


/**
 * Returns the owner document for a node.
 * @param {Node|Window} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.getOwnerDocument = function(node) {
  // TODO(arv): Remove IE5 code.
  // IE5 uses document instead of ownerDocument
  return /** @type {!Document} */ (
      node.nodeType == goog.dom.NodeType.DOCUMENT ? node :
      node.ownerDocument || node.document);
};


/**
 * Cross-browser function for getting the document element of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {!Document} The frame content document.
 */
goog.dom.getFrameContentDocument = function(frame) {
  var doc = frame.contentDocument || frame.contentWindow.document;
  return doc;
};


/**
 * Cross-browser function for getting the window of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {Window} The window associated with the given frame.
 */
goog.dom.getFrameContentWindow = function(frame) {
  return frame.contentWindow ||
      goog.dom.getWindow(goog.dom.getFrameContentDocument(frame));
};


/**
 * Sets the text content of a node, with cross-browser support.
 * @param {Node} node The node to change the text content of.
 * @param {string|number} text The value that should replace the node's content.
 */
goog.dom.setTextContent = function(node, text) {
  goog.asserts.assert(node != null,
      'goog.dom.setTextContent expects a non-null value for node');

  if ('textContent' in node) {
    node.textContent = text;
  } else if (node.nodeType == goog.dom.NodeType.TEXT) {
    node.data = text;
  } else if (node.firstChild &&
             node.firstChild.nodeType == goog.dom.NodeType.TEXT) {
    // If the first child is a text node we just change its data and remove the
    // rest of the children.
    while (node.lastChild != node.firstChild) {
      node.removeChild(node.lastChild);
    }
    node.firstChild.data = text;
  } else {
    goog.dom.removeChildren(node);
    var doc = goog.dom.getOwnerDocument(node);
    node.appendChild(doc.createTextNode(String(text)));
  }
};


/**
 * Gets the outerHTML of a node, which islike innerHTML, except that it
 * actually contains the HTML of the node itself.
 * @param {Element} element The element to get the HTML of.
 * @return {string} The outerHTML of the given element.
 */
goog.dom.getOuterHtml = function(element) {
  // IE, Opera and WebKit all have outerHTML.
  if ('outerHTML' in element) {
    return element.outerHTML;
  } else {
    var doc = goog.dom.getOwnerDocument(element);
    var div = doc.createElement('div');
    div.appendChild(element.cloneNode(true));
    return div.innerHTML;
  }
};


/**
 * Finds the first descendant node that matches the filter function, using
 * a depth first search. This function offers the most general purpose way
 * of finding a matching element. You may also wish to consider
 * {@code goog.dom.query} which can express many matching criteria using
 * CSS selector expressions. These expressions often result in a more
 * compact representation of the desired result.
 * @see goog.dom.query
 *
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Node|undefined} The found node or undefined if none is found.
 */
goog.dom.findNode = function(root, p) {
  var rv = [];
  var found = goog.dom.findNodes_(root, p, rv, true);
  return found ? rv[0] : undefined;
};


/**
 * Finds all the descendant nodes that match the filter function, using a
 * a depth first search. This function offers the most general-purpose way
 * of finding a set of matching elements. You may also wish to consider
 * {@code goog.dom.query} which can express many matching criteria using
 * CSS selector expressions. These expressions often result in a more
 * compact representation of the desired result.

 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {!Array.<!Node>} The found nodes or an empty array if none are found.
 */
goog.dom.findNodes = function(root, p) {
  var rv = [];
  goog.dom.findNodes_(root, p, rv, false);
  return rv;
};


/**
 * Finds the first or all the descendant nodes that match the filter function,
 * using a depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @param {!Array.<!Node>} rv The found nodes are added to this array.
 * @param {boolean} findOne If true we exit after the first found node.
 * @return {boolean} Whether the search is complete or not. True in case findOne
 *     is true and the node is found. False otherwise.
 * @private
 */
goog.dom.findNodes_ = function(root, p, rv, findOne) {
  if (root != null) {
    var child = root.firstChild;
    while (child) {
      if (p(child)) {
        rv.push(child);
        if (findOne) {
          return true;
        }
      }
      if (goog.dom.findNodes_(child, p, rv, findOne)) {
        return true;
      }
      child = child.nextSibling;
    }
  }
  return false;
};


/**
 * Map of tags whose content to ignore when calculating text length.
 * @type {Object}
 * @private
 */
goog.dom.TAGS_TO_IGNORE_ = {
  'SCRIPT': 1,
  'STYLE': 1,
  'HEAD': 1,
  'IFRAME': 1,
  'OBJECT': 1
};


/**
 * Map of tags which have predefined values with regard to whitespace.
 * @type {Object}
 * @private
 */
goog.dom.PREDEFINED_TAG_VALUES_ = {'IMG': ' ', 'BR': '\n'};


/**
 * Returns true if the element has a tab index that allows it to receive
 * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements
 * natively support keyboard focus, even if they have no tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a tab index that allows keyboard
 *     focus.
 * @see http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
 */
goog.dom.isFocusableTabIndex = function(element) {
  return goog.dom.hasSpecifiedTabIndex_(element) &&
         goog.dom.isTabIndexFocusable_(element);
};


/**
 * Enables or disables keyboard focus support on the element via its tab index.
 * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
 * (or elements that natively support keyboard focus, like form elements) can
 * receive keyboard focus.  See http://go/tabindex for more info.
 * @param {Element} element Element whose tab index is to be changed.
 * @param {boolean} enable Whether to set or remove a tab index on the element
 *     that supports keyboard focus.
 */
goog.dom.setFocusableTabIndex = function(element, enable) {
  if (enable) {
    element.tabIndex = 0;
  } else {
    // Set tabIndex to -1 first, then remove it. This is a workaround for
    // Safari (confirmed in version 4 on Windows). When removing the attribute
    // without setting it to -1 first, the element remains keyboard focusable
    // despite not having a tabIndex attribute anymore.
    element.tabIndex = -1;
    element.removeAttribute('tabIndex'); // Must be camelCase!
  }
};


/**
 * Returns true if the element can be focused, i.e. it has a tab index that
 * allows it to receive keyboard focus (tabIndex >= 0), or it is an element
 * that natively supports keyboard focus.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element allows keyboard focus.
 */
goog.dom.isFocusable = function(element) {
  var focusable;
  // Some elements can have unspecified tab index and still receive focus.
  if (goog.dom.nativelySupportsFocus_(element)) {
    // Make sure the element is not disabled ...
    focusable = !element.disabled &&
        // ... and if a tab index is specified, it allows focus.
        (!goog.dom.hasSpecifiedTabIndex_(element) ||
         goog.dom.isTabIndexFocusable_(element));
  } else {
    focusable = goog.dom.isFocusableTabIndex(element);
  }

  // IE requires elements to be visible in order to focus them.
  return focusable && goog.userAgent.IE ?
             goog.dom.hasNonZeroBoundingRect_(element) : focusable;
};


/**
 * Returns true if the element has a specified tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a specified tab index.
 * @private
 */
goog.dom.hasSpecifiedTabIndex_ = function(element) {
  // IE returns 0 for an unset tabIndex, so we must use getAttributeNode(),
  // which returns an object with a 'specified' property if tabIndex is
  // specified.  This works on other browsers, too.
  var attrNode = element.getAttributeNode('tabindex'); // Must be lowercase!
  return goog.isDefAndNotNull(attrNode) && attrNode.specified;
};


/**
 * Returns true if the element's tab index allows the element to be focused.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element's tab index allows focus.
 * @private
 */
goog.dom.isTabIndexFocusable_ = function(element) {
  var index = element.tabIndex;
  // NOTE: IE9 puts tabIndex in 16-bit int, e.g. -2 is 65534.
  return goog.isNumber(index) && index >= 0 && index < 32768;
};


/**
 * Returns true if the element is focusable even when tabIndex is not set.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element natively supports focus.
 * @private
 */
goog.dom.nativelySupportsFocus_ = function(element) {
  return element.tagName == goog.dom.TagName.A ||
         element.tagName == goog.dom.TagName.INPUT ||
         element.tagName == goog.dom.TagName.TEXTAREA ||
         element.tagName == goog.dom.TagName.SELECT ||
         element.tagName == goog.dom.TagName.BUTTON;
};


/**
 * Returns true if the element has a bounding rectangle that would be visible
 * (i.e. its width and height are greater than zero).
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a non-zero bounding rectangle.
 * @private
 */
goog.dom.hasNonZeroBoundingRect_ = function(element) {
  var rect = goog.isFunction(element['getBoundingClientRect']) ?
      element.getBoundingClientRect() :
      {'height': element.offsetHeight, 'width': element.offsetWidth};
  return goog.isDefAndNotNull(rect) && rect.height > 0 && rect.width > 0;
};


/**
 * Returns the text content of the current node, without markup and invisible
 * symbols. New lines are stripped and whitespace is collapsed,
 * such that each character would be visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.getTextContent = function(node) {
  var textContent;
  // Note(arv): IE9, Opera, and Safari 3 support innerText but they include
  // text nodes in script tags. So we revert to use a user agent test here.
  if (goog.dom.BrowserFeature.CAN_USE_INNER_TEXT && ('innerText' in node)) {
    textContent = goog.string.canonicalizeNewlines(node.innerText);
    // Unfortunately .innerText() returns text with &shy; symbols
    // We need to filter it out and then remove duplicate whitespaces
  } else {
    var buf = [];
    goog.dom.getTextContent_(node, buf, true);
    textContent = buf.join('');
  }

  // Strip &shy; entities. goog.format.insertWordBreaks inserts them in Opera.
  textContent = textContent.replace(/ \xAD /g, ' ').replace(/\xAD/g, '');
  // Strip &#8203; entities. goog.format.insertWordBreaks inserts them in IE8.
  textContent = textContent.replace(/\u200B/g, '');

  // Skip this replacement on old browsers with working innerText, which
  // automatically turns &nbsp; into ' ' and / +/ into ' ' when reading
  // innerText.
  if (!goog.dom.BrowserFeature.CAN_USE_INNER_TEXT) {
    textContent = textContent.replace(/ +/g, ' ');
  }
  if (textContent != ' ') {
    textContent = textContent.replace(/^\s*/, '');
  }

  return textContent;
};


/**
 * Returns the text content of the current node, without markup.
 *
 * Unlike {@code getTextContent} this method does not collapse whitespaces
 * or normalize lines breaks.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The raw text content.
 */
goog.dom.getRawTextContent = function(node) {
  var buf = [];
  goog.dom.getTextContent_(node, buf, false);

  return buf.join('');
};


/**
 * Recursive support function for text content retrieval.
 *
 * @param {Node} node The node from which we are getting content.
 * @param {Array} buf string buffer.
 * @param {boolean} normalizeWhitespace Whether to normalize whitespace.
 * @private
 */
goog.dom.getTextContent_ = function(node, buf, normalizeWhitespace) {
  if (node.nodeName in goog.dom.TAGS_TO_IGNORE_) {
    // ignore certain tags
  } else if (node.nodeType == goog.dom.NodeType.TEXT) {
    if (normalizeWhitespace) {
      buf.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      buf.push(node.nodeValue);
    }
  } else if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
    buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);
  } else {
    var child = node.firstChild;
    while (child) {
      goog.dom.getTextContent_(child, buf, normalizeWhitespace);
      child = child.nextSibling;
    }
  }
};


/**
 * Returns the text length of the text contained in a node, without markup. This
 * is equivalent to the selection length if the node was selected, or the number
 * of cursor movements to traverse the node. Images & BRs take one space.  New
 * lines are ignored.
 *
 * @param {Node} node The node whose text content length is being calculated.
 * @return {number} The length of {@code node}'s text content.
 */
goog.dom.getNodeTextLength = function(node) {
  return goog.dom.getTextContent(node).length;
};


/**
 * Returns the text offset of a node relative to one of its ancestors. The text
 * length is the same as the length calculated by goog.dom.getNodeTextLength.
 *
 * @param {Node} node The node whose offset is being calculated.
 * @param {Node=} opt_offsetParent The node relative to which the offset will
 *     be calculated. Defaults to the node's owner document's body.
 * @return {number} The text offset.
 */
goog.dom.getNodeTextOffset = function(node, opt_offsetParent) {
  var root = opt_offsetParent || goog.dom.getOwnerDocument(node).body;
  var buf = [];
  while (node && node != root) {
    var cur = node;
    while ((cur = cur.previousSibling)) {
      buf.unshift(goog.dom.getTextContent(cur));
    }
    node = node.parentNode;
  }
  // Trim left to deal with FF cases when there might be line breaks and empty
  // nodes at the front of the text
  return goog.string.trimLeft(buf.join('')).replace(/ +/g, ' ').length;
};


/**
 * Returns the node at a given offset in a parent node.  If an object is
 * provided for the optional third parameter, the node and the remainder of the
 * offset will stored as properties of this object.
 * @param {Node} parent The parent node.
 * @param {number} offset The offset into the parent node.
 * @param {Object=} opt_result Object to be used to store the return value. The
 *     return value will be stored in the form {node: Node, remainder: number}
 *     if this object is provided.
 * @return {Node} The node at the given offset.
 */
goog.dom.getNodeAtOffset = function(parent, offset, opt_result) {
  var stack = [parent], pos = 0, cur = null;
  while (stack.length > 0 && pos < offset) {
    cur = stack.pop();
    if (cur.nodeName in goog.dom.TAGS_TO_IGNORE_) {
      // ignore certain tags
    } else if (cur.nodeType == goog.dom.NodeType.TEXT) {
      var text = cur.nodeValue.replace(/(\r\n|\r|\n)/g, '').replace(/ +/g, ' ');
      pos += text.length;
    } else if (cur.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
      pos += goog.dom.PREDEFINED_TAG_VALUES_[cur.nodeName].length;
    } else {
      for (var i = cur.childNodes.length - 1; i >= 0; i--) {
        stack.push(cur.childNodes[i]);
      }
    }
  }
  if (goog.isObject(opt_result)) {
    opt_result.remainder = cur ? cur.nodeValue.length + offset - pos - 1 : 0;
    opt_result.node = cur;
  }

  return cur;
};


/**
 * Returns true if the object is a {@code NodeList}.  To qualify as a NodeList,
 * the object must have a numeric length property and an item function (which
 * has type 'string' on IE for some reason).
 * @param {Object} val Object to test.
 * @return {boolean} Whether the object is a NodeList.
 */
goog.dom.isNodeList = function(val) {
  // TODO(attila): Now the isNodeList is part of goog.dom we can use
  // goog.userAgent to make this simpler.
  // A NodeList must have a length property of type 'number' on all platforms.
  if (val && typeof val.length == 'number') {
    // A NodeList is an object everywhere except Safari, where it's a function.
    if (goog.isObject(val)) {
      // A NodeList must have an item function (on non-IE platforms) or an item
      // property of type 'string' (on IE).
      return typeof val.item == 'function' || typeof val.item == 'string';
    } else if (goog.isFunction(val)) {
      // On Safari, a NodeList is a function with an item property that is also
      // a function.
      return typeof val.item == 'function';
    }
  }

  // Not a NodeList.
  return false;
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * tag name and/or class name. If the passed element matches the specified
 * criteria, the element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {?(goog.dom.TagName|string)=} opt_tag The tag name to match (or
 *     null/undefined to match only based on class name).
 * @param {?string=} opt_class The class name to match (or null/undefined to
 *     match only based on tag name).
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if no match is found.
 */
goog.dom.getAncestorByTagNameAndClass = function(element, opt_tag, opt_class) {
  if (!opt_tag && !opt_class) {
    return null;
  }
  var tagName = opt_tag ? opt_tag.toUpperCase() : null;
  return /** @type {Element} */ (goog.dom.getAncestor(element,
      function(node) {
        return (!tagName || node.nodeName == tagName) &&
               (!opt_class || goog.dom.classes.has(node, opt_class));
      }, true));
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * class name. If the passed element matches the specified criteria, the
 * element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {string} className The class name to match.
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if none match.
 */
goog.dom.getAncestorByClass = function(element, className) {
  return goog.dom.getAncestorByTagNameAndClass(element, null, className);
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that passes the
 * matcher function.
 * @param {Node} element The DOM node to start with.
 * @param {function(Node) : boolean} matcher A function that returns true if the
 *     passed node matches the desired criteria.
 * @param {boolean=} opt_includeNode If true, the node itself is included in
 *     the search (the first call to the matcher will pass startElement as
 *     the node to test).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Node} DOM node that matched the matcher, or null if there was
 *     no match.
 */
goog.dom.getAncestor = function(
    element, matcher, opt_includeNode, opt_maxSearchSteps) {
  if (!opt_includeNode) {
    element = element.parentNode;
  }
  var ignoreSearchSteps = opt_maxSearchSteps == null;
  var steps = 0;
  while (element && (ignoreSearchSteps || steps <= opt_maxSearchSteps)) {
    if (matcher(element)) {
      return element;
    }
    element = element.parentNode;
    steps++;
  }
  // Reached the root of the DOM without a match
  return null;
};


/**
 * Determines the active element in the given document.
 * @param {Document} doc The document to look in.
 * @return {Element} The active element.
 */
goog.dom.getActiveElement = function(doc) {
  try {
    return doc && doc.activeElement;
  } catch (e) {
    // NOTE(nicksantos): Sometimes, evaluating document.activeElement in IE
    // throws an exception. I'm not 100% sure why, but I suspect it chokes
    // on document.activeElement if the activeElement has been recently
    // removed from the DOM by a JS operation.
    //
    // We assume that an exception here simply means
    // "there is no active element."
  }

  return null;
};


/**
 * @private {number} Cached version of the devicePixelRatio.
 */
goog.dom.devicePixelRatio_;


/**
 * Gives the devicePixelRatio, or attempts to determine if not present.
 *
 * By default, this is the same value given by window.devicePixelRatio. If
 * devicePixelRatio is not defined, the ratio is calculated with
 * window.matchMedia, if present. Otherwise, gives 1.0.
 *
 * This function is cached so that the pixel ratio is calculated only once
 * and only calculated when first requested.
 *
 * @return {number} The number of actual pixels per virtual pixel.
 */
goog.dom.getPixelRatio = goog.functions.cacheReturnValue(function() {
  var win = goog.dom.getWindow();

  // devicePixelRatio does not work on Mobile firefox.
  // TODO(ecattell): Enable this check on a known working mobile Gecko version.
  // Filed a bug: https://bugzilla.mozilla.org/show_bug.cgi?id=896804
  var isFirefoxMobile = goog.userAgent.GECKO && goog.userAgent.MOBILE;

  if (goog.isDef(win.devicePixelRatio) && !isFirefoxMobile) {
    return win.devicePixelRatio;
  } else if (win.matchMedia) {
    return goog.dom.matchesPixelRatio_(.75) ||
           goog.dom.matchesPixelRatio_(1.5) ||
           goog.dom.matchesPixelRatio_(2) ||
           goog.dom.matchesPixelRatio_(3) || 1;
  }
  return 1;
});


/**
 * Calculates a mediaQuery to check if the current device supports the
 * given actual to virtual pixel ratio.
 * @param {number} pixelRatio The ratio of actual pixels to virtual pixels.
 * @return {number} pixelRatio if applicable, otherwise 0.
 * @private
 */
goog.dom.matchesPixelRatio_ = function(pixelRatio) {
  var win = goog.dom.getWindow();
  var query = ('(-webkit-min-device-pixel-ratio: ' + pixelRatio + '),' +
               '(min--moz-device-pixel-ratio: ' + pixelRatio + '),' +
               '(min-resolution: ' + pixelRatio + 'dppx)');
  return win.matchMedia(query).matches ? pixelRatio : 0;
};



/**
 * Create an instance of a DOM helper with a new document object.
 * @param {Document=} opt_document Document object to associate with this
 *     DOM helper.
 * @constructor
 */
goog.dom.DomHelper = function(opt_document) {
  /**
   * Reference to the document object to use
   * @type {!Document}
   * @private
   */
  this.document_ = opt_document || goog.global.document || document;
};


/**
 * Gets the dom helper object for the document where the element resides.
 * @param {Node=} opt_node If present, gets the DomHelper for this node.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.DomHelper.prototype.getDomHelper = goog.dom.getDomHelper;


/**
 * Sets the document object.
 * @param {!Document} document Document object.
 */
goog.dom.DomHelper.prototype.setDocument = function(document) {
  this.document_ = document;
};


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.DomHelper.prototype.getDocument = function() {
  return this.document_;
};


/**
 * Alias for {@code getElementById}. If a DOM node is passed in then we just
 * return that.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.DomHelper.prototype.getElement = function(element) {
  return goog.dom.getElementHelper_(this.document_, element);
};


/**
 * Gets an element by id, asserting that the element is found.
 *
 * This is used when an element is expected to exist, and should fail with
 * an assertion error if it does not (if assertions are enabled).
 *
 * @param {string} id Element ID.
 * @return {!Element} The element with the given ID, if it exists.
 */
goog.dom.DomHelper.prototype.getRequiredElement = function(id) {
  return goog.dom.getRequiredElementHelper_(this.document_, id);
};


/**
 * Alias for {@code getElement}.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.DomHelper.prototype.getElement} instead.
 */
goog.dom.DomHelper.prototype.$ = goog.dom.DomHelper.prototype.getElement;


/**
 * Looks up elements by both tag and class name, using browser native functions
 * ({@code querySelectorAll}, {@code getElementsByTagName} or
 * {@code getElementsByClassName}) where possible. The returned array is a live
 * NodeList or a static list depending on the code path taken.
 *
 * @see goog.dom.query
 *
 * @param {?string=} opt_tag Element tag name or * for all tags.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.DomHelper.prototype.getElementsByTagNameAndClass = function(opt_tag,
                                                                     opt_class,
                                                                     opt_el) {
  return goog.dom.getElementsByTagNameAndClass_(this.document_, opt_tag,
                                                opt_class, opt_el);
};


/**
 * Returns an array of all the elements with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return { {length: number} } The items found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementsByClass = function(className, opt_el) {
  var doc = opt_el || this.document_;
  return goog.dom.getElementsByClass(className, doc);
};


/**
 * Returns the first element we find matching the provided class name.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {(Element|Document)=} opt_el Optional element to look in.
 * @return {Element} The first item found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementByClass = function(className, opt_el) {
  var doc = opt_el || this.document_;
  return goog.dom.getElementByClass(className, doc);
};


/**
 * Ensures an element with the given className exists, and then returns the
 * first element with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {(!Element|!Document)=} opt_root Optional element or document to look
 *     in.
 * @return {!Element} The first item found with the class name provided.
 * @throws {goog.asserts.AssertionError} Thrown if no element is found.
 */
goog.dom.DomHelper.prototype.getRequiredElementByClass = function(className,
                                                                  opt_root) {
  var root = opt_root || this.document_;
  return goog.dom.getRequiredElementByClass(className, root);
};


/**
 * Alias for {@code getElementsByTagNameAndClass}.
 * @deprecated Use DomHelper getElementsByTagNameAndClass.
 * @see goog.dom.query
 *
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.DomHelper.prototype.$$ =
    goog.dom.DomHelper.prototype.getElementsByTagNameAndClass;


/**
 * Sets a number of properties on a node.
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 */
goog.dom.DomHelper.prototype.setProperties = goog.dom.setProperties;


/**
 * Gets the dimensions of the viewport.
 * @param {Window=} opt_window Optional window element to test. Defaults to
 *     the window of the Dom Helper.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.DomHelper.prototype.getViewportSize = function(opt_window) {
  // TODO(arv): This should not take an argument. That breaks the rule of a
  // a DomHelper representing a single frame/window/document.
  return goog.dom.getViewportSize(opt_window || this.getWindow());
};


/**
 * Calculates the height of the document.
 *
 * @return {number} The height of the document.
 */
goog.dom.DomHelper.prototype.getDocumentHeight = function() {
  return goog.dom.getDocumentHeight_(this.getWindow());
};


/**
 * Typedef for use with goog.dom.createDom and goog.dom.append.
 * @typedef {Object|string|Array|NodeList}
 */
goog.dom.Appendable;


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom('div', null, createDom('p'), createDom('p'));</code>
 * would return a div with two child paragraphs
 *
 * An easy way to move all child nodes of an existing element to a new parent
 * element is:
 * <code>createDom('div', null, oldElement.childNodes);</code>
 * which will remove all child nodes from the old element and add them as
 * child nodes of the new DIV.
 *
 * @param {string} tagName Tag to create.
 * @param {Object|string=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...goog.dom.Appendable} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array or
 *     NodeList, its elements will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 */
goog.dom.DomHelper.prototype.createDom = function(tagName,
                                                  opt_attributes,
                                                  var_args) {
  return goog.dom.createDom_(this.document_, arguments);
};


/**
 * Alias for {@code createDom}.
 * @param {string} tagName Tag to create.
 * @param {(Object|string)=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...goog.dom.Appendable} var_args Further DOM nodes or strings for
 *     text nodes.  If one of the var_args is an array, its children will be
 *     added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 * @deprecated Use {@link goog.dom.DomHelper.prototype.createDom} instead.
 */
goog.dom.DomHelper.prototype.$dom = goog.dom.DomHelper.prototype.createDom;


/**
 * Creates a new element.
 * @param {string} name Tag name.
 * @return {!Element} The new element.
 */
goog.dom.DomHelper.prototype.createElement = function(name) {
  return this.document_.createElement(name);
};


/**
 * Creates a new text node.
 * @param {number|string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.DomHelper.prototype.createTextNode = function(content) {
  return this.document_.createTextNode(String(content));
};


/**
 * Create a table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean=} opt_fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 */
goog.dom.DomHelper.prototype.createTable = function(rows, columns,
    opt_fillWithNbsp) {
  return goog.dom.createTable_(this.document_, rows, columns,
      !!opt_fillWithNbsp);
};


/**
 * Converts an HTML string into a node or a document fragment.  A single Node
 * is used if the {@code htmlString} only generates a single node.  If the
 * {@code htmlString} generates multiple nodes then these are put inside a
 * {@code DocumentFragment}.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting node.
 */
goog.dom.DomHelper.prototype.htmlToDocumentFragment = function(htmlString) {
  return goog.dom.htmlToDocumentFragment_(this.document_, htmlString);
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @return {boolean} True if in CSS1-compatible mode.
 */
goog.dom.DomHelper.prototype.isCss1CompatMode = function() {
  return goog.dom.isCss1CompatMode_(this.document_);
};


/**
 * Gets the window object associated with the document.
 * @return {!Window} The window associated with the given document.
 */
goog.dom.DomHelper.prototype.getWindow = function() {
  return goog.dom.getWindow_(this.document_);
};


/**
 * Gets the document scroll element.
 * @return {Element} Scrolling element.
 */
goog.dom.DomHelper.prototype.getDocumentScrollElement = function() {
  return goog.dom.getDocumentScrollElement_(this.document_);
};


/**
 * Gets the document scroll distance as a coordinate object.
 * @return {!goog.math.Coordinate} Object with properties 'x' and 'y'.
 */
goog.dom.DomHelper.prototype.getDocumentScroll = function() {
  return goog.dom.getDocumentScroll_(this.document_);
};


/**
 * Determines the active element in the given document.
 * @param {Document=} opt_doc The document to look in.
 * @return {Element} The active element.
 */
goog.dom.DomHelper.prototype.getActiveElement = function(opt_doc) {
  return goog.dom.getActiveElement(opt_doc || this.document_);
};


/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.DomHelper.prototype.appendChild = goog.dom.appendChild;


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.DomHelper.prototype.append = goog.dom.append;


/**
 * Determines if the given node can contain children, intended to be used for
 * HTML generation.
 *
 * @param {Node} node The node to check.
 * @return {boolean} Whether the node can contain children.
 */
goog.dom.DomHelper.prototype.canHaveChildren = goog.dom.canHaveChildren;


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 */
goog.dom.DomHelper.prototype.removeChildren = goog.dom.removeChildren;


/**
 * Inserts a new node before an existing reference node (i.e., as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.DomHelper.prototype.insertSiblingBefore = goog.dom.insertSiblingBefore;


/**
 * Inserts a new node after an existing reference node (i.e., as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 */
goog.dom.DomHelper.prototype.insertSiblingAfter = goog.dom.insertSiblingAfter;


/**
 * Insert a child at a given index. If index is larger than the number of child
 * nodes that the parent currently has, the node is inserted as the last child
 * node.
 * @param {Element} parent The element into which to insert the child.
 * @param {Node} child The element to insert.
 * @param {number} index The index at which to insert the new child node. Must
 *     not be negative.
 */
goog.dom.DomHelper.prototype.insertChildAt = goog.dom.insertChildAt;


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.DomHelper.prototype.removeNode = goog.dom.removeNode;


/**
 * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.DomHelper.prototype.replaceNode = goog.dom.replaceNode;


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children, or undefined if the element was already not in the
 *     document.
 */
goog.dom.DomHelper.prototype.flattenElement = goog.dom.flattenElement;


/**
 * Returns an array containing just the element children of the given element.
 * @param {Element} element The element whose element children we want.
 * @return {!(Array|NodeList)} An array or array-like list of just the element
 *     children of the given element.
 */
goog.dom.DomHelper.prototype.getChildren = goog.dom.getChildren;


/**
 * Returns the first child node that is an element.
 * @param {Node} node The node to get the first child element of.
 * @return {Element} The first child node of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getFirstElementChild =
    goog.dom.getFirstElementChild;


/**
 * Returns the last child node that is an element.
 * @param {Node} node The node to get the last child element of.
 * @return {Element} The last child node of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getLastElementChild = goog.dom.getLastElementChild;


/**
 * Returns the first next sibling that is an element.
 * @param {Node} node The node to get the next sibling element of.
 * @return {Element} The next sibling of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getNextElementSibling =
    goog.dom.getNextElementSibling;


/**
 * Returns the first previous sibling that is an element.
 * @param {Node} node The node to get the previous sibling element of.
 * @return {Element} The first previous sibling of {@code node} that is
 *     an element.
 */
goog.dom.DomHelper.prototype.getPreviousElementSibling =
    goog.dom.getPreviousElementSibling;


/**
 * Returns the next node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The next node in the DOM tree, or null if this was the last
 *     node.
 */
goog.dom.DomHelper.prototype.getNextNode = goog.dom.getNextNode;


/**
 * Returns the previous node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The previous node in the DOM tree, or null if this was the
 *     first node.
 */
goog.dom.DomHelper.prototype.getPreviousNode = goog.dom.getPreviousNode;


/**
 * Whether the object looks like a DOM node.
 * @param {?} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.DomHelper.prototype.isNodeLike = goog.dom.isNodeLike;


/**
 * Whether the object looks like an Element.
 * @param {?} obj The object being tested for Element likeness.
 * @return {boolean} Whether the object looks like an Element.
 */
goog.dom.DomHelper.prototype.isElement = goog.dom.isElement;


/**
 * Returns true if the specified value is a Window object. This includes the
 * global window for HTML pages, and iframe windows.
 * @param {?} obj Variable to test.
 * @return {boolean} Whether the variable is a window.
 */
goog.dom.DomHelper.prototype.isWindow = goog.dom.isWindow;


/**
 * Returns an element's parent, if it's an Element.
 * @param {Element} element The DOM element.
 * @return {Element} The parent, or null if not an Element.
 */
goog.dom.DomHelper.prototype.getParentElement = goog.dom.getParentElement;


/**
 * Whether a node contains another node.
 * @param {Node} parent The node that should contain the other node.
 * @param {Node} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendent node.
 */
goog.dom.DomHelper.prototype.contains = goog.dom.contains;


/**
 * Compares the document order of two nodes, returning 0 if they are the same
 * node, a negative number if node1 is before node2, and a positive number if
 * node2 is before node1.  Note that we compare the order the tags appear in the
 * document so in the tree <b><i>text</i></b> the B node is considered to be
 * before the I node.
 *
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} 0 if the nodes are the same node, a negative number if node1
 *     is before node2, and a positive number if node2 is before node1.
 */
goog.dom.DomHelper.prototype.compareNodeOrder = goog.dom.compareNodeOrder;


/**
 * Find the deepest common ancestor of the given nodes.
 * @param {...Node} var_args The nodes to find a common ancestor of.
 * @return {Node} The common ancestor of the nodes, or null if there is none.
 *     null will only be returned if two or more of the nodes are from different
 *     documents.
 */
goog.dom.DomHelper.prototype.findCommonAncestor = goog.dom.findCommonAncestor;


/**
 * Returns the owner document for a node.
 * @param {Node} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.DomHelper.prototype.getOwnerDocument = goog.dom.getOwnerDocument;


/**
 * Cross browser function for getting the document element of an iframe.
 * @param {Element} iframe Iframe element.
 * @return {!Document} The frame content document.
 */
goog.dom.DomHelper.prototype.getFrameContentDocument =
    goog.dom.getFrameContentDocument;


/**
 * Cross browser function for getting the window of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {Window} The window associated with the given frame.
 */
goog.dom.DomHelper.prototype.getFrameContentWindow =
    goog.dom.getFrameContentWindow;


/**
 * Sets the text content of a node, with cross-browser support.
 * @param {Node} node The node to change the text content of.
 * @param {string|number} text The value that should replace the node's content.
 */
goog.dom.DomHelper.prototype.setTextContent = goog.dom.setTextContent;


/**
 * Gets the outerHTML of a node, which islike innerHTML, except that it
 * actually contains the HTML of the node itself.
 * @param {Element} element The element to get the HTML of.
 * @return {string} The outerHTML of the given element.
 */
goog.dom.DomHelper.prototype.getOuterHtml = goog.dom.getOuterHtml;


/**
 * Finds the first descendant node that matches the filter function. This does
 * a depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Node|undefined} The found node or undefined if none is found.
 */
goog.dom.DomHelper.prototype.findNode = goog.dom.findNode;


/**
 * Finds all the descendant nodes that matches the filter function. This does a
 * depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Array.<Node>} The found nodes or an empty array if none are found.
 */
goog.dom.DomHelper.prototype.findNodes = goog.dom.findNodes;


/**
 * Returns true if the element has a tab index that allows it to receive
 * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements
 * natively support keyboard focus, even if they have no tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a tab index that allows keyboard
 *     focus.
 */
goog.dom.DomHelper.prototype.isFocusableTabIndex = goog.dom.isFocusableTabIndex;


/**
 * Enables or disables keyboard focus support on the element via its tab index.
 * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
 * (or elements that natively support keyboard focus, like form elements) can
 * receive keyboard focus.  See http://go/tabindex for more info.
 * @param {Element} element Element whose tab index is to be changed.
 * @param {boolean} enable Whether to set or remove a tab index on the element
 *     that supports keyboard focus.
 */
goog.dom.DomHelper.prototype.setFocusableTabIndex =
    goog.dom.setFocusableTabIndex;


/**
 * Returns true if the element can be focused, i.e. it has a tab index that
 * allows it to receive keyboard focus (tabIndex >= 0), or it is an element
 * that natively supports keyboard focus.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element allows keyboard focus.
 */
goog.dom.DomHelper.prototype.isFocusable = goog.dom.isFocusable;


/**
 * Returns the text contents of the current node, without markup. New lines are
 * stripped and whitespace is collapsed, such that each character would be
 * visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.DomHelper.prototype.getTextContent = goog.dom.getTextContent;


/**
 * Returns the text length of the text contained in a node, without markup. This
 * is equivalent to the selection length if the node was selected, or the number
 * of cursor movements to traverse the node. Images & BRs take one space.  New
 * lines are ignored.
 *
 * @param {Node} node The node whose text content length is being calculated.
 * @return {number} The length of {@code node}'s text content.
 */
goog.dom.DomHelper.prototype.getNodeTextLength = goog.dom.getNodeTextLength;


/**
 * Returns the text offset of a node relative to one of its ancestors. The text
 * length is the same as the length calculated by
 * {@code goog.dom.getNodeTextLength}.
 *
 * @param {Node} node The node whose offset is being calculated.
 * @param {Node=} opt_offsetParent Defaults to the node's owner document's body.
 * @return {number} The text offset.
 */
goog.dom.DomHelper.prototype.getNodeTextOffset = goog.dom.getNodeTextOffset;


/**
 * Returns the node at a given offset in a parent node.  If an object is
 * provided for the optional third parameter, the node and the remainder of the
 * offset will stored as properties of this object.
 * @param {Node} parent The parent node.
 * @param {number} offset The offset into the parent node.
 * @param {Object=} opt_result Object to be used to store the return value. The
 *     return value will be stored in the form {node: Node, remainder: number}
 *     if this object is provided.
 * @return {Node} The node at the given offset.
 */
goog.dom.DomHelper.prototype.getNodeAtOffset = goog.dom.getNodeAtOffset;


/**
 * Returns true if the object is a {@code NodeList}.  To qualify as a NodeList,
 * the object must have a numeric length property and an item function (which
 * has type 'string' on IE for some reason).
 * @param {Object} val Object to test.
 * @return {boolean} Whether the object is a NodeList.
 */
goog.dom.DomHelper.prototype.isNodeList = goog.dom.isNodeList;


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * tag name and/or class name. If the passed element matches the specified
 * criteria, the element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {?(goog.dom.TagName|string)=} opt_tag The tag name to match (or
 *     null/undefined to match only based on class name).
 * @param {?string=} opt_class The class name to match (or null/undefined to
 *     match only based on tag name).
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if no match is found.
 */
goog.dom.DomHelper.prototype.getAncestorByTagNameAndClass =
    goog.dom.getAncestorByTagNameAndClass;


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * class name. If the passed element matches the specified criteria, the
 * element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {string} class The class name to match.
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if none match.
 */
goog.dom.DomHelper.prototype.getAncestorByClass =
    goog.dom.getAncestorByClass;


/**
 * Walks up the DOM hierarchy returning the first ancestor that passes the
 * matcher function.
 * @param {Node} element The DOM node to start with.
 * @param {function(Node) : boolean} matcher A function that returns true if the
 *     passed node matches the desired criteria.
 * @param {boolean=} opt_includeNode If true, the node itself is included in
 *     the search (the first call to the matcher will pass startElement as
 *     the node to test).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Node} DOM node that matched the matcher, or null if there was
 *     no match.
 */
goog.dom.DomHelper.prototype.getAncestor = goog.dom.getAncestor;

//javascript/apps/drive/dataservice/sync/change/tangochangelogevent.js
goog.provide('drive.ds.sync.change.TangoChangelogEvent');

goog.require('goog.events');
goog.require('goog.events.Event');



/**
 * An event for tango changelog updates.
 *
 * @param {number=} opt_changeId The change id from tango for this user.
 * @param {Object=} opt_target Reference to the object that is the target of
 *     this event. It has to implement the {@code EventTarget} interface
 *     declared at {@link http://developer.mozilla.org/en/DOM/EventTarget}.
 * @constructor
 * @extends {goog.events.Event}
 */
drive.ds.sync.change.TangoChangelogEvent = function(opt_changeId, opt_target) {
  goog.base(this, drive.ds.sync.change.TangoChangelogEvent.TYPE, opt_target);

  /**
   * The version of the change.
   * @private {number|undefined}
   */
  this.changeId_ = opt_changeId;
};
goog.inherits(drive.ds.sync.change.TangoChangelogEvent, goog.events.Event);


/**
 * Gets the changelog version for this event.
 *
 * If defined, this client should retreive all changelog updates betweeen
 * its current version and the specified change log id.
 *
 * If undefined, which should happen very rarely, clients should query the
 * Drive API for the current changelog number and update accordingly.
 *
 * @return {number|undefined} The changelog version number.
 */
drive.ds.sync.change.TangoChangelogEvent.prototype.getChangeId = function() {
  return this.changeId_;
};


/**
 * The event type for a ChangelogEvent.
 * @type {string}
 */
drive.ds.sync.change.TangoChangelogEvent.TYPE =
    goog.events.getUniqueId('TangoChangelogEvent');

//buzz/channel/javascript/external/interface/session.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview An interface for sending data to a specific service over a
 *     given channel.
 *
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('buzz.channel.Session');

/**
 * A session with a given service over a channel.
 * @interface
 */
buzz.channel.Session = function() {};

/**
 * Opens the session if it's not already open.
 */
buzz.channel.Session.prototype.open = goog.abstractMethod;

/**
 * Sends a message with the given data over this session.
 * @param {string} data The data to send.
 */
buzz.channel.Session.prototype.send = goog.abstractMethod;

//buzz/channel/javascript/external/interface/sessionhandler.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview An interface for receiving data on a session.
 *
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('buzz.channel.SessionErrorHandler');
goog.provide('buzz.channel.SessionHandler');

goog.require('buzz.channel.Session');

/**
 * Receives messages for a given session.
 * @interface
 */
buzz.channel.SessionHandler = function() {};

// TODO(ghc): [bug 7415990] Standardize the naming scheme for API calls.

/**
 * Receives a message on the given channel.
 * @param {buzz.channel.Session} session The session on which the data was
 *     received.
 * @param {string} data The message.
 */
buzz.channel.SessionHandler.prototype.receive = goog.abstractMethod;

/**
 * Informs the application about the address of the session.
 * @param {buzz.channel.Session} session The session whose address has been
 *     assigned.
 * @param {string} address The serialized address of this session.
 */
buzz.channel.SessionHandler.prototype.onAddressAssigned = goog.abstractMethod;


/**
 * Handles an error callback for sessions. This is kept separate from
 * {@code buzz.channel.SessionHandler} to avoid breaking existing customers
 * who haven't implemented this callback.
 * @interface
 */
buzz.channel.SessionErrorHandler = function() {};

/**
 * Informs the application about an error on the session.
 * @param {buzz.channel.Session} session The session on which the error
 *     occurred.
 * @param {{isTransient: boolean, description: string}} errorInfo A record
 *     containing various properties of the error. If the {@code isTransient}
 *     property is {@code false}, the application must not retry creating the
 *     session.
 */
buzz.channel.SessionErrorHandler.prototype.onSessionError = goog.abstractMethod;

//buzz/channel/javascript/external/interface/channel.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A shared network channel interface.
 *
 * @author ghc@google.com (Greg Cooper)
 * @author mharris@google.com (Matthew Harris)
 */

goog.provide('buzz.channel.Channel');

goog.require('buzz.channel.Session');
goog.require('buzz.channel.SessionHandler');

/**
 * A bidirectional channel, which may be shared among multiple sessions.
 * @extends {goog.disposable.IDisposable}
 * @interface
 */
buzz.channel.Channel = function() {};

/**
 * Sets an OAuth token to use for authenticating the channel.  An OAuth access
 * token is typically valid for one hour; it is the application's responsibility
 * to call this method regularly to refresh the token (otherwise the channel
 * will be closed by the server).  First-party applications typically don't need
 * to call this.
 * @param {string} oauthToken The token to use.
 */
buzz.channel.Channel.prototype.setOAuthToken = goog.abstractMethod;

/**
 * Initiates opening of the channel.  This is an asynchronous operation.  The
 * handler's {@code onOpen} function will be called once the channel is actually
 * open.
 */
buzz.channel.Channel.prototype.open = goog.abstractMethod;

/**
 * @param {string} serviceName The name of the service with which this session
 *     is associated.
 * @param {!buzz.channel.SessionHandler} handler Handler for messages received
 *     by this session. If this also implements the
 *     {@code buzz.channel.SessionErrorHandler} interface, the
 *     {@code onSessionError} callback will be invoked in the case of an error.
 * @return {buzz.channel.Session} The new session, or {@code null} if this
 *     channel is closed.
 */
buzz.channel.Channel.prototype.newSession = goog.abstractMethod;

/**
 * Applications must not call this function without permission of the Marmoset
 * team. This indicates that the user has performed an action requesting an
 * immediate attempt to reconnect the channel. The channel implementation may
 * use this information as a hint to make a reconnection attempt sooner than the
 * randomized exponential backoff algorithm would ordinarily allow. The
 * implementation is also free to ignore this call at its discretion.
 */
buzz.channel.Channel.prototype.tryImmediateReconnectByUserRequest =
    goog.abstractMethod;

//buzz/channel/javascript/external/interface/channelconfig.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Config interface for Marmoset browser channel.
 *
 * @author xiaolan@google.com (Joy Zhang)
 */

goog.provide('buzz.channel.ChannelConfig');

/**
 * A marmoset channel config. Channel factory contains the implementation.
 * @interface
 */
buzz.channel.ChannelConfig = function() {};

/**
 * The domain for the production channel service.
 * @type {string}
 * @const
 */
buzz.channel.ChannelConfig.PRODUCTION_DOMAIN = 'client-channel.google.com';

/**
 * The default root for client channel servlets.
 * @type {string}
 * @const
 */
buzz.channel.ChannelConfig.DEFAULT_SERVLET_ROOT = 'client-channel';

/**
 * The default sub-path (under the root) for the client iframe.
 * @type {string}
 * @const
 */
buzz.channel.ChannelConfig.DEFAULT_CLIENT_IFRAME_SUBPATH = 'client';

/**
 * The domain and path to use for connecting to the production service.
 * @type {string}
 * @const
 */
buzz.channel.ChannelConfig.PRODUCTION_DOMAIN_AND_PATH =
    buzz.channel.ChannelConfig.PRODUCTION_DOMAIN + '/' +
    buzz.channel.ChannelConfig.DEFAULT_SERVLET_ROOT + '/' +
    buzz.channel.ChannelConfig.DEFAULT_CLIENT_IFRAME_SUBPATH;

//javascript/closure/crypt/crypt.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Namespace with crypto related helper functions.
 * @author pupius@google.com (Daniel Pupius)
 */

goog.provide('goog.crypt');

goog.require('goog.array');


/**
 * Turns a string into an array of bytes; a "byte" being a JS number in the
 * range 0-255.
 * @param {string} str String value to arrify.
 * @return {!Array.<number>} Array of numbers corresponding to the
 *     UCS character codes of each character in str.
 */
goog.crypt.stringToByteArray = function(str) {
  var output = [], p = 0;
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    while (c > 0xff) {
      output[p++] = c & 0xff;
      c >>= 8;
    }
    output[p++] = c;
  }
  return output;
};


/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param {Array} array Array of numbers representing characters.
 * @return {string} Stringification of the array.
 */
goog.crypt.byteArrayToString = function(array) {
  return String.fromCharCode.apply(null, array);
};


/**
 * Turns an array of numbers into the hex string given by the concatenation of
 * the hex values to which the numbers correspond.
 * @param {Array} array Array of numbers representing characters.
 * @return {string} Hex string.
 */
goog.crypt.byteArrayToHex = function(array) {
  return goog.array.map(array, function(numByte) {
    var hexByte = numByte.toString(16);
    return hexByte.length > 1 ? hexByte : '0' + hexByte;
  }).join('');
};


/**
 * Converts a hex string into an integer array.
 * @param {string} hexString Hex string of 16-bit integers (two characters
 *     per integer).
 * @return {!Array.<number>} Array of {0,255} integers for the given string.
 */
goog.crypt.hexToByteArray = function(hexString) {
  goog.asserts.assert(hexString.length % 2 == 0,
                      'Key string length must be multiple of 2');
  var arr = [];
  for (var i = 0; i < hexString.length; i += 2) {
    arr.push(parseInt(hexString.substring(i, i + 2), 16));
  }
  return arr;
};


/**
 * Converts a JS string to a UTF-8 "byte" array.
 * @param {string} str 16-bit unicode string.
 * @return {Array.<number>} UTF-8 byte array.
 */
goog.crypt.stringToUtf8ByteArray = function(str) {
  // TODO(pupius): Use native implementations if/when available
  str = str.replace(/\r\n/g, '\n');
  var out = [], p = 0;
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = (c >> 6) | 192;
      out[p++] = (c & 63) | 128;
    } else {
      out[p++] = (c >> 12) | 224;
      out[p++] = ((c >> 6) & 63) | 128;
      out[p++] = (c & 63) | 128;
    }
  }
  return out;
};


/**
 * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.
 * @param {Array.<number>} bytes UTF-8 byte array.
 * @return {string} 16-bit Unicode string.
 */
goog.crypt.utf8ByteArrayToString = function(bytes) {
  // TODO(pupius): Use native implementations if/when available
  var out = [], pos = 0, c = 0;
  while (pos < bytes.length) {
    var c1 = bytes[pos++];
    if (c1 < 128) {
      out[c++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      var c2 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
    } else {
      var c2 = bytes[pos++];
      var c3 = bytes[pos++];
      out[c++] = String.fromCharCode(
          (c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    }
  }
  return out.join('');
};


/**
 * XOR two byte arrays.
 * @param {!Array.<number>} bytes1 Byte array 1.
 * @param {!Array.<number>} bytes2 Byte array 2.
 * @return {!Array.<number>} Resulting XOR of the two byte arrays.
 */
goog.crypt.xorByteArray = function(bytes1, bytes2) {
  goog.asserts.assert(
      bytes1.length == bytes2.length,
      'XOR array lengths must match');

  var result = [];
  for (var i = 0; i < bytes1.length; i++) {
    result.push(bytes1[i] ^ bytes2[i]);
  }
  return result;
};

//javascript/closure/crypt/hash.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Abstract cryptographic hash interface.
 *
 * See goog.crypt.Sha1 and goog.crypt.Md5 for sample implementations.
 *
 * @author azzie@google.com (Marcin Marszalek)
 */

goog.provide('goog.crypt.Hash');



/**
 * Create a cryptographic hash instance.
 *
 * @constructor
 */
goog.crypt.Hash = function() {};


/**
 * Resets the internal accumulator.
 */
goog.crypt.Hash.prototype.reset = goog.abstractMethod;


/**
 * Adds a byte array (array with values in [0-255] range) or a string (might
 * only contain 8-bit, i.e., Latin1 characters) to the internal accumulator.
 *
 * Many hash functions operate on blocks of data and implement optimizations
 * when a full chunk of data is readily available. Hence it is often preferable
 * to provide large chunks of data (a kilobyte or more) than to repeatedly
 * call the update method with few tens of bytes. If this is not possible, or
 * not feasible, it might be good to provide data in multiplies of hash block
 * size (often 64 bytes). Please see the implementation and performance tests
 * of your favourite hash.
 *
 * @param {Array.<number>|Uint8Array|string} bytes Data used for the update.
 * @param {number=} opt_length Number of bytes to use.
 */
goog.crypt.Hash.prototype.update = goog.abstractMethod;


/**
 * @return {!Array.<number>} The finalized hash computed
 *     from the internal accumulator.
 */
goog.crypt.Hash.prototype.digest = goog.abstractMethod;

//javascript/closure/crypt/sha1.js
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new goog.crypt.sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 * @author mschilder@google.com (Marius Schilder)
 * @author ysekhon@google.com (Yash Sekhon) - port to closure
 * @author azzie@google.com (Marcin Marszalek) - block optimizations
 */

goog.provide('goog.crypt.Sha1');

goog.require('goog.crypt.Hash');



/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @extends {goog.crypt.Hash}
 * @final
 */
goog.crypt.Sha1 = function() {
  goog.base(this);

  /**
   * Holds the previous values of accumulated variables a-e in the compress_
   * function.
   * @type {Array.<number>}
   * @private
   */
  this.chain_ = [];

  /**
   * A buffer holding the partially computed hash result.
   * @type {Array.<number>}
   * @private
   */
  this.buf_ = [];

  /**
   * An array of 80 bytes, each a part of the message to be hashed.  Referred to
   * as the message schedule in the docs.
   * @type {Array.<number>}
   * @private
   */
  this.W_ = [];

  /**
   * Contains data needed to pad messages less than 64 bytes.
   * @type {Array.<number>}
   * @private
   */
  this.pad_ = [];

  this.pad_[0] = 128;
  for (var i = 1; i < 64; ++i) {
    this.pad_[i] = 0;
  }

  this.reset();
};
goog.inherits(goog.crypt.Sha1, goog.crypt.Hash);


/** @override */
goog.crypt.Sha1.prototype.reset = function() {
  this.chain_[0] = 0x67452301;
  this.chain_[1] = 0xefcdab89;
  this.chain_[2] = 0x98badcfe;
  this.chain_[3] = 0x10325476;
  this.chain_[4] = 0xc3d2e1f0;

  this.inbuf_ = 0;
  this.total_ = 0;
};


/**
 * Internal compress helper function.
 * @param {Array.<number>|Uint8Array|string} buf Block to compress.
 * @param {number=} opt_offset Offset of the block in the buffer.
 * @private
 */
goog.crypt.Sha1.prototype.compress_ = function(buf, opt_offset) {
  if (!opt_offset) {
    opt_offset = 0;
  }

  var W = this.W_;

  // get 16 big endian words
  if (goog.isString(buf)) {
    for (var i = 0; i < 16; i++) {
      // TODO(ghc): [bug 8140122] Recent versions of Safari for Mac OS and iOS
      // have a bug that turns the post-increment ++ operator into pre-increment
      // during JIT compilation.  We have code that depends heavily on SHA-1 for
      // correctness and which is affected by this bug, so I've removed all uses
      // of post-increment ++ in which the result value is used.  We can revert
      // this change once the Safari bug
      // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
      // most clients have been updated.
      W[i] = (buf.charCodeAt(opt_offset) << 24) |
             (buf.charCodeAt(opt_offset + 1) << 16) |
             (buf.charCodeAt(opt_offset + 2) << 8) |
             (buf.charCodeAt(opt_offset + 3));
      opt_offset += 4;
    }
  } else {
    for (var i = 0; i < 16; i++) {
      W[i] = (buf[opt_offset] << 24) |
             (buf[opt_offset + 1] << 16) |
             (buf[opt_offset + 2] << 8) |
             (buf[opt_offset + 3]);
      opt_offset += 4;
    }
  }

  // expand to 80 words
  for (var i = 16; i < 80; i++) {
    var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
    W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;
  }

  var a = this.chain_[0];
  var b = this.chain_[1];
  var c = this.chain_[2];
  var d = this.chain_[3];
  var e = this.chain_[4];
  var f, k;

  // TODO(azzie): Try to unroll this loop to speed up the computation.
  for (var i = 0; i < 80; i++) {
    if (i < 40) {
      if (i < 20) {
        f = d ^ (b & (c ^ d));
        k = 0x5a827999;
      } else {
        f = b ^ c ^ d;
        k = 0x6ed9eba1;
      }
    } else {
      if (i < 60) {
        f = (b & c) | (d & (b | c));
        k = 0x8f1bbcdc;
      } else {
        f = b ^ c ^ d;
        k = 0xca62c1d6;
      }
    }

    var t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;
    e = d;
    d = c;
    c = ((b << 30) | (b >>> 2)) & 0xffffffff;
    b = a;
    a = t;
  }

  this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;
  this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;
  this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;
  this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;
  this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;
};


/** @override */
goog.crypt.Sha1.prototype.update = function(bytes, opt_length) {
  if (!goog.isDef(opt_length)) {
    opt_length = bytes.length;
  }

  var lengthMinusBlock = opt_length - 64;
  var n = 0;
  // Using local instead of member variables gives ~5% speedup on Firefox 16.
  var buf = this.buf_;
  var inbuf = this.inbuf_;

  // The outer while loop should execute at most twice.
  while (n < opt_length) {
    // When we have no data in the block to top up, we can directly process the
    // input buffer (assuming it contains sufficient data). This gives ~25%
    // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
    // the data is provided in large chunks (or in multiples of 64 bytes).
    if (inbuf == 0) {
      while (n <= lengthMinusBlock) {
        this.compress_(bytes, n);
        n += 64;
      }
    }

    if (goog.isString(bytes)) {
      while (n < opt_length) {
        buf[inbuf] = bytes.charCodeAt(n);
        ++inbuf;
        ++n;
        if (inbuf == 64) {
          this.compress_(buf);
          inbuf = 0;
          // Jump to the outer loop so we use the full-block optimization.
          break;
        }
      }
    } else {
      while (n < opt_length) {
        buf[inbuf] = bytes[n];
        ++inbuf;
        ++n;
        if (inbuf == 64) {
          this.compress_(buf);
          inbuf = 0;
          // Jump to the outer loop so we use the full-block optimization.
          break;
        }
      }
    }
  }

  this.inbuf_ = inbuf;
  this.total_ += opt_length;
};


/** @override */
goog.crypt.Sha1.prototype.digest = function() {
  var digest = [];
  var totalBits = this.total_ * 8;

  // Add pad 0x80 0x00*.
  if (this.inbuf_ < 56) {
    this.update(this.pad_, 56 - this.inbuf_);
  } else {
    this.update(this.pad_, 64 - (this.inbuf_ - 56));
  }

  // Add # bits.
  for (var i = 63; i >= 56; i--) {
    this.buf_[i] = totalBits & 255;
    totalBits /= 256; // Don't use bit-shifting here!
  }

  this.compress_(this.buf_);

  var n = 0;
  for (var i = 0; i < 5; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      digest[n] = (this.chain_[i] >> j) & 255;
      ++n;
    }
  }

  return digest;
};

//javascript/closure/net/cookies.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Functions for setting, getting and deleting cookies.
 *
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.net.Cookies');
goog.provide('goog.net.cookies');



/**
 * A class for handling browser cookies.
 * @param {Document} context The context document to get/set cookies on.
 * @constructor
 * @final
 */
goog.net.Cookies = function(context) {
  /**
   * The context document to get/set cookies on
   * @type {Document}
   * @private
   */
  this.document_ = context;
};


/**
 * Static constant for the size of cookies. Per the spec, there's a 4K limit
 * to the size of a cookie. To make sure users can't break this limit, we
 * should truncate long cookies at 3950 bytes, to be extra careful with dumb
 * browsers/proxies that interpret 4K as 4000 rather than 4096.
 * @type {number}
 */
goog.net.Cookies.MAX_COOKIE_LENGTH = 3950;


/**
 * RegExp used to split the cookies string.
 * @type {RegExp}
 * @private
 */
goog.net.Cookies.SPLIT_RE_ = /\s*;\s*/;


/**
 * Returns true if cookies are enabled.
 * @return {boolean} True if cookies are enabled.
 */
goog.net.Cookies.prototype.isEnabled = function() {
  return navigator.cookieEnabled;
};


/**
 * We do not allow '=', ';', or white space in the name.
 *
 * NOTE: The following are allowed by this method, but should be avoided for
 * cookies handled by the server.
 * - any name starting with '$'
 * - 'Comment'
 * - 'Domain'
 * - 'Expires'
 * - 'Max-Age'
 * - 'Path'
 * - 'Secure'
 * - 'Version'
 *
 * @param {string} name Cookie name.
 * @return {boolean} Whether name is valid.
 *
 * @see <a href="http://tools.ietf.org/html/rfc2109">RFC 2109</a>
 * @see <a href="http://tools.ietf.org/html/rfc2965">RFC 2965</a>
 */
goog.net.Cookies.prototype.isValidName = function(name) {
  return !(/[;=\s]/.test(name));
};


/**
 * We do not allow ';' or line break in the value.
 *
 * Spec does not mention any illegal characters, but in practice semi-colons
 * break parsing and line breaks truncate the name.
 *
 * @param {string} value Cookie value.
 * @return {boolean} Whether value is valid.
 *
 * @see <a href="http://tools.ietf.org/html/rfc2109">RFC 2109</a>
 * @see <a href="http://tools.ietf.org/html/rfc2965">RFC 2965</a>
 */
goog.net.Cookies.prototype.isValidValue = function(value) {
  return !(/[;\r\n]/.test(value));
};


/**
 * Sets a cookie.  The max_age can be -1 to set a session cookie. To remove and
 * expire cookies, use remove() instead.
 *
 * Neither the {@code name} nor the {@code value} are encoded in any way. It is
 * up to the callers of {@code get} and {@code set} (as well as all the other
 * methods) to handle any possible encoding and decoding.
 *
 * @throws {!Error} If the {@code name} fails #goog.net.cookies.isValidName.
 * @throws {!Error} If the {@code value} fails #goog.net.cookies.isValidValue.
 *
 * @param {string} name  The cookie name.
 * @param {string} value  The cookie value.
 * @param {number=} opt_maxAge  The max age in seconds (from now). Use -1 to
 *     set a session cookie. If not provided, the default is -1
 *     (i.e. set a session cookie).
 * @param {?string=} opt_path  The path of the cookie. If not present then this
 *     uses the full request path.
 * @param {?string=} opt_domain  The domain of the cookie, or null to not
 *     specify a domain attribute (browser will use the full request host name).
 *     If not provided, the default is null (i.e. let browser use full request
 *     host name).
 * @param {boolean=} opt_secure Whether the cookie should only be sent over
 *     a secure channel.
 */
goog.net.Cookies.prototype.set = function(
    name, value, opt_maxAge, opt_path, opt_domain, opt_secure) {
  if (!this.isValidName(name)) {
    throw Error('Invalid cookie name "' + name + '"');
  }
  if (!this.isValidValue(value)) {
    throw Error('Invalid cookie value "' + value + '"');
  }

  if (!goog.isDef(opt_maxAge)) {
    opt_maxAge = -1;
  }

  var domainStr = opt_domain ? ';domain=' + opt_domain : '';
  var pathStr = opt_path ? ';path=' + opt_path : '';
  var secureStr = opt_secure ? ';secure' : '';

  var expiresStr;

  // Case 1: Set a session cookie.
  if (opt_maxAge < 0) {
    expiresStr = '';

  // Case 2: Expire the cookie.
  // Note: We don't tell people about this option in the function doc because
  // we prefer people to use ExpireCookie() to expire cookies.
  } else if (opt_maxAge == 0) {
    // Note: Don't use Jan 1, 1970 for date because NS 4.76 will try to convert
    // it to local time, and if the local time is before Jan 1, 1970, then the
    // browser will ignore the Expires attribute altogether.
    var pastDate = new Date(1970, 1 /*Feb*/, 1);  // Feb 1, 1970
    expiresStr = ';expires=' + pastDate.toUTCString();

  // Case 3: Set a persistent cookie.
  } else {
    var futureDate = new Date(goog.now() + opt_maxAge * 1000);
    expiresStr = ';expires=' + futureDate.toUTCString();
  }

  this.setCookie_(name + '=' + value + domainStr + pathStr +
                  expiresStr + secureStr);
};


/**
 * Returns the value for the first cookie with the given name.
 * @param {string} name  The name of the cookie to get.
 * @param {string=} opt_default  If not found this is returned instead.
 * @return {string|undefined}  The value of the cookie. If no cookie is set this
 *     returns opt_default or undefined if opt_default is not provided.
 */
goog.net.Cookies.prototype.get = function(name, opt_default) {
  var nameEq = name + '=';
  var parts = this.getParts_();
  for (var i = 0, part; part = parts[i]; i++) {
    // startsWith
    if (part.lastIndexOf(nameEq, 0) == 0) {
      return part.substr(nameEq.length);
    }
    if (part == name) {
      return '';
    }
  }
  return opt_default;
};


/**
 * Removes and expires a cookie.
 * @param {string} name  The cookie name.
 * @param {string=} opt_path  The path of the cookie, or null to expire a cookie
 *     set at the full request path. If not provided, the default is '/'
 *     (i.e. path=/).
 * @param {string=} opt_domain  The domain of the cookie, or null to expire a
 *     cookie set at the full request host name. If not provided, the default is
 *     null (i.e. cookie at full request host name).
 * @return {boolean} Whether the cookie existed before it was removed.
 */
goog.net.Cookies.prototype.remove = function(name, opt_path, opt_domain) {
  var rv = this.containsKey(name);
  this.set(name, '', 0, opt_path, opt_domain);
  return rv;
};


/**
 * Gets the names for all the cookies.
 * @return {Array.<string>} An array with the names of the cookies.
 */
goog.net.Cookies.prototype.getKeys = function() {
  return this.getKeyValues_().keys;
};


/**
 * Gets the values for all the cookies.
 * @return {Array.<string>} An array with the values of the cookies.
 */
goog.net.Cookies.prototype.getValues = function() {
  return this.getKeyValues_().values;
};


/**
 * @return {boolean} Whether there are any cookies for this document.
 */
goog.net.Cookies.prototype.isEmpty = function() {
  return !this.getCookie_();
};


/**
 * @return {number} The number of cookies for this document.
 */
goog.net.Cookies.prototype.getCount = function() {
  var cookie = this.getCookie_();
  if (!cookie) {
    return 0;
  }
  return this.getParts_().length;
};


/**
 * Returns whether there is a cookie with the given name.
 * @param {string} key The name of the cookie to test for.
 * @return {boolean} Whether there is a cookie by that name.
 */
goog.net.Cookies.prototype.containsKey = function(key) {
  // substring will return empty string if the key is not found, so the get
  // function will only return undefined
  return goog.isDef(this.get(key));
};


/**
 * Returns whether there is a cookie with the given value. (This is an O(n)
 * operation.)
 * @param {string} value  The value to check for.
 * @return {boolean} Whether there is a cookie with that value.
 */
goog.net.Cookies.prototype.containsValue = function(value) {
  // this O(n) in any case so lets do the trivial thing.
  var values = this.getKeyValues_().values;
  for (var i = 0; i < values.length; i++) {
    if (values[i] == value) {
      return true;
    }
  }
  return false;
};


/**
 * Removes all cookies for this document.  Note that this will only remove
 * cookies from the current path and domain.  If there are cookies set using a
 * subpath and/or another domain these will still be there.
 */
goog.net.Cookies.prototype.clear = function() {
  var keys = this.getKeyValues_().keys;
  for (var i = keys.length - 1; i >= 0; i--) {
    this.remove(keys[i]);
  }
};


/**
 * Private helper function to allow testing cookies without depending on the
 * browser.
 * @param {string} s The cookie string to set.
 * @private
 */
goog.net.Cookies.prototype.setCookie_ = function(s) {
  this.document_.cookie = s;
};


/**
 * Private helper function to allow testing cookies without depending on the
 * browser. IE6 can return null here.
 * @return {?string} Returns the {@code document.cookie}.
 * @private
 */
goog.net.Cookies.prototype.getCookie_ = function() {
  return this.document_.cookie;
};


/**
 * @return {!Array.<string>} The cookie split on semi colons.
 * @private
 */
goog.net.Cookies.prototype.getParts_ = function() {
  return (this.getCookie_() || '').
      split(goog.net.Cookies.SPLIT_RE_);
};


/**
 * Gets the names and values for all the cookies.
 * @return {Object} An object with keys and values.
 * @private
 */
goog.net.Cookies.prototype.getKeyValues_ = function() {
  var parts = this.getParts_();
  var keys = [], values = [], index, part;
  for (var i = 0; part = parts[i]; i++) {
    index = part.indexOf('=');

    if (index == -1) { // empty name
      keys.push('');
      values.push(part);
    } else {
      keys.push(part.substring(0, index));
      values.push(part.substring(index + 1));
    }
  }
  return {keys: keys, values: values};
};


/**
 * A static default instance.
 * @type {goog.net.Cookies}
 */
goog.net.cookies = new goog.net.Cookies(document);


/**
 * Define the constant on the instance in order not to break many references to
 * it.
 * @type {number}
 * @deprecated Use goog.net.Cookies.MAX_COOKIE_LENGTH instead.
 */
goog.net.cookies.MAX_COOKIE_LENGTH = goog.net.Cookies.MAX_COOKIE_LENGTH;

//ipc/invalidation/javascript/utils/firstpartyauth.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview First-party auth utilities.  The mechanism is described in:
 *     https://docs.google.com/a/google.com/document/d/1AtqrIhatutQEJG8HVEqCKyRvgeFMtQwFFw_xsQRu2Ck/edit
 *     Code fragments taken from:
 *     googledata/java/gadgets/features/auth_firstparty/firstparty.js and
 *     <p>
 *     Adapted to work in a standalone way (without Apiary or any dynamically-
 *     served gadget code).  Implementation tested against Gaia Mint.
 *
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('invalidation.FirstPartyAuth');

goog.require('goog.crypt');
goog.require('goog.crypt.Sha1');
goog.require('goog.net.Cookies');

/**
 * Names of authentication cookies and related strings.
 * @enum {string}
 */
invalidation.FirstPartyAuth.Constants = {

  /** Name of the gaia auth cookie. */
  SESSION_COOKIE_NAME: 'SID',

  /** Name of the gaia API session cookie for secure connections. */
  SECURE_API_SESSION_COOKIE_NAME: 'SAPISID',

  /** Name of authorization scheme for secure first-party authentication. */
  SECURE_FIRST_PARTY_AUTH_SCHEME: 'SAPISIDHASH',

  /** Name of the gaia API session cookie for unsecured connections. */
  UNSECURED_API_SESSION_COOKIE_NAME: 'APISID',

  /** Name of authorization scheme for unsecured first-party authentication. */
  UNSECURED_FIRST_PARTY_AUTH_SCHEME: 'APISIDHASH',

  /**
   * Name of the global flag to override SID cookie check for whether or not the
   * user has logged in. This is needed for +1 Chrome extension, because it
   * cannot set cookie in incognito mode.
   */
  OVERRIDE_SID_VAR: '__OVERRIDE_SID',

  /**
   * Name of the global flag to override the SAPISID cookie. This is needed for
   * Chrome extensions using OAuth 2 so that they can avoid being confused by
   * cookies from the domains whose cookies they read.
   */
  OVERRIDE_SECURE_API_SESSION_COOKIE_VAR: '__SAPISID',

  /**
   * Name of the global flag to override the APISID cookie. This is needed for
   * Chrome extensions using OAuth 2 so that they can avoid being confused by
   * cookies from the domains whose cookies they read.
   */
  OVERRIDE_UNSECURED_API_SESSION_COOKIE_VAR: '__APISID'
};


/**
 * If the user appears to be logged in, this will return an array containing the
 * first-party authentication scheme to use, along with the API session cookie
 * hash for that scheme.
 * @param {string} origin The origin of the host page.
 * @return {{scheme: string, hash: string}|null} A record containing the
 *     authentication scheme and hash, or {@code null} if the required
 *     cookies/variables were absent.
 */
invalidation.FirstPartyAuth.getFirstPartyAuthSchemeAndHash = function(origin) {
  var cookies = new goog.net.Cookies(document);

  // First check for the variable used to override the SID cookie.
  var sessionCookie =
      window[invalidation.FirstPartyAuth.Constants.OVERRIDE_SID_VAR];

  // If it's not present, check for the SID cookie itself.
  if (sessionCookie == null) {
    sessionCookie =
        cookies.get(invalidation.FirstPartyAuth.Constants.SESSION_COOKIE_NAME);
  }

  // Only compute a first-party authentication header if there's an SID cookie.
  // (Otherwise the user isn't signed in at all.)
  if (!sessionCookie) {
    return null;
  }

  // Determine whether the page is using https.  If so, we'll use the secure
  // API session cookie (SAPISID).  This should always be the case for
  // production use.
  var isSecure = (origin.indexOf('https:') == 0 ||
      origin.indexOf('chrome-extension:') == 0);
  var apiSessionCookieName = (isSecure ?
      invalidation.FirstPartyAuth.Constants.SECURE_API_SESSION_COOKIE_NAME :
      invalidation.FirstPartyAuth.Constants.
      UNSECURED_API_SESSION_COOKIE_NAME);

  // As with the SID, first check for the variable that overrides the API
  // session cookie for Chrome extensions.
  var apiSessionCookieValue = (isSecure ?
      window[invalidation.FirstPartyAuth.Constants.
          OVERRIDE_SECURE_API_SESSION_COOKIE_VAR] :
      window[invalidation.FirstPartyAuth.Constants.
          OVERRIDE_UNSECURED_API_SESSION_COOKIE_VAR]);

  // If the variable isn't present, use the actual cookie.
  if (apiSessionCookieValue == null) {
    apiSessionCookieValue = cookies.get(apiSessionCookieName);
  }

  // If we have an API session cookie value, compute the SHA-1 hash of:
  // "<origin> <cookie>" as specified in the API session cookie design doc
  // referenced in the file jsdoc above.  Return an array with the auth scheme
  // and hash.
  if (apiSessionCookieValue) {
    var authScheme = (isSecure ?
        invalidation.FirstPartyAuth.Constants.SECURE_FIRST_PARTY_AUTH_SCHEME :
        invalidation.FirstPartyAuth.Constants.
            UNSECURED_FIRST_PARTY_AUTH_SCHEME);
    var sha1 = new goog.crypt.Sha1();
    sha1.reset();
    sha1.update([apiSessionCookieValue, origin].join(' '));
    var digestString = goog.crypt.byteArrayToHex(sha1.digest());
    return {
      scheme: authScheme,
      hash: digestString.toLowerCase()
    };
  } else {
    return null;
  }
};

//buzz/channel/javascript/internal/browserchannelutil.js
/**
 * @fileoverview A class for detecting whether the current browser has
 * particular features.  Copied from
 * //javascript/apps/docs/net/browserchannelutil.js and stripped to remove
 * docs dependencies, which would otherwise result in a dependency cycle
 * with Tango and Buzz.  Also modified to use a different cookie from the
 * one docs uses, and to use a smaller set of subdomains.
 *
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('buzz.channel.BrowserChannelUtil');

/**
 * Name of the cookie holding the last used subdomain.  Short for 'last LCS
 * browser channel subdomain'.
 * @const {string}
 * @private
 */
buzz.channel.BrowserChannelUtil.SUBDOMAIN_COOKIE_NAME_ = 'llbcs';


/**
 * The maximum number of allowable subdomains before we start reusing them.
 * @const {number}
 * @private
 */
buzz.channel.BrowserChannelUtil.SUBDOMAIN_COUNT_ = 30;


/**
 * The host prefix, if it has been generated.
 * @type {?string}
 * @private
 */
buzz.channel.BrowserChannelUtil.hostPrefix_ = null;


/**
 * Returns the appropriate browser channel host prefix to use for this session.
 * It checks for spdy, in which case it always uses the same prefix.
 * In all other situations it generates the host prefix from a cookie:
 * 1. Read the last host prefix cookie,
 * 2. increment its value,
 * 2. update the cookie.
 * Return the host prefix thus reserved.
 * @return {?string} The appropriate host prefix for this session.
 * @private
 */
buzz.channel.BrowserChannelUtil.getHostPrefixInternal_ = function() {
  // If we're using SPDY, there are no effective connection limits, as SPDY will
  // multiplex all connections to a given host name into one TCP connection.
  // Using rotating subdomains where SPDY is present can actually cause a bug,
  // as forcing different hostnames can force different TCP connections.  These
  // are long lived, may be kept open speculatively, and can be exhausted.  A
  // chrome-specific client side API is used to check whether we're using SPDY.
  if (buzz.channel.BrowserChannelUtil.isChromeAndUsesSpdy()) {
    return '0';
  }

  // Otherwise, use a local cookie to decide which subdomain to use.
  var lastPrefix = parseInt(goog.net.cookies.get(
      buzz.channel.BrowserChannelUtil.SUBDOMAIN_COOKIE_NAME_, '-1'), 10);
  if (isNaN(lastPrefix)) {
    lastPrefix = -1;
  }
  var nextPrefix = ((lastPrefix + 1) %
      buzz.channel.BrowserChannelUtil.SUBDOMAIN_COUNT_).toString();
  goog.net.cookies.set(buzz.channel.BrowserChannelUtil.SUBDOMAIN_COOKIE_NAME_,
                       nextPrefix, -1 /* session cookie */, '/' /* path */,
                       undefined /* use current hostname */,
                       false /* not secure */);
  return nextPrefix;
};


/**
 * Determines which host name prefix to use, if any.
 * Uses a lazily generated static value, all requests in the same
 * JS context will yield the same value.
 * @return {?string} The host name prefix to use, or null for none.
 */
buzz.channel.BrowserChannelUtil.getHostPrefix = function() {
  if (!buzz.channel.BrowserChannelUtil.hostPrefix_) {
    buzz.channel.BrowserChannelUtil.hostPrefix_ =
        buzz.channel.BrowserChannelUtil.getHostPrefixInternal_();
  }
  return buzz.channel.BrowserChannelUtil.hostPrefix_;
};


/**
 * Uses a Chrome-specific API to detect whether the current window was served
 * via SPDY.
 * @return {boolean} Whether this browser is Chrome, and the current window was
 *     served using SPDY.
 */
buzz.channel.BrowserChannelUtil.isChromeAndUsesSpdy = function() {
  try {
    return !!goog.global['chrome']['loadTimes']()['wasFetchedViaSpdy'];
  } catch (e) {
    return false;
  }
};

//buzz/channel/javascript/internal/channelconfigimpl.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Config for Marmoset browser channel.
 *
 * @author xiaolan@google.com (Joy Zhang)
 */

goog.provide('buzz.channel.ChannelConfigImpl');

goog.require('buzz.channel.BrowserChannelUtil');
goog.require('buzz.channel.ChannelConfig');
goog.require('goog.Uri');
goog.require('goog.structs.Set');
goog.require('invalidation.FirstPartyAuth');

/**
 * Construct a config class for Marmoset browser channel.
 * @param {string} uriStr The address to which to connect. This is a fully
 *     qualified path to the iframe if xpc is used. Or it is a relative path if
 *     not. Must be on the same domain as the one from which this script was
 *     downloaded.
 * @param {string} clientType Client type value (must less than 16 characters).
 * @param {boolean} serverAssignsSessionName Whether to allow the server to
 *     assign our session names.
 * @param {number=} opt_authuser Optional authuser parameter for the channel
 *     (indicates which session to use for multi-login).
 * @param {string=} opt_gaiaServiceOverride Optional Gaia service name override
 *     (for applications and domains where Talk may be disabled).
 * @implements {buzz.channel.ChannelConfig}
 * @constructor
 */
buzz.channel.ChannelConfigImpl = function(uriStr, clientType,
    serverAssignsSessionName, opt_authuser, opt_gaiaServiceOverride) {
  var uri = new goog.Uri(uriStr);
  var domain = uri.getDomain();

  // Add a domain prefix if we're connecting to the production domain.
  if (domain == buzz.channel.ChannelConfig.PRODUCTION_DOMAIN) {
    var subdomain = buzz.channel.BrowserChannelUtil.getHostPrefix();
    if (subdomain) {
      uri.setDomain(subdomain + '.' + domain);
    }
  }

  /**
   * The base uri for the browser channel iframe if iframe is used.
   * Otherwise, it is the base URL of the browser channel service to which to
   * connect, which may be specified relative to the location of the page
   * containing this script.
   * @type {goog.Uri}
   * @private
   */
  this.uri_ = uri;

  /**
   * The optional authuser parameter for browser channel requests.
   * @type {?number}
   * @private
   */
  this.authuser_ = opt_authuser || null;

  /**
   * The client type from the client.
   * @type {string}
   * @private
   */
  this.clientType_ = clientType;

  /**
   * Optional Gaia service name override (for applications and domains where
   * Talk may be disabled).
   * @type {?string}
   * @private
   */
  this.gaiaServiceOverride_ = opt_gaiaServiceOverride || null;

  /**
   * Whether to have the server assign names for sessions.
   * @type {boolean}
   * @private
   */
  this.serverAssignsSessionName_ = serverAssignsSessionName;
};


/** @return {string} The browser channel URI. */
buzz.channel.ChannelConfigImpl.prototype.getUri = function() {
  return this.uri_.toString();
};


/** @return {string} The client type. */
buzz.channel.ChannelConfigImpl.prototype.getClientType = function() {
  return this.clientType_;
};


/** @return {?number} The authuser parameter. */
buzz.channel.ChannelConfigImpl.prototype.getAuthuser = function() {
  return this.authuser_;
};


/** @return {boolean} Whether to allow the server to assign session names. */
buzz.channel.ChannelConfigImpl.prototype.getServerAssignsSessionName =
    function() {
  return this.serverAssignsSessionName_;
};


/** @return {?string} A Gaia service name override, or {@code null}. */
buzz.channel.ChannelConfigImpl.prototype.getGaiaServiceOverride = function() {
  return this.gaiaServiceOverride_;
};


/**
 * @return {!buzz.channel.proto.BrowserChannelConfig} A browser channel
 *     configuration proto with the relevant information from this object.
 */
buzz.channel.ChannelConfigImpl.prototype.toConfigProto = function() {
  return buzz.channel.CommonProtos.newBrowserChannelConfig(
      this.clientType_, this.gaiaServiceOverride_);
};


/**
 * @param {string} origin This page's origin (may be ignored by the
 *     implementation).
 * @return {{scheme: string, hash: string}|null} A record containing the scheme
 *     and hash for first-party auth.
 */
buzz.channel.ChannelConfigImpl.prototype.getFirstPartyAuthSchemeAndHash =
    function(origin) {
  return invalidation.FirstPartyAuth.getFirstPartyAuthSchemeAndHash(origin);
};

/**
 * Constructs the underlying browser channel.
 * @param {buzz.channel.BrowserChannelHandlerInterface} handler A handler for
 *     browser channel events.
 */
buzz.channel.ChannelConfigImpl.prototype.createBrowserChannel =
    goog.abstractMethod;

//javascript/closure/debug/relativetimeprovider.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition the goog.debug.RelativeTimeProvider class.
 *
 * @author jonp@google.com (Jon Perlow)
 */

goog.provide('goog.debug.RelativeTimeProvider');



/**
 * A simple object to keep track of a timestamp considered the start of
 * something. The main use is for the logger system to maintain a start time
 * that is occasionally reset. For example, in Gmail, we reset this relative
 * time at the start of a user action so that timings are offset from the
 * beginning of the action. This class also provides a singleton as the default
 * behavior for most use cases is to share the same start time.
 *
 * @constructor
 * @final
 */
goog.debug.RelativeTimeProvider = function() {
  /**
   * The start time.
   * @type {number}
   * @private
   */
  this.relativeTimeStart_ = goog.now();
};


/**
 * Default instance.
 * @type {goog.debug.RelativeTimeProvider}
 * @private
 */
goog.debug.RelativeTimeProvider.defaultInstance_ =
    new goog.debug.RelativeTimeProvider();


/**
 * Sets the start time to the specified time.
 * @param {number} timeStamp The start time.
 */
goog.debug.RelativeTimeProvider.prototype.set = function(timeStamp) {
  this.relativeTimeStart_ = timeStamp;
};


/**
 * Resets the start time to now.
 */
goog.debug.RelativeTimeProvider.prototype.reset = function() {
  this.set(goog.now());
};


/**
 * @return {number} The start time.
 */
goog.debug.RelativeTimeProvider.prototype.get = function() {
  return this.relativeTimeStart_;
};


/**
 * @return {goog.debug.RelativeTimeProvider} The default instance.
 */
goog.debug.RelativeTimeProvider.getDefaultInstance = function() {
  return goog.debug.RelativeTimeProvider.defaultInstance_;
};

//javascript/closure/debug/formatter.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of various formatters for logging. Please minimize
 * dependencies this file has on other closure classes as any dependency it
 * takes won't be able to use the logging infrastructure.
 *
 * @author jonp@google.com (Jon Perlow)
 */

goog.provide('goog.debug.Formatter');
goog.provide('goog.debug.HtmlFormatter');
goog.provide('goog.debug.TextFormatter');

goog.require('goog.debug.RelativeTimeProvider');
goog.require('goog.string');



/**
 * Base class for Formatters. A Formatter is used to format a LogRecord into
 * something that can be displayed to the user.
 *
 * @param {string=} opt_prefix The prefix to place before text records.
 * @constructor
 */
goog.debug.Formatter = function(opt_prefix) {
  this.prefix_ = opt_prefix || '';

  /**
   * A provider that returns the relative start time.
   * @type {goog.debug.RelativeTimeProvider}
   * @private
   */
  this.startTimeProvider_ =
      goog.debug.RelativeTimeProvider.getDefaultInstance();
};


/**
 * Whether to append newlines to the end of formatted log records.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.appendNewline = true;


/**
 * Whether to show absolute time in the DebugWindow.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.showAbsoluteTime = true;


/**
 * Whether to show relative time in the DebugWindow.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.showRelativeTime = true;


/**
 * Whether to show the logger name in the DebugWindow.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.showLoggerName = true;


/**
 * Whether to show the logger exception text.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.showExceptionText = false;


/**
 * Whether to show the severity level.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.showSeverityLevel = false;


/**
 * Formats a record.
 * @param {goog.debug.LogRecord} logRecord the logRecord to format.
 * @return {string} The formatted string.
 */
goog.debug.Formatter.prototype.formatRecord = goog.abstractMethod;


/**
 * Sets the start time provider. By default, this is the default instance
 * but can be changed.
 * @param {goog.debug.RelativeTimeProvider} provider The provider to use.
 */
goog.debug.Formatter.prototype.setStartTimeProvider = function(provider) {
  this.startTimeProvider_ = provider;
};


/**
 * Returns the start time provider. By default, this is the default instance
 * but can be changed.
 * @return {goog.debug.RelativeTimeProvider} The start time provider.
 */
goog.debug.Formatter.prototype.getStartTimeProvider = function() {
  return this.startTimeProvider_;
};


/**
 * Resets the start relative time.
 */
goog.debug.Formatter.prototype.resetRelativeTimeStart = function() {
  this.startTimeProvider_.reset();
};


/**
 * Returns a string for the time/date of the LogRecord.
 * @param {goog.debug.LogRecord} logRecord The record to get a time stamp for.
 * @return {string} A string representation of the time/date of the LogRecord.
 * @private
 */
goog.debug.Formatter.getDateTimeStamp_ = function(logRecord) {
  var time = new Date(logRecord.getMillis());
  return goog.debug.Formatter.getTwoDigitString_((time.getFullYear() - 2000)) +
         goog.debug.Formatter.getTwoDigitString_((time.getMonth() + 1)) +
         goog.debug.Formatter.getTwoDigitString_(time.getDate()) + ' ' +
         goog.debug.Formatter.getTwoDigitString_(time.getHours()) + ':' +
         goog.debug.Formatter.getTwoDigitString_(time.getMinutes()) + ':' +
         goog.debug.Formatter.getTwoDigitString_(time.getSeconds()) + '.' +
         goog.debug.Formatter.getTwoDigitString_(
             Math.floor(time.getMilliseconds() / 10));
};


/**
 * Returns the number as a two-digit string, meaning it prepends a 0 if the
 * number if less than 10.
 * @param {number} n The number to format.
 * @return {string} A two-digit string representation of {@code n}.
 * @private
 */
goog.debug.Formatter.getTwoDigitString_ = function(n) {
  if (n < 10) {
    return '0' + n;
  }
  return String(n);
};


/**
 * Returns a string for the number of seconds relative to the start time.
 * Prepads with spaces so that anything less than 1000 seconds takes up the
 * same number of characters for better formatting.
 * @param {goog.debug.LogRecord} logRecord The log to compare time to.
 * @param {number} relativeTimeStart The start time to compare to.
 * @return {string} The number of seconds of the LogRecord relative to the
 *     start time.
 * @private
 */
goog.debug.Formatter.getRelativeTime_ = function(logRecord,
                                                 relativeTimeStart) {
  var ms = logRecord.getMillis() - relativeTimeStart;
  var sec = ms / 1000;
  var str = sec.toFixed(3);

  var spacesToPrepend = 0;
  if (sec < 1) {
    spacesToPrepend = 2;
  } else {
    while (sec < 100) {
      spacesToPrepend++;
      sec *= 10;
    }
  }
  while (spacesToPrepend-- > 0) {
    str = ' ' + str;
  }
  return str;
};



/**
 * Formatter that returns formatted html. See formatRecord for the classes
 * it uses for various types of formatted output.
 *
 * @param {string=} opt_prefix The prefix to place before text records.
 * @constructor
 * @extends {goog.debug.Formatter}
 */
goog.debug.HtmlFormatter = function(opt_prefix) {
  goog.debug.Formatter.call(this, opt_prefix);
};
goog.inherits(goog.debug.HtmlFormatter, goog.debug.Formatter);


/**
 * Whether to show the logger exception text
 * @type {boolean}
 * @override
 */
goog.debug.HtmlFormatter.prototype.showExceptionText = true;


/**
 * Formats a record
 * @param {goog.debug.LogRecord} logRecord the logRecord to format.
 * @return {string} The formatted string as html.
 * @override
 */
goog.debug.HtmlFormatter.prototype.formatRecord = function(logRecord) {
  var className;
  switch (logRecord.getLevel().value) {
    case goog.debug.Logger.Level.SHOUT.value:
      className = 'dbg-sh';
      break;
    case goog.debug.Logger.Level.SEVERE.value:
      className = 'dbg-sev';
      break;
    case goog.debug.Logger.Level.WARNING.value:
      className = 'dbg-w';
      break;
    case goog.debug.Logger.Level.INFO.value:
      className = 'dbg-i';
      break;
    case goog.debug.Logger.Level.FINE.value:
    default:
      className = 'dbg-f';
      break;
  }

  // Build message html
  var sb = [];
  sb.push(this.prefix_, ' ');
  if (this.showAbsoluteTime) {
    sb.push('[', goog.debug.Formatter.getDateTimeStamp_(logRecord), '] ');
  }
  if (this.showRelativeTime) {
    sb.push('[',
        goog.string.whitespaceEscape(
            goog.debug.Formatter.getRelativeTime_(logRecord,
                this.startTimeProvider_.get())),
        's] ');
  }

  if (this.showLoggerName) {
    sb.push('[', goog.string.htmlEscape(logRecord.getLoggerName()), '] ');
  }
  if (this.showSeverityLevel) {
    sb.push('[', goog.string.htmlEscape(logRecord.getLevel().name), '] ');
  }
  sb.push('<span class="', className, '">',
      goog.string.newLineToBr(goog.string.whitespaceEscape(
          goog.string.htmlEscape(logRecord.getMessage()))));

  if (this.showExceptionText && logRecord.getException()) {
    sb.push('<br>',
        goog.string.newLineToBr(goog.string.whitespaceEscape(
            logRecord.getExceptionText() || '')));
  }
  sb.push('</span>');
  if (this.appendNewline) {
    sb.push('<br>');
  }

  return sb.join('');
};



/**
 * Formatter that returns formatted plain text
 *
 * @param {string=} opt_prefix The prefix to place before text records.
 * @constructor
 * @extends {goog.debug.Formatter}
 * @final
 */
goog.debug.TextFormatter = function(opt_prefix) {
  goog.debug.Formatter.call(this, opt_prefix);
};
goog.inherits(goog.debug.TextFormatter, goog.debug.Formatter);


/**
 * Formats a record as text
 * @param {goog.debug.LogRecord} logRecord the logRecord to format.
 * @return {string} The formatted string.
 * @override
 */
goog.debug.TextFormatter.prototype.formatRecord = function(logRecord) {
  // Build message html
  var sb = [];
  sb.push(this.prefix_, ' ');
  if (this.showAbsoluteTime) {
    sb.push('[', goog.debug.Formatter.getDateTimeStamp_(logRecord), '] ');
  }
  if (this.showRelativeTime) {
    sb.push('[', goog.debug.Formatter.getRelativeTime_(logRecord,
        this.startTimeProvider_.get()), 's] ');
  }

  if (this.showLoggerName) {
    sb.push('[', logRecord.getLoggerName(), '] ');
  }
  if (this.showSeverityLevel) {
    sb.push('[', logRecord.getLevel().name, '] ');
  }
  sb.push(logRecord.getMessage());
  if (this.showExceptionText && logRecord.getException()) {
    sb.push('\n', logRecord.getExceptionText());
  }
  if (this.appendNewline) {
    sb.push('\n');
  }
  return sb.join('');
};

//javascript/closure/string/parser.js
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * @fileoverview Defines an interface for parsing strings into objects.
 * @author zachlloyd@google.com (Zachary Lloyd)
 */

goog.provide('goog.string.Parser');



/**
 * An interface for parsing strings into objects.
 * @interface
 */
goog.string.Parser = function() {};


/**
 * Parses a string into an object and returns the result.
 * Agnostic to the format of string and object.
 *
 * @param {string} s The string to parse.
 * @return {*} The object generated from the string.
 */
goog.string.Parser.prototype.parse;

//javascript/closure/string/stringifier.js
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * @fileoverview Defines an interface for serializing objects into strings.
 * @author zachlloyd@google.com (Zachary Lloyd)
 */

goog.provide('goog.string.Stringifier');



/**
 * An interface for serializing objects into strings.
 * @interface
 */
goog.string.Stringifier = function() {};


/**
 * Serializes an object or a value to a string.
 * Agnostic to the particular format of object and string.
 *
 * @param {*} object The object to stringify.
 * @return {string} A string representation of the input.
 */
goog.string.Stringifier.prototype.stringify;

//javascript/closure/json/processor.js
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * @fileoverview Defines an interface for JSON parsing and serialization.
 * @author zachlloyd@google.com (Zachary Lloyd)
 */

goog.provide('goog.json.Processor');

goog.require('goog.string.Parser');
goog.require('goog.string.Stringifier');



/**
 * An interface for JSON parsing and serialization.
 * @interface
 * @extends {goog.string.Parser}
 * @extends {goog.string.Stringifier}
 */
goog.json.Processor = function() {};

//javascript/closure/json/evaljsonprocessor.js
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * @fileoverview Defines a class for parsing JSON using eval.
 * @author zachlloyd@google.com (Zachary Lloyd)
 */

goog.provide('goog.json.EvalJsonProcessor');

goog.require('goog.json');
goog.require('goog.json.Processor');
goog.require('goog.json.Serializer');



/**
 * A class that parses and stringifies JSON using eval (as implemented in
 * goog.json).
 * Adapts {@code goog.json} to the {@code goog.json.Processor} interface.
 *
 * @param {?goog.json.Replacer=} opt_replacer An optional replacer to use during
 *     serialization.
 * @param {?boolean=} opt_useUnsafeParsing Whether to use goog.json.unsafeParse
 *     for parsing. Safe parsing is very slow on large strings. On the other
 *     hand, unsafe parsing uses eval() without checking whether the string is
 *     valid, so it should only be used if you trust the source of the string.
 * @constructor
 * @implements {goog.json.Processor}
 * @final
 */
goog.json.EvalJsonProcessor = function(opt_replacer, opt_useUnsafeParsing) {
  /**
   * @type {goog.json.Serializer}
   * @private
   */
  this.serializer_ = new goog.json.Serializer(opt_replacer);

  /**
   * @type {function(string): *}
   * @private
   */
  this.parser_ = opt_useUnsafeParsing ? goog.json.unsafeParse : goog.json.parse;
};


/** @override */
goog.json.EvalJsonProcessor.prototype.stringify = function(object) {
  return this.serializer_.serialize(object);
};


/** @override */
goog.json.EvalJsonProcessor.prototype.parse = function(s) {
  return this.parser_(s);
};

//javascript/closure/structs/circularbuffer.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * @fileoverview Datastructure: Circular Buffer.
 *
 * Implements a buffer with a maximum size. New entries override the oldest
 * entries when the maximum size has been reached.
 *
 * @author jonp@google.com (Jon Perlow)
 */


goog.provide('goog.structs.CircularBuffer');



/**
 * Class for CircularBuffer.
 * @param {number=} opt_maxSize The maximum size of the buffer.
 * @constructor
 * @template T
 */
goog.structs.CircularBuffer = function(opt_maxSize) {
  /**
   * Index of the next element in the circular array structure.
   * @private {number}
   */
  this.nextPtr_ = 0;

  /**
   * Maximum size of the the circular array structure.
   * @private {number}
   */
  this.maxSize_ = opt_maxSize || 100;

  /**
   * Underlying array for the CircularBuffer.
   * @private {!Array.<T>}
   */
  this.buff_ = [];
};


/**
 * Adds an item to the buffer. May remove the oldest item if the buffer is at
 * max size.
 * @param {T} item The item to add.
 * @return {T|undefined} The removed old item, if the buffer is at max size.
 *     Return undefined, otherwise.
 */
goog.structs.CircularBuffer.prototype.add = function(item) {
  var previousItem = this.buff_[this.nextPtr_];
  this.buff_[this.nextPtr_] = item;
  this.nextPtr_ = (this.nextPtr_ + 1) % this.maxSize_;
  return previousItem;
};


/**
 * Returns the item at the specified index.
 * @param {number} index The index of the item. The index of an item can change
 *     after calls to {@code add()} if the buffer is at maximum size.
 * @return {T} The item at the specified index.
 */
goog.structs.CircularBuffer.prototype.get = function(index) {
  index = this.normalizeIndex_(index);
  return this.buff_[index];
};


/**
 * Sets the item at the specified index.
 * @param {number} index The index of the item. The index of an item can change
 *     after calls to {@code add()} if the buffer is at maximum size.
 * @param {T} item The item to add.
 */
goog.structs.CircularBuffer.prototype.set = function(index, item) {
  index = this.normalizeIndex_(index);
  this.buff_[index] = item;
};


/**
 * Returns the current number of items in the buffer.
 * @return {number} The current number of items in the buffer.
 */
goog.structs.CircularBuffer.prototype.getCount = function() {
  return this.buff_.length;
};


/**
 * @return {boolean} Whether the buffer is empty.
 */
goog.structs.CircularBuffer.prototype.isEmpty = function() {
  return this.buff_.length == 0;
};


/**
 * Empties the current buffer.
 */
goog.structs.CircularBuffer.prototype.clear = function() {
  this.buff_.length = 0;
  this.nextPtr_ = 0;
};


/** @return {!Array.<T>} The values in the buffer. */
goog.structs.CircularBuffer.prototype.getValues = function() {
  // getNewestValues returns all the values if the maxCount parameter is the
  // count
  return this.getNewestValues(this.getCount());
};


/**
 * Returns the newest values in the buffer up to {@code count}.
 * @param {number} maxCount The maximum number of values to get. Should be a
 *     positive number.
 * @return {!Array.<T>} The newest values in the buffer up to {@code count}.
 */
goog.structs.CircularBuffer.prototype.getNewestValues = function(maxCount) {
  var l = this.getCount();
  var start = this.getCount() - maxCount;
  var rv = [];
  for (var i = start; i < l; i++) {
    rv.push(this.get(i));
  }
  return rv;
};


/** @return {!Array.<number>} The indexes in the buffer. */
goog.structs.CircularBuffer.prototype.getKeys = function() {
  var rv = [];
  var l = this.getCount();
  for (var i = 0; i < l; i++) {
    rv[i] = i;
  }
  return rv;
};


/**
 * Whether the buffer contains the key/index.
 * @param {number} key The key/index to check for.
 * @return {boolean} Whether the buffer contains the key/index.
 */
goog.structs.CircularBuffer.prototype.containsKey = function(key) {
  return key < this.getCount();
};


/**
 * Whether the buffer contains the given value.
 * @param {T} value The value to check for.
 * @return {boolean} Whether the buffer contains the given value.
 */
goog.structs.CircularBuffer.prototype.containsValue = function(value) {
  var l = this.getCount();
  for (var i = 0; i < l; i++) {
    if (this.get(i) == value) {
      return true;
    }
  }
  return false;
};


/**
 * Returns the last item inserted into the buffer.
 * @return {T|null} The last item inserted into the buffer,
 *     or null if the buffer is empty.
 */
goog.structs.CircularBuffer.prototype.getLast = function() {
  if (this.getCount() == 0) {
    return null;
  }
  return this.get(this.getCount() - 1);
};


/**
 * Helper function to convert an index in the number space of oldest to
 * newest items in the array to the position that the element will be at in the
 * underlying array.
 * @param {number} index The index of the item in a list ordered from oldest to
 *     newest.
 * @return {number} The index of the item in the CircularBuffer's underlying
 *     array.
 * @private
 */
goog.structs.CircularBuffer.prototype.normalizeIndex_ = function(index) {
  if (index >= this.buff_.length) {
    throw Error('Out of bounds exception');
  }

  if (this.buff_.length < this.maxSize_) {
    return index;
  }

  return (this.nextPtr_ + Number(index)) % this.maxSize_;
};

//javascript/closure/async/throttle.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the goog.async.Throttle class.
 *
 * @author jonp@google.com (Jon Perlow)
 * @author mpd@google.com (Michael Davidson)
 * @see ../demos/timers.html
 */

goog.provide('goog.Throttle');
goog.provide('goog.async.Throttle');

goog.require('goog.Disposable');
goog.require('goog.Timer');



/**
 * Throttle will perform an action that is passed in no more than once
 * per interval (specified in milliseconds). If it gets multiple signals
 * to perform the action while it is waiting, it will only perform the action
 * once at the end of the interval.
 * @param {Function} listener Function to callback when the action is triggered.
 * @param {number} interval Interval over which to throttle. The handler can
 *     only be called once per interval.
 * @param {Object=} opt_handler Object in whose scope to call the listener.
 * @constructor
 * @extends {goog.Disposable}
 * @final
 */
goog.async.Throttle = function(listener, interval, opt_handler) {
  goog.Disposable.call(this);

  /**
   * Function to callback
   * @type {Function}
   * @private
   */
  this.listener_ = listener;

  /**
   * Interval for the throttle time
   * @type {number}
   * @private
   */
  this.interval_ = interval;

  /**
   * "this" context for the listener
   * @type {Object|undefined}
   * @private
   */
  this.handler_ = opt_handler;

  /**
   * Cached callback function invoked after the throttle timeout completes
   * @type {Function}
   * @private
   */
  this.callback_ = goog.bind(this.onTimer_, this);
};
goog.inherits(goog.async.Throttle, goog.Disposable);



/**
 * A deprecated alias.
 * @deprecated Use goog.async.Throttle instead.
 * @constructor
 * @final
 */
goog.Throttle = goog.async.Throttle;


/**
 * Indicates that the action is pending and needs to be fired.
 * @type {boolean}
 * @private
 */
goog.async.Throttle.prototype.shouldFire_ = false;


/**
 * Indicates the count of nested pauses currently in effect on the throttle.
 * When this count is not zero, fired actions will be postponed until the
 * throttle is resumed enough times to drop the pause count to zero.
 * @type {number}
 * @private
 */
goog.async.Throttle.prototype.pauseCount_ = 0;


/**
 * Timer for scheduling the next callback
 * @type {?number}
 * @private
 */
goog.async.Throttle.prototype.timer_ = null;


/**
 * Notifies the throttle that the action has happened. It will throttle the call
 * so that the callback is not called too often according to the interval
 * parameter passed to the constructor.
 */
goog.async.Throttle.prototype.fire = function() {
  if (!this.timer_ && !this.pauseCount_) {
    this.doAction_();
  } else {
    this.shouldFire_ = true;
  }
};


/**
 * Cancels any pending action callback. The throttle can be restarted by
 * calling {@link #fire}.
 */
goog.async.Throttle.prototype.stop = function() {
  if (this.timer_) {
    goog.Timer.clear(this.timer_);
    this.timer_ = null;
    this.shouldFire_ = false;
  }
};


/**
 * Pauses the throttle.  All pending and future action callbacks will be
 * delayed until the throttle is resumed.  Pauses can be nested.
 */
goog.async.Throttle.prototype.pause = function() {
  this.pauseCount_++;
};


/**
 * Resumes the throttle.  If doing so drops the pausing count to zero, pending
 * action callbacks will be executed as soon as possible, but still no sooner
 * than an interval's delay after the previous call.  Future action callbacks
 * will be executed as normal.
 */
goog.async.Throttle.prototype.resume = function() {
  this.pauseCount_--;
  if (!this.pauseCount_ && this.shouldFire_ && !this.timer_) {
    this.shouldFire_ = false;
    this.doAction_();
  }
};


/** @override */
goog.async.Throttle.prototype.disposeInternal = function() {
  goog.async.Throttle.superClass_.disposeInternal.call(this);
  this.stop();
};


/**
 * Handler for the timer to fire the throttle
 * @private
 */
goog.async.Throttle.prototype.onTimer_ = function() {
  this.timer_ = null;

  if (this.shouldFire_ && !this.pauseCount_) {
    this.shouldFire_ = false;
    this.doAction_();
  }
};


/**
 * Calls the callback
 * @private
 */
goog.async.Throttle.prototype.doAction_ = function() {
  this.timer_ = goog.Timer.callOnce(this.callback_, this.interval_);
  this.listener_.call(this.handler_);
};

//javascript/closure/net/channelrequest.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the ChannelRequest class. The ChannelRequest
 * object encapsulates the logic for making a single request, either for the
 * forward channel, back channel, or test channel, to the server. It contains
 * the logic for the three types of transports we use in the BrowserChannel:
 * XMLHTTP, Trident ActiveX (ie only), and Image request. It provides timeout
 * detection. This class is part of the BrowserChannel implementation and is not
 * for use by normal application code.
 *
 * @author jonp@google.com (Jon Perlow)
 */


goog.provide('goog.net.ChannelRequest');
goog.provide('goog.net.ChannelRequest.Error');

goog.require('goog.Timer');
goog.require('goog.async.Throttle');
goog.require('goog.events.EventHandler');
goog.require('goog.net.ErrorCode');
goog.require('goog.net.EventType');
goog.require('goog.net.XmlHttp');
goog.require('goog.object');
goog.require('goog.userAgent');

// TODO(nnaze): This file depends on goog.net.BrowserChannel and vice versa (a
// circular dependency).  Usages of BrowserChannel are marked as
// "missingRequire" below for now.  This should be fixed through refactoring.



/**
 * Creates a ChannelRequest object which encapsulates a request to the server.
 * A new ChannelRequest is created for each request to the server.
 *
 * @param {goog.net.BrowserChannel|goog.net.BrowserTestChannel} channel
 *     The BrowserChannel that owns this request.
 * @param {goog.net.ChannelDebug} channelDebug A ChannelDebug to use for
 *     logging.
 * @param {string=} opt_sessionId  The session id for the channel.
 * @param {string|number=} opt_requestId  The request id for this request.
 * @param {number=} opt_retryId  The retry id for this request.
 * @constructor
 */
goog.net.ChannelRequest = function(channel, channelDebug, opt_sessionId,
    opt_requestId, opt_retryId) {
  /**
   * The BrowserChannel object that owns the request.
   * @type {goog.net.BrowserChannel|goog.net.BrowserTestChannel}
   * @private
   */
  this.channel_ = channel;

  /**
   * The channel debug to use for logging
   * @type {goog.net.ChannelDebug}
   * @private
   */
  this.channelDebug_ = channelDebug;

  /**
   * The Session ID for the channel.
   * @type {string|undefined}
   * @private
   */
  this.sid_ = opt_sessionId;

  /**
   * The RID (request ID) for the request.
   * @type {string|number|undefined}
   * @private
   */
  this.rid_ = opt_requestId;


  /**
   * The attempt number of the current request.
   * @type {number}
   * @private
   */
  this.retryId_ = opt_retryId || 1;


  /**
   * The timeout in ms before failing the request.
   * @type {number}
   * @private
   */
  this.timeout_ = goog.net.ChannelRequest.TIMEOUT_MS;

  /**
   * An object to keep track of the channel request event listeners.
   * @type {!goog.events.EventHandler}
   * @private
   */
  this.eventHandler_ = new goog.events.EventHandler(this);

  /**
   * A timer for polling responseText in browsers that don't fire
   * onreadystatechange during incremental loading of responseText.
   * @type {goog.Timer}
   * @private
   */
  this.pollingTimer_ = new goog.Timer();

  this.pollingTimer_.setInterval(goog.net.ChannelRequest.POLLING_INTERVAL_MS);
};


/**
 * Extra HTTP headers to add to all the requests sent to the server.
 * @type {Object}
 * @private
 */
goog.net.ChannelRequest.prototype.extraHeaders_ = null;


/**
 * Whether the request was successful. This is only set to true after the
 * request successfuly completes.
 * @type {boolean}
 * @private
 */
goog.net.ChannelRequest.prototype.successful_ = false;


/**
 * The TimerID of the timer used to detect if the request has timed-out.
 * @type {?number}
 * @private
 */
goog.net.ChannelRequest.prototype.watchDogTimerId_ = null;


/**
 * The time in the future when the request will timeout.
 * @type {?number}
 * @private
 */
goog.net.ChannelRequest.prototype.watchDogTimeoutTime_ = null;


/**
 * The time the request started.
 * @type {?number}
 * @private
 */
goog.net.ChannelRequest.prototype.requestStartTime_ = null;


/**
 * The type of request (XMLHTTP, IMG, Trident)
 * @type {?number}
 * @private
 */
goog.net.ChannelRequest.prototype.type_ = null;


/**
 * The base Uri for the request. The includes all the parameters except the
 * one that indicates the retry number.
 * @type {goog.Uri?}
 * @private
 */
goog.net.ChannelRequest.prototype.baseUri_ = null;


/**
 * The request Uri that was actually used for the most recent request attempt.
 * @type {goog.Uri?}
 * @private
 */
goog.net.ChannelRequest.prototype.requestUri_ = null;


/**
 * The post data, if the request is a post.
 * @type {?string}
 * @private
 */
goog.net.ChannelRequest.prototype.postData_ = null;


/**
 * The XhrLte request if the request is using XMLHTTP
 * @type {goog.net.XhrIo}
 * @private
 */
goog.net.ChannelRequest.prototype.xmlHttp_ = null;


/**
 * The position of where the next unprocessed chunk starts in the response
 * text.
 * @type {number}
 * @private
 */
goog.net.ChannelRequest.prototype.xmlHttpChunkStart_ = 0;


/**
 * The Trident instance if the request is using Trident.
 * @type {ActiveXObject}
 * @private
 */
goog.net.ChannelRequest.prototype.trident_ = null;


/**
 * The verb (Get or Post) for the request.
 * @type {?string}
 * @private
 */
goog.net.ChannelRequest.prototype.verb_ = null;


/**
 * The last error if the request failed.
 * @type {?goog.net.ChannelRequest.Error}
 * @private
 */
goog.net.ChannelRequest.prototype.lastError_ = null;


/**
 * The last status code received.
 * @type {number}
 * @private
 */
goog.net.ChannelRequest.prototype.lastStatusCode_ = -1;


/**
 * Whether to send the Connection:close header as part of the request.
 * @type {boolean}
 * @private
 */
goog.net.ChannelRequest.prototype.sendClose_ = true;


/**
 * Whether the request has been cancelled due to a call to cancel.
 * @type {boolean}
 * @private
 */
goog.net.ChannelRequest.prototype.cancelled_ = false;


/**
 * A throttle time in ms for readystatechange events for the backchannel.
 * Useful for throttling when ready state is INTERACTIVE (partial data).
 * If set to zero no throttle is used.
 *
 * @see goog.net.BrowserChannel.prototype.readyStateChangeThrottleMs_
 *
 * @type {number}
 * @private
 */
goog.net.ChannelRequest.prototype.readyStateChangeThrottleMs_ = 0;


/**
 * The throttle for readystatechange events for the current request, or null
 * if there is none.
 * @type {goog.async.Throttle}
 * @private
 */
goog.net.ChannelRequest.prototype.readyStateChangeThrottle_ = null;


/**
 * Default timeout in MS for a request. The server must return data within this
 * time limit for the request to not timeout.
 * @type {number}
 */
goog.net.ChannelRequest.TIMEOUT_MS = 45 * 1000;


/**
 * How often to poll (in MS) for changes to responseText in browsers that don't
 * fire onreadystatechange during incremental loading of responseText.
 * @type {number}
 */
goog.net.ChannelRequest.POLLING_INTERVAL_MS = 250;


/**
 * Minimum version of Safari that receives a non-null responseText in ready
 * state interactive.
 * @type {string}
 * @private
 */
goog.net.ChannelRequest.MIN_WEBKIT_FOR_INTERACTIVE_ = '420+';


/**
 * Enum for channel requests type
 * @enum {number}
 * @private
 */
goog.net.ChannelRequest.Type_ = {
  /**
   * XMLHTTP requests.
   */
  XML_HTTP: 1,

  /**
   * IMG requests.
   */
  IMG: 2,

  /**
   * Requests that use the MSHTML ActiveX control.
   */
  TRIDENT: 3
};


/**
 * Enum type for identifying a ChannelRequest error.
 * @enum {number}
 */
goog.net.ChannelRequest.Error = {
  /**
   * Errors due to a non-200 status code.
   */
  STATUS: 0,

  /**
   * Errors due to no data being returned.
   */
  NO_DATA: 1,

  /**
   * Errors due to a timeout.
   */
  TIMEOUT: 2,

  /**
   * Errors due to the server returning an unknown.
   */
  UNKNOWN_SESSION_ID: 3,

  /**
   * Errors due to bad data being received.
   */
  BAD_DATA: 4,

  /**
   * Errors due to the handler throwing an exception.
   */
  HANDLER_EXCEPTION: 5,

  /**
   * The browser declared itself offline during the request.
   */
  BROWSER_OFFLINE: 6,

  /**
   * IE is blocking ActiveX streaming.
   */
  ACTIVE_X_BLOCKED: 7
};


/**
 * Returns a useful error string for debugging based on the specified error
 * code.
 * @param {goog.net.ChannelRequest.Error} errorCode The error code.
 * @param {number} statusCode The HTTP status code.
 * @return {string} The error string for the given code combination.
 */
goog.net.ChannelRequest.errorStringFromCode = function(errorCode, statusCode) {
  switch (errorCode) {
    case goog.net.ChannelRequest.Error.STATUS:
      return 'Non-200 return code (' + statusCode + ')';
    case goog.net.ChannelRequest.Error.NO_DATA:
      return 'XMLHTTP failure (no data)';
    case goog.net.ChannelRequest.Error.TIMEOUT:
      return 'HttpConnection timeout';
    default:
      return 'Unknown error';
  }
};


/**
 * Sentinel value used to indicate an invalid chunk in a multi-chunk response.
 * @type {Object}
 * @private
 */
goog.net.ChannelRequest.INVALID_CHUNK_ = {};


/**
 * Sentinel value used to indicate an incomplete chunk in a multi-chunk
 * response.
 * @type {Object}
 * @private
 */
goog.net.ChannelRequest.INCOMPLETE_CHUNK_ = {};


/**
 * Returns whether XHR streaming is supported on this browser.
 *
 * If XHR streaming is not supported, we will try to use an ActiveXObject
 * to create a Forever IFrame.
 *
 * @return {boolean} Whether XHR streaming is supported.
 * @see http://code.google.com/p/closure-library/issues/detail?id=346
 */
goog.net.ChannelRequest.supportsXhrStreaming = function() {
  return !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(10);
};


/**
 * Sets extra HTTP headers to add to all the requests sent to the server.
 *
 * @param {Object} extraHeaders The HTTP headers.
 */
goog.net.ChannelRequest.prototype.setExtraHeaders = function(extraHeaders) {
  this.extraHeaders_ = extraHeaders;
};


/**
 * Sets the timeout for a request
 *
 * @param {number} timeout   The timeout in MS for when we fail the request.
 */
goog.net.ChannelRequest.prototype.setTimeout = function(timeout) {
  this.timeout_ = timeout;
};


/**
 * Sets the throttle for handling onreadystatechange events for the request.
 *
 * @param {number} throttle The throttle in ms.  A value of zero indicates
 *     no throttle.
 */
goog.net.ChannelRequest.prototype.setReadyStateChangeThrottle = function(
    throttle) {
  this.readyStateChangeThrottleMs_ = throttle;
};


/**
 * Uses XMLHTTP to send an HTTP POST to the server.
 *
 * @param {goog.Uri} uri  The uri of the request.
 * @param {string} postData  The data for the post body.
 * @param {boolean} decodeChunks  Whether to the result is expected to be
 *     encoded for chunking and thus requires decoding.
 */
goog.net.ChannelRequest.prototype.xmlHttpPost = function(uri, postData,
                                                         decodeChunks) {
  this.type_ = goog.net.ChannelRequest.Type_.XML_HTTP;
  this.baseUri_ = uri.clone().makeUnique();
  this.postData_ = postData;
  this.decodeChunks_ = decodeChunks;
  this.sendXmlHttp_(null /* hostPrefix */);
};


/**
 * Uses XMLHTTP to send an HTTP GET to the server.
 *
 * @param {goog.Uri} uri  The uri of the request.
 * @param {boolean} decodeChunks  Whether to the result is expected to be
 *     encoded for chunking and thus requires decoding.
 * @param {?string} hostPrefix  The host prefix, if we might be using a
 *     secondary domain.  Note that it should also be in the URL, adding this
 *     won't cause it to be added to the URL.
 * @param {boolean=} opt_noClose   Whether to request that the tcp/ip connection
 *     should be closed.
 */
goog.net.ChannelRequest.prototype.xmlHttpGet = function(uri, decodeChunks,
    hostPrefix, opt_noClose) {
  this.type_ = goog.net.ChannelRequest.Type_.XML_HTTP;
  this.baseUri_ = uri.clone().makeUnique();
  this.postData_ = null;
  this.decodeChunks_ = decodeChunks;
  if (opt_noClose) {
    this.sendClose_ = false;
  }
  this.sendXmlHttp_(hostPrefix);
};


/**
 * Sends a request via XMLHTTP according to the current state of the
 * ChannelRequest object.
 *
 * @param {?string} hostPrefix The host prefix, if we might be using a secondary
 *     domain.
 * @private
 */
goog.net.ChannelRequest.prototype.sendXmlHttp_ = function(hostPrefix) {
  this.requestStartTime_ = goog.now();
  this.ensureWatchDogTimer_();

  // clone the base URI to create the request URI. The request uri has the
  // attempt number as a parameter which helps in debugging.
  this.requestUri_ = this.baseUri_.clone();
  this.requestUri_.setParameterValues('t', this.retryId_);

  // send the request either as a POST or GET
  this.xmlHttpChunkStart_ = 0;
  var useSecondaryDomains = this.channel_.shouldUseSecondaryDomains();
  this.xmlHttp_ = this.channel_.createXhrIo(useSecondaryDomains ?
      hostPrefix : null);

  if (this.readyStateChangeThrottleMs_ > 0) {
    this.readyStateChangeThrottle_ = new goog.async.Throttle(
        goog.bind(this.xmlHttpHandler_, this, this.xmlHttp_),
        this.readyStateChangeThrottleMs_);
  }

  this.eventHandler_.listen(this.xmlHttp_,
      goog.net.EventType.READY_STATE_CHANGE,
      this.readyStateChangeHandler_);

  var headers = this.extraHeaders_ ? goog.object.clone(this.extraHeaders_) : {};
  if (this.postData_) {
    // todo (jonp) - use POST constant when Dan defines it
    this.verb_ = 'POST';
    headers['Content-Type'] = 'application/x-www-form-urlencoded';
    this.xmlHttp_.send(this.requestUri_, this.verb_, this.postData_, headers);
  } else {
    // todo (jonp) - use GET constant when Dan defines it
    this.verb_ = 'GET';

    // If the user agent is webkit, we cannot send the close header since it is
    // disallowed by the browser.  If we attempt to set the "Connection: close"
    // header in WEBKIT browser, it will actually causes an error message.
    if (this.sendClose_ && !goog.userAgent.WEBKIT) {
      headers['Connection'] = 'close';
    }
    this.xmlHttp_.send(this.requestUri_, this.verb_, null, headers);
  }
  this.channel_.notifyServerReachabilityEvent(
      /** @suppress {missingRequire} */ (
      goog.net.BrowserChannel.ServerReachability.REQUEST_MADE));
  this.channelDebug_.xmlHttpChannelRequest(this.verb_,
      this.requestUri_, this.rid_, this.retryId_,
      this.postData_);
};


/**
 * Handles a readystatechange event.
 * @param {goog.events.Event} evt The event.
 * @private
 */
goog.net.ChannelRequest.prototype.readyStateChangeHandler_ = function(evt) {
  var xhr = /** @type {goog.net.XhrIo} */ (evt.target);
  var throttle = this.readyStateChangeThrottle_;
  if (throttle &&
      xhr.getReadyState() == goog.net.XmlHttp.ReadyState.INTERACTIVE) {
    // Only throttle in the partial data case.
    this.channelDebug_.debug('Throttling readystatechange.');
    throttle.fire();
  } else {
    // If we haven't throttled, just handle response directly.
    this.xmlHttpHandler_(xhr);
  }
};


/**
 * XmlHttp handler
 * @param {goog.net.XhrIo} xmlhttp The XhrIo object for the current request.
 * @private
 */
goog.net.ChannelRequest.prototype.xmlHttpHandler_ = function(xmlhttp) {
  /** @suppress {missingRequire} */
  goog.net.BrowserChannel.onStartExecution();

  /** @preserveTry */
  try {
    if (xmlhttp == this.xmlHttp_) {
      this.onXmlHttpReadyStateChanged_();
    } else {
      this.channelDebug_.warning('Called back with an ' +
                                     'unexpected xmlhttp');
    }
  } catch (ex) {
    this.channelDebug_.debug('Failed call to OnXmlHttpReadyStateChanged_');
    if (this.xmlHttp_ && this.xmlHttp_.getResponseText()) {
      this.channelDebug_.dumpException(ex,
          'ResponseText: ' + this.xmlHttp_.getResponseText());
    } else {
      this.channelDebug_.dumpException(ex, 'No response text');
    }
  } finally {
    /** @suppress {missingRequire} */
    goog.net.BrowserChannel.onEndExecution();
  }
};


/**
 * Called by the readystate handler for XMLHTTP requests.
 *
 * @private
 */
goog.net.ChannelRequest.prototype.onXmlHttpReadyStateChanged_ = function() {
  var readyState = this.xmlHttp_.getReadyState();
  var errorCode = this.xmlHttp_.getLastErrorCode();
  var statusCode = this.xmlHttp_.getStatus();
  // If it is Safari less than 420+, there is a bug that causes null to be
  // in the responseText on ready state interactive so we must wait for
  // ready state complete.
  if (!goog.net.ChannelRequest.supportsXhrStreaming() ||
      (goog.userAgent.WEBKIT &&
       !goog.userAgent.isVersionOrHigher(
           goog.net.ChannelRequest.MIN_WEBKIT_FOR_INTERACTIVE_))) {
    if (readyState < goog.net.XmlHttp.ReadyState.COMPLETE) {
      // not yet ready
      return;
    }
  } else {
    // we get partial results in browsers that support ready state interactive.
    // We also make sure that getResponseText is not null in interactive mode
    // before we continue.  However, we don't do it in Opera because it only
    // fire readyState == INTERACTIVE once.  We need the following code to poll
    if (readyState < goog.net.XmlHttp.ReadyState.INTERACTIVE ||
        readyState == goog.net.XmlHttp.ReadyState.INTERACTIVE &&
        !goog.userAgent.OPERA && !this.xmlHttp_.getResponseText()) {
      // not yet ready
      return;
    }
  }

  // Dispatch any appropriate network events.
  if (!this.cancelled_ && readyState == goog.net.XmlHttp.ReadyState.COMPLETE &&
      errorCode != goog.net.ErrorCode.ABORT) {

    // Pretty conservative, these are the only known scenarios which we'd
    // consider indicative of a truly non-functional network connection.
    if (errorCode == goog.net.ErrorCode.TIMEOUT ||
        statusCode <= 0) {
      this.channel_.notifyServerReachabilityEvent(
          /** @suppress {missingRequire} */
          goog.net.BrowserChannel.ServerReachability.REQUEST_FAILED);
    } else {
      this.channel_.notifyServerReachabilityEvent(
          /** @suppress {missingRequire} */
          goog.net.BrowserChannel.ServerReachability.REQUEST_SUCCEEDED);
    }
  }

  // got some data so cancel the watchdog timer
  this.cancelWatchDogTimer_();

  var status = this.xmlHttp_.getStatus();
  this.lastStatusCode_ = status;
  var responseText = this.xmlHttp_.getResponseText();
  if (!responseText) {
    this.channelDebug_.debug('No response text for uri ' +
        this.requestUri_ + ' status ' + status);
  }
  this.successful_ = (status == 200);

  this.channelDebug_.xmlHttpChannelResponseMetaData(
      /** @type {string} */ (this.verb_),
      this.requestUri_, this.rid_, this.retryId_, readyState,
      status);

  if (!this.successful_) {
    if (status == 400 &&
        responseText.indexOf('Unknown SID') > 0) {
      // the server error string will include 'Unknown SID' which indicates the
      // server doesn't know about the session (maybe it got restarted, maybe
      // the user got moved to another server, etc.,). Handlers can special
      // case this error
      this.lastError_ = goog.net.ChannelRequest.Error.UNKNOWN_SESSION_ID;
      /** @suppress {missingRequire} */
      goog.net.BrowserChannel.notifyStatEvent(
          /** @suppress {missingRequire} */
          goog.net.BrowserChannel.Stat.REQUEST_UNKNOWN_SESSION_ID);
      this.channelDebug_.warning('XMLHTTP Unknown SID (' + this.rid_ + ')');
    } else {
      this.lastError_ = goog.net.ChannelRequest.Error.STATUS;
      /** @suppress {missingRequire} */
      goog.net.BrowserChannel.notifyStatEvent(
          /** @suppress {missingRequire} */
          goog.net.BrowserChannel.Stat.REQUEST_BAD_STATUS);
      this.channelDebug_.warning(
          'XMLHTTP Bad status ' + status + ' (' + this.rid_ + ')');
    }
    this.cleanup_();
    this.dispatchFailure_();
    return;
  }

  if (readyState == goog.net.XmlHttp.ReadyState.COMPLETE) {
    this.cleanup_();
  }

  if (this.decodeChunks_) {
    this.decodeNextChunks_(readyState, responseText);
    if (goog.userAgent.OPERA && this.successful_ &&
        readyState == goog.net.XmlHttp.ReadyState.INTERACTIVE) {
      this.startPolling_();
    }
  } else {
    this.channelDebug_.xmlHttpChannelResponseText(
        this.rid_, responseText, null);
    this.safeOnRequestData_(responseText);
  }

  if (!this.successful_) {
    return;
  }

  if (!this.cancelled_) {
    if (readyState == goog.net.XmlHttp.ReadyState.COMPLETE) {
      this.channel_.onRequestComplete(this);
    } else {
      // The default is false, the result from this callback shouldn't carry
      // over to the next callback, otherwise the request looks successful if
      // the watchdog timer gets called
      this.successful_ = false;
      this.ensureWatchDogTimer_();
    }
  }
};


/**
 * Decodes the next set of available chunks in the response.
 * @param {number} readyState The value of readyState.
 * @param {string} responseText The value of responseText.
 * @private
 */
goog.net.ChannelRequest.prototype.decodeNextChunks_ = function(readyState,
        responseText) {
  var decodeNextChunksSuccessful = true;
  while (!this.cancelled_ &&
         this.xmlHttpChunkStart_ < responseText.length) {
    var chunkText = this.getNextChunk_(responseText);
    if (chunkText == goog.net.ChannelRequest.INCOMPLETE_CHUNK_) {
      if (readyState == goog.net.XmlHttp.ReadyState.COMPLETE) {
        // should have consumed entire response when the request is done
        this.lastError_ = goog.net.ChannelRequest.Error.BAD_DATA;
        /** @suppress {missingRequire} */
        goog.net.BrowserChannel.notifyStatEvent(
            /** @suppress {missingRequire} */
            goog.net.BrowserChannel.Stat.REQUEST_INCOMPLETE_DATA);
        decodeNextChunksSuccessful = false;
      }
      this.channelDebug_.xmlHttpChannelResponseText(
          this.rid_, null, '[Incomplete Response]');
      break;
    } else if (chunkText == goog.net.ChannelRequest.INVALID_CHUNK_) {
      this.lastError_ = goog.net.ChannelRequest.Error.BAD_DATA;
      /** @suppress {missingRequire} */
      goog.net.BrowserChannel.notifyStatEvent(
          /** @suppress {missingRequire} */
          goog.net.BrowserChannel.Stat.REQUEST_BAD_DATA);
      this.channelDebug_.xmlHttpChannelResponseText(
          this.rid_, responseText, '[Invalid Chunk]');
      decodeNextChunksSuccessful = false;
      break;
    } else {
      this.channelDebug_.xmlHttpChannelResponseText(
          this.rid_, /** @type {string} */ (chunkText), null);
      this.safeOnRequestData_(/** @type {string} */ (chunkText));
    }
  }
  if (readyState == goog.net.XmlHttp.ReadyState.COMPLETE &&
      responseText.length == 0) {
    // also an error if we didn't get any response
    this.lastError_ = goog.net.ChannelRequest.Error.NO_DATA;
    /** @suppress {missingRequire} */
    goog.net.BrowserChannel.notifyStatEvent(
        /** @suppress {missingRequire} */
        goog.net.BrowserChannel.Stat.REQUEST_NO_DATA);
    decodeNextChunksSuccessful = false;
  }
  this.successful_ = this.successful_ && decodeNextChunksSuccessful;
  if (!decodeNextChunksSuccessful) {
    // malformed response - we make this trigger retry logic
    this.channelDebug_.xmlHttpChannelResponseText(
        this.rid_, responseText, '[Invalid Chunked Response]');
    this.cleanup_();
    this.dispatchFailure_();
  }
};


/**
 * Polls the response for new data.
 * @private
 */
goog.net.ChannelRequest.prototype.pollResponse_ = function() {
  var readyState = this.xmlHttp_.getReadyState();
  var responseText = this.xmlHttp_.getResponseText();
  if (this.xmlHttpChunkStart_ < responseText.length) {
    this.cancelWatchDogTimer_();
    this.decodeNextChunks_(readyState, responseText);
    if (this.successful_ &&
        readyState != goog.net.XmlHttp.ReadyState.COMPLETE) {
      this.ensureWatchDogTimer_();
    }
  }
};


/**
 * Starts a polling interval for changes to responseText of the
 * XMLHttpRequest, for browsers that don't fire onreadystatechange
 * as data comes in incrementally.  This timer is disabled in
 * cleanup_().
 * @private
 */
goog.net.ChannelRequest.prototype.startPolling_ = function() {
  this.eventHandler_.listen(this.pollingTimer_, goog.Timer.TICK,
      this.pollResponse_);
  this.pollingTimer_.start();
};


/**
 * Called when the browser declares itself offline at the start of a request or
 * during its lifetime.  Abandons that request.
 * @private
 */
goog.net.ChannelRequest.prototype.cancelRequestAsBrowserIsOffline_ =
    function() {
  if (this.successful_) {
    // Should never happen.
    this.channelDebug_.severe(
        'Received browser offline event even though request completed ' +
        'successfully');
  }

  this.channelDebug_.browserOfflineResponse(this.requestUri_);
  this.cleanup_();

  // set error and dispatch failure
  this.lastError_ = goog.net.ChannelRequest.Error.BROWSER_OFFLINE;
  /** @suppress {missingRequire} */
  goog.net.BrowserChannel.notifyStatEvent(
      /** @suppress {missingRequire} */
      goog.net.BrowserChannel.Stat.BROWSER_OFFLINE);
  this.dispatchFailure_();
};


/**
 * Returns the next chunk of a chunk-encoded response. This is not standard
 * HTTP chunked encoding because browsers don't expose the chunk boundaries to
 * the application through XMLHTTP. So we have an additional chunk encoding at
 * the application level that lets us tell where the beginning and end of
 * individual responses are so that we can only try to eval a complete JS array.
 *
 * The encoding is the size of the chunk encoded as a decimal string followed
 * by a newline followed by the data.
 *
 * @param {string} responseText The response text from the XMLHTTP response.
 * @return {string|Object} The next chunk string or a sentinel object
 *                         indicating a special condition.
 * @private
 */
goog.net.ChannelRequest.prototype.getNextChunk_ = function(responseText) {
  var sizeStartIndex = this.xmlHttpChunkStart_;
  var sizeEndIndex = responseText.indexOf('\n', sizeStartIndex);
  if (sizeEndIndex == -1) {
    return goog.net.ChannelRequest.INCOMPLETE_CHUNK_;
  }

  var sizeAsString = responseText.substring(sizeStartIndex, sizeEndIndex);
  var size = Number(sizeAsString);
  if (isNaN(size)) {
    return goog.net.ChannelRequest.INVALID_CHUNK_;
  }

  var chunkStartIndex = sizeEndIndex + 1;
  if (chunkStartIndex + size > responseText.length) {
    return goog.net.ChannelRequest.INCOMPLETE_CHUNK_;
  }

  var chunkText = responseText.substr(chunkStartIndex, size);
  this.xmlHttpChunkStart_ = chunkStartIndex + size;
  return chunkText;
};


/**
 * Uses the Trident htmlfile ActiveX control to send a GET request in IE. This
 * is the innovation discovered that lets us get intermediate results in
 * Internet Explorer.  Thanks to http://go/kev
 * @param {goog.Uri} uri The uri to request from.
 * @param {boolean} usingSecondaryDomain Whether to use a secondary domain.
 */
goog.net.ChannelRequest.prototype.tridentGet = function(uri,
    usingSecondaryDomain) {
  this.type_ = goog.net.ChannelRequest.Type_.TRIDENT;
  this.baseUri_ = uri.clone().makeUnique();
  this.tridentGet_(usingSecondaryDomain);
};


/**
 * Starts the Trident request.
 * @param {boolean} usingSecondaryDomain Whether to use a secondary domain.
 * @private
 */
goog.net.ChannelRequest.prototype.tridentGet_ = function(usingSecondaryDomain) {
  this.requestStartTime_ = goog.now();
  this.ensureWatchDogTimer_();

  var hostname = usingSecondaryDomain ? window.location.hostname : '';
  this.requestUri_ = this.baseUri_.clone();
  this.requestUri_.setParameterValue('DOMAIN', hostname);
  this.requestUri_.setParameterValue('t', this.retryId_);

  try {
    this.trident_ = new ActiveXObject('htmlfile');
  } catch (e) {
    this.channelDebug_.severe('ActiveX blocked');
    this.cleanup_();

    this.lastError_ = goog.net.ChannelRequest.Error.ACTIVE_X_BLOCKED;
    /** @suppress {missingRequire} */
    goog.net.BrowserChannel.notifyStatEvent(
        /** @suppress {missingRequire} */
        goog.net.BrowserChannel.Stat.ACTIVE_X_BLOCKED);
    this.dispatchFailure_();
    return;
  }

  var body = '<html><body>';
  if (usingSecondaryDomain) {
    body += '<script>document.domain="' + hostname + '"</scr' + 'ipt>';
  }
  body += '</body></html>';

  this.trident_.open();
  this.trident_.write(body);
  this.trident_.close();

  this.trident_.parentWindow['m'] = goog.bind(this.onTridentRpcMessage_, this);
  this.trident_.parentWindow['d'] = goog.bind(this.onTridentDone_, this, true);
  this.trident_.parentWindow['rpcClose'] =
      goog.bind(this.onTridentDone_, this, false);

  var div = this.trident_.createElement('div');
  this.trident_.parentWindow.document.body.appendChild(div);
  div.innerHTML = '<iframe src="' + this.requestUri_ + '"></iframe>';
  this.channelDebug_.tridentChannelRequest('GET',
      this.requestUri_, this.rid_, this.retryId_);
  this.channel_.notifyServerReachabilityEvent(
      /** @suppress {missingRequire} */
      goog.net.BrowserChannel.ServerReachability.REQUEST_MADE);
};


/**
 * Callback from the Trident htmlfile ActiveX control for when a new message
 * is received.
 *
 * @param {string} msg The data payload.
 * @private
 */
goog.net.ChannelRequest.prototype.onTridentRpcMessage_ = function(msg) {
  // need to do async b/c this gets called off of the context of the ActiveX
  /** @suppress {missingRequire} */
  goog.net.BrowserChannel.setTimeout(
      goog.bind(this.onTridentRpcMessageAsync_, this, msg), 0);
};


/**
 * Callback from the Trident htmlfile ActiveX control for when a new message
 * is received.
 *
 * @param {string} msg  The data payload.
 * @private
 */
goog.net.ChannelRequest.prototype.onTridentRpcMessageAsync_ = function(msg) {
  if (this.cancelled_) {
    return;
  }
  this.channelDebug_.tridentChannelResponseText(this.rid_, msg);
  this.cancelWatchDogTimer_();
  this.safeOnRequestData_(msg);
  this.ensureWatchDogTimer_();
};


/**
 * Callback from the Trident htmlfile ActiveX control for when the request
 * is complete
 *
 * @param {boolean} successful Whether the request successfully completed.
 * @private
 */
goog.net.ChannelRequest.prototype.onTridentDone_ = function(successful) {
  // need to do async b/c this gets called off of the context of the ActiveX
  /** @suppress {missingRequire} */
  goog.net.BrowserChannel.setTimeout(
      goog.bind(this.onTridentDoneAsync_, this, successful), 0);
};


/**
 * Callback from the Trident htmlfile ActiveX control for when the request
 * is complete
 *
 * @param {boolean} successful Whether the request successfully completed.
 * @private
 */
goog.net.ChannelRequest.prototype.onTridentDoneAsync_ = function(successful) {
  if (this.cancelled_) {
    return;
  }
  this.channelDebug_.tridentChannelResponseDone(
      this.rid_, successful);
  this.cleanup_();
  this.successful_ = successful;
  this.channel_.onRequestComplete(this);
  this.channel_.notifyServerReachabilityEvent(
      /** @suppress {missingRequire} */
      goog.net.BrowserChannel.ServerReachability.BACK_CHANNEL_ACTIVITY);
};


/**
 * Uses an IMG tag to send an HTTP get to the server. This is only currently
 * used to terminate the connection, as an IMG tag is the most reliable way to
 * send something to the server while the page is getting torn down.
 * @param {goog.Uri} uri The uri to send a request to.
 */
goog.net.ChannelRequest.prototype.sendUsingImgTag = function(uri) {
  this.type_ = goog.net.ChannelRequest.Type_.IMG;
  this.baseUri_ = uri.clone().makeUnique();
  this.imgTagGet_();
};


/**
 * Starts the IMG request.
 *
 * @private
 */
goog.net.ChannelRequest.prototype.imgTagGet_ = function() {
  var eltImg = new Image();
  eltImg.src = this.baseUri_;
  this.requestStartTime_ = goog.now();
  this.ensureWatchDogTimer_();
};


/**
 * Cancels the request no matter what the underlying transport is.
 */
goog.net.ChannelRequest.prototype.cancel = function() {
  this.cancelled_ = true;
  this.cleanup_();
};


/**
 * Ensures that there is watchdog timeout which is used to ensure that
 * the connection completes in time.
 *
 * @private
 */
goog.net.ChannelRequest.prototype.ensureWatchDogTimer_ = function() {
  this.watchDogTimeoutTime_ = goog.now() + this.timeout_;
  this.startWatchDogTimer_(this.timeout_);
};


/**
 * Starts the watchdog timer which is used to ensure that the connection
 * completes in time.
 * @param {number} time The number of milliseconds to wait.
 * @private
 */
goog.net.ChannelRequest.prototype.startWatchDogTimer_ = function(time) {
  if (this.watchDogTimerId_ != null) {
    // assertion
    throw Error('WatchDog timer not null');
  }
  this.watchDogTimerId_ =   /** @suppress {missingRequire} */ (
      goog.net.BrowserChannel.setTimeout(
          goog.bind(this.onWatchDogTimeout_, this), time));
};


/**
 * Cancels the watchdog timer if it has been started.
 *
 * @private
 */
goog.net.ChannelRequest.prototype.cancelWatchDogTimer_ = function() {
  if (this.watchDogTimerId_) {
    goog.global.clearTimeout(this.watchDogTimerId_);
    this.watchDogTimerId_ = null;
  }
};


/**
 * Called when the watchdog timer is triggered. It also handles a case where it
 * is called too early which we suspect may be happening sometimes
 * (not sure why)
 *
 * @private
 */
goog.net.ChannelRequest.prototype.onWatchDogTimeout_ = function() {
  this.watchDogTimerId_ = null;
  var now = goog.now();
  if (now - this.watchDogTimeoutTime_ >= 0) {
    this.handleTimeout_();
  } else {
    // got called too early for some reason
    this.channelDebug_.warning('WatchDog timer called too early');
    this.startWatchDogTimer_(this.watchDogTimeoutTime_ - now);
  }
};


/**
 * Called when the request has actually timed out. Will cleanup and notify the
 * channel of the failure.
 *
 * @private
 */
goog.net.ChannelRequest.prototype.handleTimeout_ = function() {
  if (this.successful_) {
    // Should never happen.
    this.channelDebug_.severe(
        'Received watchdog timeout even though request loaded successfully');
  }

  this.channelDebug_.timeoutResponse(this.requestUri_);
  // IMG requests never notice if they were successful, and always 'time out'.
  // This fact says nothing about reachability.
  if (this.type_ != goog.net.ChannelRequest.Type_.IMG) {
    this.channel_.notifyServerReachabilityEvent(
        /** @suppress {missingRequire} */
        goog.net.BrowserChannel.ServerReachability.REQUEST_FAILED);
  }
  this.cleanup_();

  // set error and dispatch failure
  this.lastError_ = goog.net.ChannelRequest.Error.TIMEOUT;
  /** @suppress {missingRequire} */
  goog.net.BrowserChannel.notifyStatEvent(
      /** @suppress {missingRequire} */
      goog.net.BrowserChannel.Stat.REQUEST_TIMEOUT);
  this.dispatchFailure_();
};


/**
 * Notifies the channel that this request failed.
 * @private
 */
goog.net.ChannelRequest.prototype.dispatchFailure_ = function() {
  if (this.channel_.isClosed() || this.cancelled_) {
    return;
  }

  this.channel_.onRequestComplete(this);
};


/**
 * Cleans up the objects used to make the request. This function is
 * idempotent.
 *
 * @private
 */
goog.net.ChannelRequest.prototype.cleanup_ = function() {
  this.cancelWatchDogTimer_();

  goog.dispose(this.readyStateChangeThrottle_);
  this.readyStateChangeThrottle_ = null;

  // Stop the polling timer, if necessary.
  this.pollingTimer_.stop();

  // Unhook all event handlers.
  this.eventHandler_.removeAll();

  if (this.xmlHttp_) {
    // clear out this.xmlHttp_ before aborting so we handle getting reentered
    // inside abort
    var xmlhttp = this.xmlHttp_;
    this.xmlHttp_ = null;
    xmlhttp.abort();
    xmlhttp.dispose();
  }

  if (this.trident_) {
    this.trident_ = null;
  }
};


/**
 * Indicates whether the request was successful. Only valid after the handler
 * is called to indicate completion of the request.
 *
 * @return {boolean} True if the request succeeded.
 */
goog.net.ChannelRequest.prototype.getSuccess = function() {
  return this.successful_;
};


/**
 * If the request was not successful, returns the reason.
 *
 * @return {?goog.net.ChannelRequest.Error}  The last error.
 */
goog.net.ChannelRequest.prototype.getLastError = function() {
  return this.lastError_;
};


/**
 * Returns the status code of the last request.
 * @return {number} The status code of the last request.
 */
goog.net.ChannelRequest.prototype.getLastStatusCode = function() {
  return this.lastStatusCode_;
};


/**
 * Returns the session id for this channel.
 *
 * @return {string|undefined} The session ID.
 */
goog.net.ChannelRequest.prototype.getSessionId = function() {
  return this.sid_;
};


/**
 * Returns the request id for this request. Each request has a unique request
 * id and the request IDs are a sequential increasing count.
 *
 * @return {string|number|undefined} The request ID.
 */
goog.net.ChannelRequest.prototype.getRequestId = function() {
  return this.rid_;
};


/**
 * Returns the data for a post, if this request is a post.
 *
 * @return {?string} The POST data provided by the request initiator.
 */
goog.net.ChannelRequest.prototype.getPostData = function() {
  return this.postData_;
};


/**
 * Returns the time that the request started, if it has started.
 *
 * @return {?number} The time the request started, as returned by goog.now().
 */
goog.net.ChannelRequest.prototype.getRequestStartTime = function() {
  return this.requestStartTime_;
};


/**
 * Helper to call the callback's onRequestData, which catches any
 * exception and cleans up the request.
 * @param {string} data The request data.
 * @private
 */
goog.net.ChannelRequest.prototype.safeOnRequestData_ = function(data) {
  /** @preserveTry */
  try {
    this.channel_.onRequestData(this, data);
    this.channel_.notifyServerReachabilityEvent(
        /** @suppress {missingRequire} */
        goog.net.BrowserChannel.ServerReachability.BACK_CHANNEL_ACTIVITY);
  } catch (e) {
    // Dump debug info, but keep going without closing the channel.
    this.channelDebug_.dumpException(
        e, 'Error in httprequest callback');
  }
};

//javascript/closure/net/channeldebug.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the ChannelDebug class. ChannelDebug provides
 * a utility for tracing and debugging the BrowserChannel requests.
 *
 * @author jonp@google.com (Jon Perlow)
 */


/**
 * Namespace for BrowserChannel
 */
goog.provide('goog.net.ChannelDebug');

goog.require('goog.json');
goog.require('goog.log');



/**
 * Logs and keeps a buffer of debugging info for the Channel.
 *
 * @constructor
 */
goog.net.ChannelDebug = function() {
  /**
   * The logger instance.
   * @const
   * @private
   */
  this.logger_ = goog.log.getLogger('goog.net.BrowserChannel');
};


/**
 * Gets the logger used by this ChannelDebug.
 * @return {goog.debug.Logger} The logger used by this ChannelDebug.
 */
goog.net.ChannelDebug.prototype.getLogger = function() {
  return this.logger_;
};


/**
 * Logs that the browser went offline during the lifetime of a request.
 * @param {goog.Uri} url The URL being requested.
 */
goog.net.ChannelDebug.prototype.browserOfflineResponse = function(url) {
  this.info('BROWSER_OFFLINE: ' + url);
};


/**
 * Logs an XmlHttp request..
 * @param {string} verb The request type (GET/POST).
 * @param {goog.Uri} uri The request destination.
 * @param {string|number|undefined} id The request id.
 * @param {number} attempt Which attempt # the request was.
 * @param {?string} postData The data posted in the request.
 */
goog.net.ChannelDebug.prototype.xmlHttpChannelRequest =
    function(verb, uri, id, attempt, postData) {
  this.info(
      'XMLHTTP REQ (' + id + ') [attempt ' + attempt + ']: ' +
      verb + '\n' + uri + '\n' +
      this.maybeRedactPostData_(postData));
};


/**
 * Logs the meta data received from an XmlHttp request.
 * @param {string} verb The request type (GET/POST).
 * @param {goog.Uri} uri The request destination.
 * @param {string|number|undefined} id The request id.
 * @param {number} attempt Which attempt # the request was.
 * @param {goog.net.XmlHttp.ReadyState} readyState The ready state.
 * @param {number} statusCode The HTTP status code.
 */
goog.net.ChannelDebug.prototype.xmlHttpChannelResponseMetaData =
    function(verb, uri, id, attempt, readyState, statusCode)  {
  this.info(
      'XMLHTTP RESP (' + id + ') [ attempt ' + attempt + ']: ' +
      verb + '\n' + uri + '\n' + readyState + ' ' + statusCode);
};


/**
 * Logs the response data received from an XmlHttp request.
 * @param {string|number|undefined} id The request id.
 * @param {?string} responseText The response text.
 * @param {?string=} opt_desc Optional request description.
 */
goog.net.ChannelDebug.prototype.xmlHttpChannelResponseText =
    function(id, responseText, opt_desc) {
  this.info(
      'XMLHTTP TEXT (' + id + '): ' +
      this.redactResponse_(responseText) +
      (opt_desc ? ' ' + opt_desc : ''));
};


/**
 * Logs a Trident ActiveX request.
 * @param {string} verb The request type (GET/POST).
 * @param {goog.Uri} uri The request destination.
 * @param {string|number|undefined} id The request id.
 * @param {number} attempt Which attempt # the request was.
 */
goog.net.ChannelDebug.prototype.tridentChannelRequest =
    function(verb, uri, id, attempt) {
  this.info(
      'TRIDENT REQ (' + id + ') [ attempt ' + attempt + ']: ' +
      verb + '\n' + uri);
};


/**
 * Logs the response text received from a Trident ActiveX request.
 * @param {string|number|undefined} id The request id.
 * @param {string} responseText The response text.
 */
goog.net.ChannelDebug.prototype.tridentChannelResponseText =
    function(id, responseText) {
  this.info(
      'TRIDENT TEXT (' + id + '): ' +
      this.redactResponse_(responseText));
};


/**
 * Logs the done response received from a Trident ActiveX request.
 * @param {string|number|undefined} id The request id.
 * @param {boolean} successful Whether the request was successful.
 */
goog.net.ChannelDebug.prototype.tridentChannelResponseDone =
    function(id, successful) {
  this.info(
      'TRIDENT TEXT (' + id + '): ' + successful ? 'success' : 'failure');
};


/**
 * Logs a request timeout.
 * @param {goog.Uri} uri The uri that timed out.
 */
goog.net.ChannelDebug.prototype.timeoutResponse = function(uri) {
  this.info('TIMEOUT: ' + uri);
};


/**
 * Logs a debug message.
 * @param {string} text The message.
 */
goog.net.ChannelDebug.prototype.debug = function(text) {
  this.info(text);
};


/**
 * Logs an exception
 * @param {Error} e The error or error event.
 * @param {string=} opt_msg The optional message, defaults to 'Exception'.
 */
goog.net.ChannelDebug.prototype.dumpException = function(e, opt_msg) {
  this.severe((opt_msg || 'Exception') + e);
};


/**
 * Logs an info message.
 * @param {string} text The message.
 */
goog.net.ChannelDebug.prototype.info = function(text) {
  goog.log.info(this.logger_, text);
};


/**
 * Logs a warning message.
 * @param {string} text The message.
 */
goog.net.ChannelDebug.prototype.warning = function(text) {
  goog.log.warning(this.logger_, text);
};


/**
 * Logs a severe message.
 * @param {string} text The message.
 */
goog.net.ChannelDebug.prototype.severe = function(text) {
  goog.log.error(this.logger_, text);
};


/**
 * Removes potentially private data from a response so that we don't
 * accidentally save private and personal data to the server logs.
 * @param {?string} responseText A JSON response to clean.
 * @return {?string} The cleaned response.
 * @private
 */
goog.net.ChannelDebug.prototype.redactResponse_ = function(responseText) {
  // first check if it's not JS - the only non-JS should be the magic cookie
  if (!responseText ||
      /** @suppress {missingRequire}.  The require creates a circular
       *  dependency.
       */
      responseText == goog.net.BrowserChannel.MAGIC_RESPONSE_COOKIE) {
    return responseText;
  }
  /** @preserveTry */
  try {
    var responseArray = goog.json.unsafeParse(responseText);
    if (responseArray) {
      for (var i = 0; i < responseArray.length; i++) {
        if (goog.isArray(responseArray[i])) {
          this.maybeRedactArray_(responseArray[i]);
        }
      }
    }

    return goog.json.serialize(responseArray);
  } catch (e) {
    this.debug('Exception parsing expected JS array - probably was not JS');
    return responseText;
  }
};


/**
 * Removes data from a response array that may be sensitive.
 * @param {Array} array The array to clean.
 * @private
 */
goog.net.ChannelDebug.prototype.maybeRedactArray_ = function(array) {
  if (array.length < 2) {
    return;
  }
  var dataPart = array[1];
  if (!goog.isArray(dataPart)) {
    return;
  }
  if (dataPart.length < 1) {
    return;
  }

  var type = dataPart[0];
  if (type != 'noop' && type != 'stop') {
    // redact all fields in the array
    for (var i = 1; i < dataPart.length; i++) {
      dataPart[i] = '';
    }
  }
};


/**
 * Removes potentially private data from a request POST body so that we don't
 * accidentally save private and personal data to the server logs.
 * @param {?string} data The data string to clean.
 * @return {?string} The data string with sensitive data replaced by 'redacted'.
 * @private
 */
goog.net.ChannelDebug.prototype.maybeRedactPostData_ = function(data) {
  if (!data) {
    return null;
  }
  var out = '';
  var params = data.split('&');
  for (var i = 0; i < params.length; i++) {
    var param = params[i];
    var keyValue = param.split('=');
    if (keyValue.length > 1) {
      var key = keyValue[0];
      var value = keyValue[1];

      var keyParts = key.split('_');
      if (keyParts.length >= 2 && keyParts[1] == 'type') {
        out += key + '=' + value + '&';
      } else {
        out += key + '=' + 'redacted' + '&';
      }
    }
  }
  return out;
};

//javascript/closure/net/tmpnetwork.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview tmpnetwork.js contains some temporary networking functions
 * for browserchannel which will be moved at a later date.
 */


/**
 * Namespace for BrowserChannel
 */
goog.provide('goog.net.tmpnetwork');

goog.require('goog.Uri');
goog.require('goog.net.ChannelDebug');


/**
 * Default timeout to allow for google.com pings.
 * @type {number}
 */
goog.net.tmpnetwork.GOOGLECOM_TIMEOUT = 10000;


/**
 * Pings the network to check if an error is a server error or user's network
 * error.
 *
 * @param {Function} callback The function to call back with results.
 * @param {goog.Uri?=} opt_imageUri The URI of an image to use for the network
 *     test. You *must* provide an image URI; the default behavior is provided
 *     for compatibility with existing code, but the search team does not want
 *     people using images served off of google.com for this purpose. The
 *     default will go away when all usages have been changed.
 */
goog.net.tmpnetwork.testGoogleCom = function(callback, opt_imageUri) {
  // We need to add a 'rand' to make sure the response is not fulfilled
  // by browser cache.
  var uri = opt_imageUri;
  if (!uri) {
    uri = new goog.Uri('//www.google.com/images/cleardot.gif');
    uri.makeUnique();
  }
  goog.net.tmpnetwork.testLoadImage(uri.toString(),
      goog.net.tmpnetwork.GOOGLECOM_TIMEOUT, callback);
};


/**
 * Test loading the given image, retrying if necessary.
 * @param {string} url URL to the iamge.
 * @param {number} timeout Milliseconds before giving up.
 * @param {Function} callback Function to call with results.
 * @param {number} retries The number of times to retry.
 * @param {number=} opt_pauseBetweenRetriesMS Optional number of milliseconds
 *     between retries - defaults to 0.
 */
goog.net.tmpnetwork.testLoadImageWithRetries = function(url, timeout, callback,
    retries, opt_pauseBetweenRetriesMS) {
  var channelDebug = new goog.net.ChannelDebug();
  channelDebug.debug('TestLoadImageWithRetries: ' + opt_pauseBetweenRetriesMS);
  if (retries == 0) {
    // no more retries, give up
    callback(false);
    return;
  }

  var pauseBetweenRetries = opt_pauseBetweenRetriesMS || 0;
  retries--;
  goog.net.tmpnetwork.testLoadImage(url, timeout, function(succeeded) {
    if (succeeded) {
      callback(true);
    } else {
      // try again
      goog.global.setTimeout(function() {
        goog.net.tmpnetwork.testLoadImageWithRetries(url, timeout, callback,
            retries, pauseBetweenRetries);
      }, pauseBetweenRetries);
    }
  });
};


/**
 * Test loading the given image.
 * @param {string} url URL to the iamge.
 * @param {number} timeout Milliseconds before giving up.
 * @param {Function} callback Function to call with results.
 */
goog.net.tmpnetwork.testLoadImage = function(url, timeout, callback) {
  var channelDebug = new goog.net.ChannelDebug();
  channelDebug.debug('TestLoadImage: loading ' + url);
  var img = new Image();
  img.onload = function() {
    try {
      channelDebug.debug('TestLoadImage: loaded');
      goog.net.tmpnetwork.clearImageCallbacks_(img);
      callback(true);
    } catch (e) {
      channelDebug.dumpException(e);
    }
  };
  img.onerror = function() {
    try {
      channelDebug.debug('TestLoadImage: error');
      goog.net.tmpnetwork.clearImageCallbacks_(img);
      callback(false);
    } catch (e) {
      channelDebug.dumpException(e);
    }
  };
  img.onabort = function() {
    try {
      channelDebug.debug('TestLoadImage: abort');
      goog.net.tmpnetwork.clearImageCallbacks_(img);
      callback(false);
    } catch (e) {
      channelDebug.dumpException(e);
    }
  };
  img.ontimeout = function() {
    try {
      channelDebug.debug('TestLoadImage: timeout');
      goog.net.tmpnetwork.clearImageCallbacks_(img);
      callback(false);
    } catch (e) {
      channelDebug.dumpException(e);
    }
  };

  goog.global.setTimeout(function() {
    if (img.ontimeout) {
      img.ontimeout();
    }
  }, timeout);
  img.src = url;
};


/**
 * Clear handlers to avoid memory leaks.
 * @param {Image} img The image to clear handlers from.
 * @private
 */
goog.net.tmpnetwork.clearImageCallbacks_ = function(img) {
  // NOTE(pupius): Nullified individually to avoid compiler warnings
  // (BUG 658126)
  img.onload = null;
  img.onerror = null;
  img.onabort = null;
  img.ontimeout = null;
};

//javascript/closure/net/browsertestchannel.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the BrowserTestChannel class.  A
 * BrowserTestChannel is used during the first part of channel negotiation
 * with the server to create the channel. It helps us determine whether we're
 * behind a buffering proxy. It also runs the logic to see if the channel
 * has been blocked by a network administrator. This class is part of the
 * BrowserChannel implementation and is not for use by normal application code.
 *
 * @author jonp@google.com (Jon Perlow)
 */



goog.provide('goog.net.BrowserTestChannel');

goog.require('goog.json.EvalJsonProcessor');
goog.require('goog.net.ChannelRequest');
goog.require('goog.net.ChannelRequest.Error');
goog.require('goog.net.tmpnetwork');
goog.require('goog.string.Parser');
goog.require('goog.userAgent');



/**
 * Encapsulates the logic for a single BrowserTestChannel.
 *
 * @constructor
 * @param {goog.net.BrowserChannel} channel  The BrowserChannel that owns this
 *     test channel.
 * @param {goog.net.ChannelDebug} channelDebug A ChannelDebug to use for
 *     logging.
 * @final
 */
goog.net.BrowserTestChannel = function(channel, channelDebug) {
  /**
   * The BrowserChannel that owns this test channel
   * @type {goog.net.BrowserChannel}
   * @private
   */
  this.channel_ = channel;

  /**
   * The channel debug to use for logging
   * @type {goog.net.ChannelDebug}
   * @private
   */
  this.channelDebug_ = channelDebug;

  /**
   * Parser for a response payload. Defaults to use
   * {@code goog.json.unsafeParse}. The parser should return an array.
   * @type {goog.string.Parser}
   * @private
   */
  this.parser_ = new goog.json.EvalJsonProcessor(null, true);
};


/**
 * Extra HTTP headers to add to all the requests sent to the server.
 * @type {Object}
 * @private
 */
goog.net.BrowserTestChannel.prototype.extraHeaders_ = null;


/**
 * The test request.
 * @type {goog.net.ChannelRequest}
 * @private
 */
goog.net.BrowserTestChannel.prototype.request_ = null;


/**
 * Whether we have received the first result as an intermediate result. This
 * helps us determine whether we're behind a buffering proxy.
 * @type {boolean}
 * @private
 */
goog.net.BrowserTestChannel.prototype.receivedIntermediateResult_ = false;


/**
 * The time when the test request was started. We use timing in IE as
 * a heuristic for whether we're behind a buffering proxy.
 * @type {?number}
 * @private
 */
goog.net.BrowserTestChannel.prototype.startTime_ = null;


/**
 * The time for of the first result part. We use timing in IE as a
 * heuristic for whether we're behind a buffering proxy.
 * @type {?number}
 * @private
 */
goog.net.BrowserTestChannel.prototype.firstTime_ = null;


/**
 * The time for of the last result part. We use timing in IE as a
 * heuristic for whether we're behind a buffering proxy.
 * @type {?number}
 * @private
 */
goog.net.BrowserTestChannel.prototype.lastTime_ = null;


/**
 * The relative path for test requests.
 * @type {?string}
 * @private
 */
goog.net.BrowserTestChannel.prototype.path_ = null;


/**
 * The state of the state machine for this object.
 *
 * @type {?number}
 * @private
 */
goog.net.BrowserTestChannel.prototype.state_ = null;


/**
 * The last status code received.
 * @type {number}
 * @private
 */
goog.net.BrowserTestChannel.prototype.lastStatusCode_ = -1;


/**
 * A subdomain prefix for using a subdomain in IE for the backchannel
 * requests.
 * @type {?string}
 * @private
 */
goog.net.BrowserTestChannel.prototype.hostPrefix_ = null;


/**
 * A subdomain prefix for testing whether the channel was disabled by
 * a network administrator;
 * @type {?string}
 * @private
 */
goog.net.BrowserTestChannel.prototype.blockedPrefix_ = null;


/**
 * Enum type for the browser test channel state machine
 * @enum {number}
 * @private
 */
goog.net.BrowserTestChannel.State_ = {
  /**
   * The state for the BrowserTestChannel state machine where we making the
   * initial call to get the server configured parameters.
   */
  INIT: 0,

  /**
   * The state for the BrowserTestChannel state machine where we're checking to
   * see if the channel has been blocked.
   */
  CHECKING_BLOCKED: 1,

  /**
   * The  state for the BrowserTestChannel state machine where we're checking to
   * se if we're behind a buffering proxy.
   */
  CONNECTION_TESTING: 2
};


/**
 * Time in MS for waiting for the request to see if the channel is blocked.
 * If the response takes longer than this many ms, we assume the request has
 * failed.
 * @type {number}
 * @private
 */
goog.net.BrowserTestChannel.BLOCKED_TIMEOUT_ = 5000;


/**
 * Number of attempts to try to see if the check to see if we're blocked
 * succeeds. Sometimes the request can fail because of flaky network conditions
 * and checking multiple times reduces false positives.
 * @type {number}
 * @private
 */
goog.net.BrowserTestChannel.BLOCKED_RETRIES_ = 3;


/**
 * Time in ms between retries of the blocked request
 * @type {number}
 * @private
 */
goog.net.BrowserTestChannel.BLOCKED_PAUSE_BETWEEN_RETRIES_ = 2000;


/**
 * Time between chunks in the test connection that indicates that we
 * are not behind a buffering proxy. This value should be less than or
 * equals to the time between chunks sent from the server.
 * @type {number}
 * @private
 */
goog.net.BrowserTestChannel.MIN_TIME_EXPECTED_BETWEEN_DATA_ = 500;


/**
 * Sets extra HTTP headers to add to all the requests sent to the server.
 *
 * @param {Object} extraHeaders The HTTP headers.
 */
goog.net.BrowserTestChannel.prototype.setExtraHeaders = function(extraHeaders) {
  this.extraHeaders_ = extraHeaders;
};


/**
 * Sets a new parser for the response payload. A custom parser may be set to
 * avoid using eval(), for example.
 * By default, the parser uses {@code goog.json.unsafeParse}.
 * @param {!goog.string.Parser} parser Parser.
 */
goog.net.BrowserTestChannel.prototype.setParser = function(parser) {
  this.parser_ = parser;
};


/**
 * Starts the test channel. This initiates connections to the server.
 *
 * @param {string} path The relative uri for the test connection.
 */
goog.net.BrowserTestChannel.prototype.connect = function(path) {
  this.path_ = path;
  var sendDataUri = this.channel_.getForwardChannelUri(this.path_);

  goog.net.BrowserChannel.notifyStatEvent(
      goog.net.BrowserChannel.Stat.TEST_STAGE_ONE_START);
  this.startTime_ = goog.now();

  // If the channel already has the result of the first test, then skip it.
  var firstTestResults = this.channel_.getFirstTestResults();
  if (goog.isDefAndNotNull(firstTestResults)) {
    this.hostPrefix_ = this.channel_.correctHostPrefix(firstTestResults[0]);
    this.blockedPrefix_ = firstTestResults[1];
    if (this.blockedPrefix_) {
      this.state_ = goog.net.BrowserTestChannel.State_.CHECKING_BLOCKED;
      this.checkBlocked_();
    } else {
      this.state_ = goog.net.BrowserTestChannel.State_.CONNECTION_TESTING;
      this.connectStage2_();
    }
    return;
  }

  // the first request returns server specific parameters
  sendDataUri.setParameterValues('MODE', 'init');
  this.request_ = goog.net.BrowserChannel.createChannelRequest(
      this, this.channelDebug_);
  this.request_.setExtraHeaders(this.extraHeaders_);
  this.request_.xmlHttpGet(sendDataUri, false /* decodeChunks */,
      null /* hostPrefix */, true /* opt_noClose */);
  this.state_ = goog.net.BrowserTestChannel.State_.INIT;
};


/**
 * Checks to see whether the channel is blocked. This is for implementing the
 * feature that allows network administrators to block Gmail Chat. The
 * strategy to determine if we're blocked is to try to load an image off a
 * special subdomain that network administrators will block access to if they
 * are trying to block chat. For Gmail Chat, the subdomain is
 * chatenabled.mail.google.com.
 * @private
 */
goog.net.BrowserTestChannel.prototype.checkBlocked_ = function() {
  var uri = this.channel_.createDataUri(this.blockedPrefix_,
      '/mail/images/cleardot.gif');
  uri.makeUnique();
  goog.net.tmpnetwork.testLoadImageWithRetries(uri.toString(),
      goog.net.BrowserTestChannel.BLOCKED_TIMEOUT_,
      goog.bind(this.checkBlockedCallback_, this),
      goog.net.BrowserTestChannel.BLOCKED_RETRIES_,
      goog.net.BrowserTestChannel.BLOCKED_PAUSE_BETWEEN_RETRIES_);
  this.notifyServerReachabilityEvent(
      goog.net.BrowserChannel.ServerReachability.REQUEST_MADE);
};


/**
 * Callback for testLoadImageWithRetries to check if browser channel is
 * blocked.
 * @param {boolean} succeeded Whether the request succeeded.
 * @private
 */
goog.net.BrowserTestChannel.prototype.checkBlockedCallback_ = function(
    succeeded) {
  if (succeeded) {
    this.state_ = goog.net.BrowserTestChannel.State_.CONNECTION_TESTING;
    this.connectStage2_();
  } else {
    goog.net.BrowserChannel.notifyStatEvent(
        goog.net.BrowserChannel.Stat.CHANNEL_BLOCKED);
    this.channel_.testConnectionBlocked(this);
  }

  // We don't dispatch a REQUEST_FAILED server reachability event when the
  // block request fails, as such a failure is not a good signal that the
  // server has actually become unreachable.
  if (succeeded) {
    this.notifyServerReachabilityEvent(
        goog.net.BrowserChannel.ServerReachability.REQUEST_SUCCEEDED);
  }
};


/**
 * Begins the second stage of the test channel where we test to see if we're
 * behind a buffering proxy. The server sends back a multi-chunked response
 * with the first chunk containing the content '1' and then two seconds later
 * sending the second chunk containing the content '2'. Depending on how we
 * receive the content, we can tell if we're behind a buffering proxy.
 * @private
 */
goog.net.BrowserTestChannel.prototype.connectStage2_ = function() {
  this.channelDebug_.debug('TestConnection: starting stage 2');

  // If the second test results are available, skip its execution.
  var secondTestResults = this.channel_.getSecondTestResults();
  if (goog.isDefAndNotNull(secondTestResults)) {
    this.channelDebug_.debug(
        'TestConnection: skipping stage 2, precomputed result is '
        + secondTestResults ? 'Buffered' : 'Unbuffered');
    goog.net.BrowserChannel.notifyStatEvent(
        goog.net.BrowserChannel.Stat.TEST_STAGE_TWO_START);
    if (secondTestResults) { // Buffered/Proxy connection
      goog.net.BrowserChannel.notifyStatEvent(
          goog.net.BrowserChannel.Stat.PROXY);
      this.channel_.testConnectionFinished(this, false);
    } else { // Unbuffered/NoProxy connection
      goog.net.BrowserChannel.notifyStatEvent(
          goog.net.BrowserChannel.Stat.NOPROXY);
      this.channel_.testConnectionFinished(this, true);
    }
    return; // Skip the test
  }
  this.request_ = goog.net.BrowserChannel.createChannelRequest(
      this, this.channelDebug_);
  this.request_.setExtraHeaders(this.extraHeaders_);
  var recvDataUri = this.channel_.getBackChannelUri(this.hostPrefix_,
      /** @type {string} */ (this.path_));

  goog.net.BrowserChannel.notifyStatEvent(
      goog.net.BrowserChannel.Stat.TEST_STAGE_TWO_START);
  if (!goog.net.ChannelRequest.supportsXhrStreaming()) {
    recvDataUri.setParameterValues('TYPE', 'html');
    this.request_.tridentGet(recvDataUri, Boolean(this.hostPrefix_));
  } else {
    recvDataUri.setParameterValues('TYPE', 'xmlhttp');
    this.request_.xmlHttpGet(recvDataUri, false /** decodeChunks */,
        this.hostPrefix_, false /** opt_noClose */);
  }
};


/**
 * Factory method for XhrIo objects.
 * @param {?string} hostPrefix The host prefix, if we need an XhrIo object
 *     capable of calling a secondary domain.
 * @return {!goog.net.XhrIo} New XhrIo object.
 */
goog.net.BrowserTestChannel.prototype.createXhrIo = function(hostPrefix) {
  return this.channel_.createXhrIo(hostPrefix);
};


/**
 * Aborts the test channel.
 */
goog.net.BrowserTestChannel.prototype.abort = function() {
  if (this.request_) {
    this.request_.cancel();
    this.request_ = null;
  }
  this.lastStatusCode_ = -1;
};


/**
 * Returns whether the test channel is closed. The ChannelRequest object expects
 * this method to be implemented on its handler.
 *
 * @return {boolean} Whether the channel is closed.
 */
goog.net.BrowserTestChannel.prototype.isClosed = function() {
  return false;
};


/**
 * Callback from ChannelRequest for when new data is received
 *
 * @param {goog.net.ChannelRequest} req  The request object.
 * @param {string} responseText The text of the response.
 */
goog.net.BrowserTestChannel.prototype.onRequestData =
    function(req, responseText) {
  this.lastStatusCode_ = req.getLastStatusCode();
  if (this.state_ == goog.net.BrowserTestChannel.State_.INIT) {
    this.channelDebug_.debug('TestConnection: Got data for stage 1');
    if (!responseText) {
      this.channelDebug_.debug('TestConnection: Null responseText');
      // The server should always send text; something is wrong here
      this.channel_.testConnectionFailure(this,
          goog.net.ChannelRequest.Error.BAD_DATA);
      return;
    }
    /** @preserveTry */
    try {
      var respArray = this.parser_.parse(responseText);
    } catch (e) {
      this.channelDebug_.dumpException(e);
      this.channel_.testConnectionFailure(this,
          goog.net.ChannelRequest.Error.BAD_DATA);
      return;
    }
    this.hostPrefix_ = this.channel_.correctHostPrefix(respArray[0]);
    this.blockedPrefix_ = respArray[1];
  } else if (this.state_ ==
             goog.net.BrowserTestChannel.State_.CONNECTION_TESTING) {
    if (this.receivedIntermediateResult_) {
      goog.net.BrowserChannel.notifyStatEvent(
          goog.net.BrowserChannel.Stat.TEST_STAGE_TWO_DATA_TWO);
      this.lastTime_ = goog.now();
    } else {
      // '11111' is used instead of '1' to prevent a small amount of buffering
      // by Safari.
      if (responseText == '11111') {
        goog.net.BrowserChannel.notifyStatEvent(
            goog.net.BrowserChannel.Stat.TEST_STAGE_TWO_DATA_ONE);
        this.receivedIntermediateResult_ = true;
        this.firstTime_ = goog.now();
        if (this.checkForEarlyNonBuffered_()) {
          // If early chunk detection is on, and we passed the tests,
          // assume HTTP_OK, cancel the test and turn on noproxy mode.
          this.lastStatusCode_ = 200;
          this.request_.cancel();
          this.channelDebug_.debug(
              'Test connection succeeded; using streaming connection');
          goog.net.BrowserChannel.notifyStatEvent(
              goog.net.BrowserChannel.Stat.NOPROXY);
          this.channel_.testConnectionFinished(this, true);
        }
      } else {
        goog.net.BrowserChannel.notifyStatEvent(
            goog.net.BrowserChannel.Stat.TEST_STAGE_TWO_DATA_BOTH);
        this.firstTime_ = this.lastTime_ = goog.now();
        this.receivedIntermediateResult_ = false;
      }
    }
  }
};


/**
 * Callback from ChannelRequest that indicates a request has completed.
 *
 * @param {goog.net.ChannelRequest} req  The request object.
 */
goog.net.BrowserTestChannel.prototype.onRequestComplete =
    function(req) {
  this.lastStatusCode_ = this.request_.getLastStatusCode();
  if (!this.request_.getSuccess()) {
    this.channelDebug_.debug(
        'TestConnection: request failed, in state ' + this.state_);
    if (this.state_ == goog.net.BrowserTestChannel.State_.INIT) {
      goog.net.BrowserChannel.notifyStatEvent(
          goog.net.BrowserChannel.Stat.TEST_STAGE_ONE_FAILED);
    } else if (this.state_ ==
               goog.net.BrowserTestChannel.State_.CONNECTION_TESTING) {
      goog.net.BrowserChannel.notifyStatEvent(
          goog.net.BrowserChannel.Stat.TEST_STAGE_TWO_FAILED);
    }
    this.channel_.testConnectionFailure(this,
        /** @type {goog.net.ChannelRequest.Error} */
        (this.request_.getLastError()));
    return;
  }

  if (this.state_ == goog.net.BrowserTestChannel.State_.INIT) {
    this.channelDebug_.debug(
        'TestConnection: request complete for initial check');
    if (this.blockedPrefix_) {
      this.state_ = goog.net.BrowserTestChannel.State_.CHECKING_BLOCKED;
      this.checkBlocked_();
    } else {
      this.state_ = goog.net.BrowserTestChannel.State_.CONNECTION_TESTING;
      this.connectStage2_();
    }
  } else if (this.state_ ==
             goog.net.BrowserTestChannel.State_.CONNECTION_TESTING) {
    this.channelDebug_.debug('TestConnection: request complete for stage 2');
    var goodConn = false;

    if (!goog.net.ChannelRequest.supportsXhrStreaming()) {
      // we always get Trident responses in separate calls to
      // onRequestData, so we have to check the time they came
      var ms = this.lastTime_ - this.firstTime_;
      if (ms < 200) {
        // TODO: need to empirically verify that this number is OK
        // for slow computers
        goodConn = false;
      } else {
        goodConn = true;
      }
    } else {
      goodConn = this.receivedIntermediateResult_;
    }

    if (goodConn) {
      this.channelDebug_.debug(
          'Test connection succeeded; using streaming connection');
      goog.net.BrowserChannel.notifyStatEvent(
          goog.net.BrowserChannel.Stat.NOPROXY);
      this.channel_.testConnectionFinished(this, true);
    } else {
      this.channelDebug_.debug(
          'Test connection failed; not using streaming');
      goog.net.BrowserChannel.notifyStatEvent(
          goog.net.BrowserChannel.Stat.PROXY);
      this.channel_.testConnectionFinished(this, false);
    }
  }
};


/**
 * Returns the last status code received for a request.
 * @return {number} The last status code received for a request.
 */
goog.net.BrowserTestChannel.prototype.getLastStatusCode = function() {
  return this.lastStatusCode_;
};


/**
 * @return {boolean} Whether we should be using secondary domains when the
 *     server instructs us to do so.
 */
goog.net.BrowserTestChannel.prototype.shouldUseSecondaryDomains = function() {
  return this.channel_.shouldUseSecondaryDomains();
};


/**
 * Gets whether this channel is currently active. This is used to determine the
 * length of time to wait before retrying.
 *
 * @param {goog.net.BrowserChannel} browserChannel The browser channel.
 * @return {boolean} Whether the channel is currently active.
 */
goog.net.BrowserTestChannel.prototype.isActive =
    function(browserChannel) {
  return this.channel_.isActive();
};


/**
 * @return {boolean} True if test stage 2 detected a non-buffered
 *     channel early and early no buffering detection is enabled.
 * @private
 */
goog.net.BrowserTestChannel.prototype.checkForEarlyNonBuffered_ =
    function() {
  var ms = this.firstTime_ - this.startTime_;

  // we always get Trident responses in separate calls to
  // onRequestData, so we have to check the time that the first came in
  // and verify that the data arrived before the second portion could
  // have been sent. For all other browser's we skip the timing test.
  return goog.net.ChannelRequest.supportsXhrStreaming() ||
      ms < goog.net.BrowserTestChannel.MIN_TIME_EXPECTED_BETWEEN_DATA_;
};


/**
 * Notifies the channel of a fine grained network event.
 * @param {goog.net.BrowserChannel.ServerReachability} reachabilityType The
 *     reachability event type.
 */
goog.net.BrowserTestChannel.prototype.notifyServerReachabilityEvent =
    function(reachabilityType) {
  this.channel_.notifyServerReachabilityEvent(reachabilityType);
};

//javascript/closure/net/browserchannel.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the BrowserChannel class.  A BrowserChannel
 * simulates a bidirectional socket over HTTP. It is the basis of the
 * Gmail Chat IM connections to the server.
 *
 * Typical usage will look like
 *  var handler = [handler object];
 *  var channel = new BrowserChannel(clientVersion);
 *  channel.setHandler(handler);
 *  channel.connect('channel/test', 'channel/bind');
 *
 * See goog.net.BrowserChannel.Handler for the handler interface.
 *
 * @author jonp@google.com (Jon Perlow)
 */


goog.provide('goog.net.BrowserChannel');
goog.provide('goog.net.BrowserChannel.Error');
goog.provide('goog.net.BrowserChannel.Event');
goog.provide('goog.net.BrowserChannel.Handler');
goog.provide('goog.net.BrowserChannel.LogSaver');
goog.provide('goog.net.BrowserChannel.QueuedMap');
goog.provide('goog.net.BrowserChannel.ServerReachability');
goog.provide('goog.net.BrowserChannel.ServerReachabilityEvent');
goog.provide('goog.net.BrowserChannel.Stat');
goog.provide('goog.net.BrowserChannel.StatEvent');
goog.provide('goog.net.BrowserChannel.State');
goog.provide('goog.net.BrowserChannel.TimingEvent');

goog.require('goog.Uri');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug.TextFormatter');
goog.require('goog.events.Event');
goog.require('goog.events.EventTarget');
goog.require('goog.json');
goog.require('goog.json.EvalJsonProcessor');
goog.require('goog.log');
goog.require('goog.net.BrowserTestChannel');
goog.require('goog.net.ChannelDebug');
goog.require('goog.net.ChannelRequest');
goog.require('goog.net.XhrIo');
goog.require('goog.net.tmpnetwork');
goog.require('goog.string');
goog.require('goog.structs');
goog.require('goog.structs.CircularBuffer');



/**
 * Encapsulates the logic for a single BrowserChannel.
 *
 * @param {string=} opt_clientVersion An application-specific version number
 *        that is sent to the server when connected.
 * @param {Array.<string>=} opt_firstTestResults Previously determined results
 *        of the first browser channel test.
 * @param {boolean=} opt_secondTestResults Previously determined results
 *        of the second browser channel test.
 * @constructor
 */
goog.net.BrowserChannel = function(opt_clientVersion, opt_firstTestResults,
    opt_secondTestResults) {
  /**
   * The application specific version that is passed to the server.
   * @type {?string}
   * @private
   */
  this.clientVersion_ = opt_clientVersion || null;

  /**
   * The current state of the BrowserChannel. It should be one of the
   * goog.net.BrowserChannel.State constants.
   * @type {!goog.net.BrowserChannel.State}
   * @private
   */
  this.state_ = goog.net.BrowserChannel.State.INIT;

  /**
   * An array of queued maps that need to be sent to the server.
   * @type {Array.<goog.net.BrowserChannel.QueuedMap>}
   * @private
   */
  this.outgoingMaps_ = [];

  /**
   * An array of dequeued maps that we have either received a non-successful
   * response for, or no response at all, and which therefore may or may not
   * have been received by the server.
   * @type {Array.<goog.net.BrowserChannel.QueuedMap>}
   * @private
   */
  this.pendingMaps_ = [];

  /**
   * The channel debug used for browserchannel logging
   * @type {!goog.net.ChannelDebug}
   * @private
   */
  this.channelDebug_ = new goog.net.ChannelDebug();

  /**
   * Parser for a response payload. Defaults to use
   * {@code goog.json.unsafeParse}. The parser should return an array.
   * @type {!goog.string.Parser}
   * @private
   */
  this.parser_ = new goog.json.EvalJsonProcessor(null, true);

  /**
   * An array of results for the first browser channel test call.
   * @type {Array.<string>}
   * @private
   */
  this.firstTestResults_ = opt_firstTestResults || null;

  /**
   * The results of the second browser channel test. True implies the
   * connection is buffered, False means unbuffered, null means that
   * the results are not available.
   * @private
   */
  this.secondTestResults_ = goog.isDefAndNotNull(opt_secondTestResults) ?
      opt_secondTestResults : null;
};



/**
 * Simple container class for a (mapId, map) pair.
 * @param {number} mapId The id for this map.
 * @param {Object|goog.structs.Map} map The map itself.
 * @param {Object=} opt_context The context associated with the map.
 * @constructor
 * @final
 */
goog.net.BrowserChannel.QueuedMap = function(mapId, map, opt_context) {
  /**
   * The id for this map.
   * @type {number}
   */
  this.mapId = mapId;

  /**
   * The map itself.
   * @type {Object|goog.structs.Map}
   */
  this.map = map;

  /**
   * The context for the map.
   * @type {Object}
   */
  this.context = opt_context || null;
};


/**
 * Extra HTTP headers to add to all the requests sent to the server.
 * @type {Object}
 * @private
 */
goog.net.BrowserChannel.prototype.extraHeaders_ = null;


/**
 * Extra parameters to add to all the requests sent to the server.
 * @type {Object}
 * @private
 */
goog.net.BrowserChannel.prototype.extraParams_ = null;


/**
 * The current ChannelRequest object for the forwardchannel.
 * @type {goog.net.ChannelRequest?}
 * @private
 */
goog.net.BrowserChannel.prototype.forwardChannelRequest_ = null;


/**
 * The ChannelRequest object for the backchannel.
 * @type {goog.net.ChannelRequest?}
 * @private
 */
goog.net.BrowserChannel.prototype.backChannelRequest_ = null;


/**
 * The relative path (in the context of the the page hosting the browser
 * channel) for making requests to the server.
 * @type {?string}
 * @private
 */
goog.net.BrowserChannel.prototype.path_ = null;


/**
 * The absolute URI for the forwardchannel request.
 * @type {goog.Uri}
 * @private
 */
goog.net.BrowserChannel.prototype.forwardChannelUri_ = null;


/**
 * The absolute URI for the backchannel request.
 * @type {goog.Uri}
 * @private
 */
goog.net.BrowserChannel.prototype.backChannelUri_ = null;


/**
 * A subdomain prefix for using a subdomain in IE for the backchannel
 * requests.
 * @type {?string}
 * @private
 */
goog.net.BrowserChannel.prototype.hostPrefix_ = null;


/**
 * Whether we allow the use of a subdomain in IE for the backchannel requests.
 * @private
 */
goog.net.BrowserChannel.prototype.allowHostPrefix_ = true;


/**
 * The next id to use for the RID (request identifier) parameter. This
 * identifier uniquely identifies the forward channel request.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.nextRid_ = 0;


/**
 * The id to use for the next outgoing map. This identifier uniquely
 * identifies a sent map.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.nextMapId_ = 0;


/**
 * Whether to fail forward-channel requests after one try, or after a few tries.
 * @type {boolean}
 * @private
 */
goog.net.BrowserChannel.prototype.failFast_ = false;


/**
 * The handler that receive callbacks for state changes and data.
 * @type {goog.net.BrowserChannel.Handler}
 * @private
 */
goog.net.BrowserChannel.prototype.handler_ = null;


/**
 * Timer identifier for asynchronously making a forward channel request.
 * @type {?number}
 * @private
 */
goog.net.BrowserChannel.prototype.forwardChannelTimerId_ = null;


/**
 * Timer identifier for asynchronously making a back channel request.
 * @type {?number}
 * @private
 */
goog.net.BrowserChannel.prototype.backChannelTimerId_ = null;


/**
 * Timer identifier for the timer that waits for us to retry the backchannel in
 * the case where it is dead and no longer receiving data.
 * @type {?number}
 * @private
 */
goog.net.BrowserChannel.prototype.deadBackChannelTimerId_ = null;


/**
 * The BrowserTestChannel object which encapsulates the logic for determining
 * interesting network conditions about the client.
 * @type {goog.net.BrowserTestChannel?}
 * @private
 */
goog.net.BrowserChannel.prototype.connectionTest_ = null;


/**
 * Whether the client's network conditions can support chunked responses.
 * @type {?boolean}
 * @private
 */
goog.net.BrowserChannel.prototype.useChunked_ = null;


/**
 * Whether chunked mode is allowed. In certain debugging situations, it's
 * useful to disable this.
 * @private
 */
goog.net.BrowserChannel.prototype.allowChunkedMode_ = true;


/**
 * The array identifier of the last array received from the server for the
 * backchannel request.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.lastArrayId_ = -1;


/**
 * The array identifier of the last array sent by the server that we know about.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.lastPostResponseArrayId_ = -1;


/**
 * The last status code received.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.lastStatusCode_ = -1;


/**
 * Number of times we have retried the current forward channel request.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.forwardChannelRetryCount_ = 0;


/**
 * Number of times it a row that we have retried the current back channel
 * request and received no data.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.backChannelRetryCount_ = 0;


/**
 * The attempt id for the current back channel request. Starts at 1 and
 * increments for each reconnect. The server uses this to log if our connection
 * is flaky or not.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.backChannelAttemptId_;


/**
 * The base part of the time before firing next retry request. Default is 5
 * seconds. Note that a random delay is added (see {@link retryDelaySeedMs_})
 * for all retries, and linear backoff is applied to the sum for subsequent
 * retries.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.baseRetryDelayMs_ = 5 * 1000;


/**
 * A random time between 0 and this number of MS is added to the
 * {@link baseRetryDelayMs_}. Default is 10 seconds.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.retryDelaySeedMs_ = 10 * 1000;


/**
 * Maximum number of attempts to connect to the server for forward channel
 * requests. Defaults to 2.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.forwardChannelMaxRetries_ = 2;


/**
 * The timeout in milliseconds for a forward channel request. Defaults to 20
 * seconds. Note that part of this timeout can be randomized.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.forwardChannelRequestTimeoutMs_ = 20 * 1000;


/**
 * A throttle time in ms for readystatechange events for the backchannel.
 * Useful for throttling when ready state is INTERACTIVE (partial data).
 *
 * This throttle is useful if the server sends large data chunks down the
 * backchannel.  It prevents examining XHR partial data on every
 * readystate change event.  This is useful because large chunks can
 * trigger hundreds of readystatechange events, each of which takes ~5ms
 * or so to handle, in turn making the UI unresponsive for a significant period.
 *
 * If set to zero no throttle is used.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.readyStateChangeThrottleMs_ = 0;


/**
 * Whether cross origin requests are supported for the browser channel.
 *
 * See {@link goog.net.XhrIo#setWithCredentials}.
 * @type {boolean}
 * @private
 */
goog.net.BrowserChannel.prototype.supportsCrossDomainXhrs_ = false;


/**
 * The latest protocol version that this class supports. We request this version
 * from the server when opening the connection. Should match
 * com.google.net.browserchannel.BrowserChannel.LATEST_CHANNEL_VERSION.
 * @type {number}
 */
goog.net.BrowserChannel.LATEST_CHANNEL_VERSION = 8;


/**
 * The channel version that we negotiated with the server for this session.
 * Starts out as the version we request, and then is changed to the negotiated
 * version after the initial open.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.prototype.channelVersion_ =
    goog.net.BrowserChannel.LATEST_CHANNEL_VERSION;


/**
 * Enum type for the browser channel state machine.
 * @enum {number}
 */
goog.net.BrowserChannel.State = {
  /** The channel is closed. */
  CLOSED: 0,

  /** The channel has been initialized but hasn't yet initiated a connection. */
  INIT: 1,

  /** The channel is in the process of opening a connection to the server. */
  OPENING: 2,

  /** The channel is open. */
  OPENED: 3
};


/**
 * The timeout in milliseconds for a forward channel request.
 * @type {number}
 */
goog.net.BrowserChannel.FORWARD_CHANNEL_RETRY_TIMEOUT = 20 * 1000;


/**
 * Maximum number of attempts to connect to the server for back channel
 * requests.
 * @type {number}
 */
goog.net.BrowserChannel.BACK_CHANNEL_MAX_RETRIES = 3;


/**
 * A number in MS of how long we guess the maxmium amount of time a round trip
 * to the server should take. In the future this could be substituted with a
 * real measurement of the RTT.
 * @type {number}
 */
goog.net.BrowserChannel.RTT_ESTIMATE = 3 * 1000;


/**
 * When retrying for an inactive channel, we will multiply the total delay by
 * this number.
 * @type {number}
 */
goog.net.BrowserChannel.INACTIVE_CHANNEL_RETRY_FACTOR = 2;


/**
 * Enum type for identifying a BrowserChannel error.
 * @enum {number}
 */
goog.net.BrowserChannel.Error = {
  /** Value that indicates no error has occurred. */
  OK: 0,

  /** An error due to a request failing. */
  REQUEST_FAILED: 2,

  /** An error due to the user being logged out. */
  LOGGED_OUT: 4,

  /** An error due to server response which contains no data. */
  NO_DATA: 5,

  /** An error due to a server response indicating an unknown session id */
  UNKNOWN_SESSION_ID: 6,

  /** An error due to a server response requesting to stop the channel. */
  STOP: 7,

  /** A general network error. */
  NETWORK: 8,

  /** An error due to the channel being blocked by a network administrator. */
  BLOCKED: 9,

  /** An error due to bad data being returned from the server. */
  BAD_DATA: 10,

  /** An error due to a response that doesn't start with the magic cookie. */
  BAD_RESPONSE: 11,

  /** ActiveX is blocked by the machine's admin settings. */
  ACTIVE_X_BLOCKED: 12
};


/**
 * Internal enum type for the two browser channel channel types.
 * @enum {number}
 * @private
 */
goog.net.BrowserChannel.ChannelType_ = {
  FORWARD_CHANNEL: 1,

  BACK_CHANNEL: 2
};


/**
 * The maximum number of maps that can be sent in one POST. Should match
 * com.google.net.browserchannel.BrowserChannel.MAX_MAPS_PER_REQUEST.
 * @type {number}
 * @private
 */
goog.net.BrowserChannel.MAX_MAPS_PER_REQUEST_ = 1000;


/**
 * Singleton event target for firing stat events
 * @type {goog.events.EventTarget}
 * @private
 */
goog.net.BrowserChannel.statEventTarget_ = new goog.events.EventTarget();


/**
 * Events fired by BrowserChannel and associated objects
 * @type {Object}
 */
goog.net.BrowserChannel.Event = {};


/**
 * Stat Event that fires when things of interest happen that may be useful for
 * applications to know about for stats or debugging purposes. This event fires
 * on the EventTarget returned by getStatEventTarget.
 */
goog.net.BrowserChannel.Event.STAT_EVENT = 'statevent';



/**
 * Event class for goog.net.BrowserChannel.Event.STAT_EVENT
 *
 * @param {goog.events.EventTarget} eventTarget The stat event target for
       the browser channel.
 * @param {goog.net.BrowserChannel.Stat} stat The stat.
 * @constructor
 * @extends {goog.events.Event}
 * @final
 */
goog.net.BrowserChannel.StatEvent = function(eventTarget, stat) {
  goog.events.Event.call(this, goog.net.BrowserChannel.Event.STAT_EVENT,
      eventTarget);

  /**
   * The stat
   * @type {goog.net.BrowserChannel.Stat}
   */
  this.stat = stat;

};
goog.inherits(goog.net.BrowserChannel.StatEvent, goog.events.Event);


/**
 * An event that fires when POST requests complete successfully, indicating
 * the size of the POST and the round trip time.
 * This event fires on the EventTarget returned by getStatEventTarget.
 */
goog.net.BrowserChannel.Event.TIMING_EVENT = 'timingevent';



/**
 * Event class for goog.net.BrowserChannel.Event.TIMING_EVENT
 *
 * @param {goog.events.EventTarget} target The stat event target for
       the browser channel.
 * @param {number} size The number of characters in the POST data.
 * @param {number} rtt The total round trip time from POST to response in MS.
 * @param {number} retries The number of times the POST had to be retried.
 * @constructor
 * @extends {goog.events.Event}
 * @final
 */
goog.net.BrowserChannel.TimingEvent = function(target, size, rtt, retries) {
  goog.events.Event.call(this, goog.net.BrowserChannel.Event.TIMING_EVENT,
      target);

  /**
   * @type {number}
   */
  this.size = size;

  /**
   * @type {number}
   */
  this.rtt = rtt;

  /**
   * @type {number}
   */
  this.retries = retries;

};
goog.inherits(goog.net.BrowserChannel.TimingEvent, goog.events.Event);


/**
 * The type of event that occurs every time some information about how reachable
 * the server is is discovered.
 */
goog.net.BrowserChannel.Event.SERVER_REACHABILITY_EVENT =
    'serverreachability';


/**
 * Types of events which reveal information about the reachability of the
 * server.
 * @enum {number}
 */
goog.net.BrowserChannel.ServerReachability = {
  REQUEST_MADE: 1,
  REQUEST_SUCCEEDED: 2,
  REQUEST_FAILED: 3,
  BACK_CHANNEL_ACTIVITY: 4
};



/**
 * Event class for goog.net.BrowserChannel.Event.SERVER_REACHABILITY_EVENT.
 *
 * @param {goog.events.EventTarget} target The stat event target for
       the browser channel.
 * @param {goog.net.BrowserChannel.ServerReachability} reachabilityType The
 *     reachability event type.
 * @constructor
 * @extends {goog.events.Event}
 * @final
 */
goog.net.BrowserChannel.ServerReachabilityEvent = function(target,
    reachabilityType) {
  goog.events.Event.call(this,
      goog.net.BrowserChannel.Event.SERVER_REACHABILITY_EVENT, target);

  /**
   * @type {goog.net.BrowserChannel.ServerReachability}
   */
  this.reachabilityType = reachabilityType;
};
goog.inherits(goog.net.BrowserChannel.ServerReachabilityEvent,
    goog.events.Event);


/**
 * Enum that identifies events for statistics that are interesting to track.
 * TODO(jonp) - Change name not to use Event or use EventTarget
 * @enum {number}
 */
goog.net.BrowserChannel.Stat = {
  /** Event indicating a new connection attempt. */
  CONNECT_ATTEMPT: 0,

  /** Event indicating a connection error due to a general network problem. */
  ERROR_NETWORK: 1,

  /**
   * Event indicating a connection error that isn't due to a general network
   * problem.
   */
  ERROR_OTHER: 2,

  /** Event indicating the start of test stage one. */
  TEST_STAGE_ONE_START: 3,


  /** Event indicating the channel is blocked by a network administrator. */
  CHANNEL_BLOCKED: 4,

  /** Event indicating the start of test stage two. */
  TEST_STAGE_TWO_START: 5,

  /** Event indicating the first piece of test data was received. */
  TEST_STAGE_TWO_DATA_ONE: 6,

  /**
   * Event indicating that the second piece of test data was received and it was
   * recieved separately from the first.
   */
  TEST_STAGE_TWO_DATA_TWO: 7,

  /** Event indicating both pieces of test data were received simultaneously. */
  TEST_STAGE_TWO_DATA_BOTH: 8,

  /** Event indicating stage one of the test request failed. */
  TEST_STAGE_ONE_FAILED: 9,

  /** Event indicating stage two of the test request failed. */
  TEST_STAGE_TWO_FAILED: 10,

  /**
   * Event indicating that a buffering proxy is likely between the client and
   * the server.
   */
  PROXY: 11,

  /**
   * Event indicating that no buffering proxy is likely between the client and
   * the server.
   */
  NOPROXY: 12,

  /** Event indicating an unknown SID error. */
  REQUEST_UNKNOWN_SESSION_ID: 13,

  /** Event indicating a bad status code was received. */
  REQUEST_BAD_STATUS: 14,

  /** Event indicating incomplete data was received */
  REQUEST_INCOMPLETE_DATA: 15,

  /** Event indicating bad data was received */
  REQUEST_BAD_DATA: 16,

  /** Event indicating no data was received when data was expected. */
  REQUEST_NO_DATA: 17,

  /** Event indicating a request timeout. */
  REQUEST_TIMEOUT: 18,

  /**
   * Event indicating that the server never received our hanging GET and so it
   * is being retried.
   */
  BACKCHANNEL_MISSING: 19,

  /**
   * Event indicating that we have determined that our hanging GET is not
   * receiving data when it should be. Thus it is dead dead and will be retried.
   */
  BACKCHANNEL_DEAD: 20,

  /**
   * The browser declared itself offline during the lifetime of a request, or
   * was offline when a request was initially made.
   */
  BROWSER_OFFLINE: 21,

  /** ActiveX is blocked by the machine's admin settings. */
  ACTIVE_X_BLOCKED: 22
};


/**
 * The normal response for forward channel requests.
 * Used only before version 8 of the protocol.
 * @type {string}
 */
goog.net.BrowserChannel.MAGIC_RESPONSE_COOKIE = 'y2f%';


/**
 * A guess at a cutoff at which to no longer assume the backchannel is dead
 * when we are slow to receive data. Number in bytes.
 *
 * Assumption: The worst bandwidth we work on is 50 kilobits/sec
 * 50kbits/sec * (1 byte / 8 bits) * 6 sec dead backchannel timeout
 * @type {number}
 */
goog.net.BrowserChannel.OUTSTANDING_DATA_BACKCHANNEL_RETRY_CUTOFF = 37500;


/**
 * Returns the browserchannel logger.
 *
 * @return {goog.net.ChannelDebug} The channel debug object.
 */
goog.net.BrowserChannel.prototype.getChannelDebug = function() {
  return this.channelDebug_;
};


/**
 * Set the browserchannel logger.
 * TODO(wud): Add interface for channel loggers or remove this function.
 *
 * @param {goog.net.ChannelDebug} channelDebug The channel debug object.
 */
goog.net.BrowserChannel.prototype.setChannelDebug = function(
    channelDebug) {
  if (goog.isDefAndNotNull(channelDebug)) {
    this.channelDebug_ = channelDebug;
  }
};


/**
 * Allows the application to set an execution hooks for when BrowserChannel
 * starts processing requests. This is useful to track timing or logging
 * special information. The function takes no parameters and return void.
 * @param {Function} startHook  The function for the start hook.
 */
goog.net.BrowserChannel.setStartThreadExecutionHook = function(startHook) {
  goog.net.BrowserChannel.startExecutionHook_ = startHook;
};


/**
 * Allows the application to set an execution hooks for when BrowserChannel
 * stops processing requests. This is useful to track timing or logging
 * special information. The function takes no parameters and return void.
 * @param {Function} endHook  The function for the end hook.
 */
goog.net.BrowserChannel.setEndThreadExecutionHook = function(endHook) {
  goog.net.BrowserChannel.endExecutionHook_ = endHook;
};


/**
 * Application provided execution hook for the start hook.
 *
 * @type {Function}
 * @private
 */
goog.net.BrowserChannel.startExecutionHook_ = function() { };


/**
 * Application provided execution hook for the end hook.
 *
 * @type {Function}
 * @private
 */
goog.net.BrowserChannel.endExecutionHook_ = function() { };


/**
 * Instantiates a ChannelRequest with the given parameters. Overidden in tests.
 *
 * @param {goog.net.BrowserChannel|goog.net.BrowserTestChannel} channel
 *     The BrowserChannel that owns this request.
 * @param {goog.net.ChannelDebug} channelDebug A ChannelDebug to use for
 *     logging.
 * @param {string=} opt_sessionId  The session id for the channel.
 * @param {string|number=} opt_requestId  The request id for this request.
 * @param {number=} opt_retryId  The retry id for this request.
 * @return {goog.net.ChannelRequest} The created channel request.
 */
goog.net.BrowserChannel.createChannelRequest = function(channel, channelDebug,
    opt_sessionId, opt_requestId, opt_retryId) {
  return new goog.net.ChannelRequest(
      channel,
      channelDebug,
      opt_sessionId,
      opt_requestId,
      opt_retryId);
};


/**
 * Starts the channel. This initiates connections to the server.
 *
 * @param {string} testPath  The path for the test connection.
 * @param {string} channelPath  The path for the channel connection.
 * @param {Object=} opt_extraParams  Extra parameter keys and values to add to
 *     the requests.
 * @param {string=} opt_oldSessionId  Session ID from a previous session.
 * @param {number=} opt_oldArrayId  The last array ID from a previous session.
 */
goog.net.BrowserChannel.prototype.connect = function(testPath, channelPath,
    opt_extraParams, opt_oldSessionId, opt_oldArrayId) {
  this.channelDebug_.debug('connect()');

  goog.net.BrowserChannel.notifyStatEvent(
      goog.net.BrowserChannel.Stat.CONNECT_ATTEMPT);

  this.path_ = channelPath;
  this.extraParams_ = opt_extraParams || {};

  // Attach parameters about the previous session if reconnecting.
  if (opt_oldSessionId && goog.isDef(opt_oldArrayId)) {
    this.extraParams_['OSID'] = opt_oldSessionId;
    this.extraParams_['OAID'] = opt_oldArrayId;
  }

  this.connectTest_(testPath);
};


/**
 * Disconnects and closes the channel.
 */
goog.net.BrowserChannel.prototype.disconnect = function() {
  this.channelDebug_.debug('disconnect()');

  this.cancelRequests_();

  if (this.state_ == goog.net.BrowserChannel.State.OPENED) {
    var rid = this.nextRid_++;
    var uri = this.forwardChannelUri_.clone();
    uri.setParameterValue('SID', this.sid_);
    uri.setParameterValue('RID', rid);
    uri.setParameterValue('TYPE', 'terminate');

    // Add the reconnect parameters.
    this.addAdditionalParams_(uri);

    var request = goog.net.BrowserChannel.createChannelRequest(
        this, this.channelDebug_, this.sid_, rid);
    request.sendUsingImgTag(uri);
  }

  this.onClose_();
};


/**
 * Returns the session id of the channel. Only available after the
 * channel has been opened.
 * @return {string} Session ID.
 */
goog.net.BrowserChannel.prototype.getSessionId = function() {
  return this.sid_;
};


/**
 * Starts the test channel to determine network conditions.
 *
 * @param {string} testPath  The relative PATH for the test connection.
 * @private
 */
goog.net.BrowserChannel.prototype.connectTest_ = function(testPath) {
  this.channelDebug_.debug('connectTest_()');
  if (!this.okToMakeRequest_()) {
    return; // channel is cancelled
  }
  this.connectionTest_ = new goog.net.BrowserTestChannel(
      this, this.channelDebug_);
  this.connectionTest_.setExtraHeaders(this.extraHeaders_);
  this.connectionTest_.setParser(this.parser_);
  this.connectionTest_.connect(testPath);
};


/**
 * Starts the regular channel which is run after the test channel is complete.
 * @private
 */
goog.net.BrowserChannel.prototype.connectChannel_ = function() {
  this.channelDebug_.debug('connectChannel_()');
  this.ensureInState_(goog.net.BrowserChannel.State.INIT,
      goog.net.BrowserChannel.State.CLOSED);
  this.forwardChannelUri_ =
      this.getForwardChannelUri(/** @type {string} */ (this.path_));
  this.ensureForwardChannel_();
};


/**
 * Cancels all outstanding requests.
 * @private
 */
goog.net.BrowserChannel.prototype.cancelRequests_ = function() {
  if (this.connectionTest_) {
    this.connectionTest_.abort();
    this.connectionTest_ = null;
  }

  if (this.backChannelRequest_) {
    this.backChannelRequest_.cancel();
    this.backChannelRequest_ = null;
  }

  if (this.backChannelTimerId_) {
    goog.global.clearTimeout(this.backChannelTimerId_);
    this.backChannelTimerId_ = null;
  }

  this.clearDeadBackchannelTimer_();

  if (this.forwardChannelRequest_) {
    this.forwardChannelRequest_.cancel();
    this.forwardChannelRequest_ = null;
  }

  if (this.forwardChannelTimerId_) {
    goog.global.clearTimeout(this.forwardChannelTimerId_);
    this.forwardChannelTimerId_ = null;
  }
};


/**
 * Returns the extra HTTP headers to add to all the requests sent to the server.
 *
 * @return {Object} The HTTP headers, or null.
 */
goog.net.BrowserChannel.prototype.getExtraHeaders = function() {
  return this.extraHeaders_;
};


/**
 * Sets extra HTTP headers to add to all the requests sent to the server.
 *
 * @param {Object} extraHeaders The HTTP headers, or null.
 */
goog.net.BrowserChannel.prototype.setExtraHeaders = function(extraHeaders) {
  this.extraHeaders_ = extraHeaders;
};


/**
 * Sets the throttle for handling onreadystatechange events for the request.
 *
 * @param {number} throttle The throttle in ms.  A value of zero indicates
 *     no throttle.
 */
goog.net.BrowserChannel.prototype.setReadyStateChangeThrottle = function(
    throttle) {
  this.readyStateChangeThrottleMs_ = throttle;
};


/**
 * Sets whether cross origin requests are supported for the browser channel.
 *
 * Setting this allows the creation of requests to secondary domains and
 * sends XHRs with the CORS withCredentials bit set to true.
 *
 * In order for cross-origin requests to work, the server will also need to set
 * CORS response headers as per:
 * https://developer.mozilla.org/en-US/docs/HTTP_access_control
 *
 * See {@link goog.net.XhrIo#setWithCredentials}.
 * @param {boolean} supportCrossDomain Whether cross domain XHRs are supported.
 */
goog.net.BrowserChannel.prototype.setSupportsCrossDomainXhrs = function(
    supportCrossDomain) {
  this.supportsCrossDomainXhrs_ = supportCrossDomain;
};


/**
 * Returns the handler used for channel callback events.
 *
 * @return {goog.net.BrowserChannel.Handler} The handler.
 */
goog.net.BrowserChannel.prototype.getHandler = function() {
  return this.handler_;
};


/**
 * Sets the handler used for channel callback events.
 * @param {goog.net.BrowserChannel.Handler} handler The handler to set.
 */
goog.net.BrowserChannel.prototype.setHandler = function(handler) {
  this.handler_ = handler;
};


/**
 * Returns whether the channel allows the use of a subdomain. There may be
 * cases where this isn't allowed.
 * @return {boolean} Whether a host prefix is allowed.
 */
goog.net.BrowserChannel.prototype.getAllowHostPrefix = function() {
  return this.allowHostPrefix_;
};


/**
 * Sets whether the channel allows the use of a subdomain. There may be cases
 * where this isn't allowed, for example, logging in with troutboard where
 * using a subdomain causes Apache to force the user to authenticate twice.
 * @param {boolean} allowHostPrefix Whether a host prefix is allowed.
 */
goog.net.BrowserChannel.prototype.setAllowHostPrefix =
    function(allowHostPrefix) {
  this.allowHostPrefix_ = allowHostPrefix;
};


/**
 * Returns whether the channel is buffered or not. This state is valid for
 * querying only after the test connection has completed. This may be
 * queried in the goog.net.BrowserChannel.okToMakeRequest() callback.
 * A channel may be buffered if the test connection determines that
 * a chunked response could not be sent down within a suitable time.
 * @return {boolean} Whether the channel is buffered.
 */
goog.net.BrowserChannel.prototype.isBuffered = function() {
  return !this.useChunked_;
};


/**
 * Returns whether chunked mode is allowed. In certain debugging situations,
 * it's useful for the application to have a way to disable chunked mode for a
 * user.

 * @return {boolean} Whether chunked mode is allowed.
 */
goog.net.BrowserChannel.prototype.getAllowChunkedMode =
    function() {
  return this.allowChunkedMode_;
};


/**
 * Sets whether chunked mode is allowed. In certain debugging situations, it's
 * useful for the application to have a way to disable chunked mode for a user.
 * @param {boolean} allowChunkedMode  Whether chunked mode is allowed.
 */
goog.net.BrowserChannel.prototype.setAllowChunkedMode =
    function(allowChunkedMode) {
  this.allowChunkedMode_ = allowChunkedMode;
};


/**
 * Sends a request to the server. The format of the request is a Map data
 * structure of key/value pairs. These maps are then encoded in a format
 * suitable for the wire and then reconstituted as a Map data structure that
 * the server can process.
 * @param {Object|goog.structs.Map} map  The map to send.
 * @param {?Object=} opt_context The context associated with the map.
 */
goog.net.BrowserChannel.prototype.sendMap = function(map, opt_context) {
  if (this.state_ == goog.net.BrowserChannel.State.CLOSED) {
    throw Error('Invalid operation: sending map when state is closed');
  }

  // We can only send 1000 maps per POST, but typically we should never have
  // that much to send, so warn if we exceed that (we still send all the maps).
  if (this.outgoingMaps_.length ==
      goog.net.BrowserChannel.MAX_MAPS_PER_REQUEST_) {
    // severe() is temporary so that we get these uploaded and can figure out
    // what's causing them. Afterwards can change to warning().
    this.channelDebug_.severe(
        'Already have ' + goog.net.BrowserChannel.MAX_MAPS_PER_REQUEST_ +
        ' queued maps upon queueing ' + goog.json.serialize(map));
  }

  this.outgoingMaps_.push(
      new goog.net.BrowserChannel.QueuedMap(this.nextMapId_++, map,
                                            opt_context));
  if (this.state_ == goog.net.BrowserChannel.State.OPENING ||
      this.state_ == goog.net.BrowserChannel.State.OPENED) {
    this.ensureForwardChannel_();
  }
};


/**
 * When set to true, this changes the behavior of the forward channel so it
 * will not retry requests; it will fail after one network failure, and if
 * there was already one network failure, the request will fail immediately.
 * @param {boolean} failFast  Whether or not to fail fast.
 */
goog.net.BrowserChannel.prototype.setFailFast = function(failFast) {
  this.failFast_ = failFast;
  this.channelDebug_.info('setFailFast: ' + failFast);
  if ((this.forwardChannelRequest_ || this.forwardChannelTimerId_) &&
      this.forwardChannelRetryCount_ > this.getForwardChannelMaxRetries()) {
    this.channelDebug_.info(
        'Retry count ' + this.forwardChannelRetryCount_ +
        ' > new maxRetries ' + this.getForwardChannelMaxRetries() +
        '. Fail immediately!');
    if (this.forwardChannelRequest_) {
      this.forwardChannelRequest_.cancel();
      // Go through the standard onRequestComplete logic to expose the max-retry
      // failure in the standard way.
      this.onRequestComplete(this.forwardChannelRequest_);
    } else {  // i.e., this.forwardChannelTimerId_
      goog.global.clearTimeout(this.forwardChannelTimerId_);
      this.forwardChannelTimerId_ = null;
      // The error code from the last failed request is gone, so just use a
      // generic one.
      this.signalError_(goog.net.BrowserChannel.Error.REQUEST_FAILED);
    }
  }
};


/**
 * @return {number} The max number of forward-channel retries, which will be 0
 * in fail-fast mode.
 */
goog.net.BrowserChannel.prototype.getForwardChannelMaxRetries = function() {
  return this.failFast_ ? 0 : this.forwardChannelMaxRetries_;
};


/**
 * Sets the maximum number of attempts to connect to the server for forward
 * channel requests.
 * @param {number} retries The maximum number of attempts.
 */
goog.net.BrowserChannel.prototype.setForwardChannelMaxRetries =
    function(retries) {
  this.forwardChannelMaxRetries_ = retries;
};


/**
 * Sets the timeout for a forward channel request.
 * @param {number} timeoutMs The timeout in milliseconds.
 */
goog.net.BrowserChannel.prototype.setForwardChannelRequestTimeout =
    function(timeoutMs) {
  this.forwardChannelRequestTimeoutMs_ = timeoutMs;
};


/**
 * @return {number} The max number of back-channel retries, which is a constant.
 */
goog.net.BrowserChannel.prototype.getBackChannelMaxRetries = function() {
  // Back-channel retries is a constant.
  return goog.net.BrowserChannel.BACK_CHANNEL_MAX_RETRIES;
};


/**
 * Returns whether the channel is closed
 * @return {boolean} true if the channel is closed.
 */
goog.net.BrowserChannel.prototype.isClosed = function() {
  return this.state_ == goog.net.BrowserChannel.State.CLOSED;
};


/**
 * Returns the browser channel state.
 * @return {goog.net.BrowserChannel.State} The current state of the browser
 * channel.
 */
goog.net.BrowserChannel.prototype.getState = function() {
  return this.state_;
};


/**
 * Return the last status code received for a request.
 * @return {number} The last status code received for a request.
 */
goog.net.BrowserChannel.prototype.getLastStatusCode = function() {
  return this.lastStatusCode_;
};


/**
 * @return {number} The last array id received.
 */
goog.net.BrowserChannel.prototype.getLastArrayId = function() {
  return this.lastArrayId_;
};


/**
 * Returns whether there are outstanding requests servicing the channel.
 * @return {boolean} true if there are outstanding requests.
 */
goog.net.BrowserChannel.prototype.hasOutstandingRequests = function() {
  return this.outstandingRequests_() != 0;
};


/**
 * Sets a new parser for the response payload. A custom parser may be set to
 * avoid using eval(), for example. By default, the parser uses
 * {@code goog.json.unsafeParse}.
 * @param {!goog.string.Parser} parser Parser.
 */
goog.net.BrowserChannel.prototype.setParser = function(parser) {
  this.parser_ = parser;
};


/**
 * Returns the number of outstanding requests.
 * @return {number} The number of outstanding requests to the server.
 * @private
 */
goog.net.BrowserChannel.prototype.outstandingRequests_ = function() {
  var count = 0;
  if (this.backChannelRequest_) {
    count++;
  }
  if (this.forwardChannelRequest_) {
    count++;
  }
  return count;
};


/**
 * Ensures that a forward channel request is scheduled.
 * @private
 */
goog.net.BrowserChannel.prototype.ensureForwardChannel_ = function() {
  if (this.forwardChannelRequest_) {
    // connection in process - no need to start a new request
    return;
  }

  if (this.forwardChannelTimerId_) {
    // no need to start a new request - one is already scheduled
    return;
  }

  this.forwardChannelTimerId_ = goog.net.BrowserChannel.setTimeout(
      goog.bind(this.onStartForwardChannelTimer_, this), 0);
  this.forwardChannelRetryCount_ = 0;
};


/**
 * Schedules a forward-channel retry for the specified request, unless the max
 * retries has been reached.
 * @param {goog.net.ChannelRequest} request The failed request to retry.
 * @return {boolean} true iff a retry was scheduled.
 * @private
 */
goog.net.BrowserChannel.prototype.maybeRetryForwardChannel_ =
    function(request) {
  if (this.forwardChannelRequest_ || this.forwardChannelTimerId_) {
    // Should be impossible to be called in this state.
    this.channelDebug_.severe('Request already in progress');
    return false;
  }

  if (this.state_ == goog.net.BrowserChannel.State.INIT ||  // no retry open_()
      (this.forwardChannelRetryCount_ >= this.getForwardChannelMaxRetries())) {
    return false;
  }

  this.channelDebug_.debug('Going to retry POST');

  this.forwardChannelTimerId_ = goog.net.BrowserChannel.setTimeout(
      goog.bind(this.onStartForwardChannelTimer_, this, request),
      this.getRetryTime_(this.forwardChannelRetryCount_));
  this.forwardChannelRetryCount_++;
  return true;
};


/**
 * Timer callback for ensureForwardChannel
 * @param {goog.net.ChannelRequest=} opt_retryRequest A failed request to retry.
 * @private
 */
goog.net.BrowserChannel.prototype.onStartForwardChannelTimer_ = function(
    opt_retryRequest) {
  this.forwardChannelTimerId_ = null;
  this.startForwardChannel_(opt_retryRequest);
};


/**
 * Begins a new forward channel operation to the server.
 * @param {goog.net.ChannelRequest=} opt_retryRequest A failed request to retry.
 * @private
 */
goog.net.BrowserChannel.prototype.startForwardChannel_ = function(
    opt_retryRequest) {
  this.channelDebug_.debug('startForwardChannel_');
  if (!this.okToMakeRequest_()) {
    return; // channel is cancelled
  } else if (this.state_ == goog.net.BrowserChannel.State.INIT) {
    if (opt_retryRequest) {
      this.channelDebug_.severe('Not supposed to retry the open');
      return;
    }
    this.open_();
    this.state_ = goog.net.BrowserChannel.State.OPENING;
  } else if (this.state_ == goog.net.BrowserChannel.State.OPENED) {
    if (opt_retryRequest) {
      this.makeForwardChannelRequest_(opt_retryRequest);
      return;
    }

    if (this.outgoingMaps_.length == 0) {
      this.channelDebug_.debug('startForwardChannel_ returned: ' +
                                   'nothing to send');
      // no need to start a new forward channel request
      return;
    }

    if (this.forwardChannelRequest_) {
      // Should be impossible to be called in this state.
      this.channelDebug_.severe('startForwardChannel_ returned: ' +
                                    'connection already in progress');
      return;
    }

    this.makeForwardChannelRequest_();
    this.channelDebug_.debug('startForwardChannel_ finished, sent request');
  }
};


/**
 * Establishes a new channel session with the the server.
 * @private
 */
goog.net.BrowserChannel.prototype.open_ = function() {
  this.channelDebug_.debug('open_()');
  this.nextRid_ = Math.floor(Math.random() * 100000);

  var rid = this.nextRid_++;
  var request = goog.net.BrowserChannel.createChannelRequest(
      this, this.channelDebug_, '', rid);
  request.setExtraHeaders(this.extraHeaders_);
  var requestText = this.dequeueOutgoingMaps_();
  var uri = this.forwardChannelUri_.clone();
  uri.setParameterValue('RID', rid);
  if (this.clientVersion_) {
    uri.setParameterValue('CVER', this.clientVersion_);
  }

  // Add the reconnect parameters.
  this.addAdditionalParams_(uri);

  request.xmlHttpPost(uri, requestText, true);
  this.forwardChannelRequest_ = request;
};


/**
 * Makes a forward channel request using XMLHTTP.
 * @param {goog.net.ChannelRequest=} opt_retryRequest A failed request to retry.
 * @private
 */
goog.net.BrowserChannel.prototype.makeForwardChannelRequest_ =
    function(opt_retryRequest) {
  var rid;
  var requestText;
  if (opt_retryRequest) {
    if (this.channelVersion_ > 6) {
      // In version 7 and up we can tack on new arrays to a retry.
      this.requeuePendingMaps_();
      rid = this.nextRid_ - 1;  // Must use last RID
      requestText = this.dequeueOutgoingMaps_();
    } else {
      // TODO(tschmelcher): Remove this code and the opt_retryRequest passing
      // once server-side support for ver 7 is ubiquitous.
      rid = opt_retryRequest.getRequestId();
      requestText = /** @type {string} */ (opt_retryRequest.getPostData());
    }
  } else {
    rid = this.nextRid_++;
    requestText = this.dequeueOutgoingMaps_();
  }

  var uri = this.forwardChannelUri_.clone();
  uri.setParameterValue('SID', this.sid_);
  uri.setParameterValue('RID', rid);
  uri.setParameterValue('AID', this.lastArrayId_);
  // Add the additional reconnect parameters.
  this.addAdditionalParams_(uri);

  var request = goog.net.BrowserChannel.createChannelRequest(
      this,
      this.channelDebug_,
      this.sid_,
      rid,
      this.forwardChannelRetryCount_ + 1);
  request.setExtraHeaders(this.extraHeaders_);

  // randomize from 50%-100% of the forward channel timeout to avoid
  // a big hit if servers happen to die at once.
  request.setTimeout(
      Math.round(this.forwardChannelRequestTimeoutMs_ * 0.50) +
      Math.round(this.forwardChannelRequestTimeoutMs_ * 0.50 * Math.random()));
  this.forwardChannelRequest_ = request;
  request.xmlHttpPost(uri, requestText, true);
};


/**
 * Adds the additional parameters from the handler to the given URI.
 * @param {goog.Uri} uri The URI to add the parameters to.
 * @private
 */
goog.net.BrowserChannel.prototype.addAdditionalParams_ = function(uri) {
  // Add the additional reconnect parameters as needed.
  if (this.handler_) {
    var params = this.handler_.getAdditionalParams(this);
    if (params) {
      goog.structs.forEach(params, function(value, key, coll) {
        uri.setParameterValue(key, value);
      });
    }
  }
};


/**
 * Returns the request text from the outgoing maps and resets it.
 * @return {string} The encoded request text created from all the currently
 *                  queued outgoing maps.
 * @private
 */
goog.net.BrowserChannel.prototype.dequeueOutgoingMaps_ = function() {
  var count = Math.min(this.outgoingMaps_.length,
                       goog.net.BrowserChannel.MAX_MAPS_PER_REQUEST_);
  var sb = ['count=' + count];
  var offset;
  if (this.channelVersion_ > 6 && count > 0) {
    // To save a bit of bandwidth, specify the base mapId and the rest as
    // offsets from it.
    offset = this.outgoingMaps_[0].mapId;
    sb.push('ofs=' + offset);
  } else {
    offset = 0;
  }
  for (var i = 0; i < count; i++) {
    var mapId = this.outgoingMaps_[i].mapId;
    var map = this.outgoingMaps_[i].map;
    if (this.channelVersion_ <= 6) {
      // Map IDs were not used in ver 6 and before, just indexes in the request.
      mapId = i;
    } else {
      mapId -= offset;
    }
    try {
      goog.structs.forEach(map, function(value, key, coll) {
        sb.push('req' + mapId + '_' + key + '=' + encodeURIComponent(value));
      });
    } catch (ex) {
      // We send a map here because lots of the retry logic relies on map IDs,
      // so we have to send something.
      sb.push('req' + mapId + '_' + 'type' + '=' +
              encodeURIComponent('_badmap'));
      if (this.handler_) {
        this.handler_.badMapError(this, map);
      }
    }
  }
  this.pendingMaps_ = this.pendingMaps_.concat(
      this.outgoingMaps_.splice(0, count));
  return sb.join('&');
};


/**
 * Requeues unacknowledged sent arrays for retransmission in the next forward
 * channel request.
 * @private
 */
goog.net.BrowserChannel.prototype.requeuePendingMaps_ = function() {
  this.outgoingMaps_ = this.pendingMaps_.concat(this.outgoingMaps_);
  this.pendingMaps_.length = 0;
};


/**
 * Ensures there is a backchannel request for receiving data from the server.
 * @private
 */
goog.net.BrowserChannel.prototype.ensureBackChannel_ = function() {
  if (this.backChannelRequest_) {
    // already have one
    return;
  }

  if (this.backChannelTimerId_) {
    // no need to start a new request - one is already scheduled
    return;
  }

  this.backChannelAttemptId_ = 1;
  this.backChannelTimerId_ = goog.net.BrowserChannel.setTimeout(
      goog.bind(this.onStartBackChannelTimer_, this), 0);
  this.backChannelRetryCount_ = 0;
};


/**
 * Schedules a back-channel retry, unless the max retries has been reached.
 * @return {boolean} true iff a retry was scheduled.
 * @private
 */
goog.net.BrowserChannel.prototype.maybeRetryBackChannel_ = function() {
  if (this.backChannelRequest_ || this.backChannelTimerId_) {
    // Should be impossible to be called in this state.
    this.channelDebug_.severe('Request already in progress');
    return false;
  }

  if (this.backChannelRetryCount_ >= this.getBackChannelMaxRetries()) {
    return false;
  }

  this.channelDebug_.debug('Going to retry GET');

  this.backChannelAttemptId_++;
  this.backChannelTimerId_ = goog.net.BrowserChannel.setTimeout(
      goog.bind(this.onStartBackChannelTimer_, this),
      this.getRetryTime_(this.backChannelRetryCount_));
  this.backChannelRetryCount_++;
  return true;
};


/**
 * Timer callback for ensureBackChannel_.
 * @private
 */
goog.net.BrowserChannel.prototype.onStartBackChannelTimer_ = function() {
  this.backChannelTimerId_ = null;
  this.startBackChannel_();
};


/**
 * Begins a new back channel operation to the server.
 * @private
 */
goog.net.BrowserChannel.prototype.startBackChannel_ = function() {
  if (!this.okToMakeRequest_()) {
    // channel is cancelled
    return;
  }

  this.channelDebug_.debug('Creating new HttpRequest');
  this.backChannelRequest_ = goog.net.BrowserChannel.createChannelRequest(
      this,
      this.channelDebug_,
      this.sid_,
      'rpc',
      this.backChannelAttemptId_);
  this.backChannelRequest_.setExtraHeaders(this.extraHeaders_);
  this.backChannelRequest_.setReadyStateChangeThrottle(
      this.readyStateChangeThrottleMs_);
  var uri = this.backChannelUri_.clone();
  uri.setParameterValue('RID', 'rpc');
  uri.setParameterValue('SID', this.sid_);
  uri.setParameterValue('CI', this.useChunked_ ? '0' : '1');
  uri.setParameterValue('AID', this.lastArrayId_);

  // Add the reconnect parameters.
  this.addAdditionalParams_(uri);

  if (!goog.net.ChannelRequest.supportsXhrStreaming()) {
    uri.setParameterValue('TYPE', 'html');
    this.backChannelRequest_.tridentGet(uri, Boolean(this.hostPrefix_));
  } else {
    uri.setParameterValue('TYPE', 'xmlhttp');
    this.backChannelRequest_.xmlHttpGet(uri, true /* decodeChunks */,
        this.hostPrefix_, false /* opt_noClose */);
  }
  this.channelDebug_.debug('New Request created');
};


/**
 * Gives the handler a chance to return an error code and stop channel
 * execution. A handler might want to do this to check that the user is still
 * logged in, for example.
 * @private
 * @return {boolean} If it's OK to make a request.
 */
goog.net.BrowserChannel.prototype.okToMakeRequest_ = function() {
  if (this.handler_) {
    var result = this.handler_.okToMakeRequest(this);
    if (result != goog.net.BrowserChannel.Error.OK) {
      this.channelDebug_.debug('Handler returned error code from ' +
                                   'okToMakeRequest');
      this.signalError_(result);
      return false;
    }
  }
  return true;
};


/**
 * Callback from BrowserTestChannel for when the channel is finished.
 * @param {goog.net.BrowserTestChannel} testChannel The BrowserTestChannel.
 * @param {boolean} useChunked  Whether we can chunk responses.
 */
goog.net.BrowserChannel.prototype.testConnectionFinished =
    function(testChannel, useChunked) {
  this.channelDebug_.debug('Test Connection Finished');

  this.useChunked_ = this.allowChunkedMode_ && useChunked;
  this.lastStatusCode_ = testChannel.getLastStatusCode();
  this.connectChannel_();
};


/**
 * Callback from BrowserTestChannel for when the channel has an error.
 * @param {goog.net.BrowserTestChannel} testChannel The BrowserTestChannel.
 * @param {goog.net.ChannelRequest.Error} errorCode  The error code of the
       failure.
 */
goog.net.BrowserChannel.prototype.testConnectionFailure =
    function(testChannel, errorCode) {
  this.channelDebug_.debug('Test Connection Failed');
  this.lastStatusCode_ = testChannel.getLastStatusCode();
  this.signalError_(goog.net.BrowserChannel.Error.REQUEST_FAILED);
};


/**
 * Callback from BrowserTestChannel for when the channel is blocked.
 * @param {goog.net.BrowserTestChannel} testChannel The BrowserTestChannel.
 */
goog.net.BrowserChannel.prototype.testConnectionBlocked =
    function(testChannel) {
  this.channelDebug_.debug('Test Connection Blocked');
  this.lastStatusCode_ = this.connectionTest_.getLastStatusCode();
  this.signalError_(goog.net.BrowserChannel.Error.BLOCKED);
};


/**
 * Callback from ChannelRequest for when new data is received
 * @param {goog.net.ChannelRequest} request  The request object.
 * @param {string} responseText The text of the response.
 */
goog.net.BrowserChannel.prototype.onRequestData =
    function(request, responseText) {
  if (this.state_ == goog.net.BrowserChannel.State.CLOSED ||
      (this.backChannelRequest_ != request &&
       this.forwardChannelRequest_ != request)) {
    // either CLOSED or a request we don't know about (perhaps an old request)
    return;
  }
  this.lastStatusCode_ = request.getLastStatusCode();

  if (this.forwardChannelRequest_ == request &&
      this.state_ == goog.net.BrowserChannel.State.OPENED) {
    if (this.channelVersion_ > 7) {
      var response;
      try {
        response = this.parser_.parse(responseText);
      } catch (ex) {
        response = null;
      }
      if (goog.isArray(response) && response.length == 3) {
        this.handlePostResponse_(/** @type {Array} */ (response));
      } else {
        this.channelDebug_.debug('Bad POST response data returned');
        this.signalError_(goog.net.BrowserChannel.Error.BAD_RESPONSE);
      }
    } else if (responseText != goog.net.BrowserChannel.MAGIC_RESPONSE_COOKIE) {
      this.channelDebug_.debug('Bad data returned - missing/invald ' +
                                   'magic cookie');
      this.signalError_(goog.net.BrowserChannel.Error.BAD_RESPONSE);
    }
  } else {
    if (this.backChannelRequest_ == request) {
      this.clearDeadBackchannelTimer_();
    }
    if (!goog.string.isEmpty(responseText)) {
      var response = this.parser_.parse(responseText);
      goog.asserts.assert(goog.isArray(response));
      this.onInput_(/** @type {!Array} */ (response));
    }
  }
};


/**
 * Handles a POST response from the server.
 * @param {Array} responseValues The key value pairs in the POST response.
 * @private
 */
goog.net.BrowserChannel.prototype.handlePostResponse_ = function(
    responseValues) {
  // The first response value is set to 0 if server is missing backchannel.
  if (responseValues[0] == 0) {
    this.handleBackchannelMissing_();
    return;
  }
  this.lastPostResponseArrayId_ = responseValues[1];
  var outstandingArrays = this.lastPostResponseArrayId_ - this.lastArrayId_;
  if (0 < outstandingArrays) {
    var numOutstandingBackchannelBytes = responseValues[2];
    this.channelDebug_.debug(numOutstandingBackchannelBytes + ' bytes (in ' +
        outstandingArrays + ' arrays) are outstanding on the BackChannel');
    if (!this.shouldRetryBackChannel_(numOutstandingBackchannelBytes)) {
      return;
    }
    if (!this.deadBackChannelTimerId_) {
      // We expect to receive data within 2 RTTs or we retry the backchannel.
      this.deadBackChannelTimerId_ = goog.net.BrowserChannel.setTimeout(
          goog.bind(this.onBackChannelDead_, this),
          2 * goog.net.BrowserChannel.RTT_ESTIMATE);
    }
  }
};


/**
 * Handles a POST response from the server telling us that it has detected that
 * we have no hanging GET connection.
 * @private
 */
goog.net.BrowserChannel.prototype.handleBackchannelMissing_ = function() {
  // As long as the back channel was started before the POST was sent,
  // we should retry the backchannel. We give a slight buffer of RTT_ESTIMATE
  // so as not to excessively retry the backchannel
  this.channelDebug_.debug('Server claims our backchannel is missing.');
  if (this.backChannelTimerId_) {
    this.channelDebug_.debug('But we are currently starting the request.');
    return;
  } else if (!this.backChannelRequest_) {
    this.channelDebug_.warning(
        'We do not have a BackChannel established');
  } else if (this.backChannelRequest_.getRequestStartTime() +
      goog.net.BrowserChannel.RTT_ESTIMATE <
      this.forwardChannelRequest_.getRequestStartTime()) {
    this.clearDeadBackchannelTimer_();
    this.backChannelRequest_.cancel();
    this.backChannelRequest_ = null;
  } else {
    return;
  }
  this.maybeRetryBackChannel_();
  goog.net.BrowserChannel.notifyStatEvent(
      goog.net.BrowserChannel.Stat.BACKCHANNEL_MISSING);
};


/**
 * Determines whether we should start the process of retrying a possibly
 * dead backchannel.
 * @param {number} outstandingBytes The number of bytes for which the server has
 *     not yet received acknowledgement.
 * @return {boolean} Whether to start the backchannel retry timer.
 * @private
 */
goog.net.BrowserChannel.prototype.shouldRetryBackChannel_ = function(
    outstandingBytes) {
  // Not too many outstanding bytes, not buffered and not after a retry.
  return outstandingBytes <
      goog.net.BrowserChannel.OUTSTANDING_DATA_BACKCHANNEL_RETRY_CUTOFF &&
      !this.isBuffered() &&
      this.backChannelRetryCount_ == 0;
};


/**
 * Decides which host prefix should be used, if any.  If there is a handler,
 * allows the handler to validate a host prefix provided by the server, and
 * optionally override it.
 * @param {?string} serverHostPrefix The host prefix provided by the server.
 * @return {?string} The host prefix to actually use, if any. Will return null
 *     if the use of host prefixes was disabled via setAllowHostPrefix().
 */
goog.net.BrowserChannel.prototype.correctHostPrefix = function(
    serverHostPrefix) {
  if (this.allowHostPrefix_) {
    if (this.handler_) {
      return this.handler_.correctHostPrefix(serverHostPrefix);
    }
    return serverHostPrefix;
  }
  return null;
};


/**
 * Handles the timer that indicates that our backchannel is no longer able to
 * successfully receive data from the server.
 * @private
 */
goog.net.BrowserChannel.prototype.onBackChannelDead_ = function() {
  if (goog.isDefAndNotNull(this.deadBackChannelTimerId_)) {
    this.deadBackChannelTimerId_ = null;
    this.backChannelRequest_.cancel();
    this.backChannelRequest_ = null;
    this.maybeRetryBackChannel_();
    goog.net.BrowserChannel.notifyStatEvent(
        goog.net.BrowserChannel.Stat.BACKCHANNEL_DEAD);
  }
};


/**
 * Clears the timer that indicates that our backchannel is no longer able to
 * successfully receive data from the server.
 * @private
 */
goog.net.BrowserChannel.prototype.clearDeadBackchannelTimer_ = function() {
  if (goog.isDefAndNotNull(this.deadBackChannelTimerId_)) {
    goog.global.clearTimeout(this.deadBackChannelTimerId_);
    this.deadBackChannelTimerId_ = null;
  }
};


/**
 * Returns whether or not the given error/status combination is fatal or not.
 * On fatal errors we immediately close the session rather than retrying the
 * failed request.
 * @param {goog.net.ChannelRequest.Error?} error The error code for the failed
 * request.
 * @param {number} statusCode The last HTTP status code.
 * @return {boolean} Whether or not the error is fatal.
 * @private
 */
goog.net.BrowserChannel.isFatalError_ =
    function(error, statusCode) {
  return error == goog.net.ChannelRequest.Error.UNKNOWN_SESSION_ID ||
      error == goog.net.ChannelRequest.Error.ACTIVE_X_BLOCKED ||
      (error == goog.net.ChannelRequest.Error.STATUS &&
       statusCode > 0);
};


/**
 * Callback from ChannelRequest that indicates a request has completed.
 * @param {goog.net.ChannelRequest} request  The request object.
 */
goog.net.BrowserChannel.prototype.onRequestComplete =
    function(request) {
  this.channelDebug_.debug('Request complete');
  var type;
  if (this.backChannelRequest_ == request) {
    this.clearDeadBackchannelTimer_();
    this.backChannelRequest_ = null;
    type = goog.net.BrowserChannel.ChannelType_.BACK_CHANNEL;
  } else if (this.forwardChannelRequest_ == request) {
    this.forwardChannelRequest_ = null;
    type = goog.net.BrowserChannel.ChannelType_.FORWARD_CHANNEL;
  } else {
    // return if it was an old request from a previous session
    return;
  }

  this.lastStatusCode_ = request.getLastStatusCode();

  if (this.state_ == goog.net.BrowserChannel.State.CLOSED) {
    return;
  }

  if (request.getSuccess()) {
    // Yay!
    if (type == goog.net.BrowserChannel.ChannelType_.FORWARD_CHANNEL) {
      var size = request.getPostData() ? request.getPostData().length : 0;
      goog.net.BrowserChannel.notifyTimingEvent(size,
          goog.now() - request.getRequestStartTime(),
          this.forwardChannelRetryCount_);
      this.ensureForwardChannel_();
      this.onSuccess_();
      this.pendingMaps_.length = 0;
    } else {  // i.e., back-channel
      this.ensureBackChannel_();
    }
    return;
  }
  // Else unsuccessful. Fall through.

  var lastError = request.getLastError();
  if (!goog.net.BrowserChannel.isFatalError_(lastError,
                                             this.lastStatusCode_)) {
    // Maybe retry.
    this.channelDebug_.debug('Maybe retrying, last error: ' +
        goog.net.ChannelRequest.errorStringFromCode(
            /** @type {goog.net.ChannelRequest.Error} */ (lastError),
            this.lastStatusCode_));
    if (type == goog.net.BrowserChannel.ChannelType_.FORWARD_CHANNEL) {
      if (this.maybeRetryForwardChannel_(request)) {
        return;
      }
    }
    if (type == goog.net.BrowserChannel.ChannelType_.BACK_CHANNEL) {
      if (this.maybeRetryBackChannel_()) {
        return;
      }
    }
    // Else exceeded max retries. Fall through.
    this.channelDebug_.debug('Exceeded max number of retries');
  } else {
    // Else fatal error. Fall through and mark the pending maps as failed.
    this.channelDebug_.debug('Not retrying due to error type');
  }


  // Can't save this session. :(
  this.channelDebug_.debug('Error: HTTP request failed');
  switch (lastError) {
    case goog.net.ChannelRequest.Error.NO_DATA:
      this.signalError_(goog.net.BrowserChannel.Error.NO_DATA);
      break;
    case goog.net.ChannelRequest.Error.BAD_DATA:
      this.signalError_(goog.net.BrowserChannel.Error.BAD_DATA);
      break;
    case goog.net.ChannelRequest.Error.UNKNOWN_SESSION_ID:
      this.signalError_(goog.net.BrowserChannel.Error.UNKNOWN_SESSION_ID);
      break;
    case goog.net.ChannelRequest.Error.ACTIVE_X_BLOCKED:
      this.signalError_(goog.net.BrowserChannel.Error.ACTIVE_X_BLOCKED);
      break;
    default:
      this.signalError_(goog.net.BrowserChannel.Error.REQUEST_FAILED);
      break;
  }
};


/**
 * @param {number} retryCount Number of retries so far.
 * @return {number} Time in ms before firing next retry request.
 * @private
 */
goog.net.BrowserChannel.prototype.getRetryTime_ = function(retryCount) {
  var retryTime = this.baseRetryDelayMs_ +
      Math.floor(Math.random() * this.retryDelaySeedMs_);
  if (!this.isActive()) {
    this.channelDebug_.debug('Inactive channel');
    retryTime =
        retryTime * goog.net.BrowserChannel.INACTIVE_CHANNEL_RETRY_FACTOR;
  }
  // Backoff for subsequent retries
  retryTime = retryTime * retryCount;
  return retryTime;
};


/**
 * @param {number} baseDelayMs The base part of the retry delay, in ms.
 * @param {number} delaySeedMs A random delay between 0 and this is added to
 *     the base part.
 */
goog.net.BrowserChannel.prototype.setRetryDelay = function(baseDelayMs,
    delaySeedMs) {
  this.baseRetryDelayMs_ = baseDelayMs;
  this.retryDelaySeedMs_ = delaySeedMs;
};


/**
 * Processes the data returned by the server.
 * @param {!Array.<!Array>} respArray The response array returned by the server.
 * @private
 */
goog.net.BrowserChannel.prototype.onInput_ = function(respArray) {
  var batch = this.handler_ && this.handler_.channelHandleMultipleArrays ?
      [] : null;
  for (var i = 0; i < respArray.length; i++) {
    var nextArray = respArray[i];
    this.lastArrayId_ = nextArray[0];
    nextArray = nextArray[1];
    if (this.state_ == goog.net.BrowserChannel.State.OPENING) {
      if (nextArray[0] == 'c') {
        this.sid_ = nextArray[1];
        this.hostPrefix_ = this.correctHostPrefix(nextArray[2]);
        var negotiatedVersion = nextArray[3];
        if (goog.isDefAndNotNull(negotiatedVersion)) {
          this.channelVersion_ = negotiatedVersion;
        } else {
          // Servers prior to version 7 did not send this, so assume version 6.
          this.channelVersion_ = 6;
        }
        this.state_ = goog.net.BrowserChannel.State.OPENED;
        if (this.handler_) {
          this.handler_.channelOpened(this);
        }
        this.backChannelUri_ = this.getBackChannelUri(
            this.hostPrefix_, /** @type {string} */ (this.path_));
        // Open connection to receive data
        this.ensureBackChannel_();
      } else if (nextArray[0] == 'stop') {
        this.signalError_(goog.net.BrowserChannel.Error.STOP);
      }
    } else if (this.state_ == goog.net.BrowserChannel.State.OPENED) {
      if (nextArray[0] == 'stop') {
        if (batch && !goog.array.isEmpty(batch)) {
          this.handler_.channelHandleMultipleArrays(this, batch);
          batch.length = 0;
        }
        this.signalError_(goog.net.BrowserChannel.Error.STOP);
      } else if (nextArray[0] == 'noop') {
        // ignore - noop to keep connection happy
      } else {
        if (batch) {
          batch.push(nextArray);
        } else if (this.handler_) {
          this.handler_.channelHandleArray(this, nextArray);
        }
      }
      // We have received useful data on the back-channel, so clear its retry
      // count. We do this because back-channels by design do not complete
      // quickly, so on a flaky connection we could have many fail to complete
      // fully but still deliver a lot of data before they fail. We don't want
      // to count such failures towards the retry limit, because we don't want
      // to give up on a session if we can still receive data.
      this.backChannelRetryCount_ = 0;
    }
  }
  if (batch && !goog.array.isEmpty(batch)) {
    this.handler_.channelHandleMultipleArrays(this, batch);
  }
};


/**
 * Helper to ensure the BrowserChannel is in the expected state.
 * @param {...number} var_args The channel must be in one of the indicated
 *     states.
 * @private
 */
goog.net.BrowserChannel.prototype.ensureInState_ = function(var_args) {
  if (!goog.array.contains(arguments, this.state_)) {
    throw Error('Unexpected channel state: ' + this.state_);
  }
};


/**
 * Signals an error has occurred.
 * @param {goog.net.BrowserChannel.Error} error  The error code for the failure.
 * @private
 */
goog.net.BrowserChannel.prototype.signalError_ = function(error) {
  this.channelDebug_.info('Error code ' + error);
  if (error == goog.net.BrowserChannel.Error.REQUEST_FAILED ||
      error == goog.net.BrowserChannel.Error.BLOCKED) {
    // Ping google to check if it's a server error or user's network error.
    var imageUri = null;
    if (this.handler_) {
      imageUri = this.handler_.getNetworkTestImageUri(this);
    }
    goog.net.tmpnetwork.testGoogleCom(
        goog.bind(this.testGoogleComCallback_, this), imageUri);
  } else {
    goog.net.BrowserChannel.notifyStatEvent(
        goog.net.BrowserChannel.Stat.ERROR_OTHER);
  }
  this.onError_(error);
};


/**
 * Callback for testGoogleCom during error handling.
 * @param {boolean} networkUp Whether the network is up.
 * @private
 */
goog.net.BrowserChannel.prototype.testGoogleComCallback_ = function(networkUp) {
  if (networkUp) {
    this.channelDebug_.info('Successfully pinged google.com');
    goog.net.BrowserChannel.notifyStatEvent(
        goog.net.BrowserChannel.Stat.ERROR_OTHER);
  } else {
    this.channelDebug_.info('Failed to ping google.com');
    goog.net.BrowserChannel.notifyStatEvent(
        goog.net.BrowserChannel.Stat.ERROR_NETWORK);
    // We cann onError_ here instead of signalError_ because the latter just
    // calls notifyStatEvent, and we don't want to have another stat event.
    this.onError_(goog.net.BrowserChannel.Error.NETWORK);
  }
};


/**
 * Called when messages have been successfully sent from the queue.
 * @private
 */
goog.net.BrowserChannel.prototype.onSuccess_ = function() {
  if (this.handler_) {
    this.handler_.channelSuccess(this, this.pendingMaps_);
  }
};


/**
 * Called when we've determined the final error for a channel. It closes the
 * notifiers the handler of the error and closes the channel.
 * @param {goog.net.BrowserChannel.Error} error  The error code for the failure.
 * @private
 */
goog.net.BrowserChannel.prototype.onError_ = function(error) {
  this.channelDebug_.debug('HttpChannel: error - ' + error);
  this.state_ = goog.net.BrowserChannel.State.CLOSED;
  if (this.handler_) {
    this.handler_.channelError(this, error);
  }
  this.onClose_();
  this.cancelRequests_();
};


/**
 * Called when the channel has been closed. It notifiers the handler of the
 * event, and reports any pending or undelivered maps.
 * @private
 */
goog.net.BrowserChannel.prototype.onClose_ = function() {
  this.state_ = goog.net.BrowserChannel.State.CLOSED;
  this.lastStatusCode_ = -1;
  if (this.handler_) {
    if (this.pendingMaps_.length == 0 && this.outgoingMaps_.length == 0) {
      this.handler_.channelClosed(this);
    } else {
      this.channelDebug_.debug('Number of undelivered maps' +
          ', pending: ' + this.pendingMaps_.length +
          ', outgoing: ' + this.outgoingMaps_.length);

      var copyOfPendingMaps = goog.array.clone(this.pendingMaps_);
      var copyOfUndeliveredMaps = goog.array.clone(this.outgoingMaps_);
      this.pendingMaps_.length = 0;
      this.outgoingMaps_.length = 0;

      this.handler_.channelClosed(this,
          copyOfPendingMaps,
          copyOfUndeliveredMaps);
    }
  }
};


/**
 * Gets the Uri used for the connection that sends data to the server.
 * @param {string} path The path on the host.
 * @return {goog.Uri} The forward channel URI.
 */
goog.net.BrowserChannel.prototype.getForwardChannelUri =
    function(path) {
  var uri = this.createDataUri(null, path);
  this.channelDebug_.debug('GetForwardChannelUri: ' + uri);
  return uri;
};


/**
 * Gets the results for the first browser channel test
 * @return {Array.<string>} The results.
 */
goog.net.BrowserChannel.prototype.getFirstTestResults =
    function() {
  return this.firstTestResults_;
};


/**
 * Gets the results for the second browser channel test
 * @return {?boolean} The results. True -> buffered connection,
 *      False -> unbuffered, null -> unknown.
 */
goog.net.BrowserChannel.prototype.getSecondTestResults = function() {
  return this.secondTestResults_;
};


/**
 * Gets the Uri used for the connection that receives data from the server.
 * @param {?string} hostPrefix The host prefix.
 * @param {string} path The path on the host.
 * @return {goog.Uri} The back channel URI.
 */
goog.net.BrowserChannel.prototype.getBackChannelUri =
    function(hostPrefix, path) {
  var uri = this.createDataUri(this.shouldUseSecondaryDomains() ?
      hostPrefix : null, path);
  this.channelDebug_.debug('GetBackChannelUri: ' + uri);
  return uri;
};


/**
 * Creates a data Uri applying logic for secondary hostprefix, port
 * overrides, and versioning.
 * @param {?string} hostPrefix The host prefix.
 * @param {string} path The path on the host (may be absolute or relative).
 * @param {number=} opt_overridePort Optional override port.
 * @return {goog.Uri} The data URI.
 */
goog.net.BrowserChannel.prototype.createDataUri =
    function(hostPrefix, path, opt_overridePort) {
  var uri = goog.Uri.parse(path);
  var uriAbsolute = (uri.getDomain() != '');
  if (uriAbsolute) {
    if (hostPrefix) {
      uri.setDomain(hostPrefix + '.' + uri.getDomain());
    }

    uri.setPort(opt_overridePort || uri.getPort());
  } else {
    var locationPage = window.location;
    var hostName;
    if (hostPrefix) {
      hostName = hostPrefix + '.' + locationPage.hostname;
    } else {
      hostName = locationPage.hostname;
    }

    var port = opt_overridePort || locationPage.port;

    uri = goog.Uri.create(locationPage.protocol, null, hostName, port, path);
  }

  if (this.extraParams_) {
    goog.structs.forEach(this.extraParams_, function(value, key, coll) {
      uri.setParameterValue(key, value);
    });
  }

  // Add the protocol version to the URI.
  uri.setParameterValue('VER', this.channelVersion_);

  // Add the reconnect parameters.
  this.addAdditionalParams_(uri);

  return uri;
};


/**
 * Called when BC needs to create an XhrIo object.  Override in a subclass if
 * you need to customize the behavior, for example to enable the creation of
 * XHR's capable of calling a secondary domain. Will also allow calling
 * a secondary domain if withCredentials (CORS) is enabled.
 * @param {?string} hostPrefix The host prefix, if we need an XhrIo object
 *     capable of calling a secondary domain.
 * @return {!goog.net.XhrIo} A new XhrIo object.
 */
goog.net.BrowserChannel.prototype.createXhrIo = function(hostPrefix) {
  if (hostPrefix && !this.supportsCrossDomainXhrs_) {
    throw Error('Can\'t create secondary domain capable XhrIo object.');
  }
  var xhr = new goog.net.XhrIo();
  xhr.setWithCredentials(this.supportsCrossDomainXhrs_);
  return xhr;
};


/**
 * Gets whether this channel is currently active. This is used to determine the
 * length of time to wait before retrying. This call delegates to the handler.
 * @return {boolean} Whether the channel is currently active.
 */
goog.net.BrowserChannel.prototype.isActive = function() {
  return !!this.handler_ && this.handler_.isActive(this);
};


/**
 * Wrapper around SafeTimeout which calls the start and end execution hooks
 * with a try...finally block.
 * @param {Function} fn The callback function.
 * @param {number} ms The time in MS for the timer.
 * @return {number} The ID of the timer.
 */
goog.net.BrowserChannel.setTimeout = function(fn, ms) {
  if (!goog.isFunction(fn)) {
    throw Error('Fn must not be null and must be a function');
  }
  return goog.global.setTimeout(function() {
    goog.net.BrowserChannel.onStartExecution();
    try {
      fn();
    } finally {
      goog.net.BrowserChannel.onEndExecution();
    }
  }, ms);
};


/**
 * Helper function to call the start hook
 */
goog.net.BrowserChannel.onStartExecution = function() {
  goog.net.BrowserChannel.startExecutionHook_();
};


/**
 * Helper function to call the end hook
 */
goog.net.BrowserChannel.onEndExecution = function() {
  goog.net.BrowserChannel.endExecutionHook_();
};


/**
 * Returns the singleton event target for stat events.
 * @return {goog.events.EventTarget} The event target for stat events.
 */
goog.net.BrowserChannel.getStatEventTarget = function() {
  return goog.net.BrowserChannel.statEventTarget_;
};


/**
 * Notify the channel that a particular fine grained network event has occurred.
 * Should be considered package-private.
 * @param {goog.net.BrowserChannel.ServerReachability} reachabilityType The
 *     reachability event type.
 */
goog.net.BrowserChannel.prototype.notifyServerReachabilityEvent = function(
    reachabilityType) {
  var target = goog.net.BrowserChannel.statEventTarget_;
  target.dispatchEvent(new goog.net.BrowserChannel.ServerReachabilityEvent(
      target, reachabilityType));
};


/**
 * Helper function to call the stat event callback.
 * @param {goog.net.BrowserChannel.Stat} stat The stat.
 */
goog.net.BrowserChannel.notifyStatEvent = function(stat) {
  var target = goog.net.BrowserChannel.statEventTarget_;
  target.dispatchEvent(
      new goog.net.BrowserChannel.StatEvent(target, stat));
};


/**
 * Helper function to notify listeners about POST request performance.
 *
 * @param {number} size Number of characters in the POST data.
 * @param {number} rtt The amount of time from POST start to response.
 * @param {number} retries The number of times the POST had to be retried.
 */
goog.net.BrowserChannel.notifyTimingEvent = function(size, rtt, retries) {
  var target = goog.net.BrowserChannel.statEventTarget_;
  target.dispatchEvent(
      new goog.net.BrowserChannel.TimingEvent(target, size, rtt, retries));
};


/**
 * Determines whether to use a secondary domain when the server gives us
 * a host prefix. This allows us to work around browser per-domain
 * connection limits.
 *
 * Currently, we  use secondary domains when using Trident's ActiveXObject,
 * because it supports cross-domain requests out of the box.  Note that in IE10
 * we no longer use ActiveX since it's not supported in Metro mode and IE10
 * supports XHR streaming.
 *
 * If you need to use secondary domains on other browsers and IE10,
 * you have two choices:
 *     1) If you only care about browsers that support CORS
 *        (https://developer.mozilla.org/en-US/docs/HTTP_access_control), you
 *        can use {@link #setSupportsCrossDomainXhrs} and set the appropriate
 *        CORS response headers on the server.
 *     2) Or, override this method in a subclass, and make sure that those
 *        browsers use some messaging mechanism that works cross-domain (e.g
 *        iframes and window.postMessage).
 *
 * @return {boolean} Whether to use secondary domains.
 * @see http://code.google.com/p/closure-library/issues/detail?id=339
 */
goog.net.BrowserChannel.prototype.shouldUseSecondaryDomains = function() {
  return this.supportsCrossDomainXhrs_ ||
      !goog.net.ChannelRequest.supportsXhrStreaming();
};


/**
 * A LogSaver that can be used to accumulate all the debug logs for
 * BrowserChannels so they can be sent to the server when a problem is
 * detected.
 */
goog.net.BrowserChannel.LogSaver = {};


/**
 * Buffer for accumulating the debug log
 * @type {goog.structs.CircularBuffer}
 * @private
 */
goog.net.BrowserChannel.LogSaver.buffer_ =
    new goog.structs.CircularBuffer(1000);


/**
 * Whether we're currently accumulating the debug log.
 * @type {boolean}
 * @private
 */
goog.net.BrowserChannel.LogSaver.enabled_ = false;


/**
 * Formatter for saving logs.
 * @type {goog.debug.Formatter}
 * @private
 */
goog.net.BrowserChannel.LogSaver.formatter_ = new goog.debug.TextFormatter();


/**
 * Returns whether the LogSaver is enabled.
 * @return {boolean} Whether saving is enabled or disabled.
 */
goog.net.BrowserChannel.LogSaver.isEnabled = function() {
  return goog.net.BrowserChannel.LogSaver.enabled_;
};


/**
 * Enables of disables the LogSaver.
 * @param {boolean} enable Whether to enable or disable saving.
 */
goog.net.BrowserChannel.LogSaver.setEnabled = function(enable) {
  if (enable == goog.net.BrowserChannel.LogSaver.enabled_) {
    return;
  }

  var fn = goog.net.BrowserChannel.LogSaver.addLogRecord;
  var logger = goog.log.getLogger('goog.net');
  if (enable) {
    goog.log.addHandler(logger, fn);
  } else {
    goog.log.removeHandler(logger, fn);
  }
};


/**
 * Adds a log record.
 * @param {goog.log.LogRecord} logRecord the LogRecord.
 */
goog.net.BrowserChannel.LogSaver.addLogRecord = function(logRecord) {
  goog.net.BrowserChannel.LogSaver.buffer_.add(
      goog.net.BrowserChannel.LogSaver.formatter_.formatRecord(logRecord));
};


/**
 * Returns the log as a single string.
 * @return {string} The log as a single string.
 */
goog.net.BrowserChannel.LogSaver.getBuffer = function() {
  return goog.net.BrowserChannel.LogSaver.buffer_.getValues().join('');
};


/**
 * Clears the buffer
 */
goog.net.BrowserChannel.LogSaver.clearBuffer = function() {
  goog.net.BrowserChannel.LogSaver.buffer_.clear();
};



/**
 * Abstract base class for the browser channel handler
 * @constructor
 */
goog.net.BrowserChannel.Handler = function() {
};


/**
 * Callback handler for when a batch of response arrays is received from the
 * server.
 * @type {?function(!goog.net.BrowserChannel, !Array.<!Array>)}
 */
goog.net.BrowserChannel.Handler.prototype.channelHandleMultipleArrays = null;


/**
 * Whether it's okay to make a request to the server. A handler can return
 * false if the channel should fail. For example, if the user has logged out,
 * the handler may want all requests to fail immediately.
 * @param {goog.net.BrowserChannel} browserChannel The browser channel.
 * @return {goog.net.BrowserChannel.Error} An error code. The code should
 * return goog.net.BrowserChannel.Error.OK to indicate it's okay. Any other
 * error code will cause a failure.
 */
goog.net.BrowserChannel.Handler.prototype.okToMakeRequest =
    function(browserChannel) {
  return goog.net.BrowserChannel.Error.OK;
};


/**
 * Indicates the BrowserChannel has successfully negotiated with the server
 * and can now send and receive data.
 * @param {goog.net.BrowserChannel} browserChannel The browser channel.
 */
goog.net.BrowserChannel.Handler.prototype.channelOpened =
    function(browserChannel) {
};


/**
 * New input is available for the application to process.
 *
 * @param {goog.net.BrowserChannel} browserChannel The browser channel.
 * @param {Array} array The data array.
 */
goog.net.BrowserChannel.Handler.prototype.channelHandleArray =
    function(browserChannel, array) {
};


/**
 * Indicates maps were successfully sent on the BrowserChannel.
 *
 * @param {goog.net.BrowserChannel} browserChannel The browser channel.
 * @param {Array.<goog.net.BrowserChannel.QueuedMap>} deliveredMaps The
 *     array of maps that have been delivered to the server. This is a direct
 *     reference to the internal BrowserChannel array, so a copy should be made
 *     if the caller desires a reference to the data.
 */
goog.net.BrowserChannel.Handler.prototype.channelSuccess =
    function(browserChannel, deliveredMaps) {
};


/**
 * Indicates an error occurred on the BrowserChannel.
 *
 * @param {goog.net.BrowserChannel} browserChannel The browser channel.
 * @param {goog.net.BrowserChannel.Error} error The error code.
 */
goog.net.BrowserChannel.Handler.prototype.channelError =
    function(browserChannel, error) {
};


/**
 * Indicates the BrowserChannel is closed. Also notifies about which maps,
 * if any, that may not have been delivered to the server.
 * @param {goog.net.BrowserChannel} browserChannel The browser channel.
 * @param {Array.<goog.net.BrowserChannel.QueuedMap>=} opt_pendingMaps The
 *     array of pending maps, which may or may not have been delivered to the
 *     server.
 * @param {Array.<goog.net.BrowserChannel.QueuedMap>=} opt_undeliveredMaps
 *     The array of undelivered maps, which have definitely not been delivered
 *     to the server.
 */
goog.net.BrowserChannel.Handler.prototype.channelClosed =
    function(browserChannel, opt_pendingMaps, opt_undeliveredMaps) {
};


/**
 * Gets any parameters that should be added at the time another connection is
 * made to the server.
 * @param {goog.net.BrowserChannel} browserChannel The browser channel.
 * @return {Object} Extra parameter keys and values to add to the
 *                  requests.
 */
goog.net.BrowserChannel.Handler.prototype.getAdditionalParams =
    function(browserChannel) {
  return {};
};


/**
 * Gets the URI of an image that can be used to test network connectivity.
 * @param {goog.net.BrowserChannel} browserChannel The browser channel.
 * @return {goog.Uri?} A custom URI to load for the network test.
 */
goog.net.BrowserChannel.Handler.prototype.getNetworkTestImageUri =
    function(browserChannel) {
  return null;
};


/**
 * Gets whether this channel is currently active. This is used to determine the
 * length of time to wait before retrying.
 * @param {goog.net.BrowserChannel} browserChannel The browser channel.
 * @return {boolean} Whether the channel is currently active.
 */
goog.net.BrowserChannel.Handler.prototype.isActive = function(browserChannel) {
  return true;
};


/**
 * Called by the channel if enumeration of the map throws an exception.
 * @param {goog.net.BrowserChannel} browserChannel The browser channel.
 * @param {Object} map The map that can't be enumerated.
 */
goog.net.BrowserChannel.Handler.prototype.badMapError =
    function(browserChannel, map) {
  return;
};


/**
 * Allows the handler to override a host prefix provided by the server.  Will
 * be called whenever the channel has received such a prefix and is considering
 * its use.
 * @param {?string} serverHostPrefix The host prefix provided by the server.
 * @return {?string} The host prefix the client should use.
 */
goog.net.BrowserChannel.Handler.prototype.correctHostPrefix =
    function(serverHostPrefix) {
  return serverHostPrefix;
};

//buzz/channel/javascript/external/interface/channelerror.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Defines a type for errors that may occur on a channel.
 *
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('buzz.channel.ChannelError');

// TODO(ghc): [bug 6103250] Have our own set of error codes instead of exposing
// the BC ones directly.
goog.require('goog.net.BrowserChannel');

/**
 * Encapsulates information about a channel error.
 * @param {goog.net.BrowserChannel.Error} bcError The underlying error.
 * @constructor
 */
buzz.channel.ChannelError = function(bcError) {

  /**
   * Underlying browser channel error.
   * @type {goog.net.BrowserChannel.Error}
   * @private
   */
  this.bcError_ = bcError;
};

/**
 * @return {goog.net.BrowserChannel.Error} The underlying browser channel error
 *     code.
 */
buzz.channel.ChannelError.prototype.getBrowserChannelErrorCode = function() {
  return this.bcError_;
};

//buzz/channel/javascript/external/interface/channelhandler.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Defines a handler interface for channel events.
 *
 * @author ghc@google.com (Greg Cooper)
 * @author mharris@google.com (Matthew Harris)
 */

goog.provide('buzz.channel.ChannelHandler');

goog.require('buzz.channel.Channel');
goog.require('buzz.channel.ChannelError');

/**
 * Handles state-change events on a channel.
 * @interface
 */
buzz.channel.ChannelHandler = function() {};

/**
 * Indicates that the given channel is open.
 * @param {buzz.channel.Channel} channel The channel that is now open.
 * @param {Object=} opt_metadata Optional application-specific metadata about
 *     the channel. Most applications should not be using this parameter.
 */
buzz.channel.ChannelHandler.prototype.onOpen = goog.abstractMethod;

/**
 * Indicates that an error occurred on the given channel.
 * @param {buzz.channel.Channel} channel The channel on which the error has
 *     occurred.
 * @param {buzz.channel.ChannelError} error Information about the error that
 *     occurred.
 */
buzz.channel.ChannelHandler.prototype.onError = goog.abstractMethod;

/**
 * Indicates that the given channel is closed.
 * @param {buzz.channel.Channel} channel The channel that is now closed.
 */
buzz.channel.ChannelHandler.prototype.onClose = goog.abstractMethod;

//javascript/closure/proto2/descriptor.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Protocol Buffer (Message) Descriptor class.
 * @author jschorr@google.com (Joseph Schorr)
 */

goog.provide('goog.proto2.Descriptor');
goog.provide('goog.proto2.Metadata');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.object');
goog.require('goog.string');


/**
 * @typedef {{name: (string|undefined),
 *            fullName: (string|undefined),
 *            containingType: (goog.proto2.Message|undefined)}}
 */
goog.proto2.Metadata;



/**
 * A class which describes a Protocol Buffer 2 Message.
 *
 * @param {function(new:goog.proto2.Message)} messageType Constructor for
 *      the message class that this descriptor describes.
 * @param {!goog.proto2.Metadata} metadata The metadata about the message that
 *      will be used to construct this descriptor.
 * @param {Array.<!goog.proto2.FieldDescriptor>} fields The fields of the
 *      message described by this descriptor.
 *
 * @constructor
 * @final
 */
goog.proto2.Descriptor = function(messageType, metadata, fields) {

  /**
   * @type {function(new:goog.proto2.Message)}
   * @private
   */
  this.messageType_ = messageType;

  /**
   * @type {?string}
   * @private
   */
  this.name_ = metadata.name || null;

  /**
   * @type {?string}
   * @private
   */
  this.fullName_ = metadata.fullName || null;

  /**
   * @type {goog.proto2.Message|undefined}
   * @private
   */
  this.containingType_ = metadata.containingType;

  /**
   * The fields of the message described by this descriptor.
   * @type {!Object.<number, !goog.proto2.FieldDescriptor>}
   * @private
   */
  this.fields_ = {};

  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    this.fields_[field.getTag()] = field;
  }
};


/**
 * Returns the name of the message, if any.
 *
 * @return {?string} The name.
 */
goog.proto2.Descriptor.prototype.getName = function() {
  return this.name_;
};


/**
 * Returns the full name of the message, if any.
 *
 * @return {?string} The name.
 */
goog.proto2.Descriptor.prototype.getFullName = function() {
  return this.fullName_;
};


/**
 * Returns the descriptor of the containing message type or null if none.
 *
 * @return {goog.proto2.Descriptor} The descriptor.
 */
goog.proto2.Descriptor.prototype.getContainingType = function() {
  if (!this.containingType_) {
    return null;
  }

  return this.containingType_.getDescriptor();
};


/**
 * Returns the fields in the message described by this descriptor ordered by
 * tag.
 *
 * @return {!Array.<!goog.proto2.FieldDescriptor>} The array of field
 *     descriptors.
 */
goog.proto2.Descriptor.prototype.getFields = function() {
  /**
   * @param {!goog.proto2.FieldDescriptor} fieldA First field.
   * @param {!goog.proto2.FieldDescriptor} fieldB Second field.
   * @return {number} Negative if fieldA's tag number is smaller, positive
   *     if greater, zero if the same.
   */
  function tagComparator(fieldA, fieldB) {
    return fieldA.getTag() - fieldB.getTag();
  };

  var fields = goog.object.getValues(this.fields_);
  goog.array.sort(fields, tagComparator);

  return fields;
};


/**
 * Returns the fields in the message as a key/value map, where the key is
 * the tag number of the field. DO NOT MODIFY THE RETURNED OBJECT. We return
 * the actual, internal, fields map for performance reasons, and changing the
 * map can result in undefined behavior of this library.
 *
 * @return {!Object.<number, !goog.proto2.FieldDescriptor>} The field map.
 */
goog.proto2.Descriptor.prototype.getFieldsMap = function() {
  return this.fields_;
};


/**
 * Returns the field matching the given name, if any. Note that
 * this method searches over the *original* name of the field,
 * not the camelCase version.
 *
 * @param {string} name The field name for which to search.
 *
 * @return {goog.proto2.FieldDescriptor} The field found, if any.
 */
goog.proto2.Descriptor.prototype.findFieldByName = function(name) {
  var valueFound = goog.object.findValue(this.fields_,
      function(field, key, obj) {
        return field.getName() == name;
      });

  return /** @type {goog.proto2.FieldDescriptor} */ (valueFound) || null;
};


/**
 * Returns the field matching the given tag number, if any.
 *
 * @param {number|string} tag The field tag number for which to search.
 *
 * @return {goog.proto2.FieldDescriptor} The field found, if any.
 */
goog.proto2.Descriptor.prototype.findFieldByTag = function(tag) {
  goog.asserts.assert(goog.string.isNumeric(tag));
  return this.fields_[parseInt(tag, 10)] || null;
};


/**
 * Creates an instance of the message type that this descriptor
 * describes.
 *
 * @return {!goog.proto2.Message} The instance of the message.
 */
goog.proto2.Descriptor.prototype.createMessageInstance = function() {
  return new this.messageType_;
};

//javascript/closure/proto2/fielddescriptor.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Protocol Buffer Field Descriptor class.
 * @author jschorr@google.com (Joseph Schorr)
 */

goog.provide('goog.proto2.FieldDescriptor');

goog.require('goog.asserts');
goog.require('goog.string');



/**
 * A class which describes a field in a Protocol Buffer 2 Message.
 *
 * @param {Function} messageType Constructor for the message
 *     class to which the field described by this class belongs.
 * @param {number|string} tag The field's tag index.
 * @param {Object} metadata The metadata about this field that will be used
 *     to construct this descriptor.
 *
 * @constructor
 * @final
 */
goog.proto2.FieldDescriptor = function(messageType, tag, metadata) {
  /**
   * The message type that contains the field that this
   * descriptor describes.
   * @type {Function}
   * @private
   */
  this.parent_ = messageType;

  // Ensure that the tag is numeric.
  goog.asserts.assert(goog.string.isNumeric(tag));

  /**
   * The field's tag number.
   * @type {number}
   * @private
   */
  this.tag_ = /** @type {number} */ (tag);

  /**
   * The field's name.
   * @type {string}
   * @private
   */
  this.name_ = metadata.name;

  /** @type {goog.proto2.FieldDescriptor.FieldType} */
  metadata.fieldType;

  /** @type {*} */
  metadata.repeated;

  /** @type {*} */
  metadata.required;

  /**
   * If true, this field is a repeating field.
   * @type {boolean}
   * @private
   */
  this.isRepeated_ = !!metadata.repeated;

  /**
   * If true, this field is required.
   * @type {boolean}
   * @private
   */
  this.isRequired_ = !!metadata.required;

  /**
   * The field type of this field.
   * @type {goog.proto2.FieldDescriptor.FieldType}
   * @private
   */
  this.fieldType_ = metadata.fieldType;

  /**
   * If this field is a primitive: The native (ECMAScript) type of this field.
   * If an enumeration: The enumeration object.
   * If a message or group field: The Message function.
   * @type {Function}
   * @private
   */
  this.nativeType_ = metadata.type;

  /**
   * Is it permissible on deserialization to convert between numbers and
   * well-formed strings?  Is true for 64-bit integral field types, false for
   * all other field types.
   * @type {boolean}
   * @private
   */
  this.deserializationConversionPermitted_ = false;

  switch (this.fieldType_) {
    case goog.proto2.FieldDescriptor.FieldType.INT64:
    case goog.proto2.FieldDescriptor.FieldType.UINT64:
    case goog.proto2.FieldDescriptor.FieldType.FIXED64:
    case goog.proto2.FieldDescriptor.FieldType.SFIXED64:
    case goog.proto2.FieldDescriptor.FieldType.SINT64:
      this.deserializationConversionPermitted_ = true;
      break;
  }

  /**
   * The default value of this field, if different from the default, default
   * value.
   * @type {*}
   * @private
   */
  this.defaultValue_ = metadata.defaultValue;
};


/**
 * An enumeration defining the possible field types.
 * Should be a mirror of that defined in descriptor.h.
 *
 * @enum {number}
 */
goog.proto2.FieldDescriptor.FieldType = {
  DOUBLE: 1,
  FLOAT: 2,
  INT64: 3,
  UINT64: 4,
  INT32: 5,
  FIXED64: 6,
  FIXED32: 7,
  BOOL: 8,
  STRING: 9,
  GROUP: 10,
  MESSAGE: 11,
  BYTES: 12,
  UINT32: 13,
  ENUM: 14,
  SFIXED32: 15,
  SFIXED64: 16,
  SINT32: 17,
  SINT64: 18
};


/**
 * Returns the tag of the field that this descriptor represents.
 *
 * @return {number} The tag number.
 */
goog.proto2.FieldDescriptor.prototype.getTag = function() {
  return this.tag_;
};


/**
 * Returns the descriptor describing the message that defined this field.
 * @return {goog.proto2.Descriptor} The descriptor.
 */
goog.proto2.FieldDescriptor.prototype.getContainingType = function() {
  return this.parent_.getDescriptor();
};


/**
 * Returns the name of the field that this descriptor represents.
 * @return {string} The name.
 */
goog.proto2.FieldDescriptor.prototype.getName = function() {
  return this.name_;
};


/**
 * Returns the default value of this field.
 * @return {*} The default value.
 */
goog.proto2.FieldDescriptor.prototype.getDefaultValue = function() {
  if (this.defaultValue_ === undefined) {
    // Set the default value based on a new instance of the native type.
    // This will be (0, false, "") for (number, boolean, string) and will
    // be a new instance of a group/message if the field is a message type.
    var nativeType = this.nativeType_;
    if (nativeType === Boolean) {
      this.defaultValue_ = false;
    } else if (nativeType === Number) {
      this.defaultValue_ = 0;
    } else if (nativeType === String) {
      if (this.deserializationConversionPermitted_) {
        // This field is a 64 bit integer represented as a string.
        this.defaultValue_ = '0';
      } else {
        this.defaultValue_ = '';
      }
    } else {
      this.defaultValue_ = new nativeType;
    }
  }

  return this.defaultValue_;
};


/**
 * Returns the field type of the field described by this descriptor.
 * @return {goog.proto2.FieldDescriptor.FieldType} The field type.
 */
goog.proto2.FieldDescriptor.prototype.getFieldType = function() {
  return this.fieldType_;
};


/**
 * Returns the native (i.e. ECMAScript) type of the field described by this
 * descriptor.
 *
 * @return {Object} The native type.
 */
goog.proto2.FieldDescriptor.prototype.getNativeType = function() {
  return this.nativeType_;
};


/**
 * Returns true if simple conversions between numbers and strings are permitted
 * during deserialization for this field.
 *
 * @return {boolean} Whether conversion is permitted.
 */
goog.proto2.FieldDescriptor.prototype.deserializationConversionPermitted =
    function() {
  return this.deserializationConversionPermitted_;
};


/**
 * Returns the descriptor of the message type of this field. Only valid
 * for fields of type GROUP and MESSAGE.
 *
 * @return {goog.proto2.Descriptor} The message descriptor.
 */
goog.proto2.FieldDescriptor.prototype.getFieldMessageType = function() {
  goog.asserts.assert(this.isCompositeType(), 'Expected message or group');

  return this.nativeType_.getDescriptor();
};


/**
 * @return {boolean} True if the field stores composite data or repeated
 *     composite data (message or group).
 */
goog.proto2.FieldDescriptor.prototype.isCompositeType = function() {
  return this.fieldType_ == goog.proto2.FieldDescriptor.FieldType.MESSAGE ||
      this.fieldType_ == goog.proto2.FieldDescriptor.FieldType.GROUP;
};


/**
 * Returns whether the field described by this descriptor is repeating.
 * @return {boolean} Whether the field is repeated.
 */
goog.proto2.FieldDescriptor.prototype.isRepeated = function() {
  return this.isRepeated_;
};


/**
 * Returns whether the field described by this descriptor is required.
 * @return {boolean} Whether the field is required.
 */
goog.proto2.FieldDescriptor.prototype.isRequired = function() {
  return this.isRequired_;
};


/**
 * Returns whether the field described by this descriptor is optional.
 * @return {boolean} Whether the field is optional.
 */
goog.proto2.FieldDescriptor.prototype.isOptional = function() {
  return !this.isRepeated_ && !this.isRequired_;
};

//javascript/closure/proto2/message.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Protocol Buffer Message base class.
 * @author jschorr@google.com (Joseph Schorr)
 * @author pallosp@google.com (Peter Pallos)
 */

goog.provide('goog.proto2.Message');

goog.require('goog.asserts');
goog.require('goog.proto2.Descriptor');
goog.require('goog.proto2.FieldDescriptor');
goog.require('goog.string');



/**
 * Abstract base class for all Protocol Buffer 2 messages. It will be
 * subclassed in the code generated by the Protocol Compiler. Any other
 * subclasses are prohibited.
 * @constructor
 */
goog.proto2.Message = function() {
  /**
   * Stores the field values in this message. Keyed by the tag of the fields.
   * @type {*}
   * @private
   */
  this.values_ = {};

  /**
   * Stores the field information (i.e. metadata) about this message.
   * @type {Object.<number, !goog.proto2.FieldDescriptor>}
   * @private
   */
  this.fields_ = this.getDescriptor().getFieldsMap();

  /**
   * The lazy deserializer for this message instance, if any.
   * @type {goog.proto2.LazyDeserializer}
   * @private
   */
  this.lazyDeserializer_ = null;

  /**
   * A map of those fields deserialized, from tag number to their deserialized
   * value.
   * @type {Object}
   * @private
   */
  this.deserializedFields_ = null;
};


/**
 * An enumeration defining the possible field types.
 * Should be a mirror of that defined in descriptor.h.
 *
 * TODO(sra): Remove this alias.  The code generator generates code that
 * references this enum, so it needs to exist until the code generator is
 * changed.  The enum was moved to from Message to FieldDescriptor to avoid a
 * dependency cycle.
 *
 * Use goog.proto2.FieldDescriptor.FieldType instead.
 *
 * @enum {number}
 */
goog.proto2.Message.FieldType = {
  DOUBLE: 1,
  FLOAT: 2,
  INT64: 3,
  UINT64: 4,
  INT32: 5,
  FIXED64: 6,
  FIXED32: 7,
  BOOL: 8,
  STRING: 9,
  GROUP: 10,
  MESSAGE: 11,
  BYTES: 12,
  UINT32: 13,
  ENUM: 14,
  SFIXED32: 15,
  SFIXED64: 16,
  SINT32: 17,
  SINT64: 18
};


/**
 * All instances of goog.proto2.Message should have a static descriptorObj_
 * property. This is a JSON representation of a Descriptor. The real Descriptor
 * will be deserialized lazily in the getDescriptor() method.
 *
 * This declaration is just here for documentation purposes.
 * goog.proto2.Message does not have its own descriptor.
 *
 * @type {undefined}
 * @private
 */
goog.proto2.Message.descriptorObj_;


/**
 * All instances of goog.proto2.Message should have a static descriptor_
 * property. The Descriptor will be deserialized lazily in the getDescriptor()
 * method.
 *
 * This declaration is just here for documentation purposes.
 * goog.proto2.Message does not have its own descriptor.
 *
 * @type {undefined}
 * @private
 */
goog.proto2.Message.descriptor_;


/**
 * Initializes the message with a lazy deserializer and its associated data.
 * This method should be called by internal methods ONLY.
 *
 * @param {goog.proto2.LazyDeserializer} deserializer The lazy deserializer to
 *   use to decode the data on the fly.
 *
 * @param {*} data The data to decode/deserialize.
 */
goog.proto2.Message.prototype.initializeForLazyDeserializer = function(
    deserializer, data) {

  this.lazyDeserializer_ = deserializer;
  this.values_ = data;
  this.deserializedFields_ = {};
};


/**
 * Sets the value of an unknown field, by tag.
 *
 * @param {number} tag The tag of an unknown field (must be >= 1).
 * @param {*} value The value for that unknown field.
 */
goog.proto2.Message.prototype.setUnknown = function(tag, value) {
  goog.asserts.assert(!this.fields_[tag],
      'Field is not unknown in this message');
  goog.asserts.assert(tag >= 1, 'Tag is not valid');
  goog.asserts.assert(value !== null, 'Value cannot be null');

  this.values_[tag] = value;
  if (this.deserializedFields_) {
    delete this.deserializedFields_[tag];
  }
};


/**
 * Iterates over all the unknown fields in the message.
 *
 * @param {function(number, *)} callback A callback method
 *     which gets invoked for each unknown field.
 * @param {Object=} opt_scope The scope under which to execute the callback.
 *     If not given, the current message will be used.
 */
goog.proto2.Message.prototype.forEachUnknown = function(callback, opt_scope) {
  var scope = opt_scope || this;
  for (var key in this.values_) {
    var keyNum = Number(key);
    if (!this.fields_[keyNum]) {
      callback.call(scope, keyNum, this.values_[key]);
    }
  }
};


/**
 * Returns the descriptor which describes the current message.
 *
 * This only works if we assume people never subclass protobufs.
 *
 * @return {!goog.proto2.Descriptor} The descriptor.
 */
goog.proto2.Message.prototype.getDescriptor = function() {
  // NOTE(nicksantos): These sorts of indirect references to descriptor
  // through this.constructor are fragile. See the comments
  // in set$Metadata for more info.
  var Ctor = this.constructor;
  return Ctor.descriptor_ ||
      (Ctor.descriptor_ = goog.proto2.Message.create$Descriptor(
          Ctor, Ctor.descriptorObj_));
};


/**
 * Returns whether there is a value stored at the field specified by the
 * given field descriptor.
 *
 * @param {goog.proto2.FieldDescriptor} field The field for which to check
 *     if there is a value.
 *
 * @return {boolean} True if a value was found.
 */
goog.proto2.Message.prototype.has = function(field) {
  goog.asserts.assert(
      field.getContainingType() == this.getDescriptor(),
      'The current message does not contain the given field');

  return this.has$Value(field.getTag());
};


/**
 * Returns the array of values found for the given repeated field.
 *
 * @param {goog.proto2.FieldDescriptor} field The field for which to
 *     return the values.
 *
 * @return {!Array} The values found.
 */
goog.proto2.Message.prototype.arrayOf = function(field) {
  goog.asserts.assert(
      field.getContainingType() == this.getDescriptor(),
      'The current message does not contain the given field');

  return this.array$Values(field.getTag());
};


/**
 * Returns the number of values stored in the given field.
 *
 * @param {goog.proto2.FieldDescriptor} field The field for which to count
 *     the number of values.
 *
 * @return {number} The count of the values in the given field.
 */
goog.proto2.Message.prototype.countOf = function(field) {
  goog.asserts.assert(
      field.getContainingType() == this.getDescriptor(),
      'The current message does not contain the given field');

  return this.count$Values(field.getTag());
};


/**
 * Returns the value stored at the field specified by the
 * given field descriptor.
 *
 * @param {goog.proto2.FieldDescriptor} field The field for which to get the
 *     value.
 * @param {number=} opt_index If the field is repeated, the index to use when
 *     looking up the value.
 *
 * @return {*} The value found or null if none.
 */
goog.proto2.Message.prototype.get = function(field, opt_index) {
  goog.asserts.assert(
      field.getContainingType() == this.getDescriptor(),
      'The current message does not contain the given field');

  return this.get$Value(field.getTag(), opt_index);
};


/**
 * Returns the value stored at the field specified by the
 * given field descriptor or the default value if none exists.
 *
 * @param {goog.proto2.FieldDescriptor} field The field for which to get the
 *     value.
 * @param {number=} opt_index If the field is repeated, the index to use when
 *     looking up the value.
 *
 * @return {*} The value found or the default if none.
 */
goog.proto2.Message.prototype.getOrDefault = function(field, opt_index) {
  goog.asserts.assert(
      field.getContainingType() == this.getDescriptor(),
      'The current message does not contain the given field');

  return this.get$ValueOrDefault(field.getTag(), opt_index);
};


/**
 * Stores the given value to the field specified by the
 * given field descriptor. Note that the field must not be repeated.
 *
 * @param {goog.proto2.FieldDescriptor} field The field for which to set
 *     the value.
 * @param {*} value The new value for the field.
 */
goog.proto2.Message.prototype.set = function(field, value) {
  goog.asserts.assert(
      field.getContainingType() == this.getDescriptor(),
      'The current message does not contain the given field');

  this.set$Value(field.getTag(), value);
};


/**
 * Adds the given value to the field specified by the
 * given field descriptor. Note that the field must be repeated.
 *
 * @param {goog.proto2.FieldDescriptor} field The field in which to add the
 *     the value.
 * @param {*} value The new value to add to the field.
 */
goog.proto2.Message.prototype.add = function(field, value) {
  goog.asserts.assert(
      field.getContainingType() == this.getDescriptor(),
      'The current message does not contain the given field');

  this.add$Value(field.getTag(), value);
};


/**
 * Clears the field specified.
 *
 * @param {goog.proto2.FieldDescriptor} field The field to clear.
 */
goog.proto2.Message.prototype.clear = function(field) {
  goog.asserts.assert(
      field.getContainingType() == this.getDescriptor(),
      'The current message does not contain the given field');

  this.clear$Field(field.getTag());
};


/**
 * Compares this message with another one ignoring the unknown fields.
 * @param {*} other The other message.
 * @return {boolean} Whether they are equal. Returns false if the {@code other}
 *     argument is a different type of message or not a message.
 */
goog.proto2.Message.prototype.equals = function(other) {
  if (!other || this.constructor != other.constructor) {
    return false;
  }

  var fields = this.getDescriptor().getFields();
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    if (this.has(field) != other.has(field)) {
      return false;
    }

    if (this.has(field)) {
      var isComposite = field.isCompositeType();

      var fieldsEqual = function(value1, value2) {
        return isComposite ? value1.equals(value2) : value1 == value2;
      };

      var thisValue = this.getValueForField_(field);
      var otherValue = other.getValueForField_(field);

      if (field.isRepeated()) {
        // In this case thisValue and otherValue are arrays.
        if (thisValue.length != otherValue.length) {
          return false;
        }
        for (var j = 0; j < thisValue.length; j++) {
          if (!fieldsEqual(thisValue[j], otherValue[j])) {
            return false;
          }
        }
      } else if (!fieldsEqual(thisValue, otherValue)) {
        return false;
      }
    }
  }

  return true;
};


/**
 * Recursively copies the known fields from the given message to this message.
 * Removes the fields which are not present in the source message.
 * @param {!goog.proto2.Message} message The source message.
 */
goog.proto2.Message.prototype.copyFrom = function(message) {
  goog.asserts.assert(this.constructor == message.constructor,
      'The source message must have the same type.');

  if (this != message) {
    this.values_ = {};
    if (this.deserializedFields_) {
      this.deserializedFields_ = {};
    }
    this.mergeFrom(message);
  }
};


/**
 * Merges the given message into this message.
 *
 * Singular fields will be overwritten, except for embedded messages which will
 * be merged. Repeated fields will be concatenated.
 * @param {!goog.proto2.Message} message The source message.
 */
goog.proto2.Message.prototype.mergeFrom = function(message) {
  goog.asserts.assert(this.constructor == message.constructor,
      'The source message must have the same type.');
  var fields = this.getDescriptor().getFields();

  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    if (message.has(field)) {
      if (this.deserializedFields_) {
        delete this.deserializedFields_[field.getTag()];
      }

      var isComposite = field.isCompositeType();
      if (field.isRepeated()) {
        var values = message.arrayOf(field);
        for (var j = 0; j < values.length; j++) {
          this.add(field, isComposite ? values[j].clone() : values[j]);
        }
      } else {
        var value = message.getValueForField_(field);
        if (isComposite) {
          var child = this.getValueForField_(field);
          if (child) {
            child.mergeFrom(value);
          } else {
            this.set(field, value.clone());
          }
        } else {
          this.set(field, value);
        }
      }
    }
  }
};


/**
 * @return {!goog.proto2.Message} Recursive clone of the message only including
 *     the known fields.
 */
goog.proto2.Message.prototype.clone = function() {
  var clone = new this.constructor;
  clone.copyFrom(this);
  return clone;
};


/**
 * Fills in the protocol buffer with default values. Any fields that are
 * already set will not be overridden.
 * @param {boolean} simpleFieldsToo If true, all fields will be initialized;
 *     if false, only the nested messages and groups.
 */
goog.proto2.Message.prototype.initDefaults = function(simpleFieldsToo) {
  var fields = this.getDescriptor().getFields();
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    var tag = field.getTag();
    var isComposite = field.isCompositeType();

    // Initialize missing fields.
    if (!this.has(field) && !field.isRepeated()) {
      if (isComposite) {
        this.values_[tag] = new /** @type {Function} */ (field.getNativeType());
      } else if (simpleFieldsToo) {
        this.values_[tag] = field.getDefaultValue();
      }
    }

    // Fill in the existing composite fields recursively.
    if (isComposite) {
      if (field.isRepeated()) {
        var values = this.array$Values(tag);
        for (var j = 0; j < values.length; j++) {
          values[j].initDefaults(simpleFieldsToo);
        }
      } else {
        this.get$Value(tag).initDefaults(simpleFieldsToo);
      }
    }
  }
};


/**
 * Returns the field in this message by the given tag number. If no
 * such field exists, throws an exception.
 *
 * @param {number} tag The field's tag index.
 * @return {!goog.proto2.FieldDescriptor} The descriptor for the field.
 * @private
 */
goog.proto2.Message.prototype.getFieldByTag_ = function(tag) {
  goog.asserts.assert(this.fields_[tag], 'No field found for the given tag');

  return this.fields_[tag];
};


/**
 * Returns the whether or not the field indicated by the given tag
 * has a value.
 *
 * GENERATED CODE USE ONLY. Basis of the has{Field} methods.
 *
 * @param {number} tag The tag.
 *
 * @return {boolean} Whether the message has a value for the field.
 */
goog.proto2.Message.prototype.has$Value = function(tag) {
  goog.asserts.assert(this.fields_[tag], 'No field found for the given tag');

  return goog.isDefAndNotNull(this.values_[tag]);
};


/**
 * Returns the value for the given field. If a lazy deserializer is
 * instantiated, lazily deserializes the field if required before returning the
 * value.
 *
 * @param {goog.proto2.FieldDescriptor} field The field.
 * @return {*} The field value, if any.
 * @private
 */
goog.proto2.Message.prototype.getValueForField_ = function(field) {
  // Retrieve the current value, which may still be serialized.
  var tag = field.getTag();

  var value = this.values_[tag];
  if (!goog.isDefAndNotNull(value)) {
    return null;
  }

  // If we have a lazy deserializer, then ensure that the field is
  // properly deserialized.
  if (this.lazyDeserializer_) {
    // If the tag is not deserialized, then we must do so now. Deserialize
    // the field's value via the deserializer.
    if (!(tag in this.deserializedFields_)) {
      var deserializedValue = this.lazyDeserializer_.deserializeField(
          this, field, value);
      this.deserializedFields_[tag] = deserializedValue;
      return deserializedValue;
    }

    return this.deserializedFields_[tag];
  }

  // Otherwise, just return the value.
  return value;
};


/**
 * Gets the value at the field indicated by the given tag.
 *
 * GENERATED CODE USE ONLY. Basis of the get{Field} methods.
 *
 * @param {number} tag The field's tag index.
 * @param {number=} opt_index If the field is a repeated field, the index
 *     at which to get the value.
 *
 * @return {*} The value found or null for none.
 * @protected
 */
goog.proto2.Message.prototype.get$Value = function(tag, opt_index) {
  var field = this.getFieldByTag_(tag);
  var value = this.getValueForField_(field);

  if (field.isRepeated()) {
    goog.asserts.assert(goog.isArray(value));

    var index = opt_index || 0;
    goog.asserts.assert(index >= 0 && index < value.length,
        'Given index is out of bounds');

    return value[index];
  }

  goog.asserts.assert(!goog.isArray(value));
  return value;
};


/**
 * Gets the value at the field indicated by the given tag or the default value
 * if none.
 *
 * GENERATED CODE USE ONLY. Basis of the get{Field} methods.
 *
 * @param {number} tag The field's tag index.
 * @param {number=} opt_index If the field is a repeated field, the index
 *     at which to get the value.
 *
 * @return {*} The value found or the default value if none set.
 * @protected
 */
goog.proto2.Message.prototype.get$ValueOrDefault = function(tag, opt_index) {

  if (!this.has$Value(tag)) {
    // Return the default value.
    var field = this.getFieldByTag_(tag);
    return field.getDefaultValue();
  }

  return this.get$Value(tag, opt_index);
};


/**
 * Gets the values at the field indicated by the given tag.
 *
 * GENERATED CODE USE ONLY. Basis of the {field}Array methods.
 *
 * @param {number} tag The field's tag index.
 *
 * @return {!Array} The values found. If none, returns an empty array.
 * @protected
 */
goog.proto2.Message.prototype.array$Values = function(tag) {
  goog.asserts.assert(this.getFieldByTag_(tag).isRepeated(),
      'Cannot call fieldArray on a non-repeated field');
  var field = this.getFieldByTag_(tag);
  var value = this.getValueForField_(field);
  goog.asserts.assert(value == null || goog.isArray(value));
  return /** @type {Array} */ (value) || [];
};


/**
 * Returns the number of values stored in the field by the given tag.
 *
 * GENERATED CODE USE ONLY. Basis of the {field}Count methods.
 *
 * @param {number} tag The tag.
 *
 * @return {number} The number of values.
 * @protected
 */
goog.proto2.Message.prototype.count$Values = function(tag) {
  var field = this.getFieldByTag_(tag);

  if (field.isRepeated()) {
    if (this.has$Value(tag)) {
      goog.asserts.assert(goog.isArray(this.values_[tag]));
    }

    return this.has$Value(tag) ? this.values_[tag].length : 0;
  } else {
    return this.has$Value(tag) ? 1 : 0;
  }
};


/**
 * Sets the value of the *non-repeating* field indicated by the given tag.
 *
 * GENERATED CODE USE ONLY. Basis of the set{Field} methods.
 *
 * @param {number} tag The field's tag index.
 * @param {*} value The field's value.
 * @protected
 */
goog.proto2.Message.prototype.set$Value = function(tag, value) {
  if (goog.asserts.ENABLE_ASSERTS) {
    var field = this.getFieldByTag_(tag);
    goog.asserts.assert(!field.isRepeated(),
        'Cannot call set on a repeated field');
    this.checkFieldType_(field, value);
  }

  this.values_[tag] = value;
  if (this.deserializedFields_) {
    this.deserializedFields_[tag] = value;
  }
};


/**
 * Adds the value to the *repeating* field indicated by the given tag.
 *
 * GENERATED CODE USE ONLY. Basis of the add{Field} methods.
 *
 * @param {number} tag The field's tag index.
 * @param {*} value The value to add.
 * @protected
 */
goog.proto2.Message.prototype.add$Value = function(tag, value) {
  if (goog.asserts.ENABLE_ASSERTS) {
    var field = this.getFieldByTag_(tag);
    goog.asserts.assert(field.isRepeated(),
        'Cannot call add on a non-repeated field');
    this.checkFieldType_(field, value);
  }

  if (!this.values_[tag]) {
    this.values_[tag] = [];
  }

  this.values_[tag].push(value);
  if (this.deserializedFields_) {
    delete this.deserializedFields_[tag];
  }
};


/**
 * Ensures that the value being assigned to the given field
 * is valid.
 *
 * @param {!goog.proto2.FieldDescriptor} field The field being assigned.
 * @param {*} value The value being assigned.
 * @private
 */
goog.proto2.Message.prototype.checkFieldType_ = function(field, value) {
  if (field.getFieldType() == goog.proto2.FieldDescriptor.FieldType.ENUM) {
    goog.asserts.assertNumber(value);
  } else {
    goog.asserts.assert(value.constructor == field.getNativeType());
  }
};


/**
 * Clears the field specified by tag.
 *
 * GENERATED CODE USE ONLY. Basis of the clear{Field} methods.
 *
 * @param {number} tag The tag of the field to clear.
 * @protected
 */
goog.proto2.Message.prototype.clear$Field = function(tag) {
  goog.asserts.assert(this.getFieldByTag_(tag), 'Unknown field');
  delete this.values_[tag];
  if (this.deserializedFields_) {
    delete this.deserializedFields_[tag];
  }
};


/**
 * Creates the metadata descriptor representing the definition of this message.
 *
 * GENERATED CODE USE ONLY. Called when constructing message classes.
 *
 * @param {function(new:goog.proto2.Message)} messageType Constructor for the
 *     message type to which this metadata applies.
 * @param {Object} metadataObj The object containing the metadata.
 * @return {!goog.proto2.Descriptor} The new descriptor.
 */
goog.proto2.Message.create$Descriptor = function(messageType, metadataObj) {
  var fields = [];
  var descriptorInfo;

  for (var key in metadataObj) {
    if (!metadataObj.hasOwnProperty(key)) {
      continue;
    }

    goog.asserts.assert(goog.string.isNumeric(key), 'Keys must be numeric');

    if (key == 0) {
      descriptorInfo = metadataObj[0];
      continue;
    }

    // Create the field descriptor.
    fields.push(
        new goog.proto2.FieldDescriptor(messageType, key, metadataObj[key]));
  }

  goog.asserts.assert(descriptorInfo);
  return new goog.proto2.Descriptor(messageType, descriptorInfo, fields);
};


/**
 * Sets the metadata that represents the definition of this message.
 *
 * GENERATED CODE USE ONLY. Called when constructing message classes.
 *
 * @param {!Function} messageType Constructor for the
 *     message type to which this metadata applies.
 * @param {Object} metadataObj The object containing the metadata.
 */
goog.proto2.Message.set$Metadata = function(messageType, metadataObj) {
  // NOTE(nicksantos): JSCompiler's type-based optimizations really do not
  // like indirectly defined methods (both prototype methods and
  // static methods). This is very fragile in compiled code. I think it only
  // really works by accident, and is highly likely to break in the future.
  messageType.descriptorObj_ = metadataObj;
  messageType.getDescriptor = function() {
    // The descriptor is created lazily when we instantiate a new instance.
    return messageType.descriptor_ ||
        (new messageType()).getDescriptor();
  };
};

//buzz/channel/proto/browser_channel.pb.js
// Protocol Buffer 2 Copyright 2008 Google Inc.
// All other code copyright its respective owners.

/**
 * @fileoverview Generated Protocol Buffer code for file
 * buzz/channel/proto/browser_channel.proto.
 */

goog.provide('buzz.channel.proto.BrowserChannelConfig');
goog.provide('buzz.channel.proto.AuthenticationParameters');
goog.provide('buzz.channel.proto.AuthenticationParameters.Scheme');

goog.require('goog.proto2.Message');



/**
 * Message BrowserChannelConfig.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.BrowserChannelConfig = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.BrowserChannelConfig, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.BrowserChannelConfig} The cloned message.
 * @override
 */
buzz.channel.proto.BrowserChannelConfig.prototype.clone;


/**
 * Gets the value of the authuser field.
 * @return {?number} The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.getAuthuser = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the authuser field or the default value if not set.
 * @return {number} The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.getAuthuserOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the authuser field.
 * @param {number} value The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.setAuthuser = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the authuser field has a value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.hasAuthuser = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the authuser field.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.authuserCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the authuser field.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.clearAuthuser = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the client_type field.
 * @return {?string} The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.getClientType = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the client_type field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.getClientTypeOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the client_type field.
 * @param {string} value The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.setClientType = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the client_type field has a value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.hasClientType = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the client_type field.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.clientTypeCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the client_type field.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.clearClientType = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the init_delay_ms field.
 * @return {?number} The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.getInitDelayMs = function() {
  return /** @type {?number} */ (this.get$Value(3));
};


/**
 * Gets the value of the init_delay_ms field or the default value if not set.
 * @return {number} The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.getInitDelayMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the init_delay_ms field.
 * @param {number} value The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.setInitDelayMs = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the init_delay_ms field has a value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.hasInitDelayMs = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the init_delay_ms field.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.initDelayMsCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the init_delay_ms field.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.clearInitDelayMs = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the service_override field.
 * @return {?string} The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.getServiceOverride = function() {
  return /** @type {?string} */ (this.get$Value(4));
};


/**
 * Gets the value of the service_override field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.getServiceOverrideOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the service_override field.
 * @param {string} value The value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.setServiceOverride = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the service_override field has a value.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.hasServiceOverride = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the service_override field.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.serviceOverrideCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the service_override field.
 */
buzz.channel.proto.BrowserChannelConfig.prototype.clearServiceOverride = function() {
  this.clear$Field(4);
};



/**
 * Message AuthenticationParameters.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.AuthenticationParameters = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.AuthenticationParameters, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.AuthenticationParameters} The cloned message.
 * @override
 */
buzz.channel.proto.AuthenticationParameters.prototype.clone;


/**
 * Gets the value of the origin field.
 * @return {?string} The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.getOrigin = function() {
  return /** @type {?string} */ (this.get$Value(1));
};


/**
 * Gets the value of the origin field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.getOriginOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the origin field.
 * @param {string} value The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.setOrigin = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the origin field has a value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.hasOrigin = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the origin field.
 */
buzz.channel.proto.AuthenticationParameters.prototype.originCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the origin field.
 */
buzz.channel.proto.AuthenticationParameters.prototype.clearOrigin = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the scheme field.
 * @return {?number} The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.getScheme = function() {
  return /** @type {?number} */ (this.get$Value(2));
};


/**
 * Gets the value of the scheme field or the default value if not set.
 * @return {number} The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.getSchemeOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the scheme field.
 * @param {number} value The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.setScheme = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the scheme field has a value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.hasScheme = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the scheme field.
 */
buzz.channel.proto.AuthenticationParameters.prototype.schemeCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the scheme field.
 */
buzz.channel.proto.AuthenticationParameters.prototype.clearScheme = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the token field.
 * @return {?string} The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.getToken = function() {
  return /** @type {?string} */ (this.get$Value(3));
};


/**
 * Gets the value of the token field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.getTokenOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the token field.
 * @param {string} value The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.setToken = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the token field has a value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.hasToken = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the token field.
 */
buzz.channel.proto.AuthenticationParameters.prototype.tokenCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the token field.
 */
buzz.channel.proto.AuthenticationParameters.prototype.clearToken = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the authuser field.
 * @return {?number} The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.getAuthuser = function() {
  return /** @type {?number} */ (this.get$Value(4));
};


/**
 * Gets the value of the authuser field or the default value if not set.
 * @return {number} The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.getAuthuserOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the authuser field.
 * @param {number} value The value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.setAuthuser = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the authuser field has a value.
 */
buzz.channel.proto.AuthenticationParameters.prototype.hasAuthuser = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the authuser field.
 */
buzz.channel.proto.AuthenticationParameters.prototype.authuserCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the authuser field.
 */
buzz.channel.proto.AuthenticationParameters.prototype.clearAuthuser = function() {
  this.clear$Field(4);
};


/**
 * Enumeration Scheme.
 * @enum {number}
 */
buzz.channel.proto.AuthenticationParameters.Scheme = {
  APISIDHASH: 1,
  SAPISIDHASH: 2,
  OAUTH: 3
};


goog.proto2.Message.set$Metadata(buzz.channel.proto.BrowserChannelConfig, {
  0: {
    name: 'BrowserChannelConfig',
    fullName: 'buzz.channel.proto.BrowserChannelConfig'
  },
  1: {
    name: 'authuser',
    fieldType: goog.proto2.Message.FieldType.UINT64,
    type: Number
  },
  2: {
    name: 'client_type',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  3: {
    name: 'init_delay_ms',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  },
  4: {
    name: 'service_override',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.AuthenticationParameters, {
  0: {
    name: 'AuthenticationParameters',
    fullName: 'buzz.channel.proto.AuthenticationParameters'
  },
  1: {
    name: 'origin',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  2: {
    name: 'scheme',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  },
  3: {
    name: 'token',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  4: {
    name: 'authuser',
    fieldType: goog.proto2.Message.FieldType.UINT32,
    type: Number
  }
});

//buzz/channel/proto/channel_internal.pb.js
// Protocol Buffer 2 Copyright 2008 Google Inc.
// All other code copyright its respective owners.

/**
 * @fileoverview Generated Protocol Buffer code for file
 * buzz/channel/proto/channel_internal.proto.
 */

goog.provide('buzz.channel.proto.LcsMessage');
goog.provide('buzz.channel.proto.Version');
goog.provide('buzz.channel.proto.ProtocolVersion');
goog.provide('buzz.channel.proto.ClientVersion');
goog.provide('buzz.channel.proto.SessionId');
goog.provide('buzz.channel.proto.ClientToServerMessage');
goog.provide('buzz.channel.proto.ClientHeader');
goog.provide('buzz.channel.proto.InitEndpointMessage');
goog.provide('buzz.channel.proto.InitSessionMessage');
goog.provide('buzz.channel.proto.DataMessage');
goog.provide('buzz.channel.proto.SessionStatusMessage');
goog.provide('buzz.channel.proto.ServerToClientMessage');
goog.provide('buzz.channel.proto.ServerHeader');
goog.provide('buzz.channel.proto.StatusP');
goog.provide('buzz.channel.proto.StatusP.Code');
goog.provide('buzz.channel.proto.ChannelStatusMessage');

goog.require('goog.proto2.Message');



/**
 * Message LcsMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.LcsMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.LcsMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.LcsMessage} The cloned message.
 * @override
 */
buzz.channel.proto.LcsMessage.prototype.clone;


/**
 * Gets the value of the session field.
 * @return {?string} The value.
 */
buzz.channel.proto.LcsMessage.prototype.getSession = function() {
  return /** @type {?string} */ (this.get$Value(1));
};


/**
 * Gets the value of the session field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.LcsMessage.prototype.getSessionOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the session field.
 * @param {string} value The value.
 */
buzz.channel.proto.LcsMessage.prototype.setSession = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the session field has a value.
 */
buzz.channel.proto.LcsMessage.prototype.hasSession = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the session field.
 */
buzz.channel.proto.LcsMessage.prototype.sessionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the session field.
 */
buzz.channel.proto.LcsMessage.prototype.clearSession = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the message_id field.
 * @return {?string} The value.
 */
buzz.channel.proto.LcsMessage.prototype.getMessageId = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the message_id field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.LcsMessage.prototype.getMessageIdOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the message_id field.
 * @param {string} value The value.
 */
buzz.channel.proto.LcsMessage.prototype.setMessageId = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the message_id field has a value.
 */
buzz.channel.proto.LcsMessage.prototype.hasMessageId = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the message_id field.
 */
buzz.channel.proto.LcsMessage.prototype.messageIdCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the message_id field.
 */
buzz.channel.proto.LcsMessage.prototype.clearMessageId = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the data field.
 * @return {?string} The value.
 */
buzz.channel.proto.LcsMessage.prototype.getData = function() {
  return /** @type {?string} */ (this.get$Value(3));
};


/**
 * Gets the value of the data field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.LcsMessage.prototype.getDataOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the data field.
 * @param {string} value The value.
 */
buzz.channel.proto.LcsMessage.prototype.setData = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the data field has a value.
 */
buzz.channel.proto.LcsMessage.prototype.hasData = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the data field.
 */
buzz.channel.proto.LcsMessage.prototype.dataCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the data field.
 */
buzz.channel.proto.LcsMessage.prototype.clearData = function() {
  this.clear$Field(3);
};



/**
 * Message Version.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.Version = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.Version, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.Version} The cloned message.
 * @override
 */
buzz.channel.proto.Version.prototype.clone;


/**
 * Gets the value of the major_version field.
 * @return {?number} The value.
 */
buzz.channel.proto.Version.prototype.getMajorVersion = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the major_version field or the default value if not set.
 * @return {number} The value.
 */
buzz.channel.proto.Version.prototype.getMajorVersionOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the major_version field.
 * @param {number} value The value.
 */
buzz.channel.proto.Version.prototype.setMajorVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the major_version field has a value.
 */
buzz.channel.proto.Version.prototype.hasMajorVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the major_version field.
 */
buzz.channel.proto.Version.prototype.majorVersionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the major_version field.
 */
buzz.channel.proto.Version.prototype.clearMajorVersion = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the minor_version field.
 * @return {?number} The value.
 */
buzz.channel.proto.Version.prototype.getMinorVersion = function() {
  return /** @type {?number} */ (this.get$Value(2));
};


/**
 * Gets the value of the minor_version field or the default value if not set.
 * @return {number} The value.
 */
buzz.channel.proto.Version.prototype.getMinorVersionOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the minor_version field.
 * @param {number} value The value.
 */
buzz.channel.proto.Version.prototype.setMinorVersion = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the minor_version field has a value.
 */
buzz.channel.proto.Version.prototype.hasMinorVersion = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the minor_version field.
 */
buzz.channel.proto.Version.prototype.minorVersionCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the minor_version field.
 */
buzz.channel.proto.Version.prototype.clearMinorVersion = function() {
  this.clear$Field(2);
};



/**
 * Message ProtocolVersion.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.ProtocolVersion = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.ProtocolVersion, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.ProtocolVersion} The cloned message.
 * @override
 */
buzz.channel.proto.ProtocolVersion.prototype.clone;


/**
 * Gets the value of the version field.
 * @return {buzz.channel.proto.Version} The value.
 */
buzz.channel.proto.ProtocolVersion.prototype.getVersion = function() {
  return /** @type {buzz.channel.proto.Version} */ (this.get$Value(1));
};


/**
 * Gets the value of the version field or the default value if not set.
 * @return {!buzz.channel.proto.Version} The value.
 */
buzz.channel.proto.ProtocolVersion.prototype.getVersionOrDefault = function() {
  return /** @type {!buzz.channel.proto.Version} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the version field.
 * @param {!buzz.channel.proto.Version} value The value.
 */
buzz.channel.proto.ProtocolVersion.prototype.setVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the version field has a value.
 */
buzz.channel.proto.ProtocolVersion.prototype.hasVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the version field.
 */
buzz.channel.proto.ProtocolVersion.prototype.versionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the version field.
 */
buzz.channel.proto.ProtocolVersion.prototype.clearVersion = function() {
  this.clear$Field(1);
};



/**
 * Message ClientVersion.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.ClientVersion = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.ClientVersion, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.ClientVersion} The cloned message.
 * @override
 */
buzz.channel.proto.ClientVersion.prototype.clone;


/**
 * Gets the value of the version field.
 * @return {buzz.channel.proto.Version} The value.
 */
buzz.channel.proto.ClientVersion.prototype.getVersion = function() {
  return /** @type {buzz.channel.proto.Version} */ (this.get$Value(1));
};


/**
 * Gets the value of the version field or the default value if not set.
 * @return {!buzz.channel.proto.Version} The value.
 */
buzz.channel.proto.ClientVersion.prototype.getVersionOrDefault = function() {
  return /** @type {!buzz.channel.proto.Version} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the version field.
 * @param {!buzz.channel.proto.Version} value The value.
 */
buzz.channel.proto.ClientVersion.prototype.setVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the version field has a value.
 */
buzz.channel.proto.ClientVersion.prototype.hasVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the version field.
 */
buzz.channel.proto.ClientVersion.prototype.versionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the version field.
 */
buzz.channel.proto.ClientVersion.prototype.clearVersion = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the platform field.
 * @return {?string} The value.
 */
buzz.channel.proto.ClientVersion.prototype.getPlatform = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the platform field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.ClientVersion.prototype.getPlatformOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the platform field.
 * @param {string} value The value.
 */
buzz.channel.proto.ClientVersion.prototype.setPlatform = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the platform field has a value.
 */
buzz.channel.proto.ClientVersion.prototype.hasPlatform = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the platform field.
 */
buzz.channel.proto.ClientVersion.prototype.platformCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the platform field.
 */
buzz.channel.proto.ClientVersion.prototype.clearPlatform = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the language field.
 * @return {?string} The value.
 */
buzz.channel.proto.ClientVersion.prototype.getLanguage = function() {
  return /** @type {?string} */ (this.get$Value(3));
};


/**
 * Gets the value of the language field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.ClientVersion.prototype.getLanguageOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the language field.
 * @param {string} value The value.
 */
buzz.channel.proto.ClientVersion.prototype.setLanguage = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the language field has a value.
 */
buzz.channel.proto.ClientVersion.prototype.hasLanguage = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the language field.
 */
buzz.channel.proto.ClientVersion.prototype.languageCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the language field.
 */
buzz.channel.proto.ClientVersion.prototype.clearLanguage = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the application_info field.
 * @return {?string} The value.
 */
buzz.channel.proto.ClientVersion.prototype.getApplicationInfo = function() {
  return /** @type {?string} */ (this.get$Value(4));
};


/**
 * Gets the value of the application_info field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.ClientVersion.prototype.getApplicationInfoOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the application_info field.
 * @param {string} value The value.
 */
buzz.channel.proto.ClientVersion.prototype.setApplicationInfo = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the application_info field has a value.
 */
buzz.channel.proto.ClientVersion.prototype.hasApplicationInfo = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the application_info field.
 */
buzz.channel.proto.ClientVersion.prototype.applicationInfoCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the application_info field.
 */
buzz.channel.proto.ClientVersion.prototype.clearApplicationInfo = function() {
  this.clear$Field(4);
};



/**
 * Message SessionId.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.SessionId = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.SessionId, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.SessionId} The cloned message.
 * @override
 */
buzz.channel.proto.SessionId.prototype.clone;


/**
 * Gets the value of the service_name field.
 * @return {?string} The value.
 */
buzz.channel.proto.SessionId.prototype.getServiceName = function() {
  return /** @type {?string} */ (this.get$Value(1));
};


/**
 * Gets the value of the service_name field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.SessionId.prototype.getServiceNameOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the service_name field.
 * @param {string} value The value.
 */
buzz.channel.proto.SessionId.prototype.setServiceName = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the service_name field has a value.
 */
buzz.channel.proto.SessionId.prototype.hasServiceName = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the service_name field.
 */
buzz.channel.proto.SessionId.prototype.serviceNameCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the service_name field.
 */
buzz.channel.proto.SessionId.prototype.clearServiceName = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the session_name field.
 * @return {?string} The value.
 */
buzz.channel.proto.SessionId.prototype.getSessionName = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the session_name field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.SessionId.prototype.getSessionNameOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the session_name field.
 * @param {string} value The value.
 */
buzz.channel.proto.SessionId.prototype.setSessionName = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the session_name field has a value.
 */
buzz.channel.proto.SessionId.prototype.hasSessionName = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the session_name field.
 */
buzz.channel.proto.SessionId.prototype.sessionNameCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the session_name field.
 */
buzz.channel.proto.SessionId.prototype.clearSessionName = function() {
  this.clear$Field(2);
};



/**
 * Message ClientToServerMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.ClientToServerMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.ClientToServerMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.ClientToServerMessage} The cloned message.
 * @override
 */
buzz.channel.proto.ClientToServerMessage.prototype.clone;


/**
 * Gets the value of the header field.
 * @return {buzz.channel.proto.ClientHeader} The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.getHeader = function() {
  return /** @type {buzz.channel.proto.ClientHeader} */ (this.get$Value(1));
};


/**
 * Gets the value of the header field or the default value if not set.
 * @return {!buzz.channel.proto.ClientHeader} The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.getHeaderOrDefault = function() {
  return /** @type {!buzz.channel.proto.ClientHeader} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the header field.
 * @param {!buzz.channel.proto.ClientHeader} value The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.setHeader = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the header field has a value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.hasHeader = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the header field.
 */
buzz.channel.proto.ClientToServerMessage.prototype.headerCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the header field.
 */
buzz.channel.proto.ClientToServerMessage.prototype.clearHeader = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the init_endpoint_message field.
 * @return {buzz.channel.proto.InitEndpointMessage} The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.getInitEndpointMessage = function() {
  return /** @type {buzz.channel.proto.InitEndpointMessage} */ (this.get$Value(2));
};


/**
 * Gets the value of the init_endpoint_message field or the default value if not set.
 * @return {!buzz.channel.proto.InitEndpointMessage} The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.getInitEndpointMessageOrDefault = function() {
  return /** @type {!buzz.channel.proto.InitEndpointMessage} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the init_endpoint_message field.
 * @param {!buzz.channel.proto.InitEndpointMessage} value The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.setInitEndpointMessage = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the init_endpoint_message field has a value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.hasInitEndpointMessage = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the init_endpoint_message field.
 */
buzz.channel.proto.ClientToServerMessage.prototype.initEndpointMessageCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the init_endpoint_message field.
 */
buzz.channel.proto.ClientToServerMessage.prototype.clearInitEndpointMessage = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the init_session_message field.
 * @return {buzz.channel.proto.InitSessionMessage} The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.getInitSessionMessage = function() {
  return /** @type {buzz.channel.proto.InitSessionMessage} */ (this.get$Value(3));
};


/**
 * Gets the value of the init_session_message field or the default value if not set.
 * @return {!buzz.channel.proto.InitSessionMessage} The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.getInitSessionMessageOrDefault = function() {
  return /** @type {!buzz.channel.proto.InitSessionMessage} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the init_session_message field.
 * @param {!buzz.channel.proto.InitSessionMessage} value The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.setInitSessionMessage = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the init_session_message field has a value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.hasInitSessionMessage = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the init_session_message field.
 */
buzz.channel.proto.ClientToServerMessage.prototype.initSessionMessageCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the init_session_message field.
 */
buzz.channel.proto.ClientToServerMessage.prototype.clearInitSessionMessage = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the client_data_message field.
 * @return {buzz.channel.proto.DataMessage} The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.getClientDataMessage = function() {
  return /** @type {buzz.channel.proto.DataMessage} */ (this.get$Value(4));
};


/**
 * Gets the value of the client_data_message field or the default value if not set.
 * @return {!buzz.channel.proto.DataMessage} The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.getClientDataMessageOrDefault = function() {
  return /** @type {!buzz.channel.proto.DataMessage} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the client_data_message field.
 * @param {!buzz.channel.proto.DataMessage} value The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.setClientDataMessage = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the client_data_message field has a value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.hasClientDataMessage = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the client_data_message field.
 */
buzz.channel.proto.ClientToServerMessage.prototype.clientDataMessageCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the client_data_message field.
 */
buzz.channel.proto.ClientToServerMessage.prototype.clearClientDataMessage = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the send_on_disconnect_message field.
 * @return {buzz.channel.proto.DataMessage} The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.getSendOnDisconnectMessage = function() {
  return /** @type {buzz.channel.proto.DataMessage} */ (this.get$Value(5));
};


/**
 * Gets the value of the send_on_disconnect_message field or the default value if not set.
 * @return {!buzz.channel.proto.DataMessage} The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.getSendOnDisconnectMessageOrDefault = function() {
  return /** @type {!buzz.channel.proto.DataMessage} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the send_on_disconnect_message field.
 * @param {!buzz.channel.proto.DataMessage} value The value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.setSendOnDisconnectMessage = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the send_on_disconnect_message field has a value.
 */
buzz.channel.proto.ClientToServerMessage.prototype.hasSendOnDisconnectMessage = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the send_on_disconnect_message field.
 */
buzz.channel.proto.ClientToServerMessage.prototype.sendOnDisconnectMessageCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the send_on_disconnect_message field.
 */
buzz.channel.proto.ClientToServerMessage.prototype.clearSendOnDisconnectMessage = function() {
  this.clear$Field(5);
};



/**
 * Message ClientHeader.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.ClientHeader = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.ClientHeader, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.ClientHeader} The cloned message.
 * @override
 */
buzz.channel.proto.ClientHeader.prototype.clone;


/**
 * Gets the value of the protocol_version field.
 * @return {buzz.channel.proto.ProtocolVersion} The value.
 */
buzz.channel.proto.ClientHeader.prototype.getProtocolVersion = function() {
  return /** @type {buzz.channel.proto.ProtocolVersion} */ (this.get$Value(1));
};


/**
 * Gets the value of the protocol_version field or the default value if not set.
 * @return {!buzz.channel.proto.ProtocolVersion} The value.
 */
buzz.channel.proto.ClientHeader.prototype.getProtocolVersionOrDefault = function() {
  return /** @type {!buzz.channel.proto.ProtocolVersion} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the protocol_version field.
 * @param {!buzz.channel.proto.ProtocolVersion} value The value.
 */
buzz.channel.proto.ClientHeader.prototype.setProtocolVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the protocol_version field has a value.
 */
buzz.channel.proto.ClientHeader.prototype.hasProtocolVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the protocol_version field.
 */
buzz.channel.proto.ClientHeader.prototype.protocolVersionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the protocol_version field.
 */
buzz.channel.proto.ClientHeader.prototype.clearProtocolVersion = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the client_version field.
 * @return {buzz.channel.proto.ClientVersion} The value.
 */
buzz.channel.proto.ClientHeader.prototype.getClientVersion = function() {
  return /** @type {buzz.channel.proto.ClientVersion} */ (this.get$Value(2));
};


/**
 * Gets the value of the client_version field or the default value if not set.
 * @return {!buzz.channel.proto.ClientVersion} The value.
 */
buzz.channel.proto.ClientHeader.prototype.getClientVersionOrDefault = function() {
  return /** @type {!buzz.channel.proto.ClientVersion} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the client_version field.
 * @param {!buzz.channel.proto.ClientVersion} value The value.
 */
buzz.channel.proto.ClientHeader.prototype.setClientVersion = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the client_version field has a value.
 */
buzz.channel.proto.ClientHeader.prototype.hasClientVersion = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the client_version field.
 */
buzz.channel.proto.ClientHeader.prototype.clientVersionCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the client_version field.
 */
buzz.channel.proto.ClientHeader.prototype.clearClientVersion = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the client_time_ms field.
 * @return {?number} The value.
 */
buzz.channel.proto.ClientHeader.prototype.getClientTimeMs = function() {
  return /** @type {?number} */ (this.get$Value(3));
};


/**
 * Gets the value of the client_time_ms field or the default value if not set.
 * @return {number} The value.
 */
buzz.channel.proto.ClientHeader.prototype.getClientTimeMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the client_time_ms field.
 * @param {number} value The value.
 */
buzz.channel.proto.ClientHeader.prototype.setClientTimeMs = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the client_time_ms field has a value.
 */
buzz.channel.proto.ClientHeader.prototype.hasClientTimeMs = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the client_time_ms field.
 */
buzz.channel.proto.ClientHeader.prototype.clientTimeMsCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the client_time_ms field.
 */
buzz.channel.proto.ClientHeader.prototype.clearClientTimeMs = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the max_known_server_time_ms field.
 * @return {?number} The value.
 */
buzz.channel.proto.ClientHeader.prototype.getMaxKnownServerTimeMs = function() {
  return /** @type {?number} */ (this.get$Value(4));
};


/**
 * Gets the value of the max_known_server_time_ms field or the default value if not set.
 * @return {number} The value.
 */
buzz.channel.proto.ClientHeader.prototype.getMaxKnownServerTimeMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the max_known_server_time_ms field.
 * @param {number} value The value.
 */
buzz.channel.proto.ClientHeader.prototype.setMaxKnownServerTimeMs = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the max_known_server_time_ms field has a value.
 */
buzz.channel.proto.ClientHeader.prototype.hasMaxKnownServerTimeMs = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the max_known_server_time_ms field.
 */
buzz.channel.proto.ClientHeader.prototype.maxKnownServerTimeMsCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the max_known_server_time_ms field.
 */
buzz.channel.proto.ClientHeader.prototype.clearMaxKnownServerTimeMs = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the message_id field.
 * @return {?string} The value.
 */
buzz.channel.proto.ClientHeader.prototype.getMessageId = function() {
  return /** @type {?string} */ (this.get$Value(5));
};


/**
 * Gets the value of the message_id field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.ClientHeader.prototype.getMessageIdOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the message_id field.
 * @param {string} value The value.
 */
buzz.channel.proto.ClientHeader.prototype.setMessageId = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the message_id field has a value.
 */
buzz.channel.proto.ClientHeader.prototype.hasMessageId = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the message_id field.
 */
buzz.channel.proto.ClientHeader.prototype.messageIdCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the message_id field.
 */
buzz.channel.proto.ClientHeader.prototype.clearMessageId = function() {
  this.clear$Field(5);
};



/**
 * Message InitEndpointMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.InitEndpointMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.InitEndpointMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.InitEndpointMessage} The cloned message.
 * @override
 */
buzz.channel.proto.InitEndpointMessage.prototype.clone;



/**
 * Message InitSessionMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.InitSessionMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.InitSessionMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.InitSessionMessage} The cloned message.
 * @override
 */
buzz.channel.proto.InitSessionMessage.prototype.clone;


/**
 * Gets the value of the session_id field.
 * @return {buzz.channel.proto.SessionId} The value.
 */
buzz.channel.proto.InitSessionMessage.prototype.getSessionId = function() {
  return /** @type {buzz.channel.proto.SessionId} */ (this.get$Value(1));
};


/**
 * Gets the value of the session_id field or the default value if not set.
 * @return {!buzz.channel.proto.SessionId} The value.
 */
buzz.channel.proto.InitSessionMessage.prototype.getSessionIdOrDefault = function() {
  return /** @type {!buzz.channel.proto.SessionId} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the session_id field.
 * @param {!buzz.channel.proto.SessionId} value The value.
 */
buzz.channel.proto.InitSessionMessage.prototype.setSessionId = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the session_id field has a value.
 */
buzz.channel.proto.InitSessionMessage.prototype.hasSessionId = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the session_id field.
 */
buzz.channel.proto.InitSessionMessage.prototype.sessionIdCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the session_id field.
 */
buzz.channel.proto.InitSessionMessage.prototype.clearSessionId = function() {
  this.clear$Field(1);
};



/**
 * Message DataMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.DataMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.DataMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.DataMessage} The cloned message.
 * @override
 */
buzz.channel.proto.DataMessage.prototype.clone;


/**
 * Gets the value of the session_id field.
 * @return {buzz.channel.proto.SessionId} The value.
 */
buzz.channel.proto.DataMessage.prototype.getSessionId = function() {
  return /** @type {buzz.channel.proto.SessionId} */ (this.get$Value(1));
};


/**
 * Gets the value of the session_id field or the default value if not set.
 * @return {!buzz.channel.proto.SessionId} The value.
 */
buzz.channel.proto.DataMessage.prototype.getSessionIdOrDefault = function() {
  return /** @type {!buzz.channel.proto.SessionId} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the session_id field.
 * @param {!buzz.channel.proto.SessionId} value The value.
 */
buzz.channel.proto.DataMessage.prototype.setSessionId = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the session_id field has a value.
 */
buzz.channel.proto.DataMessage.prototype.hasSessionId = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the session_id field.
 */
buzz.channel.proto.DataMessage.prototype.sessionIdCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the session_id field.
 */
buzz.channel.proto.DataMessage.prototype.clearSessionId = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the message field.
 * @return {?string} The value.
 */
buzz.channel.proto.DataMessage.prototype.getMessage = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the message field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.DataMessage.prototype.getMessageOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the message field.
 * @param {string} value The value.
 */
buzz.channel.proto.DataMessage.prototype.setMessage = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the message field has a value.
 */
buzz.channel.proto.DataMessage.prototype.hasMessage = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the message field.
 */
buzz.channel.proto.DataMessage.prototype.messageCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the message field.
 */
buzz.channel.proto.DataMessage.prototype.clearMessage = function() {
  this.clear$Field(2);
};



/**
 * Message SessionStatusMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.SessionStatusMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.SessionStatusMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.SessionStatusMessage} The cloned message.
 * @override
 */
buzz.channel.proto.SessionStatusMessage.prototype.clone;


/**
 * Gets the value of the session_id field.
 * @return {buzz.channel.proto.SessionId} The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.getSessionId = function() {
  return /** @type {buzz.channel.proto.SessionId} */ (this.get$Value(1));
};


/**
 * Gets the value of the session_id field or the default value if not set.
 * @return {!buzz.channel.proto.SessionId} The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.getSessionIdOrDefault = function() {
  return /** @type {!buzz.channel.proto.SessionId} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the session_id field.
 * @param {!buzz.channel.proto.SessionId} value The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.setSessionId = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the session_id field has a value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.hasSessionId = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the session_id field.
 */
buzz.channel.proto.SessionStatusMessage.prototype.sessionIdCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the session_id field.
 */
buzz.channel.proto.SessionStatusMessage.prototype.clearSessionId = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the address field.
 * @return {?string} The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.getAddress = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the address field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.getAddressOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the address field.
 * @param {string} value The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.setAddress = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the address field has a value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.hasAddress = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the address field.
 */
buzz.channel.proto.SessionStatusMessage.prototype.addressCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the address field.
 */
buzz.channel.proto.SessionStatusMessage.prototype.clearAddress = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the is_broadcast_to_user field.
 * @return {?boolean} The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.getIsBroadcastToUser = function() {
  return /** @type {?boolean} */ (this.get$Value(3));
};


/**
 * Gets the value of the is_broadcast_to_user field or the default value if not set.
 * @return {boolean} The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.getIsBroadcastToUserOrDefault = function() {
  return /** @type {boolean} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the is_broadcast_to_user field.
 * @param {boolean} value The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.setIsBroadcastToUser = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the is_broadcast_to_user field has a value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.hasIsBroadcastToUser = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the is_broadcast_to_user field.
 */
buzz.channel.proto.SessionStatusMessage.prototype.isBroadcastToUserCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the is_broadcast_to_user field.
 */
buzz.channel.proto.SessionStatusMessage.prototype.clearIsBroadcastToUser = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the status field.
 * @return {buzz.channel.proto.StatusP} The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.getStatus = function() {
  return /** @type {buzz.channel.proto.StatusP} */ (this.get$Value(4));
};


/**
 * Gets the value of the status field or the default value if not set.
 * @return {!buzz.channel.proto.StatusP} The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.getStatusOrDefault = function() {
  return /** @type {!buzz.channel.proto.StatusP} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the status field.
 * @param {!buzz.channel.proto.StatusP} value The value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.setStatus = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the status field has a value.
 */
buzz.channel.proto.SessionStatusMessage.prototype.hasStatus = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the status field.
 */
buzz.channel.proto.SessionStatusMessage.prototype.statusCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the status field.
 */
buzz.channel.proto.SessionStatusMessage.prototype.clearStatus = function() {
  this.clear$Field(4);
};



/**
 * Message ServerToClientMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.ServerToClientMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.ServerToClientMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.ServerToClientMessage} The cloned message.
 * @override
 */
buzz.channel.proto.ServerToClientMessage.prototype.clone;


/**
 * Gets the value of the header field.
 * @return {buzz.channel.proto.ServerHeader} The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.getHeader = function() {
  return /** @type {buzz.channel.proto.ServerHeader} */ (this.get$Value(1));
};


/**
 * Gets the value of the header field or the default value if not set.
 * @return {!buzz.channel.proto.ServerHeader} The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.getHeaderOrDefault = function() {
  return /** @type {!buzz.channel.proto.ServerHeader} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the header field.
 * @param {!buzz.channel.proto.ServerHeader} value The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.setHeader = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the header field has a value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.hasHeader = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the header field.
 */
buzz.channel.proto.ServerToClientMessage.prototype.headerCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the header field.
 */
buzz.channel.proto.ServerToClientMessage.prototype.clearHeader = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the server_data_message field.
 * @return {buzz.channel.proto.DataMessage} The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.getServerDataMessage = function() {
  return /** @type {buzz.channel.proto.DataMessage} */ (this.get$Value(2));
};


/**
 * Gets the value of the server_data_message field or the default value if not set.
 * @return {!buzz.channel.proto.DataMessage} The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.getServerDataMessageOrDefault = function() {
  return /** @type {!buzz.channel.proto.DataMessage} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the server_data_message field.
 * @param {!buzz.channel.proto.DataMessage} value The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.setServerDataMessage = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the server_data_message field has a value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.hasServerDataMessage = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the server_data_message field.
 */
buzz.channel.proto.ServerToClientMessage.prototype.serverDataMessageCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the server_data_message field.
 */
buzz.channel.proto.ServerToClientMessage.prototype.clearServerDataMessage = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the channel_status_message field.
 * @return {buzz.channel.proto.ChannelStatusMessage} The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.getChannelStatusMessage = function() {
  return /** @type {buzz.channel.proto.ChannelStatusMessage} */ (this.get$Value(3));
};


/**
 * Gets the value of the channel_status_message field or the default value if not set.
 * @return {!buzz.channel.proto.ChannelStatusMessage} The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.getChannelStatusMessageOrDefault = function() {
  return /** @type {!buzz.channel.proto.ChannelStatusMessage} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the channel_status_message field.
 * @param {!buzz.channel.proto.ChannelStatusMessage} value The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.setChannelStatusMessage = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the channel_status_message field has a value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.hasChannelStatusMessage = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the channel_status_message field.
 */
buzz.channel.proto.ServerToClientMessage.prototype.channelStatusMessageCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the channel_status_message field.
 */
buzz.channel.proto.ServerToClientMessage.prototype.clearChannelStatusMessage = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the session_status_message field.
 * @return {buzz.channel.proto.SessionStatusMessage} The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.getSessionStatusMessage = function() {
  return /** @type {buzz.channel.proto.SessionStatusMessage} */ (this.get$Value(4));
};


/**
 * Gets the value of the session_status_message field or the default value if not set.
 * @return {!buzz.channel.proto.SessionStatusMessage} The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.getSessionStatusMessageOrDefault = function() {
  return /** @type {!buzz.channel.proto.SessionStatusMessage} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the session_status_message field.
 * @param {!buzz.channel.proto.SessionStatusMessage} value The value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.setSessionStatusMessage = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the session_status_message field has a value.
 */
buzz.channel.proto.ServerToClientMessage.prototype.hasSessionStatusMessage = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the session_status_message field.
 */
buzz.channel.proto.ServerToClientMessage.prototype.sessionStatusMessageCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the session_status_message field.
 */
buzz.channel.proto.ServerToClientMessage.prototype.clearSessionStatusMessage = function() {
  this.clear$Field(4);
};



/**
 * Message ServerHeader.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.ServerHeader = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.ServerHeader, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.ServerHeader} The cloned message.
 * @override
 */
buzz.channel.proto.ServerHeader.prototype.clone;


/**
 * Gets the value of the protocol_version field.
 * @return {buzz.channel.proto.ProtocolVersion} The value.
 */
buzz.channel.proto.ServerHeader.prototype.getProtocolVersion = function() {
  return /** @type {buzz.channel.proto.ProtocolVersion} */ (this.get$Value(1));
};


/**
 * Gets the value of the protocol_version field or the default value if not set.
 * @return {!buzz.channel.proto.ProtocolVersion} The value.
 */
buzz.channel.proto.ServerHeader.prototype.getProtocolVersionOrDefault = function() {
  return /** @type {!buzz.channel.proto.ProtocolVersion} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the protocol_version field.
 * @param {!buzz.channel.proto.ProtocolVersion} value The value.
 */
buzz.channel.proto.ServerHeader.prototype.setProtocolVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the protocol_version field has a value.
 */
buzz.channel.proto.ServerHeader.prototype.hasProtocolVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the protocol_version field.
 */
buzz.channel.proto.ServerHeader.prototype.protocolVersionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the protocol_version field.
 */
buzz.channel.proto.ServerHeader.prototype.clearProtocolVersion = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the server_time_ms field.
 * @return {?number} The value.
 */
buzz.channel.proto.ServerHeader.prototype.getServerTimeMs = function() {
  return /** @type {?number} */ (this.get$Value(4));
};


/**
 * Gets the value of the server_time_ms field or the default value if not set.
 * @return {number} The value.
 */
buzz.channel.proto.ServerHeader.prototype.getServerTimeMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the server_time_ms field.
 * @param {number} value The value.
 */
buzz.channel.proto.ServerHeader.prototype.setServerTimeMs = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the server_time_ms field has a value.
 */
buzz.channel.proto.ServerHeader.prototype.hasServerTimeMs = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the server_time_ms field.
 */
buzz.channel.proto.ServerHeader.prototype.serverTimeMsCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the server_time_ms field.
 */
buzz.channel.proto.ServerHeader.prototype.clearServerTimeMs = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the message_id field.
 * @return {?string} The value.
 */
buzz.channel.proto.ServerHeader.prototype.getMessageId = function() {
  return /** @type {?string} */ (this.get$Value(5));
};


/**
 * Gets the value of the message_id field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.ServerHeader.prototype.getMessageIdOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the message_id field.
 * @param {string} value The value.
 */
buzz.channel.proto.ServerHeader.prototype.setMessageId = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the message_id field has a value.
 */
buzz.channel.proto.ServerHeader.prototype.hasMessageId = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the message_id field.
 */
buzz.channel.proto.ServerHeader.prototype.messageIdCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the message_id field.
 */
buzz.channel.proto.ServerHeader.prototype.clearMessageId = function() {
  this.clear$Field(5);
};



/**
 * Message StatusP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.StatusP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.StatusP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.StatusP} The cloned message.
 * @override
 */
buzz.channel.proto.StatusP.prototype.clone;


/**
 * Gets the value of the code field.
 * @return {?number} The value.
 */
buzz.channel.proto.StatusP.prototype.getCode = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the code field or the default value if not set.
 * @return {number} The value.
 */
buzz.channel.proto.StatusP.prototype.getCodeOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the code field.
 * @param {number} value The value.
 */
buzz.channel.proto.StatusP.prototype.setCode = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the code field has a value.
 */
buzz.channel.proto.StatusP.prototype.hasCode = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the code field.
 */
buzz.channel.proto.StatusP.prototype.codeCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the code field.
 */
buzz.channel.proto.StatusP.prototype.clearCode = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the description field.
 * @return {?string} The value.
 */
buzz.channel.proto.StatusP.prototype.getDescription = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the description field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.StatusP.prototype.getDescriptionOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the description field.
 * @param {string} value The value.
 */
buzz.channel.proto.StatusP.prototype.setDescription = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the description field has a value.
 */
buzz.channel.proto.StatusP.prototype.hasDescription = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the description field.
 */
buzz.channel.proto.StatusP.prototype.descriptionCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the description field.
 */
buzz.channel.proto.StatusP.prototype.clearDescription = function() {
  this.clear$Field(2);
};


/**
 * Enumeration Code.
 * @enum {number}
 */
buzz.channel.proto.StatusP.Code = {
  SUCCESS: 1,
  TRANSIENT_FAILURE: 2,
  PERMANENT_FAILURE: 3
};



/**
 * Message ChannelStatusMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
buzz.channel.proto.ChannelStatusMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(buzz.channel.proto.ChannelStatusMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!buzz.channel.proto.ChannelStatusMessage} The cloned message.
 * @override
 */
buzz.channel.proto.ChannelStatusMessage.prototype.clone;


/**
 * Gets the value of the status field.
 * @return {buzz.channel.proto.StatusP} The value.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.getStatus = function() {
  return /** @type {buzz.channel.proto.StatusP} */ (this.get$Value(1));
};


/**
 * Gets the value of the status field or the default value if not set.
 * @return {!buzz.channel.proto.StatusP} The value.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.getStatusOrDefault = function() {
  return /** @type {!buzz.channel.proto.StatusP} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the status field.
 * @param {!buzz.channel.proto.StatusP} value The value.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.setStatus = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the status field has a value.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.hasStatus = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the status field.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.statusCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the status field.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.clearStatus = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the jid_resource field.
 * @return {?string} The value.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.getJidResource = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the jid_resource field or the default value if not set.
 * @return {string} The value.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.getJidResourceOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the jid_resource field.
 * @param {string} value The value.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.setJidResource = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the jid_resource field has a value.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.hasJidResource = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the jid_resource field.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.jidResourceCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the jid_resource field.
 */
buzz.channel.proto.ChannelStatusMessage.prototype.clearJidResource = function() {
  this.clear$Field(2);
};


goog.proto2.Message.set$Metadata(buzz.channel.proto.LcsMessage, {
  0: {
    name: 'LcsMessage',
    fullName: 'buzz.channel.LcsMessage'
  },
  1: {
    name: 'session',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  2: {
    name: 'message_id',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  3: {
    name: 'data',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.Version, {
  0: {
    name: 'Version',
    fullName: 'buzz.channel.Version'
  },
  1: {
    name: 'major_version',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  },
  2: {
    name: 'minor_version',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.ProtocolVersion, {
  0: {
    name: 'ProtocolVersion',
    fullName: 'buzz.channel.ProtocolVersion'
  },
  1: {
    name: 'version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.Version
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.ClientVersion, {
  0: {
    name: 'ClientVersion',
    fullName: 'buzz.channel.ClientVersion'
  },
  1: {
    name: 'version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.Version
  },
  2: {
    name: 'platform',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  3: {
    name: 'language',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  4: {
    name: 'application_info',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.SessionId, {
  0: {
    name: 'SessionId',
    fullName: 'buzz.channel.SessionId'
  },
  1: {
    name: 'service_name',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  2: {
    name: 'session_name',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.ClientToServerMessage, {
  0: {
    name: 'ClientToServerMessage',
    fullName: 'buzz.channel.ClientToServerMessage'
  },
  1: {
    name: 'header',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.ClientHeader
  },
  2: {
    name: 'init_endpoint_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.InitEndpointMessage
  },
  3: {
    name: 'init_session_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.InitSessionMessage
  },
  4: {
    name: 'client_data_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.DataMessage
  },
  5: {
    name: 'send_on_disconnect_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.DataMessage
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.ClientHeader, {
  0: {
    name: 'ClientHeader',
    fullName: 'buzz.channel.ClientHeader'
  },
  1: {
    name: 'protocol_version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.ProtocolVersion
  },
  2: {
    name: 'client_version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.ClientVersion
  },
  3: {
    name: 'client_time_ms',
    fieldType: goog.proto2.Message.FieldType.INT64,
    type: Number
  },
  4: {
    name: 'max_known_server_time_ms',
    fieldType: goog.proto2.Message.FieldType.INT64,
    type: Number
  },
  5: {
    name: 'message_id',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.InitEndpointMessage, {
  0: {
    name: 'InitEndpointMessage',
    fullName: 'buzz.channel.InitEndpointMessage'
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.InitSessionMessage, {
  0: {
    name: 'InitSessionMessage',
    fullName: 'buzz.channel.InitSessionMessage'
  },
  1: {
    name: 'session_id',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.SessionId
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.DataMessage, {
  0: {
    name: 'DataMessage',
    fullName: 'buzz.channel.DataMessage'
  },
  1: {
    name: 'session_id',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.SessionId
  },
  2: {
    name: 'message',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.SessionStatusMessage, {
  0: {
    name: 'SessionStatusMessage',
    fullName: 'buzz.channel.SessionStatusMessage'
  },
  1: {
    name: 'session_id',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.SessionId
  },
  2: {
    name: 'address',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  3: {
    name: 'is_broadcast_to_user',
    fieldType: goog.proto2.Message.FieldType.BOOL,
    type: Boolean
  },
  4: {
    name: 'status',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.StatusP
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.ServerToClientMessage, {
  0: {
    name: 'ServerToClientMessage',
    fullName: 'buzz.channel.ServerToClientMessage'
  },
  1: {
    name: 'header',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.ServerHeader
  },
  2: {
    name: 'server_data_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.DataMessage
  },
  3: {
    name: 'channel_status_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.ChannelStatusMessage
  },
  4: {
    name: 'session_status_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.SessionStatusMessage
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.ServerHeader, {
  0: {
    name: 'ServerHeader',
    fullName: 'buzz.channel.ServerHeader'
  },
  1: {
    name: 'protocol_version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.ProtocolVersion
  },
  4: {
    name: 'server_time_ms',
    fieldType: goog.proto2.Message.FieldType.INT64,
    type: Number
  },
  5: {
    name: 'message_id',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.StatusP, {
  0: {
    name: 'StatusP',
    fullName: 'buzz.channel.StatusP'
  },
  1: {
    name: 'code',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  },
  2: {
    name: 'description',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});


goog.proto2.Message.set$Metadata(buzz.channel.proto.ChannelStatusMessage, {
  0: {
    name: 'ChannelStatusMessage',
    fullName: 'buzz.channel.ChannelStatusMessage'
  },
  1: {
    name: 'status',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: buzz.channel.proto.StatusP
  },
  2: {
    name: 'jid_resource',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});

//ipc/invalidation/javascript/utils/logger.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A logger that supports formatting (i.e., string interpolation).
 *
 * @author adya@google.com (Atul Adya)
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('invalidation.util.Logger');

goog.require('goog.debug.Logger');

/**
 * Interface for logging.
 *
 * @interface
 */
invalidation.util.Logger = function() {};

/**
 * Logs a message.
 *
 * @param {!goog.debug.Logger.Level} level The level for logging the message.
 * @param {string} template the string to log, optionally containing %
 *     sequences allowed in {@code goog.string.format}.
 * @param {...string|number|boolean} var_args variables to substitute for
 *      % sequences in {@code template}.
 */
invalidation.util.Logger.prototype.log = goog.abstractMethod;

/**
 * Logs a message at the severe level.
 *
 * @param {string} template See specs for the {@code log} method.
 * @param {...} var_args See specs for the {@code log}
 *      method.
 */
invalidation.util.Logger.prototype.severe = goog.abstractMethod;

/**
 * Logs a message at the warning level.
 *
 * @param {string} template See specs for the {@code log} method.
 * @param {...} var_args See specs for the {@code log} method.
 */
invalidation.util.Logger.prototype.warning = goog.abstractMethod;

/**
 * Logs a message at the info level.
 *
 * @param {string} template See specs for the {@code log} method.
 * @param {...} var_args See specs for the {@code log} method.
 */
invalidation.util.Logger.prototype.info = goog.abstractMethod;

/**
 * Logs a message at the fine level.
 *
 * @param {string} template See specs for the {@code log} method.
 * @param {...} var_args See specs for the {@code log} method.
 */
invalidation.util.Logger.prototype.fine = goog.abstractMethod;

/**
 * @param {!goog.debug.Logger.Level} level The level at which to log the
 *     message.
 * @return {boolean} Whether the statements at this level are being logged.
 */
invalidation.util.Logger.prototype.isLoggable = goog.abstractMethod;

/**
 * Sets the level for the logger.
 *
 * @param {goog.debug.Logger.Level} level The level to be set.
 */
invalidation.util.Logger.prototype.setLevel = goog.abstractMethod;

//javascript/closure/string/stringformat.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Implementation of sprintf-like, python-%-operator-like,
 * .NET-String.Format-like functionality. Uses JS string's replace method to
 * extract format specifiers and sends those specifiers to a handler function,
 * which then, based on conversion type part of the specifier, calls the
 * appropriate function to handle the specific conversion.
 * For specific functionality implemented, look at formatRe below, or look
 * at the tests.
 * @author rosic@google.com (Srdjan Rosic)
 */

goog.provide('goog.string.format');

goog.require('goog.string');


/**
 * Performs sprintf-like conversion, ie. puts the values in a template.
 * DO NOT use it instead of built-in conversions in simple cases such as
 * 'Cost: %.2f' as it would introduce unneccessary latency oposed to
 * 'Cost: ' + cost.toFixed(2).
 * @param {string} formatString Template string containing % specifiers.
 * @param {...string|number} var_args Values formatString is to be filled with.
 * @return {string} Formatted string.
 */
goog.string.format = function(formatString, var_args) {

  // Convert the arguments to an array (MDC recommended way).
  var args = Array.prototype.slice.call(arguments);

  // Try to get the template.
  var template = args.shift();
  if (typeof template == 'undefined') {
    throw Error('[goog.string.format] Template required');
  }

  // This re is used for matching, it also defines what is supported.
  var formatRe = /%([0\-\ \+]*)(\d+)?(\.(\d+))?([%sfdiu])/g;

  /**
   * Chooses which conversion function to call based on type conversion
   * specifier.
   * @param {string} match Contains the re matched string.
   * @param {string} flags Formatting flags.
   * @param {string} width Replacement string minimum width.
   * @param {string} dotp Matched precision including a dot.
   * @param {string} precision Specifies floating point precision.
   * @param {string} type Type conversion specifier.
   * @param {string} offset Matching location in the original string.
   * @param {string} wholeString Has the actualString being searched.
   * @return {string} Formatted parameter.
   */
  function replacerDemuxer(match,
                           flags,
                           width,
                           dotp,
                           precision,
                           type,
                           offset,
                           wholeString) {

    // The % is too simple and doesn't take an argument.
    if (type == '%') {
      return '%';
    }

    // Try to get the actual value from parent function.
    var value = args.shift();

    // If we didn't get any arguments, fail.
    if (typeof value == 'undefined') {
      throw Error('[goog.string.format] Not enough arguments');
    }

    // Patch the value argument to the beginning of our type specific call.
    arguments[0] = value;

    return goog.string.format.demuxes_[type].apply(null, arguments);

  }

  return template.replace(formatRe, replacerDemuxer);
};


/**
 * Contains various conversion functions (to be filled in later on).
 * @type {Object}
 * @private
 */
goog.string.format.demuxes_ = {};


/**
 * Processes %s conversion specifier.
 * @param {string} value Contains the formatRe matched string.
 * @param {string} flags Formatting flags.
 * @param {string} width Replacement string minimum width.
 * @param {string} dotp Matched precision including a dot.
 * @param {string} precision Specifies floating point precision.
 * @param {string} type Type conversion specifier.
 * @param {string} offset Matching location in the original string.
 * @param {string} wholeString Has the actualString being searched.
 * @return {string} Replacement string.
 */
goog.string.format.demuxes_['s'] = function(value,
                                            flags,
                                            width,
                                            dotp,
                                            precision,
                                            type,
                                            offset,
                                            wholeString) {
  var replacement = value;
  // If no padding is necessary we're done.
  // The check for '' is necessary because Firefox incorrectly provides the
  // empty string instead of undefined for non-participating capture groups,
  // and isNaN('') == false.
  if (isNaN(width) || width == '' || replacement.length >= width) {
    return replacement;
  }

  // Otherwise we should find out where to put spaces.
  if (flags.indexOf('-', 0) > -1) {
    replacement =
        replacement + goog.string.repeat(' ', width - replacement.length);
  } else {
    replacement =
        goog.string.repeat(' ', width - replacement.length) + replacement;
  }
  return replacement;
};


/**
 * Processes %f conversion specifier.
 * @param {number} value Contains the formatRe matched string.
 * @param {string} flags Formatting flags.
 * @param {string} width Replacement string minimum width.
 * @param {string} dotp Matched precision including a dot.
 * @param {string} precision Specifies floating point precision.
 * @param {string} type Type conversion specifier.
 * @param {string} offset Matching location in the original string.
 * @param {string} wholeString Has the actualString being searched.
 * @return {string} Replacement string.
 */
goog.string.format.demuxes_['f'] = function(value,
                                            flags,
                                            width,
                                            dotp,
                                            precision,
                                            type,
                                            offset,
                                            wholeString) {

  var replacement = value.toString();

  // The check for '' is necessary because Firefox incorrectly provides the
  // empty string instead of undefined for non-participating capture groups,
  // and isNaN('') == false.
  if (!(isNaN(precision) || precision == '')) {
    replacement = value.toFixed(precision);
  }

  // Generates sign string that will be attached to the replacement.
  var sign;
  if (value < 0) {
    sign = '-';
  } else if (flags.indexOf('+') >= 0) {
    sign = '+';
  } else if (flags.indexOf(' ') >= 0) {
    sign = ' ';
  } else {
    sign = '';
  }

  if (value >= 0) {
    replacement = sign + replacement;
  }

  // If no padding is neccessary we're done.
  if (isNaN(width) || replacement.length >= width) {
    return replacement;
  }

  // We need a clean signless replacement to start with
  replacement = isNaN(precision) ?
      Math.abs(value).toString() :
      Math.abs(value).toFixed(precision);

  var padCount = width - replacement.length - sign.length;

  // Find out which side to pad, and if it's left side, then which character to
  // pad, and set the sign on the left and padding in the middle.
  if (flags.indexOf('-', 0) >= 0) {
    replacement = sign + replacement + goog.string.repeat(' ', padCount);
  } else {
    // Decides which character to pad.
    var paddingChar = (flags.indexOf('0', 0) >= 0) ? '0' : ' ';
    replacement =
        sign + goog.string.repeat(paddingChar, padCount) + replacement;
  }

  return replacement;
};


/**
 * Processes %d conversion specifier.
 * @param {string} value Contains the formatRe matched string.
 * @param {string} flags Formatting flags.
 * @param {string} width Replacement string minimum width.
 * @param {string} dotp Matched precision including a dot.
 * @param {string} precision Specifies floating point precision.
 * @param {string} type Type conversion specifier.
 * @param {string} offset Matching location in the original string.
 * @param {string} wholeString Has the actualString being searched.
 * @return {string} Replacement string.
 */
goog.string.format.demuxes_['d'] = function(value,
                                            flags,
                                            width,
                                            dotp,
                                            precision,
                                            type,
                                            offset,
                                            wholeString) {
  return goog.string.format.demuxes_['f'](
      parseInt(value, 10) /* value */,
      flags, width, dotp, 0 /* precision */,
      type, offset, wholeString);
};


// These are additional aliases, for integer conversion.
goog.string.format.demuxes_['i'] = goog.string.format.demuxes_['d'];
goog.string.format.demuxes_['u'] = goog.string.format.demuxes_['d'];


//ipc/invalidation/javascript/utils/loggerimpl.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview An implementation of the logger interface.
 *
 * @author adya@google.com (Atul Adya)
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('invalidation.util.LoggerImpl');

goog.require('goog.debug.Logger');
goog.require('goog.string.format');
goog.require('invalidation.util.Logger');

/**
 * Logger based on {@code goog.debug.Logger}. Creates a logger that prefixes
 * every logging stmt with {@code logPrefix}.
 *
 * @param {string} logPrefix The prefix used for logging.
 * @implements {invalidation.util.Logger}
 * @constructor
 */
invalidation.util.LoggerImpl = function(logPrefix) {

  /**
   * The actual logger used for logging.
   * @type {!goog.debug.Logger}
   * @private
   */
  this.logger_ = goog.debug.Logger.getLogger(logPrefix);
};

/**
 * @override
 */
invalidation.util.LoggerImpl.prototype.log =
    function(level, template, var_args) {
  this.logInternal(arguments);
};

/**
 * @override
 */
invalidation.util.LoggerImpl.prototype.severe = function(template, var_args) {
  this.logInternalLevel(goog.debug.Logger.Level.SEVERE, arguments);
};

/**
 * @override
 */
invalidation.util.LoggerImpl.prototype.warning = function(template, var_args) {
  this.logInternalLevel(goog.debug.Logger.Level.WARNING, arguments);
};

/**
 * @override
 */
invalidation.util.LoggerImpl.prototype.info = function(template, var_args) {
  this.logInternalLevel(goog.debug.Logger.Level.INFO, arguments);
};

/**
 * @override
 */
invalidation.util.LoggerImpl.prototype.fine = function(template, var_args) {
  this.logInternalLevel(goog.debug.Logger.Level.FINE, arguments);
};

/**
 * @override
 */
invalidation.util.LoggerImpl.prototype.isLoggable = function(level) {
  return this.logger_.isLoggable(level);
};

/**
 * @override
 */
invalidation.util.LoggerImpl.prototype.setLevel = function(level) {
  this.logger_.setLevel(level);
};

/**
 * Logs the arguments by first formatting them with {@code goog.string.format}
 * if the logging level allows it. args[0] has the level as an object of type
 * {goog.debug.Logger.Level} and args[1] has the format template.
 *
 * @param {!Arguments} args The arguments that need to be logged.
 */
invalidation.util.LoggerImpl.prototype.logInternal = function(args) {
  if (this.logger_.isLoggable(args[0])) {
    // Convert the arguments to an array.
    var formatArguments = Array.prototype.slice.call(args);
    var level = formatArguments.shift();
    var message = goog.string.format.apply(null, formatArguments);
    this.logger_.log(level, message);
  }
};

/**
 * Logs the arguments by first formatting them with {@code goog.string.format}
 * if the logging level allows it. args[0] has the format template.
 *
 * @param {!goog.debug.Logger.Level} level The level at which
 *     logging needs to be done.
 * @param {!Arguments} args The arguments that need to be logged.
 */
invalidation.util.LoggerImpl.prototype.logInternalLevel =
    function(level, args) {
  if (this.logger_.isLoggable(level)) {
    var message = goog.string.format.apply(null, args);
    this.logger_.log(level, message);
  }
};

//javascript/closure/proto2/serializer.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Base class for all Protocol Buffer 2 serializers.
 * @author jschorr@google.com (Joseph Schorr)
 */

goog.provide('goog.proto2.Serializer');

goog.require('goog.asserts');
goog.require('goog.proto2.FieldDescriptor');
goog.require('goog.proto2.Message');



/**
 * Abstract base class for PB2 serializers. A serializer is a class which
 * implements the serialization and deserialization of a Protocol Buffer Message
 * to/from a specific format.
 *
 * @constructor
 */
goog.proto2.Serializer = function() {};


/**
 * @define {boolean} Whether to decode and convert symbolic enum values to
 * actual enum values or leave them as strings.
 */
goog.define('goog.proto2.Serializer.DECODE_SYMBOLIC_ENUMS', false);


/**
 * Serializes a message to the expected format.
 *
 * @param {goog.proto2.Message} message The message to be serialized.
 *
 * @return {*} The serialized form of the message.
 */
goog.proto2.Serializer.prototype.serialize = goog.abstractMethod;


/**
 * Returns the serialized form of the given value for the given field
 * if the field is a Message or Group and returns the value unchanged
 * otherwise.
 *
 * @param {goog.proto2.FieldDescriptor} field The field from which this
 *     value came.
 *
 * @param {*} value The value of the field.
 *
 * @return {*} The value.
 * @protected
 */
goog.proto2.Serializer.prototype.getSerializedValue = function(field, value) {
  if (field.isCompositeType()) {
    return this.serialize(/** @type {goog.proto2.Message} */ (value));
  } else {
    return value;
  }
};


/**
 * Deserializes a message from the expected format.
 *
 * @param {goog.proto2.Descriptor} descriptor The descriptor of the message
 *     to be created.
 * @param {*} data The data of the message.
 *
 * @return {goog.proto2.Message} The message created.
 */
goog.proto2.Serializer.prototype.deserialize = function(descriptor, data) {
  var message = descriptor.createMessageInstance();
  this.deserializeTo(message, data);
  goog.asserts.assert(message instanceof goog.proto2.Message);
  return message;
};


/**
 * Deserializes a message from the expected format and places the
 * data in the message.
 *
 * @param {goog.proto2.Message} message The message in which to
 *     place the information.
 * @param {*} data The data of the message.
 */
goog.proto2.Serializer.prototype.deserializeTo = goog.abstractMethod;


/**
 * Returns the deserialized form of the given value for the given field if the
 * field is a Message or Group and returns the value, converted or unchanged,
 * for primitive field types otherwise.
 *
 * @param {goog.proto2.FieldDescriptor} field The field from which this
 *     value came.
 *
 * @param {*} value The value of the field.
 *
 * @return {*} The value.
 * @protected
 */
goog.proto2.Serializer.prototype.getDeserializedValue = function(field, value) {
  // Composite types are deserialized recursively.
  if (field.isCompositeType()) {
    if (value instanceof goog.proto2.Message) {
      return value;
    }

    return this.deserialize(field.getFieldMessageType(), value);
  }

  // Decode enum values.
  if (field.getFieldType() == goog.proto2.FieldDescriptor.FieldType.ENUM) {
    // If it's a string, get enum value by name.
    // NB: In order this feature to work, property renaming should be turned off
    // for the respective enums.
    if (goog.proto2.Serializer.DECODE_SYMBOLIC_ENUMS && goog.isString(value)) {
      // enumType is a regular Javascript enum as defined in field's metadata.
      var enumType = field.getNativeType();
      if (enumType.hasOwnProperty(value)) {
        return enumType[value];
      }
    }
    // Return unknown values as is for backward compatibility.
    return value;
  }

  // Return the raw value if the field does not allow the JSON input to be
  // converted.
  if (!field.deserializationConversionPermitted()) {
    return value;
  }

  // Convert to native type of field.  Return the converted value or fall
  // through to return the raw value.  The JSON encoding of int64 value 123
  // might be either the number 123 or the string "123".  The field native type
  // could be either Number or String (depending on field options in the .proto
  // file).  All four combinations should work correctly.
  var nativeType = field.getNativeType();
  if (nativeType === String) {
    // JSON numbers can be converted to strings.
    if (goog.isNumber(value)) {
      return String(value);
    }
  } else if (nativeType === Number) {
    // JSON strings are sometimes used for large integer numeric values.
    if (goog.isString(value)) {
      // Validate the string.  If the string is not an integral number, we would
      // rather have an assertion or error in the caller than a mysterious NaN
      // value.
      if (/^-?[0-9]+$/.test(value)) {
        return Number(value);
      }
    }
  }

  return value;
};

//javascript/closure/proto2/objectserializer.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Protocol Buffer 2 Serializer which serializes messages
 *  into anonymous, simplified JSON objects.
 *
 * @author jschorr@google.com (Joseph Schorr)
 */

goog.provide('goog.proto2.ObjectSerializer');

goog.require('goog.asserts');
goog.require('goog.proto2.Serializer');
goog.require('goog.string');



/**
 * ObjectSerializer, a serializer which turns Messages into simplified
 * ECMAScript objects.
 *
 * @param {goog.proto2.ObjectSerializer.KeyOption=} opt_keyOption If specified,
 *     which key option to use when serializing/deserializing.
 * @constructor
 * @extends {goog.proto2.Serializer}
 */
goog.proto2.ObjectSerializer = function(opt_keyOption) {
  this.keyOption_ = opt_keyOption;
};
goog.inherits(goog.proto2.ObjectSerializer, goog.proto2.Serializer);


/**
 * An enumeration of the options for how to emit the keys in
 * the generated simplified object.
 *
 * @enum {number}
 */
goog.proto2.ObjectSerializer.KeyOption = {
  /**
   * Use the tag of the field as the key (default)
   */
  TAG: 0,

  /**
   * Use the name of the field as the key. Unknown fields
   * will still use their tags as keys.
   */
  NAME: 1
};


/**
 * Serializes a message to an object.
 *
 * @param {goog.proto2.Message} message The message to be serialized.
 * @return {!Object} The serialized form of the message.
 * @override
 */
goog.proto2.ObjectSerializer.prototype.serialize = function(message) {
  var descriptor = message.getDescriptor();
  var fields = descriptor.getFields();

  var objectValue = {};

  // Add the defined fields, recursively.
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];

    var key =
        this.keyOption_ == goog.proto2.ObjectSerializer.KeyOption.NAME ?
        field.getName() : field.getTag();


    if (message.has(field)) {
      if (field.isRepeated()) {
        var array = [];
        objectValue[key] = array;

        for (var j = 0; j < message.countOf(field); j++) {
          array.push(this.getSerializedValue(field, message.get(field, j)));
        }

      } else {
        objectValue[key] = this.getSerializedValue(field, message.get(field));
      }
    }
  }

  // Add the unknown fields, if any.
  message.forEachUnknown(function(tag, value) {
    objectValue[tag] = value;
  });

  return objectValue;
};


/**
 * Deserializes a message from an object and places the
 * data in the message.
 *
 * @param {goog.proto2.Message} message The message in which to
 *     place the information.
 * @param {*} data The data of the message.
 * @override
 */
goog.proto2.ObjectSerializer.prototype.deserializeTo = function(message, data) {
  var descriptor = message.getDescriptor();

  for (var key in data) {
    var field;
    var value = data[key];

    var isNumeric = goog.string.isNumeric(key);

    if (isNumeric) {
      field = descriptor.findFieldByTag(key);
    } else {
      // We must be in Key == NAME mode to lookup by name.
      goog.asserts.assert(
          this.keyOption_ == goog.proto2.ObjectSerializer.KeyOption.NAME);

      field = descriptor.findFieldByName(key);
    }

    if (field) {
      if (field.isRepeated()) {
        goog.asserts.assert(goog.isArray(value));

        for (var j = 0; j < value.length; j++) {
          message.add(field, this.getDeserializedValue(field, value[j]));
        }
      } else {
        goog.asserts.assert(!goog.isArray(value));
        message.set(field, this.getDeserializedValue(field, value));
      }
    } else {
      if (isNumeric) {
        // We have an unknown field.
        message.setUnknown(Number(key), value);
      } else {
        // Named fields must be present.
        goog.asserts.assert(field);
      }
    }
  }
};

//javascript/closure/proto2/textformatserializer.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Protocol Buffer 2 Serializer which serializes messages
 *  into a user-friendly text format. Note that this code can run a bit
 *  slowly (especially for parsing) and should therefore not be used for
 *  time or space-critical applications.
 *
 * @see http://goo.gl/QDmDr
 * @author jschorr@google.com (Joseph Schorr)
 */

goog.provide('goog.proto2.TextFormatSerializer');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.json');
goog.require('goog.math');
goog.require('goog.object');
goog.require('goog.proto2.FieldDescriptor');
goog.require('goog.proto2.Message');
goog.require('goog.proto2.Serializer');
goog.require('goog.string');



/**
 * TextFormatSerializer, a serializer which turns Messages into the human
 * readable text format.
 * @param {boolean=} opt_ignoreMissingFields If true, then fields that cannot be
 *     found on the proto when parsing the text format will be ignored.
 * @param {boolean=} opt_useEnumValues If true, serialization code for enums
 *     will use enum integer values instead of human-readable symbolic names.
 * @constructor
 * @extends {goog.proto2.Serializer}
 * @final
 */
goog.proto2.TextFormatSerializer = function(
    opt_ignoreMissingFields, opt_useEnumValues) {
  /**
   * Whether to ignore fields not defined on the proto when parsing the text
   * format.
   * @type {boolean}
   * @private
   */
  this.ignoreMissingFields_ = !!opt_ignoreMissingFields;

  /**
   * Whether to use integer enum values during enum serialization.
   * If false, symbolic names will be used.
   * @type {boolean}
   * @private
   */
  this.useEnumValues_ = !!opt_useEnumValues;
};
goog.inherits(goog.proto2.TextFormatSerializer, goog.proto2.Serializer);


/**
 * Deserializes a message from text format and places the data in the message.
 * @param {goog.proto2.Message} message The message in which to
 *     place the information.
 * @param {*} data The text format data.
 * @return {?string} The parse error or null on success.
 * @override
 */
goog.proto2.TextFormatSerializer.prototype.deserializeTo =
    function(message, data) {
  var descriptor = message.getDescriptor();
  var textData = data.toString();
  var parser = new goog.proto2.TextFormatSerializer.Parser();
  if (!parser.parse(message, textData, this.ignoreMissingFields_)) {
    return parser.getError();
  }

  return null;
};


/**
 * Serializes a message to a string.
 * @param {goog.proto2.Message} message The message to be serialized.
 * @return {string} The serialized form of the message.
 * @override
 */
goog.proto2.TextFormatSerializer.prototype.serialize = function(message) {
  var printer = new goog.proto2.TextFormatSerializer.Printer_();
  this.serializeMessage_(message, printer);
  return printer.toString();
};


/**
 * Serializes the message and prints the text form into the given printer.
 * @param {goog.proto2.Message} message The message to serialize.
 * @param {goog.proto2.TextFormatSerializer.Printer_} printer The printer to
 *    which the text format will be printed.
 * @private
 */
goog.proto2.TextFormatSerializer.prototype.serializeMessage_ =
    function(message, printer) {
  var descriptor = message.getDescriptor();
  var fields = descriptor.getFields();

  // Add the defined fields, recursively.
  goog.array.forEach(fields, function(field) {
    this.printField_(message, field, printer);
  }, this);

  // Add the unknown fields, if any.
  message.forEachUnknown(function(tag, value) {
    this.serializeUnknown_(tag, value, printer);
  }, this);
};


/**
 * Serializes an unknown field. When parsed from the JsPb object format, this
 * manifests as either a primitive type, an array, or a raw object with integer
 * keys. There is no descriptor available to interpret the types of nested
 * messages.
 * @param {number} tag The tag for the field. Since it's unknown, this is a
 *     number rather than a string.
 * @param {*} value The value of the field.
 * @param {!goog.proto2.TextFormatSerializer.Printer_} printer The printer to
 *     which the text format will be serialized.
 * @private
 */
goog.proto2.TextFormatSerializer.prototype.serializeUnknown_ =
    function(tag, value, printer) {
  if (!goog.isDefAndNotNull(value)) {
    return;
  }

  if (goog.isArray(value)) {
    goog.array.forEach(value, function(val) {
      this.serializeUnknown_(tag, val, printer);
    }, this);
    return;
  }

  if (goog.isObject(value)) {
    printer.append(tag);
    printer.append(' {');
    printer.appendLine();
    printer.indent();
    if (value instanceof goog.proto2.Message) {
      // Note(ghc): This conditional is here to make the
      // testSerializationOfUnknown unit test pass, but in practice we should
      // never have a Message for an "unknown" field.
      this.serializeMessage_(value, printer);
    } else {
      // For an unknown message, fields are keyed by positive integers. We
      // don't have a 'length' property to use for enumeration, so go through
      // all properties and ignore the ones that aren't legal keys.
      for (var key in value) {
        var keyAsNumber = goog.string.parseInt(key);
        goog.asserts.assert(goog.math.isInt(keyAsNumber));
        this.serializeUnknown_(keyAsNumber, value[key], printer);
      }
    }
    printer.dedent();
    printer.append('}');
    printer.appendLine();
    return;
  }

  if (goog.isString(value)) {
    value = goog.string.quote(value);
  }
  printer.append(tag);
  printer.append(': ');
  printer.append(value.toString());
  printer.appendLine();
};


/**
 * Prints the serialized value for the given field to the printer.
 * @param {*} value The field's value.
 * @param {goog.proto2.FieldDescriptor} field The field whose value is being
 *    printed.
 * @param {goog.proto2.TextFormatSerializer.Printer_} printer The printer to
 *    which the value will be printed.
 * @private
 */
goog.proto2.TextFormatSerializer.prototype.printFieldValue_ =
    function(value, field, printer) {
  switch (field.getFieldType()) {
    case goog.proto2.FieldDescriptor.FieldType.DOUBLE:
    case goog.proto2.FieldDescriptor.FieldType.FLOAT:
    case goog.proto2.FieldDescriptor.FieldType.INT64:
    case goog.proto2.FieldDescriptor.FieldType.UINT64:
    case goog.proto2.FieldDescriptor.FieldType.INT32:
    case goog.proto2.FieldDescriptor.FieldType.UINT32:
    case goog.proto2.FieldDescriptor.FieldType.FIXED64:
    case goog.proto2.FieldDescriptor.FieldType.FIXED32:
    case goog.proto2.FieldDescriptor.FieldType.BOOL:
    case goog.proto2.FieldDescriptor.FieldType.SFIXED32:
    case goog.proto2.FieldDescriptor.FieldType.SFIXED64:
    case goog.proto2.FieldDescriptor.FieldType.SINT32:
    case goog.proto2.FieldDescriptor.FieldType.SINT64:
      printer.append(value);
      break;

    case goog.proto2.FieldDescriptor.FieldType.BYTES:
    case goog.proto2.FieldDescriptor.FieldType.STRING:
      value = goog.string.quote(value.toString());
      printer.append(value);
      break;

    case goog.proto2.FieldDescriptor.FieldType.ENUM:
      if (!this.useEnumValues_) {
        // Search the enum type for a matching key.
        var found = false;
        goog.object.forEach(field.getNativeType(), function(eValue, key) {
          if (eValue == value) {
            printer.append(key);
            found = true;
          }
        });
      }

      if (!found || this.useEnumValues_) {
        // Otherwise, just print the numeric value.
        printer.append(value.toString());
      }
      break;

    case goog.proto2.FieldDescriptor.FieldType.GROUP:
    case goog.proto2.FieldDescriptor.FieldType.MESSAGE:
      this.serializeMessage_(
          /** @type {goog.proto2.Message} */ (value), printer);
      break;
  }
};


/**
 * Prints the serialized field to the printer.
 * @param {goog.proto2.Message} message The parent message.
 * @param {goog.proto2.FieldDescriptor} field The field to print.
 * @param {goog.proto2.TextFormatSerializer.Printer_} printer The printer to
 *    which the field will be printed.
 * @private
 */
goog.proto2.TextFormatSerializer.prototype.printField_ =
    function(message, field, printer) {
  // Skip fields not present.
  if (!message.has(field)) {
    return;
  }

  var count = message.countOf(field);
  for (var i = 0; i < count; ++i) {
    // Field name.
    printer.append(field.getName());

    // Field delimiter.
    if (field.getFieldType() == goog.proto2.FieldDescriptor.FieldType.MESSAGE ||
        field.getFieldType() == goog.proto2.FieldDescriptor.FieldType.GROUP) {
      printer.append(' {');
      printer.appendLine();
      printer.indent();
    } else {
      printer.append(': ');
    }

    // Write the field value.
    this.printFieldValue_(message.get(field, i), field, printer);

    // Close the field.
    if (field.getFieldType() == goog.proto2.FieldDescriptor.FieldType.MESSAGE ||
        field.getFieldType() == goog.proto2.FieldDescriptor.FieldType.GROUP) {
      printer.dedent();
      printer.append('}');
      printer.appendLine();
    } else {
      printer.appendLine();
    }
  }
};


////////////////////////////////////////////////////////////////////////////////



/**
 * Helper class used by the text format serializer for pretty-printing text.
 * @constructor
 * @private
 */
goog.proto2.TextFormatSerializer.Printer_ = function() {
  /**
   * The current indentation count.
   * @type {number}
   * @private
   */
  this.indentation_ = 0;

  /**
   * The buffer of string pieces.
   * @type {Array.<string>}
   * @private
   */
  this.buffer_ = [];

  /**
   * Whether indentation is required before the next append of characters.
   * @type {boolean}
   * @private
   */
  this.requiresIndentation_ = true;
};


/**
 * @return {string} The contents of the printer.
 * @override
 */
goog.proto2.TextFormatSerializer.Printer_.prototype.toString = function() {
  return this.buffer_.join('');
};


/**
 * Increases the indentation in the printer.
 */
goog.proto2.TextFormatSerializer.Printer_.prototype.indent = function() {
  this.indentation_ += 2;
};


/**
 * Decreases the indentation in the printer.
 */
goog.proto2.TextFormatSerializer.Printer_.prototype.dedent = function() {
  this.indentation_ -= 2;
  goog.asserts.assert(this.indentation_ >= 0);
};


/**
 * Appends the given value to the printer.
 * @param {*} value The value to append.
 */
goog.proto2.TextFormatSerializer.Printer_.prototype.append = function(value) {
  if (this.requiresIndentation_) {
    for (var i = 0; i < this.indentation_; ++i) {
      this.buffer_.push(' ');
    }
    this.requiresIndentation_ = false;
  }

  this.buffer_.push(value.toString());
};


/**
 * Appends a newline to the printer.
 */
goog.proto2.TextFormatSerializer.Printer_.prototype.appendLine = function() {
  this.buffer_.push('\n');
  this.requiresIndentation_ = true;
};


////////////////////////////////////////////////////////////////////////////////



/**
 * Helper class for tokenizing the text format.
 * @param {string} data The string data to tokenize.
 * @param {boolean=} opt_ignoreWhitespace If true, whitespace tokens will not
 *    be reported by the tokenizer.
 * @constructor
 * @private
 */
goog.proto2.TextFormatSerializer.Tokenizer_ =
    function(data, opt_ignoreWhitespace) {

  /**
   * Whether to skip whitespace tokens on output.
   * @type {boolean}
   * @private
   */
  this.ignoreWhitespace_ = !!opt_ignoreWhitespace;

  /**
   * The data being tokenized.
   * @type {string}
   * @private
   */
  this.data_ = data;

  /**
   * The current index in the data.
   * @type {number}
   * @private
   */
  this.index_ = 0;

  /**
   * The data string starting at the current index.
   * @type {string}
   * @private
   */
  this.currentData_ = data;

  /**
   * The current token type.
   * @type {goog.proto2.TextFormatSerializer.Tokenizer_.Token}
   * @private
   */
  this.current_ = {
    type: goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes.END,
    value: null
  };
};


/**
 * @typedef {{type: goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes,
 *            value: ?string}}
 */
goog.proto2.TextFormatSerializer.Tokenizer_.Token;


/**
 * @return {goog.proto2.TextFormatSerializer.Tokenizer_.Token} The current
 *     token.
 */
goog.proto2.TextFormatSerializer.Tokenizer_.prototype.getCurrent = function() {
  return this.current_;
};


/**
 * An enumeration of all the token types.
 * @enum {*}
 */
goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes = {
  END: /---end---/,
  // Leading "-" to identify "-infinity"."
  IDENTIFIER: /^-?[a-zA-Z][a-zA-Z0-9_]*/,
  NUMBER: /^(0x[0-9a-f]+)|(([-])?[0-9][0-9]*(\.?[0-9]+)?([f])?)/,
  COMMENT: /^#.*/,
  OPEN_BRACE: /^{/,
  CLOSE_BRACE: /^}/,
  OPEN_TAG: /^</,
  CLOSE_TAG: /^>/,
  OPEN_LIST: /^\[/,
  CLOSE_LIST: /^\]/,
  STRING: new RegExp('^"([^"\\\\]|\\\\.)*"'),
  COLON: /^:/,
  COMMA: /^,/,
  SEMI: /^;/,
  WHITESPACE: /^\s/
};


/**
 * Advances to the next token.
 * @return {boolean} True if a valid token was found, false if the end was
 *    reached or no valid token was found.
 */
goog.proto2.TextFormatSerializer.Tokenizer_.prototype.next = function() {
  var types = goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes;

  // Skip any whitespace if requested.
  while (this.nextInternal_()) {
    if (this.getCurrent().type != types.WHITESPACE || !this.ignoreWhitespace_) {
      return true;
    }
  }

  // If we reach this point, set the current token to END.
  this.current_ = {
    type: goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes.END,
    value: null
  };

  return false;
};


/**
 * Internal method for determining the next token.
 * @return {boolean} True if a next token was found, false otherwise.
 * @private
 */
goog.proto2.TextFormatSerializer.Tokenizer_.prototype.nextInternal_ =
    function() {
  if (this.index_ >= this.data_.length) {
    return false;
  }

  var data = this.currentData_;
  var types = goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes;
  var next = null;

  // Loop through each token type and try to match the beginning of the string
  // with the token's regular expression.
  goog.object.forEach(types, function(type, id) {
    if (next || type == types.END) {
      return;
    }

    // Note: This regular expression check is at, minimum, O(n).
    var info = type.exec(data);
    if (info && info.index == 0) {
      next = {
        type: type,
        value: info[0]
      };
    }
  });

  // Advance the index by the length of the token.
  if (next) {
    this.current_ =
        /** @type {goog.proto2.TextFormatSerializer.Tokenizer_.Token} */ (next);
    this.index_ += next.value.length;
    this.currentData_ = this.currentData_.substring(next.value.length);
  }

  return !!next;
};


////////////////////////////////////////////////////////////////////////////////



/**
 * Helper class for parsing the text format.
 * @constructor
 * @final
 */
goog.proto2.TextFormatSerializer.Parser = function() {
  /**
   * The error during parsing, if any.
   * @type {?string}
   * @private
   */
  this.error_ = null;

  /**
   * The current tokenizer.
   * @type {goog.proto2.TextFormatSerializer.Tokenizer_}
   * @private
   */
  this.tokenizer_ = null;

  /**
   * Whether to ignore missing fields in the proto when parsing.
   * @type {boolean}
   * @private
   */
  this.ignoreMissingFields_ = false;
};


/**
 * Parses the given data, filling the message as it goes.
 * @param {goog.proto2.Message} message The message to fill.
 * @param {string} data The text format data.
 * @param {boolean=} opt_ignoreMissingFields If true, fields missing in the
 *     proto will be ignored.
 * @return {boolean} True on success, false on failure. On failure, the
 *     getError method can be called to get the reason for failure.
 */
goog.proto2.TextFormatSerializer.Parser.prototype.parse =
    function(message, data, opt_ignoreMissingFields) {
  this.error_ = null;
  this.ignoreMissingFields_ = !!opt_ignoreMissingFields;
  this.tokenizer_ = new goog.proto2.TextFormatSerializer.Tokenizer_(data, true);
  this.tokenizer_.next();
  return this.consumeMessage_(message, '');
};


/**
 * @return {?string} The parse error, if any.
 */
goog.proto2.TextFormatSerializer.Parser.prototype.getError = function() {
  return this.error_;
};


/**
 * Reports a parse error.
 * @param {string} msg The error message.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.reportError_ =
    function(msg) {
  this.error_ = msg;
};


/**
 * Attempts to consume the given message.
 * @param {goog.proto2.Message} message The message to consume and fill. If
 *    null, then the message contents will be consumed without ever being set
 *    to anything.
 * @param {string} delimiter The delimiter expected at the end of the message.
 * @return {boolean} True on success, false otherwise.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.consumeMessage_ =
    function(message, delimiter) {
  var types = goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes;
  while (!this.lookingAt_('>') && !this.lookingAt_('}') &&
         !this.lookingAtType_(types.END)) {
    if (!this.consumeField_(message)) { return false; }
  }

  if (delimiter) {
    if (!this.consume_(delimiter)) { return false; }
  } else {
    if (!this.lookingAtType_(types.END)) {
      this.reportError_('Expected END token');
    }
  }

  return true;
};


/**
 * Attempts to consume the value of the given field.
 * @param {goog.proto2.Message} message The parent message.
 * @param {goog.proto2.FieldDescriptor} field The field.
 * @return {boolean} True on success, false otherwise.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.consumeFieldValue_ =
    function(message, field) {
  var value = this.getFieldValue_(field);
  if (goog.isNull(value)) { return false; }

  if (field.isRepeated()) {
    message.add(field, value);
  } else {
    message.set(field, value);
  }

  return true;
};


/**
 * Attempts to convert a string to a number.
 * @param {string} num in hexadecimal or float format.
 * @return {?number} The converted number or null on error.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.getNumberFromString_ =
    function(num) {

  var returnValue = goog.string.contains(num, '.') ?
      parseFloat(num) : // num is a float.
      goog.string.parseInt(num); // num is an int.

  goog.asserts.assert(!isNaN(returnValue));
  goog.asserts.assert(isFinite(returnValue));

  return returnValue;
};


/**
 * Parse NaN, positive infinity, or negative infinity from a string.
 * @param {string} identifier An identifier string to check.
 * @return {?number} Infinity, negative infinity, NaN, or null if none
 *     of the constants could be parsed.
 * @private.
 */
goog.proto2.TextFormatSerializer.Parser.parseNumericalConstant_ =
    function(identifier) {
  if (/^-?inf(?:inity)?f?$/i.test(identifier)) {
    return Infinity * (goog.string.startsWith(identifier, '-') ? -1 : 1);
  }

  if (/^nanf?$/i.test(identifier)) {
    return NaN;
  }

  return null;
};


/**
 * Attempts to parse the given field's value from the stream.
 * @param {goog.proto2.FieldDescriptor} field The field.
 * @return {*} The field's value or null if none.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.getFieldValue_ =
    function(field) {
  var types = goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes;
  switch (field.getFieldType()) {
    case goog.proto2.FieldDescriptor.FieldType.DOUBLE:
    case goog.proto2.FieldDescriptor.FieldType.FLOAT:

      var identifier = this.consumeIdentifier_();
      if (identifier) {
        var numericalIdentifier =
            goog.proto2.TextFormatSerializer.Parser.parseNumericalConstant_(
                identifier);
        // Use isDefAndNotNull since !!NaN is false.
        if (goog.isDefAndNotNull(numericalIdentifier)) {
          return numericalIdentifier;
        }
      }

    case goog.proto2.FieldDescriptor.FieldType.INT32:
    case goog.proto2.FieldDescriptor.FieldType.UINT32:
    case goog.proto2.FieldDescriptor.FieldType.FIXED32:
    case goog.proto2.FieldDescriptor.FieldType.SFIXED32:
    case goog.proto2.FieldDescriptor.FieldType.SINT32:
      var num = this.consumeNumber_();
      if (!num) {
        return null;
      }

      return goog.proto2.TextFormatSerializer.Parser.getNumberFromString_(num);

    case goog.proto2.FieldDescriptor.FieldType.INT64:
    case goog.proto2.FieldDescriptor.FieldType.UINT64:
    case goog.proto2.FieldDescriptor.FieldType.FIXED64:
    case goog.proto2.FieldDescriptor.FieldType.SFIXED64:
    case goog.proto2.FieldDescriptor.FieldType.SINT64:
      var num = this.consumeNumber_();
      if (!num) {
        return null;
      }

      if (field.getNativeType() == Number) {
        // 64-bit number stored as a number.
        return goog.proto2.TextFormatSerializer.Parser.getNumberFromString_(
            num);
      }

      return num; // 64-bit numbers are by default stored as strings.

    case goog.proto2.FieldDescriptor.FieldType.BOOL:
      var ident = this.consumeIdentifier_();
      if (!ident) {
        return null;
      }

      switch (ident) {
        case 'true': return true;
        case 'false': return false;
        default:
          this.reportError_('Unknown type for bool: ' + ident);
          return null;
      }

    case goog.proto2.FieldDescriptor.FieldType.ENUM:
      if (this.lookingAtType_(types.NUMBER)) {
        var num = this.consumeNumber_();
        if (!num) {
          return null;
        }

        return goog.proto2.TextFormatSerializer.Parser.getNumberFromString_(
            num);
      } else {
        // Search the enum type for a matching key.
        var name = this.consumeIdentifier_();
        if (!name) {
          return null;
        }

        var enumValue = field.getNativeType()[name];
        if (enumValue == null) {
          this.reportError_('Unknown enum value: ' + name);
          return null;
        }

        return enumValue;
      }

    case goog.proto2.FieldDescriptor.FieldType.BYTES:
    case goog.proto2.FieldDescriptor.FieldType.STRING:
      return this.consumeString_();
  }
};


/**
 * Attempts to consume a nested message.
 * @param {goog.proto2.Message} message The parent message.
 * @param {goog.proto2.FieldDescriptor} field The field.
 * @return {boolean} True on success, false otherwise.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.consumeNestedMessage_ =
    function(message, field) {
  var delimiter = '';

  // Messages support both < > and { } as delimiters for legacy reasons.
  if (this.tryConsume_('<')) {
    delimiter = '>';
  } else {
    if (!this.consume_('{')) { return false; }
    delimiter = '}';
  }

  var msg = field.getFieldMessageType().createMessageInstance();
  var result = this.consumeMessage_(msg, delimiter);
  if (!result) { return false; }

  // Add the message to the parent message.
  if (field.isRepeated()) {
    message.add(field, msg);
  } else {
    message.set(field, msg);
  }

  return true;
};


/**
 * Attempts to consume the value of an unknown field. This method uses
 * heuristics to try to consume just the right tokens.
 * @return {boolean} True on success, false otherwise.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.consumeUnknownFieldValue_ =
    function() {
  // : is optional.
  this.tryConsume_(':');

  // Handle form: [.. , ... , ..]
  if (this.tryConsume_('[')) {
    while (true) {
      this.tokenizer_.next();
      if (this.tryConsume_(']')) {
        break;
      }
      if (!this.consume_(',')) { return false; }
    }

    return true;
  }

  // Handle nested messages/groups.
  if (this.tryConsume_('<')) {
    return this.consumeMessage_(null /* unknown */, '>');
  } else if (this.tryConsume_('{')) {
    return this.consumeMessage_(null /* unknown */, '}');
  } else {
    // Otherwise, consume a single token for the field value.
    this.tokenizer_.next();
  }

  return true;
};


/**
 * Attempts to consume a field under a message.
 * @param {goog.proto2.Message} message The parent message. If null, then the
 *     field value will be consumed without being assigned to anything.
 * @return {boolean} True on success, false otherwise.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.consumeField_ =
    function(message) {
  var fieldName = this.consumeIdentifier_();
  if (!fieldName) {
    this.reportError_('Missing field name');
    return false;
  }

  var field = null;
  if (message) {
    field = message.getDescriptor().findFieldByName(fieldName.toString());
  }

  if (field == null) {
    if (this.ignoreMissingFields_) {
      return this.consumeUnknownFieldValue_();
    } else {
      this.reportError_('Unknown field: ' + fieldName);
      return false;
    }
  }

  if (field.getFieldType() == goog.proto2.FieldDescriptor.FieldType.MESSAGE ||
      field.getFieldType() == goog.proto2.FieldDescriptor.FieldType.GROUP) {
    // : is optional here.
    this.tryConsume_(':');
    if (!this.consumeNestedMessage_(message, field)) { return false; }
  } else {
    // Long Format: "someField: 123"
    // Short Format: "someField: [123, 456, 789]"
    if (!this.consume_(':')) { return false; }

    if (field.isRepeated() && this.tryConsume_('[')) {
      // Short repeated format, e.g.  "foo: [1, 2, 3]"
      while (true) {
        if (!this.consumeFieldValue_(message, field)) { return false; }
        if (this.tryConsume_(']')) {
          break;
        }
        if (!this.consume_(',')) { return false; }
      }
    } else {
      // Normal field format.
      if (!this.consumeFieldValue_(message, field)) { return false; }
    }
  }

  // For historical reasons, fields may optionally be separated by commas or
  // semicolons.
  this.tryConsume_(',') || this.tryConsume_(';');
  return true;
};


/**
 * Attempts to consume a token with the given string value.
 * @param {string} value The string value for the token.
 * @return {boolean} True if the token matches and was consumed, false
 *    otherwise.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.tryConsume_ =
    function(value) {
  if (this.lookingAt_(value)) {
    this.tokenizer_.next();
    return true;
  }
  return false;
};


/**
 * Consumes a token of the given type.
 * @param {goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes} type The type
 *     of the token to consume.
 * @return {?string} The string value of the token or null on error.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.consumeToken_ =
    function(type) {
  if (!this.lookingAtType_(type)) {
    this.reportError_('Expected token type: ' + type);
    return null;
  }

  var value = this.tokenizer_.getCurrent().value;
  this.tokenizer_.next();
  return value;
};


/**
 * Consumes an IDENTIFIER token.
 * @return {?string} The string value or null on error.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.consumeIdentifier_ =
    function() {
  var types = goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes;
  return this.consumeToken_(types.IDENTIFIER);
};


/**
 * Consumes a NUMBER token.
 * @return {?string} The string value or null on error.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.consumeNumber_ =
    function() {
  var types = goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes;
  return this.consumeToken_(types.NUMBER);
};


/**
 * Consumes a STRING token.
 * @return {?string} The *deescaped* string value or null on error.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.consumeString_ =
    function() {
  var types = goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes;
  var value = this.consumeToken_(types.STRING);
  if (!value) {
    return null;
  }

  return goog.json.parse(value).toString();
};


/**
 * Consumes a token with the given value. If not found, reports an error.
 * @param {string} value The string value expected for the token.
 * @return {boolean} True on success, false otherwise.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.consume_ = function(value) {
  if (!this.tryConsume_(value)) {
    this.reportError_('Expected token "' + value + '"');
    return false;
  }

  return true;
};


/**
 * @param {string} value The value to check against.
 * @return {boolean} True if the current token has the given string value.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.lookingAt_ =
    function(value) {
  return this.tokenizer_.getCurrent().value == value;
};


/**
 * @param {goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes} type The
 *     token type.
 * @return {boolean} True if the current token has the given type.
 * @private
 */
goog.proto2.TextFormatSerializer.Parser.prototype.lookingAtType_ =
    function(type) {
  return this.tokenizer_.getCurrent().type == type;
};

//ipc/invalidation/javascript/utils/utils.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview A set of utility functions.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.Utils');

goog.require('goog.json');
goog.require('goog.proto2.Message');
goog.require('goog.proto2.ObjectSerializer');
goog.require('goog.proto2.TextFormatSerializer');
goog.require('invalidation.util.Logger');

/**
 * A serializer/deserializer for protocol buffers.
 * @type {!goog.proto2.ObjectSerializer}
 */
invalidation.Utils.ObjectSerializer = new goog.proto2.ObjectSerializer();

/**
 * A formatter for protocol buffer messages.
 * @type {!goog.proto2.TextFormatSerializer}
 */
invalidation.Utils.TextFormat = new goog.proto2.TextFormatSerializer();

/**
 * Serializes a message as a json-serialized string and returns it.
 *
 * @param {!goog.proto2.Message} message actual message.
 * @return {string} Json message as string.
 */
invalidation.Utils.serializeMessage = function(message) {
  var serialized = invalidation.Utils.ObjectSerializer.serialize(message);
  var json = goog.json.serialize(serialized);
  return json;
};

/**
 * Json parser; if the browser defines a native one, we use that, since it's
 * faster and safer.  Otherwise we default to Closure's eval-based parser.
 * @type {function(string): Object}
 */
invalidation.Utils.parseJson;

/** @preserveTry */
try {
  invalidation.Utils.parseJson = window['JSON']['parse'];
} catch (exception) {
  // Default to eval-based parser.
  invalidation.Utils.parseJson = goog.json.parse;
}

/**
 * Deserializes a message and returns it. If the message does not parse
 * correctly, returns {@code null}.
 *
 * @param {!goog.proto2.Descriptor} descriptor The descriptor of the message to
 *     be created.
 * @param {string} jsonMessage Incoming message in Json format.
 * @param {invalidation.util.Logger} logger For error messages.
 * @return {goog.proto2.Message} message Deserialized protobuf message, if the
 *     serialized {@code jsonMessage} was valid; otherwise {@code null}.
 */
invalidation.Utils.deserializeMessage = function(descriptor, jsonMessage,
    logger) {
  var parsedJson;
  try {
    parsedJson = invalidation.Utils.parseJson(jsonMessage);
  } catch (exception) {
    if (logger) {
      logger.info('Exception parsing json (%s): %s', jsonMessage, exception);
    }
    return null;
  }

  // The message is now in parsed Json format.
  var message =
      invalidation.Utils.ObjectSerializer.deserialize(descriptor, parsedJson);
  if (message == null) {
    if (logger) {
      logger.warning('Incoming msg is unparseable: %s', parsedJson);
    }
    return null;
  }
  return message;
};

/**
 * A generic method that converts a protobuf using TextFormatSerializer.
 * @return {string} Returns the text format of the protobuf.
 * @override
 */
goog.proto2.Message.prototype.toString = function() {
  return invalidation.Utils.TextFormat.serialize(this);
};

/**
 * Returns a key for the protobuf to be used in maps, priority queues, etc.
 *
 * @param {goog.proto2.Message} message The message for which the key is needed.
 * @return {string} The key for the protobuf.
 */
invalidation.Utils.getMessageKey = function(message) {
  // Simply convert the proto into its text format.
  goog.asserts.assert(message != null);
  return invalidation.Utils.TextFormat.serialize(message);
};

/**
 * Given a protobuf's text formatted string {@code messageString}, parses it
 * and modifies {@code message} to store the parsed protobuf.
 *
 * @param {string} messageString The text version of the protobuf.
 * @param {!goog.proto2.Message} message The message in which
 *     {@code messageString} is deserialized into.
 * @return {?goog.proto2.Message} The parsed protocol buffer.
 */
invalidation.Utils.parseProtoFromKey = function(messageString, message) {
  var res = invalidation.Utils.TextFormat.deserializeTo(message, messageString);
  return (res != null) ? null : message;
};

/**
 * @param {*} obj The object on which toString needs to be run.
 * @return {string} Runs {@code toString} on obj and returns the string.
 *     If {@code obj} is null, does not call empty string and returns
 *     an empty string or a string contain 'null'.
 */
invalidation.Utils.toText = function(obj) {
  return (obj != null) ? obj.toString() : 'null';
};

//buzz/channel/javascript/internal/browserchannelhandlerinterface.js
// Copyright 2012 Google Inc. All rights reserved.

/**
 * @fileoverview Interface for handling the browser channel connections. Defines
 * a number of callback functions to notify the browser channel user.
 *
 * @author xiaolan@google.com (Xiaolan Zhang)
 */

goog.provide('buzz.channel.BrowserChannelHandlerInterface');

goog.require('goog.net.BrowserChannel.Error');

/**
 * Interface for handling the browser channel connections.
 *
 * @interface
 */
buzz.channel.BrowserChannelHandlerInterface = function() {};


/**
 * Indicates the browser channel has successfully negotiated with the server
 * and can now send and receive data.
 */
buzz.channel.BrowserChannelHandlerInterface.prototype.channelOpened =
    goog.abstractMethod;

/**
 * New input is available for the application to process.
 *
 * @param {Array} dataArray The data array.
 */
buzz.channel.BrowserChannelHandlerInterface.prototype.channelHandleArray =
    goog.abstractMethod;

/**
 * Indicates the brower channel is closed.
 */
buzz.channel.BrowserChannelHandlerInterface.prototype.channelClosed =
    goog.abstractMethod;

/**
 * Callback for when an error occurs on the cross-page browser channel.
 * @param {goog.net.BrowserChannel.Error} error The low-level browser channel
 *     error.
 */
buzz.channel.BrowserChannelHandlerInterface.prototype.channelError =
    goog.abstractMethod;

//ipc/invalidation/javascript/utils/messagevalidator.js
// Copyright 2012 Google Inc. All rights reserved.

/**
 * @fileoverview  Base class for protocol message validators.
 *
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('invalidation.util.MessageValidator');

goog.require('goog.proto2.FieldDescriptor');
goog.require('goog.proto2.Message');
goog.require('invalidation.util.Logger');

/**
 * A {@code Constraint} is a function that takes a field descriptor and a
 * message and returns a boolean indicating whether the message's field
 * satisfies the constraint, e.g., "is present", "is non-empty".
 *
 * @typedef
 *     {function(!goog.proto2.FieldDescriptor, !goog.proto2.Message): boolean}
 */
invalidation.util.Constraint;

/**
 * A {@code MessageSpec} is an object whose keys are the field names of a
 * message and whose values are arrays of {@code Constraint}s on the
 * corresponding fields.  For each field, all constraints on that field must
 * return {@code true} in order for the message to be valid.
 *
 * @typedef {Object.<Array.<!invalidation.util.Constraint>>}
 */
invalidation.util.MessageSpec;

/**
 * @constructor
 *
 * @param {!invalidation.util.Logger} logger The logger
 *     used by the validator.
 */
invalidation.util.MessageValidator = function(logger) {
  /**
   * Logger.
   * @type {!invalidation.util.Logger}
   * @protected
   */
  this.logger = logger;
};

/**
 * Returns the message specifications used for validation.
 * @return {!Object.<!invalidation.util.MessageSpec>} The specifications for the
 *     messages that this object knows how to validate.
 */
invalidation.util.MessageValidator.prototype.getSpecifications =
    goog.abstractMethod;

/**
 * Validates a message or field value.
 *
 * @param {!goog.proto2.Message} message The message to be
 *     validated.
 * @return {boolean} Whether the message is valid.
 * @protected
 */
invalidation.util.MessageValidator.prototype.validate = function(message) {
  // The high-level approach is to check the contents of the message via
  // recursive descent.  We get the message name from its descriptor and look up
  // its specification in this.specifications_.  We assert that the
  // specification exists and that it mentions every field in the message type.
  // For each field, we check that every constraint on the field is satisfied,
  // then recursively validate all nested messages.

  // Look up the specification for the type of this message.
  var descriptor = message.getDescriptor();
  var specification = this.getSpecifications()[
      /** @type {string} **/ (descriptor.getName())];
  goog.asserts.assert(specification, 'no validator specification for %s',
      descriptor.getFullName());

  // Check that our specification is exhaustive (mentions every field in the
  // message).
  // TODO(ghc): [perf] Consider doing this check just once, at initialization.
  var allFields = descriptor.getFields();
  for (var i = 0; i < allFields.length; ++i) {
    goog.asserts.assert(allFields[i].getName() in specification,
        'field %s unspecified in %s', allFields[i].getName(),
        descriptor.getFullName());
  }

  // For each field mentioned in the specification, check that the field
  // satisfies all the constraints on it.
  for (var fieldName in specification) {
    var fieldConstraints = specification[fieldName];

    var fieldDescriptor = /** @type {!goog.proto2.FieldDescriptor} */
        (descriptor.findFieldByName(fieldName));

    // Check that the field descriptor is in fact non-null.
    goog.asserts.assert(fieldDescriptor instanceof goog.proto2.FieldDescriptor,
        'no field descriptor for %s in %s', fieldName,
        descriptor.getFullName());

    // For each constraint, check whether the constraint holds, and recursively
    // validate each sub-message.  Return false if anything fails.
    for (var i = 0; i < fieldConstraints.length; ++i) {
      if (!fieldConstraints[i](fieldDescriptor, message)) {
        return false;
      }
      // The loop below provides a single code path for processing of both
      // optional and repeated fields.  In particular, for optional fields,
      // countOf() returns 0 or 1 to indicate whether the field is present or
      // not, and message.get() ignores the index in that case.
      for (var j = 0; j < message.countOf(fieldDescriptor); ++j) {
        var fieldValue = message.get(fieldDescriptor, j);

        // Only recursively validate nested messages (not primitives).
        if ((fieldValue instanceof goog.proto2.Message) &&
            !this.validate(/** @type {!goog.proto2.Message} */ (fieldValue))) {
          this.logger.severe('field %s (index %d) failed validation in %s',
                             fieldName, j, message);
          return false;
        }
      }
    }
  }

  // If we get through all constraints without a failure, the message is valid.
  return true;
};

/**
 * Requires {@code field} to be present in {@code message} and valid.
 *
 * @param {!goog.proto2.FieldDescriptor} field Descriptor for required field.
 * @param {!goog.proto2.Message} message The message containing the field.
 * @return {boolean} Whether the field value is present and valid.
 */
invalidation.util.MessageValidator.prototype.required =
    function(field, message) {
  var isValid = message.has(field);
  if (!isValid) {
    this.logger.severe('required field %s missing from %s', field.getName(),
        message);
  }
  return isValid;
};

/**
 * Requires the value of {@code field} to be greater than {@code value}, if
 * present.
 *
 * @param {number} value The value which the field's value in the message should
 *     be greater or equal to.
 * @param {!goog.proto2.FieldDescriptor} field Descriptor for allowed field.
 * @param {!goog.proto2.Message} message The message containing the field.
 * @return {boolean} Whether the field value is greater than {@code value}, if
 *     present.
 */
invalidation.util.MessageValidator.prototype.greaterOrEqualTo = function(
    value, field, message) {
  var isValid = !message.has(field) || (
      /** @type {number} */ (message.get(field)) >= value);
  if (!isValid) {
    this.logger.severe('%s must be greater than or equal to %d; was %d',
        field.getName(), value, /** @type {number} */ (message.get(field)));
  }
  return isValid;
};

/**
 * Requires the (string) value of {@code field} to be non-empty, if present.
 *
 * @param {!goog.proto2.FieldDescriptor} field Descriptor for allowed field.
 * @param {!goog.proto2.Message} message The message containing the field.
 * @return {boolean} Whether the field value is non-empty, if present.
 */
invalidation.util.MessageValidator.prototype.nonEmpty = function(
    field, message) {
  var isValid = !message.has(field) || (message.get(field) != '');
  if (!isValid) {
    this.logger.severe('%s must be non-empty', field.getName());
  }
  return isValid;
};

//buzz/channel/javascript/internal/channelmessagevalidator.js
// Copyright 2012 Google Inc. All rights reserved.

/**
 * @fileoverview  Validator for Channel-LCS messages.
 *
 * @author xiaolan@google.com (Joy Zhang)
 */

goog.provide('buzz.channel.ChannelMessageValidator');

goog.require('invalidation.util.Logger');
goog.require('invalidation.util.MessageValidator');

/**
 * Message validator for the Ticl.
 * @constructor
 *
 * @param {!invalidation.util.Logger} logger The logger
 *     used by the validator.
 * @extends {invalidation.util.MessageValidator}
 */
buzz.channel.ChannelMessageValidator = function(logger) {
  invalidation.util.MessageValidator.call(this, logger);

  // Local bindings for constraints, to make specifications more readable.

  /**
   * Allows a field to be present.  This is a vacuous constraint which is
   * defined solely to make validation specs clearer to read.
   *
   * @param {!goog.proto2.FieldDescriptor} field The allowed field.
   * @param {!goog.proto2.Message} message A message.
   * @return {boolean} To indicate the field is allowed.
   */
  var allowed = function(field, message) {
    return true;
  };

  /**
   * Requires a field to be present.
   *
   * @type {!invalidation.util.Constraint}
   */
  var required = goog.bind(this.required, this);

  /**
   * Given a number {@code value}, returns a constraint that requires a field,
   * if present, to be greater than or equal to {@code value}.
   *
   * @type {function(number): !invalidation.util.Constraint}
   */
  var greaterOrEqualTo = goog.bind(function(value) {
      // Return a partially-instantiated call to this.greaterOrEqualTo.
      return goog.bind(this.greaterOrEqualTo, this, value);
    }, this);

  /**
   * Requires a field value, if present, to be non-negative.
   *
   * @type {!invalidation.util.Constraint}
   */
  var nonNegative = greaterOrEqualTo(0);

  /**
   * Requires a string field, if present, to be non-empty.
   *
   * @type {!invalidation.util.Constraint}
   */
  var nonEmpty = goog.bind(this.nonEmpty, this);

  /**
   * An object whose keys are message type names and whose values are
   * specifications of the constraints on the corresponding messages.  The
   * {@code validate} method looks up the spec for the message it's validating
   * and checks that all the constraints in the spec are satisfied.
   *
   * @type {!Object.<!invalidation.util.MessageSpec>}
   * @private
   */
  this.specifications_ = {
    'Version': {
      'major_version': [required, nonNegative],
      'minor_version': [required, nonNegative]
    },
    'ProtocolVersion': {
      'version': [required]
    },
    'ClientVersion': {
      'version': [required],
      'platform': [required],
      'language': [required, nonEmpty],
      'application_info': [required, nonEmpty]
    },
    'ClientToServerMessage': {
      'header': [required],
      'init_endpoint_message': [allowed],
      'init_session_message': [allowed],
      'client_data_message': [allowed],
      'send_on_disconnect_message': [allowed]
    },
    'ClientHeader': {
      'protocol_version': [required],
      'client_version': [required],
      'client_time_ms': [required],
      'max_known_server_time_ms': [required],
      'message_id': [allowed]
    },
    'SessionId': {
      'service_name': [required, nonEmpty],
      'session_name': [allowed]  // Client may omit to let server assign.
    },
    'InitEndpointMessage': {
    },
    'InitSessionMessage': {
      'session_id': [required]
    },
    'SessionStatusMessage': {
      'session_id': [required],
      'address': [allowed, nonEmpty],
      'is_broadcast_to_user': [allowed],
      'status': [allowed]
    },
    'DataMessage': {
      'session_id': [required],
      'message': [required, nonEmpty]
    },
    'ServerToClientMessage': {
      'header': [required],
      'server_data_message': [allowed],
      'channel_status_message': [allowed],
      'session_status_message': [allowed]
    },
    'ServerHeader': {
      'protocol_version': [required],
      'server_time_ms': [required, nonNegative],
      'message_id': [allowed, nonEmpty]
    },
    'StatusP': {
      'code': [required],
      'description': [allowed]
    },
    'ChannelStatusMessage': {
      'status': [required],
      'jid_resource': [allowed]
    }
  };
};
goog.inherits(
    buzz.channel.ChannelMessageValidator, invalidation.util.MessageValidator);

/** @override */
buzz.channel.ChannelMessageValidator.prototype.getSpecifications = function() {
  return this.specifications_;
};

/**
 * Returns true iff the client {@code message} is valid.
 *
 * @param {!buzz.channel.proto.ClientToServerMessage} message The message
 *     to be validated.
 * @return {boolean} Where the client message is valid or not.
 */
buzz.channel.ChannelMessageValidator.prototype.isClientMessageValid = function(
    message) {
  return this.validate(message);
};

/**
 * Returns true iff the server {@code message} is valid.
 *
 * @param {!buzz.channel.proto.ServerToClientMessage} message The message
 *     to be validated.
 * @return {boolean} Where the server message is valid or not.
 */
buzz.channel.ChannelMessageValidator.prototype.isServerMessageValid = function(
    message) {
  var result = this.validate(message);
  if (!result) {
    return false;
  }

  return true;
};

//javascript/closure/useragent/platform.js
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for getting details about the user's platform.
 * @author mpd@google.com (Michael Davidson)
 */

goog.provide('goog.userAgent.platform');

goog.require('goog.userAgent');


/**
 * Detects the version of Windows or Mac OS that is running.
 *
 * @private
 * @return {string} The platform version.
 */
goog.userAgent.platform.determineVersion_ = function() {
  var version = '', re;
  if (goog.userAgent.WINDOWS) {
    re = /Windows NT ([0-9.]+)/;
    var match = re.exec(goog.userAgent.getUserAgentString());
    if (match) {
      return match[1];
    } else {
      return '0';
    }
  } else if (goog.userAgent.MAC) {
    re = /10[_.][0-9_.]+/;
    var match = re.exec(goog.userAgent.getUserAgentString());
    // Note: some old versions of Camino do not report an OSX version.
    // Default to 10.
    return match ? match[0].replace(/_/g, '.') : '10';
  } else if (goog.userAgent.ANDROID) {
    re = /Android\s+([^\);]+)(\)|;)/;
    var match = re.exec(goog.userAgent.getUserAgentString());
    return match ? match[1] : '';
  } else if (goog.userAgent.IPHONE || goog.userAgent.IPAD) {
    re = /(?:iPhone|CPU)\s+OS\s+(\S+)/;
    var match = re.exec(goog.userAgent.getUserAgentString());
    // Report the version as x.y.z and not x_y_z
    return match ? match[1].replace(/_/g, '.') : '';
  }

  return '';
};


/**
 * The version of the platform. We only determine the version for Windows and
 * Mac, since it doesn't make much sense on Linux. For Windows, we only look at
 * the NT version. Non-NT-based versions (e.g. 95, 98, etc.) are given version
 * 0.0
 * @type {string}
 */
goog.userAgent.platform.VERSION = goog.userAgent.platform.determineVersion_();


/**
 * Whether the user agent platform version is higher or the same as the given
 * version.
 *
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent platform version is higher or the
 *     same as the given version.
 */
goog.userAgent.platform.isVersion = function(version) {
  return goog.string.compareVersions(
      goog.userAgent.platform.VERSION, version) >= 0;
};

//buzz/channel/javascript/internal/constants.js
// Copyright 2012 Google Inc. All rights reserved.

/**
 * @fileoverview Constants used in Marmoset client.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('buzz.channel.Constants');

goog.require('buzz.channel.proto.ProtocolVersion');
goog.require('buzz.channel.proto.Version');

/**
 * Returns a new protocol version with the default major and minor versions.
 *
 * @return {!buzz.channel.proto.ProtocolVersion} The returned protocol version.
 */
buzz.channel.Constants.getProtocolVersion = function() {
  var result = new buzz.channel.proto.ProtocolVersion();
  var version = new buzz.channel.proto.Version();
  version.setMajorVersion(buzz.channel.Constants.PROTOCOL_MAJOR_VERSION);
  version.setMinorVersion(buzz.channel.Constants.PROTOCOL_MINOR_VERSION);
  result.setVersion(version);
  return result;
};

/**
 * Returns a new client version with the default major and minor versions.
 *
 * @return {!buzz.channel.proto.Version} The returned client version.
 */
buzz.channel.Constants.getClientVersion = function() {
  var result = new buzz.channel.proto.Version();
  result.setMajorVersion(buzz.channel.Constants.CLIENT_MAJOR_VERSION);
  result.setMinorVersion(buzz.channel.Constants.CLIENT_MINOR_VERSION);
  return result;
};

/**
 * Returns a new config version with the default major and minor versions.
 *
 * @return {!buzz.channel.proto.Version} The returned config version.
 */
buzz.channel.Constants.getConfigVersion = function() {
  var result = new buzz.channel.proto.Version();
  result.setMajorVersion(buzz.channel.Constants.CONFIG_MAJOR_VERSION);
  result.setMinorVersion(buzz.channel.Constants.CONFIG_MINOR_VERSION);
  return result;
};

/**
 * Major version of the client library.
 * @type {number}
 * @const
 */
buzz.channel.Constants.CLIENT_MAJOR_VERSION = 3;

/**
 * Minor version of the client library.
 * @type {number}
 * @const
 */
buzz.channel.Constants.CLIENT_MINOR_VERSION = 2;

/**
 * Major version of the protocol between the client and the server.
 * @type {number}
 * @const
 */
buzz.channel.Constants.PROTOCOL_MAJOR_VERSION = 3;

/**
 * Minor version of the protocol between the client and the server.
 * @type {number}
 * @const
 */
buzz.channel.Constants.PROTOCOL_MINOR_VERSION = 2;

/**
 * Major version of the client config.
 * @type {number}
 * @const
 */
buzz.channel.Constants.CONFIG_MAJOR_VERSION = 3;

/**
 * Minor version of the client config.
 * @type {number}
 * @const
 */
buzz.channel.Constants.CONFIG_MINOR_VERSION = 2;

/**
 * Version of the protocol currently being used by the client/server for
 * V2 clients.
 * @type {!buzz.channel.proto.ProtocolVersion}
 * @const
 */
buzz.channel.Constants.PROTOCOL_VERSION =
    buzz.channel.Constants.getProtocolVersion();

/**
 * Version of the config currently being used by the client.
 *
 * @type {!buzz.channel.proto.Version}
 * @const
 */
buzz.channel.Constants.CONFIG_VERSION_VALUE =
    buzz.channel.Constants.getConfigVersion();

/**
 * Version of the client currently being used by the client.
 *
 * @type {!buzz.channel.proto.Version}
 * @const
 */
buzz.channel.Constants.CLIENT_VERSION_VALUE =
    buzz.channel.Constants.getClientVersion();

/**
 * The key in the Browser channel map that is used for all messages.
 * Must be kept in sync with j/c/g/buzz/channel/server/Constants.java.
 * @type {string}
 * @const
 */
buzz.channel.Constants.PROTO_KEY = 'p';

/**
 * The string lenth limit for user supplied client type.
 * @type {number}
 * @const
 */
buzz.channel.Constants.STRING_LIMIT = 16;

//buzz/channel/javascript/internal/commonprotos.js
// Copyright 2012 Google Inc. All rights reserved.

/**
 * @fileoverview  Utilities for creating protocol buffers.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('buzz.channel.CommonProtos');

goog.require('buzz.channel.Constants');
goog.require('buzz.channel.proto.BrowserChannelConfig');
goog.require('buzz.channel.proto.ClientHeader');
goog.require('buzz.channel.proto.ClientToServerMessage');
goog.require('buzz.channel.proto.ClientVersion');
goog.require('buzz.channel.proto.DataMessage');
goog.require('buzz.channel.proto.InitSessionMessage');
goog.require('buzz.channel.proto.SessionId');
goog.require('goog.userAgent.platform');


/**
 * Returns a new client header.
 *
 * @param {number} clientTimeMs Timestamp from the client's clock, expressed
 *     as ms since 00:00:00 UTC, 1 January 1970 (i.e., the UNIX epoch) -
 *     for debugging/monitoring purposes.
 * @param {number} maxKnownServerTimeMs Highest server timestamp observed by
 *     the client.
 * @param {string} messageId Message id to identify the message - for
 *     debugging/monitoring purposes.
 * @param {string} applicationInfo Information about the application.
 * @return {!buzz.channel.proto.ClientHeader} Client header for
 *     a message to be sent to the server.
 */
buzz.channel.CommonProtos.newClientHeader = function(clientTimeMs,
      maxKnownServerTimeMs, messageId, applicationInfo) {
  var clientHeader = new buzz.channel.proto.ClientHeader();
  clientHeader.setProtocolVersion(buzz.channel.Constants.PROTOCOL_VERSION);
  clientHeader.setClientTimeMs(clientTimeMs);
  clientHeader.setMaxKnownServerTimeMs(maxKnownServerTimeMs);
  clientHeader.setMessageId(messageId);
  clientHeader.setClientVersion(buzz.channel.CommonProtos.newClientVersion(
      goog.userAgent.platform.VERSION, 'JS', applicationInfo));
  return clientHeader;
};

/**
 * Returns a client version protobuf for a given client.
 *
 * @param {string} platform Information about the client operating system or
 *     platform.
 * @param {string} language The language in which the library is written, i.e.,
 *     JS (Javascript).
 * @param {string} applicationInfo Name of the application using the library
 *     (for debugging/monitoring).
 * @return {!buzz.channel.proto.ClientVersion} The client's info.
 */
buzz.channel.CommonProtos.newClientVersion = function(platform, language,
    applicationInfo) {
  var clientVersion = new buzz.channel.proto.ClientVersion();
  clientVersion.setVersion(buzz.channel.Constants.CLIENT_VERSION_VALUE);
  clientVersion.setPlatform(platform);
  clientVersion.setLanguage(language);
  clientVersion.setApplicationInfo(applicationInfo);
  return clientVersion;
};

/**
 * Returns a session id proto for the given service and session names.
 *
 * @param {string} serviceName The name of the service to which the session is
 *     connected.
 * @param {?string} sessionName The client-generated name of the session, or
 *     {@code null} to indicate that the client wants the server to supply the
 *     session name.
 * @return {!buzz.channel.proto.SessionId} A session id.
 */
buzz.channel.CommonProtos.newSessionId = function(serviceName, sessionName) {
  var sessionId = new buzz.channel.proto.SessionId();
  sessionId.setServiceName(serviceName);
  if (sessionName != null) {
    sessionId.setSessionName(sessionName);
  }
  return sessionId;
};

/**
 * Returns a new message requesting initialization of a session.
 *
 * @param {string} serviceName The name of the service with which the new
 *     session is to communicate.
 * @param {?string} sessionName The name of the session on the client.
 * @return {!buzz.channel.proto.InitSessionMessage} The message to create
 *     a session.
 */
buzz.channel.CommonProtos.newInitSessionMessage =
    function(serviceName, sessionName) {
  var initSessionMessage = new buzz.channel.proto.InitSessionMessage();
  initSessionMessage.setSessionId(
      buzz.channel.CommonProtos.newSessionId(serviceName, sessionName));
  return initSessionMessage;
};

/**
 * Returns a new data message.
 *
 * @param {string} serviceName The name of the service to which the message is
 *     to be sent.
 * @param {string} sessionName The name of the session on which the message is
 *     to be sent.
 * @param {string} message The message to be sent to the server.
 * @return {!buzz.channel.proto.DataMessage} The data message.
 */
buzz.channel.CommonProtos.newDataMessage =
    function(serviceName, sessionName, message) {
  var dataMessage = new buzz.channel.proto.DataMessage();
  dataMessage.setSessionId(
      buzz.channel.CommonProtos.newSessionId(serviceName, sessionName));
  dataMessage.setMessage(message);
  return dataMessage;
};

/**
 * Returns a new client-to-server message.
 *
 * @param {!buzz.channel.proto.ClientHeader} header The client header.
 * @param {!buzz.channel.proto.InitSessionMessage|
 *     !buzz.channel.proto.DataMessage|!buzz.channel.proto.InitEndpointMessage}
 *     content The message to be wrapped in the {@code ClientToServerMessage}
 *     envelope.
 * @return {!buzz.channel.proto.ClientToServerMessage} The client message.
 */
buzz.channel.CommonProtos.newClientToServerMessage = function(header, content) {
  var message = new buzz.channel.proto.ClientToServerMessage();
  message.setHeader(header);
  if (content instanceof buzz.channel.proto.InitEndpointMessage) {
    message.setInitEndpointMessage(
        /** @type {!buzz.channel.proto.InitEndpointMessage} */ (content));
  } else if (content instanceof buzz.channel.proto.InitSessionMessage) {
    message.setInitSessionMessage(
        /** @type {!buzz.channel.proto.InitSessionMessage} */ (content));
  } else if (content instanceof buzz.channel.proto.DataMessage) {
    message.setClientDataMessage(
        /** @type {!buzz.channel.proto.DataMessage} */ (content));
  }
  return message;
};

/**
 * Returns a browser channel config for the given client type.
 *
 * @param {string} clientType The client type.
 * @param {?string} gaiaServiceOverride A Gaia service name override, or
 *     {@code null} if the client can use the default service ("talk").
 * @return {!buzz.channel.proto.BrowserChannelConfig} A browser channel config.
 */
buzz.channel.CommonProtos.newBrowserChannelConfig =
    function(clientType, gaiaServiceOverride) {
  var browserChannelConfig = new buzz.channel.proto.BrowserChannelConfig();
  browserChannelConfig.setClientType(clientType);
  if (gaiaServiceOverride != null) {
    browserChannelConfig.setServiceOverride(gaiaServiceOverride);
  }
  return browserChannelConfig;
};

//buzz/channel/javascript/internal/sharedconstants.js
// Copyright 2012 Google Inc. All rights reserved.

/**
 * @fileoverview Constants used both by cross-page browser channel and LCS
 *     client.
 *
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('buzz.channel.SharedConstants');
goog.provide('buzz.channel.XpcFunctions');

goog.require('invalidation.FirstPartyAuth');

/**
 * Constants identifying functions in the browser channel API when split across
 * an iframe via xpc.
 * @enum {string}
 */
buzz.channel.XpcFunctions = {
  // Host => iframe.
  START: 's',
  CLOSE: 'c',
  SEND_MAP: 'sm',
  UPDATE_AUTH_PARAMS: 'uap',
  TRY_CONNECT_NOW: 'tcn',

  // Iframe => host.
  CHANNEL_OPENED: 'co',
  CHANNEL_HANDLE_ARRAY: 'cha',
  CHANNEL_ERROR: 'ce',
  CHANNEL_CLOSED: 'cc'
};

/**
 * The name of the query parameter that indicates which session to use in the
 * presence of multi-login.  See:
 * https://wiki.corp.google.com/twiki/bin/view/Main/GaiaFrontendMultipleLogin
 * @type {string}
 * @const
 */
buzz.channel.SharedConstants.AUTHUSER = 'authuser';

/**
 * The name of the http query parameter used to indicate the type of the client.
 * Must match the constant with the same name in
 * java/com/google/buzz/channel/common/Constants.java.
 * @type {string}
 * @const
 */
buzz.channel.SharedConstants.CLIENT_TYPE_PARAM = 'ctype';

/**
 * The name of the http query parameter used to indicate a Gaia service override
 * for this application.  Must match the constant with the same name in
 * java/com/google/buzz/channel/common/Constants.java.
 * @type {string}
 * @const
 */
buzz.channel.SharedConstants.GAIA_SERVICE_PARAM = 'service';

/**
 * The name of the http query parameter used to indicate the browser channel
 * configuration in the uri of the iframe.
 * @type {string}
 * @const
 */
buzz.channel.SharedConstants.BROWSER_CHANNEL_CONFIG_PARAM = 'cfg';

/**
 * The name of the query parameter that can be used to pass an OAuth token (for
 * iframe requests where we can't set the Authorization header).
 */
buzz.channel.SharedConstants.OAUTH_TOKEN_PARAM = 'oauth_token';

/**
 * The name of the scheme for OAuth authentication.  Used as a prefix in the
 * value of the Authorization http header.
 * @type {string}
 * @const
 */
buzz.channel.SharedConstants.OAUTH_SCHEME_NAME = 'OAuth';

/**
 * Name of the authorization header.
 * @type {string}
 * @const
 */
buzz.channel.SharedConstants.AUTHORIZATION_HEADER = 'Authorization';

/**
 * Name of the Google AuthUser header.
 * @type {string}
 * @const
 */
buzz.channel.SharedConstants.X_GOOG_AUTHUSER_HEADER = 'X-Goog-AuthUser';

/**
 * Name of the Origin header.
 * @type {string}
 * @const
 */
buzz.channel.SharedConstants.X_ORIGIN_HEADER = 'X-Origin';

/**
 * The authentication schemes we support, by name.
 * @type {Object.<string, buzz.channel.proto.AuthenticationParameters.Scheme>}
 */
buzz.channel.SharedConstants.AuthSchemes = {};

buzz.channel.SharedConstants.AuthSchemes[invalidation.FirstPartyAuth.Constants.
    UNSECURED_FIRST_PARTY_AUTH_SCHEME] = buzz.channel.proto.
    AuthenticationParameters.Scheme.APISIDHASH;

buzz.channel.SharedConstants.AuthSchemes[invalidation.FirstPartyAuth.Constants.
    SECURE_FIRST_PARTY_AUTH_SCHEME] = buzz.channel.proto.
    AuthenticationParameters.Scheme.SAPISIDHASH;

buzz.channel.SharedConstants.AuthSchemes[buzz.channel.SharedConstants.
    OAUTH_SCHEME_NAME] = buzz.channel.proto.AuthenticationParameters.Scheme.
    OAUTH;

/**
 * The names of the authentication schemes we support.
 * @type {Object.<string>}
 */
buzz.channel.SharedConstants.AuthSchemeNames = {};

buzz.channel.SharedConstants.AuthSchemeNames[buzz.channel.proto.
    AuthenticationParameters.Scheme.APISIDHASH] = invalidation.FirstPartyAuth.
    Constants.UNSECURED_FIRST_PARTY_AUTH_SCHEME;

buzz.channel.SharedConstants.AuthSchemeNames[buzz.channel.proto.
    AuthenticationParameters.Scheme.SAPISIDHASH] = invalidation.
    FirstPartyAuth.Constants.SECURE_FIRST_PARTY_AUTH_SCHEME;

buzz.channel.SharedConstants.AuthSchemeNames[buzz.channel.proto.
    AuthenticationParameters.Scheme.OAUTH] = buzz.channel.SharedConstants.
    OAUTH_SCHEME_NAME;

//buzz/channel/javascript/internal/hanginggetchannel.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Implementation of the Channel API using BrowserChannel.  The
 * BrowserChannel protocol is built around the notion of sending JSON maps over
 * Http.  Our implementation chooses a set of single-character map keys to
 * identify different types of protocol information, such as message data and
 * session ids.
 * <p>
 * This class supports having the BrowserChannel client library linked directly
 * with it, or loading it in an iframe and communicating with it over xpc.  In
 * either case, first-party authentication via (S)APISIDHASH is used.  This
 * allows LCS to distinguish between first-party clients (which have access to
 * the API session cookie) and third-party clients (which do not).  Third-party
 * clients will be required to present OAuth credentials, while first-party
 * authentication will be done by this class, so no additional code will be
 * required in first-party applications.
 * <p>
 * This implementation allows sessions with services that use
 * <i>broadcast-to-user</i> delivery semantics. This means that a push
 * notification sent to the user on the service's notification channel will be
 * delivered to all of the user's sessions with that service. This is
 * implemented by having LCS omit the "from" filter from the push subscription
 * in chat backend, and by having the client that receives the message match the
 * session using only the service name. For more detail on the client-side
 * implementation, see the documentation on {@code broadcastSessions_} in
 * {@code buzz.channel.HangingGetChannel}.
 *
 * @author ghc@google.com (Greg Cooper)
 * @author mharris@google.com (Matthew Harris)
 */

goog.provide('buzz.channel.HangingGetChannel');
goog.provide('buzz.channel.SessionImpl');

goog.require('buzz.channel.BrowserChannelHandlerInterface');
goog.require('buzz.channel.Channel');
goog.require('buzz.channel.ChannelConfigImpl');
goog.require('buzz.channel.ChannelError');
goog.require('buzz.channel.ChannelHandler');
goog.require('buzz.channel.ChannelMessageValidator');
goog.require('buzz.channel.CommonProtos');
goog.require('buzz.channel.Session');
goog.require('buzz.channel.SessionHandler');
goog.require('buzz.channel.SharedConstants');
goog.require('buzz.channel.proto.BrowserChannelConfig');
goog.require('buzz.channel.proto.ClientToServerMessage');
goog.require('buzz.channel.proto.ServerToClientMessage');
goog.require('goog.asserts');
goog.require('goog.debug.Logger');
goog.require('goog.structs.Map');
goog.require('goog.uri.utils');
goog.require('invalidation.Utils');
goog.require('invalidation.util.Logger');
goog.require('invalidation.util.LoggerImpl');

/**
 * A session with a given service over a channel.  Clients must not call this
 * constructor directly; instead they must call
 * {@code buzz.channel.Channel.prototype.newSession}.
 * @param {!buzz.channel.HangingGetChannel} channel The channel over which this
 *     session runs.
 * @param {string} serviceName The name of the service with which this session
 *     is associated (can only contain alphanumeric characters).
 * @param {boolean} assignSessionName Whether to assign a session name (as
 *     opposed to allowing the server to do it).
 * @param {!buzz.channel.SessionHandler} sessionHandler The application's
 *     handler for messages received by this session.
 * @see buzz.channel.Channel#newSession for format of {@code uri}.
 * @implements {buzz.channel.Session}
 * @constructor
 */
buzz.channel.SessionImpl = function(channel, serviceName, assignSessionName,
    sessionHandler) {

  /**
   * The channel over which this session runs.
   * @type {!buzz.channel.HangingGetChannel}
   * @private
   */
  this.channel_ = channel;

  /**
   * The service name with which this session is associated.
   * @type {string}
   * @private
   */
  this.serviceName_ = serviceName;

  /**
   * The handler for messages received by this session.
   * @type {!buzz.channel.SessionHandler}
   * @private
   */
  this.sessionHandler_ = sessionHandler;

  var sessionPrefix = Math.floor(Math.random() * 0x100000);

  /**
   * The name for this session.  Formed by appending a monotonically increasing
   * integer to a random integer.  The use of a monotonically increasing integer
   * guarantees uniqueness for this channel, which allows the channel to use the
   * name as the key in its session map.  The random integer makes it highly
   * probable that this name will be unique across other client applications
   * running on behalf of the same user; per-user uniqueness is not a
   * requirement, but it avoids having messages delivered spuriously, which is
   * confusing and hurts performance.
   * @type {?string}
   * @private
   */
  this.sessionName_ = (assignSessionName ?
      sessionPrefix + '_' + buzz.channel.SessionImpl.nextSessionNum_++ :
      null);

  /**
   * Whether this session is open.
   * @type {boolean}
   * @private
   */
  this.isOpen_ = false;
};

/**
 * The numeric suffix to use for the next session.
 * @type {number}
 * @private
 */
buzz.channel.SessionImpl.nextSessionNum_ = 0;


/** @override */
buzz.channel.SessionImpl.prototype.open = function() {
  goog.asserts.assert(!this.isOpen_);
  this.isOpen_ = true;

  // Send a subscription message.
  this.channel_.sendSubscription_(this);
};


/** @override */
buzz.channel.SessionImpl.prototype.send = function(data) {
  goog.asserts.assert(this.isOpen_);

  // Send a data message.
  this.channel_.sendDataMessage(this, data);
};


/**
 * Assigns a name to this session.
 * REQUIRES: a name has not already been assigned.
 * @param {string} name The name to assign to this session.
 */
buzz.channel.SessionImpl.prototype.assignName = function(name) {
  goog.asserts.assert(this.sessionName_ == null);
  this.sessionName_ = name;
};


/**
 * A bidirectional channel to the given {@code uri}, which may be shared among
 * multiple sessions.
 * @param {!buzz.channel.ChannelHandler} channelHandler Application handler for
 *     channel events.
 * @param {!buzz.channel.ChannelConfigImpl} channelConfig Channel config.
 * @implements {buzz.channel.BrowserChannelHandlerInterface}
 * @implements {buzz.channel.Channel}
 * @constructor
 */
buzz.channel.HangingGetChannel = function(channelHandler, channelConfig) {
  /**
   * The channel's configuration.
   * @type {!buzz.channel.ChannelConfigImpl}
   * @private
   */
  this.channelConfig_ = channelConfig;

  // Check that the client type string isn't too long.
  // TODO(ghc): [bug 8060467] Use an int/enum value instead of a string.
  goog.asserts.assert(this.channelConfig_.getClientType().length <=
                      buzz.channel.Constants.STRING_LIMIT);

  /**
   * Sessions whose names haven't been assigned yet.
   * @type {!Array.<buzz.channel.SessionImpl>}
   * @private
   */
  this.unnamedSessions_ = [];

  /**
   * Sessions with ids that have been assigned, keyed by session name.
   * @type {!goog.structs.Map.<string,!buzz.channel.SessionImpl>}
   * @private
   */
  this.sessions_ = new goog.structs.Map();

  /**
   * A service may be configured to broadcast messages to sessions on all
   * channels belonging to a given account. (See also
   * buzz/channel/proto/lcs_config.proto and
   * buzz/channel/proto/channel_internal.proto for more information about this
   * feature.)
   * <p>
   * When we create a new session, the server responds with a "session-ready"
   * message that indicates whether the service does broadcast-to-user. If so,
   * then instead of storing it in the main session map (keyed by its
   * pseudorandom name), we store it in this map (keyed by service). If we
   * receive a message with no matching session in the main map, we look in this
   * map for one with the same service.
   * <p>
   * The type of this map restricts a channel to <i>at most one</i> session with
   * a given broadcast-to-user service. Attempting to create multiple sessions
   * for the same broadcast service will result in undefined behavior.
   * <p>
   * The broadcast-to-user feature is not first-class and will only be enabled
   * for specific services who have permission of the LCS team. This is done
   * by setting the {@code is_broadcast_to_user} field in the
   * {@code ServiceConfig} message in buzz/channel/proto/lcs_config.proto.
   * @type {!goog.structs.Map.<string,!buzz.channel.SessionImpl>}
   * @private
   */
  this.broadcastSessions_ = new goog.structs.Map();

  /**
   * The browser channel.
   * @type {buzz.channel.BrowserChannelInterface}
   * @private
   */
  this.browserChannel_ = null;

  /**
   * @type {!invalidation.util.Logger}
   * @private
   */
  this.logger_ = new invalidation.util.LoggerImpl('HangingGetChannel');

  /**
   * A validator for checking incoming and outgoing channel messages.
   * @type {!buzz.channel.ChannelMessageValidator}
   * @private
   */
  this.msgValidator_ = new buzz.channel.ChannelMessageValidator(this.logger_);

  /**
   * @type {!buzz.channel.ChannelHandler}
   * @private
   */
  this.channelHandler_ = channelHandler;

  /**
   * Whether the channel is open.
   * @type {boolean}
   * @private
   */
  this.isOpen_ = false;

  /**
   * Authentication parameters for the channel.
   * @type {!buzz.channel.proto.AuthenticationParameters}
   * @private
   */
  this.authParams_ = new buzz.channel.proto.AuthenticationParameters();

  // Read the origin of this page (which is used by the first-party auth
  // implementation when computing API session cookies hashes).
  this.authParams_.setOrigin(goog.uri.utils.getHost(self.location.href));

  // Assume first-party auth for starters.  If the application uses OAuth, we'll
  // update the field when it sets the OAuth token.
  this.authParams_.setScheme(
      buzz.channel.proto.AuthenticationParameters.Scheme.SAPISIDHASH);

  // If an authuser was specified in the config, set it in the authentication
  // parameter object.
  var authuser = channelConfig.getAuthuser();
  if (authuser != null) {
    this.authParams_.setAuthuser(authuser);
  }

  /**
   * The last known time from the server.
   * @type {number}
   * @private
   */
  this.lastKnownServerTimeMs_ = 0;

  /**
   * Number used to compute a message id sent to the server.
   * @type {number}
   * @private
   */
  this.messageId_ = 0;

  /**
   * Whether the {@code dispose} function has been called.
   * @type {boolean}
   * @private
   */
  this.isDisposed_ = false;
};


/**
 * @inheritDoc
 */
buzz.channel.HangingGetChannel.prototype.setOAuthToken = function(oauthToken) {
  this.authParams_.setScheme(buzz.channel.proto.AuthenticationParameters.Scheme.
      OAUTH);
  this.authParams_.setToken(oauthToken);
  this.updateAuthParams_();
};


/** Opens a browser channel with or without iframe and starts it. */
buzz.channel.HangingGetChannel.prototype.open = function() {
  goog.asserts.assert(!this.isDisposed_);
  goog.asserts.assert(this.browserChannel_ == null);

  // The authuser parameter, if supplied, will also be sent through the auth
  // params.  Once we've pushed the iframe side of that code to production, we
  // can stop sending it in the browser channel config.
  var authuser;
  if (this.authParams_.hasAuthuser()) {
    authuser = this.authParams_.getAuthuser();
  }
  this.browserChannel_ = this.channelConfig_.createBrowserChannel(this);

  // Send our authentication parameters to the channel implementation before
  // starting the connection.
  this.updateAuthParams_();
  this.browserChannel_.start();
  this.logger_.info('Started a browser channel.');
};


/** Closes a browser channel permanently. Will not attempt to reopen. */
buzz.channel.HangingGetChannel.prototype.close = function() {
  goog.asserts.assert(!this.isDisposed_);
  if (this.browserChannel_ != null) {
    this.browserChannel_.close();
  }
};


/** @inheritDoc */
buzz.channel.HangingGetChannel.prototype.dispose = function() {
  this.close();
  this.isDisposed_ = true;
};


/** @inheritDoc */
buzz.channel.HangingGetChannel.prototype.isDisposed = function() {
  return this.isDisposed_;
};


/**
 * Computes first-party auth parameters if necessary and forwards the current
 * auth parameters to the browser channel implementation.
 * @private
 */
buzz.channel.HangingGetChannel.prototype.updateAuthParams_ = function() {
  // If the application is using OAuth, it provides all of the authentication
  // parameters, so we can skip the first-party authentication work.
  if (this.authParams_.getScheme() !=
      buzz.channel.proto.AuthenticationParameters.Scheme.OAUTH) {
    var authSchemeAndHash = this.channelConfig_.getFirstPartyAuthSchemeAndHash(
        /** @type {string} */ (this.authParams_.getOrigin()));
    if (authSchemeAndHash != null) {
      var authSchemeName = authSchemeAndHash.scheme;
      var apiSessionCookieHash = authSchemeAndHash.hash;
      if (apiSessionCookieHash != this.authParams_.getToken()) {
        var authScheme = goog.asserts.assert(
            buzz.channel.SharedConstants.AuthSchemes[authSchemeName],
            'unknown auth scheme: ' + authSchemeName);
        this.authParams_.setScheme(authScheme);
        this.authParams_.setToken(apiSessionCookieHash);
      }
    } else {
      // No auth scheme and hash exist, so empty out the auth params.
      this.authParams_.setToken('');
    }
  }
  if (this.browserChannel_) {
    this.browserChannel_.updateAuthParams(this.authParams_);
  }
};


/**
 * @inheritDoc
 */
buzz.channel.HangingGetChannel.prototype.channelOpened = function() {
  // Physical channel is open.  Send a message requesting initialization of the
  // endpoint.
  this.sendMessageToServer_(new buzz.channel.proto.InitEndpointMessage());
};


/**
 * Handles a status message from the server.
 * @param {buzz.channel.proto.ChannelStatusMessage} statusMessage A status
 *     message.
 * @private
 */
buzz.channel.HangingGetChannel.prototype.handleStatusMessage_ =
    function(statusMessage) {
  var statusCode = statusMessage.getStatus().getCode();
  if (statusCode == buzz.channel.proto.StatusP.Code.SUCCESS) {
    this.setOpenStatus(true);

    // Resend all subscriptions, in case we're talking to a new server.
    var sessions = this.sessions_.getValues();
    for (var i = 0; i < sessions.length; ++i) {
      this.sendSubscription_(sessions[i]);
    }

    // Broadcast sessions need to have their subscriptions resent as well.
    var broadcastSessions = this.broadcastSessions_.getValues();
    for (var i = 0; i < broadcastSessions.length; ++i) {
      this.sendSubscription_(broadcastSessions[i]);
    }

    // Let the channel handler know we're open.  Do this after resending any
    // subscriptions, since otherwise the handler might also open a session,
    // which will cause us to send the subscription twice.

    // Add any metadata included in the status message.
    var metadata = {};
    if (statusMessage.hasJidResource()) {
      metadata.jidResource = statusMessage.getJidResource();
    }
    this.channelHandler_.onOpen(this, metadata);
  } else {
    this.logger_.warning(
        'Received non-SUCCESS status %s from server', statusCode);
  }
};


/**
 * Handles a session status message from the server.
 * @param {!buzz.channel.proto.SessionStatusMessage} sessionStatusMessage A
 *     message indicating that a client session is ready.
 * @private
 */
buzz.channel.HangingGetChannel.prototype.handleSessionStatusMessage_ = function(
    sessionStatusMessage) {
  // Try to look up the session by its name. If the server is assigning session
  // names, then we may not be able to find the session by name, in which case
  // we'll look for an unnamed session with the matching service.
  var sessionId = sessionStatusMessage.getSessionId();
  var sessionName = sessionId.getSessionName();
  if (sessionName == null) {
    this.logger_.warning(
        'Ignoring session-ready message without a session name');
    return;
  }
  var session = this.getSession_(sessionId);

  if ((session == null) &&
      this.channelConfig_.getServerAssignsSessionName()) {
    // If we're letting the server assign session names, just look for an
    // unnamed session with the right service name. Since the session can't have
    // been used without an address, we can safely assign this name and address
    // to it, even if there's another unnamed session for the same service.
    for (var i = 0; i < this.unnamedSessions_.length; ++i) {
      var candidate = this.unnamedSessions_[i];
      var serviceName = sessionId.getServiceName();
      if (candidate.serviceName_ == serviceName) {
        session = candidate;
        session.assignName(sessionName);

        // Remove the session from the collection without names and add it
        // to the map of named sessions.
        this.unnamedSessions_.splice(i, 1);
        if (sessionStatusMessage.getIsBroadcastToUserOrDefault()) {
          // If this session is for a service that does broadcast-to-user, then
          // only allow one such session on the channel. (Broadcast is
          // restricted to specific customers anyway, who haven't shown a need
          // for multiple such sessions, so for now we avoid the increased code
          // complexity that would be required to support such a use case.)
          if (!this.broadcastSessions_.containsKey(serviceName)) {
            this.broadcastSessions_.set(serviceName, session);
          } else {
            this.logger_.warning(
                'Duplicate session for the same broadcast service (%s): ' +
                'this is not supported and will be ignored', serviceName);
          }
        } else {
          this.sessions_.set(session.sessionName_, session);
        }
        break;
      }
    }
  }
  if (session == null) {
    this.logger_.warning('Received address for unknown session: %s, %s',
        sessionId, sessionStatusMessage.toString());
    return;
  }

  // If the session status message has no status, assume we're talking to an old
  // server, which only responds when session initialization is successful.
  if (!sessionStatusMessage.hasStatus() ||
      (sessionStatusMessage.getStatus().getCode() ==
          buzz.channel.proto.StatusP.Code.SUCCESS)) {
    // Inform the handler that we have an address for the session.
    this.logger_.info('Address %s assigned for session %s with service %s',
        sessionStatusMessage.getAddress(),
        sessionId.getSessionName(),
        sessionId.getServiceName());

    session.sessionHandler_.onAddressAssigned(
        session, /** @type {string} */ (sessionStatusMessage.getAddress()));
  } else {
    // Status indicates failure: log that there was an error initializing the
    // session, and inform the handler if it implements the appropriate
    // callback.
    this.logger_.warning('Failed to initialize session with service %s: %s',
        sessionId.getServiceName(),
        sessionStatusMessage.getStatus().getDescription());

    if (session.sessionHandler_.onSessionError) {
      session.sessionHandler_.onSessionError(
          session, {
            isTransient: false,
            description: sessionStatusMessage.getStatus().getDescription()
          });
    } else {
      this.logger_.info('onSessionError() not implemented by handler');
    }
  }
};

/**
 * @inheritDoc
 */
buzz.channel.HangingGetChannel.prototype.channelHandleArray = function(
    dataArray) {
  // Each map in the array is a message for a session.  The map contains the
  // serialized proto message.
  for (var i = 0; i < dataArray.length; i++) {
    var map = dataArray[i];
    var serializedMessage = map[buzz.channel.Constants.PROTO_KEY];

    var s2cMessage = this.deserializeMessage(serializedMessage);
    if (s2cMessage == null) {
      this.logger_.severe(
          'Cannot deserialize s2c message: %s', serializedMessage);
      continue;
    }
    this.logger_.fine('Received server message: %s', s2cMessage);

    // Validate message.
    if (!this.msgValidator_.isServerMessageValid(s2cMessage)) {
      this.logger_.severe(
          'Received invalid server message: %s', s2cMessage);
      continue;
    }

    var header = s2cMessage.getHeader();
    this.lastKnownServerTimeMs_ = Math.max(
        this.lastKnownServerTimeMs_, header.getServerTimeMs());

    // If there's a channel status message, handle it.
    if (s2cMessage.hasChannelStatusMessage()) {
      this.handleStatusMessage_(s2cMessage.getChannelStatusMessage());
    }

    // A session-ready message contains the address for the session, which must
    // be given to the appropriate session handler.
    if (s2cMessage.hasSessionStatusMessage()) {
      var sessionStatusMessage = s2cMessage.getSessionStatusMessage();
      goog.asserts.assert(sessionStatusMessage != null);
      this.handleSessionStatusMessage_(sessionStatusMessage);
    }

    // If there's a data message, handle it.
    if (s2cMessage.hasServerDataMessage()) {
      // Look up the session by its id and deliver the content to its handler.
      var dataMessage = s2cMessage.getServerDataMessage();
      var sessionId = dataMessage.getSessionId();
      var session = this.getSession_(
          /** @type {!buzz.channel.proto.SessionId} */ (sessionId));
      if (session == null) {
        this.logger_.info('Received message for unknown session: %s, %s',
                          sessionId, s2cMessage);
        continue;
      }

      session.sessionHandler_.receive(
          session, /** @type {string} */ (dataMessage.getMessage()));
    }
  }
};


/**
 * @inheritDoc
 */
buzz.channel.HangingGetChannel.prototype.channelError = function(error) {
  this.logger_.info('Error %s', error);

  // It's hard to tell whether the error was auth-related, so always check the
  // auth params if we get an error and update if things have changed.
  this.updateAuthParams_();
  this.channelHandler_.onError(this, new buzz.channel.ChannelError(error));
};


/**
 * @inheritDoc
 */
buzz.channel.HangingGetChannel.prototype.channelClosed = function() {
  this.setOpenStatus(false);
  this.channelHandler_.onClose(this);
};


/**
 * Marks the channel as being open or closed.
 * @param {boolean} isOpen Whether the channel is open.
 */
buzz.channel.HangingGetChannel.prototype.setOpenStatus = function(isOpen) {
  this.isOpen_ = isOpen;
};


/** @inheritDoc */
buzz.channel.HangingGetChannel.prototype.newSession = function(
    serviceName, sessionHandler) {
  goog.asserts.assert(!this.isDisposed_);
  goog.asserts.assert(this.isOpen_);
  var serverAssignsSessionName =
      this.channelConfig_.getServerAssignsSessionName();
  var result = new buzz.channel.SessionImpl(this, serviceName,
      !serverAssignsSessionName, sessionHandler);
  if (serverAssignsSessionName) {
    this.unnamedSessions_.push(result);
  } else {
    this.sessions_.set(result.sessionName_, result);
  }
  return result;
};


/** @inheritDoc */
buzz.channel.HangingGetChannel.prototype.tryImmediateReconnectByUserRequest =
    function() {
  if (this.browserChannel_ != null) {
    this.logger_.info('Asking browser channel to reconnect now!');
    this.browserChannel_.tryImmediateReconnectByUserRequest();
  } else {
    // If the browser channel doesn't exist yet, ignore the call.
    this.logger_.info('Not asking browser channel to reconnect now because ' +
                      'it does not exist yet!');
  }
};


/**
 * Retrieves the session with the given id.
 * @param {!buzz.channel.proto.SessionId} sessionId The id of the session.
 * @return {buzz.channel.SessionImpl} The session with the given name, or
 *     {@code null} if no matching session can be found.
 * @private
 */
buzz.channel.HangingGetChannel.prototype.getSession_ = function(sessionId) {
  // First look for an ordinary (named, non-broadcast) session.
  var session = this.sessions_.get(sessionId.getSessionName(), null);
  if (session == null) {
    // If there's no session with the matching name, look for a broadcast
    // session with a matching service name.
    session = this.broadcastSessions_.get(sessionId.getServiceName(), null);
  }
  return /** @type {buzz.channel.SessionImpl} */ (session);
};


/**
 * Sends a message to subscribe for a given session.
 * @param {!buzz.channel.SessionImpl} session The session for which to
 *     subscribe.
 * @private
 */
buzz.channel.HangingGetChannel.prototype.sendSubscription_ = function(session) {
  var sessionMessage =
      buzz.channel.CommonProtos.newInitSessionMessage(
          session.serviceName_, session.sessionName_);
  this.sendMessageToServer_(sessionMessage);
};


/**
 * Sends a data message on a session.
 * @param {!buzz.channel.SessionImpl} session The session on which the message
 *     should be sent.
 * @param {string} message The message content.
 */
buzz.channel.HangingGetChannel.prototype.sendDataMessage = function(session,
    message) {
  // Check that this is a session we know about.
  goog.asserts.assert(session.sessionName_ != null);
  goog.asserts.assert(this.sessions_.containsKey(session.sessionName_));
  var dataMessage = buzz.channel.CommonProtos.newDataMessage(
      session.serviceName_, /** @type {string} */ (session.sessionName_),
      message);
  this.sendMessageToServer_(dataMessage);
};


/**
 * Sends a packet to the server.
 * @param {!buzz.channel.proto.InitSessionMessage|
 *     !buzz.channel.proto.DataMessage|!buzz.channel.proto.InitEndpointMessage}
 *     content The content of the message to send.
 * @private
 */
buzz.channel.HangingGetChannel.prototype.sendMessageToServer_ = function(
    content) {
  var messageId = 'c' + ++this.messageId_;
  var header = buzz.channel.CommonProtos.newClientHeader(
      goog.now(), this.lastKnownServerTimeMs_, messageId, 'lcsclient');
  var c2sMessage = buzz.channel.CommonProtos.newClientToServerMessage(
      header, content);

  // Validate message.
  if (!this.msgValidator_.isClientMessageValid(c2sMessage)) {
    this.logger_.severe(
        'Attempted to send invalid client message: %s', c2sMessage.toString());
    return;
  }

  // Forward message.
  var packet = {};
  var serializedMessage = invalidation.Utils.serializeMessage(c2sMessage);
  packet[buzz.channel.Constants.PROTO_KEY] = serializedMessage;
  this.browserChannel_.sendMap(packet);
};


/**
 * Deserializes a message received from the server and returns it. If the
 * message does not parse correctly, returns null.
 *
 * @param {string} jsonMessage Incoming message in Json format.
 * @return {buzz.channel.proto.ServerToClientMessage} message Deserialized
 *     server message, if the serialized {@code jsonMessage} was valid.
 */
buzz.channel.HangingGetChannel.prototype.deserializeMessage =
    function(jsonMessage) {
  var descriptor = buzz.channel.proto.ServerToClientMessage.getDescriptor();
  var message = invalidation.Utils.deserializeMessage(descriptor, jsonMessage,
      this.logger_);
  return /** @type {buzz.channel.proto.ServerToClientMessage} */ (message);
};

//ipc/invalidation/javascript/utils/exponentialbackoffdelaygenerator.js
// Copyright 2011 Google Inc. All rights reserved.v

/**
 * @fileoverview Class that generates successive intervals for random
 * exponential backoff. Class tracks a "high water mark" which is doubled each
 * time {@code getNextDelay} is called; each call to {@code getNextDelay}
 * returns a value uniformly randomly distributed between 0 (inclusive) and the
 * high water mark (exclusive). Note that this class does not dictate the time
 * units for which the delay is computed.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.ExponentialBackoffDelayGenerator');

goog.require('goog.asserts');

/**
 * Creates a generator with the given maximum and initial delays.
 *
 * @param {!function(): number} random Random number generator that returns a
 *     number between 0 and 1.
 * @param {number} initialMaxDelay Initial max delay for delay computation.
 * @param {number} maxExponentialFactor Maximum allowed delay time as a factor
 *     of {@code initialMaxDelay}.
 * @constructor
 */
invalidation.ExponentialBackoffDelayGenerator = function(random,
    initialMaxDelay, maxExponentialFactor) {
  goog.asserts.assert(maxExponentialFactor > 0);
  goog.asserts.assert(initialMaxDelay > 0);

  /**
   * Initial allowed delay time.
   * @type {number}
   * @private
   */
  this.initialMaxDelay_ = initialMaxDelay;

  /**
   * Maximum allowed delay time as a factor of {@code initialMaxDelay}.
   * @type {number}
   * @private
   */
  this.maxExponentialFactor_ = maxExponentialFactor;


  /**
   * Random number generator that returns a number between 0 and 1.
   * @type {!function(): number}
   * @private
   */
  this.random_ = random;

  /**
   * Next delay time to use.
   * @type {number}
   * @private
   */
  this.currentMaxDelay_;

  /**
   * If the first call to getNextDelay has been made after reset.
   * @type {boolean}
   * @private
   */
  this.inRetryMode_;

  goog.asserts.assert(this.initialMaxDelay_ > 0);

  this.reset();
};

/**
 * Resets the exponential backoff generator to start delays to the initial
 * delay.
 */
invalidation.ExponentialBackoffDelayGenerator.prototype.reset =
    function() {
  this.currentMaxDelay_ = this.initialMaxDelay_;
  this.inRetryMode_ = false;
};

/**
 * Gets the next delay interval to use.
 *
 * @return {number} The next delay interval.
 */
invalidation.ExponentialBackoffDelayGenerator.prototype.getNextDelay =
    function() {
  var delay = 0;  // After a reset, the delay is 0.
  if (this.inRetryMode_) {
    // Generate the delay.
    delay = Math.ceil(this.random_() * this.currentMaxDelay_);

    // Adjust the max for the next run.
    var maxDelay = this.initialMaxDelay_ * this.maxExponentialFactor_;
    if (this.currentMaxDelay_ <= maxDelay) {  // Guard against overflow.
      this.currentMaxDelay_ *= 2;
      if (this.currentMaxDelay_ > maxDelay) {
        this.currentMaxDelay_ = maxDelay;
      }
    }
  }
  this.inRetryMode_ = true;
  return delay;
};

//buzz/channel/javascript/internal/browserchannelinterface.js
// Copyright 2012 Google Inc. All rights reserved.

/**
 * @fileoverview Interface for the browser channel.
 *
 * @author xiaolan@google.com (Xiaolan Zhang)
 */

goog.provide('buzz.channel.BrowserChannelInterface');

goog.require('buzz.channel.proto.AuthenticationParameters');
goog.require('goog.structs');

/**
 * Interface through which browser channel calls are handled.
 *
 * @interface
 */
buzz.channel.BrowserChannelInterface = function() {};

/**
 * Sets authentication parameters to be sent on browser channel requests.
 * @param {!buzz.channel.proto.AuthenticationParameters} authParams The
 *     new authentication parameters.
 */
buzz.channel.BrowserChannelInterface.prototype.updateAuthParams =
    goog.abstractMethod;

/** Starts a browser channel. May only be called once. */
buzz.channel.BrowserChannelInterface.prototype.start = goog.abstractMethod;

/** Closes a browser channel permanently. May only be called once. */
buzz.channel.BrowserChannelInterface.prototype.close = goog.abstractMethod;

/**
 * Sends a packet to the browser channel.
 *
 * @param {!Object|!goog.structs.Map} mapToSend The packet to send to the
 *     browser channel server. It is an object or a map.
 */
buzz.channel.BrowserChannelInterface.prototype.sendMap = goog.abstractMethod;

/**
 * Applications must not call this function without permission of the Marmoset
 * team. This indicates that the user has performed an action requesting an
 * immediate attempt to reconnect the channel. The channel implementation may
 * use this information as a hint to make a reconnection attempt sooner than the
 * randomized exponential backoff algorithm would ordinarily allow. The
 * implementation is also free to ignore this call at its discretion.
 */
buzz.channel.BrowserChannelInterface.prototype.
    tryImmediateReconnectByUserRequest = goog.abstractMethod;

//buzz/channel/javascript/internal/browserchannelimpl.js
// Copyright 2012 Google Inc.  All Rights Reserved.

/**
 * @fileoverview Implementation of a Marmoset browser channel connection.
 *
 * @author ghc@google.com (Greg Cooper)
 * @author xiaolan@google.com (Joy Zhang)
 */

goog.provide('buzz.channel.BrowserChannelImpl');

goog.require('buzz.channel.BrowserChannelHandlerInterface');
goog.require('buzz.channel.BrowserChannelInterface');
goog.require('buzz.channel.proto.AuthenticationParameters');
goog.require('goog.asserts');
goog.require('goog.debug.Logger');
goog.require('goog.json');
goog.require('goog.net.BrowserChannel');
goog.require('goog.net.HttpStatus');
goog.require('invalidation.ExponentialBackoffDelayGenerator');
goog.require('invalidation.util.Logger');
goog.require('invalidation.util.LoggerImpl');

/**
 * A browser channel connection implementation in a browser client.
 *
 * @param {string} baseUri The browser channel base uri.
 * @param {buzz.channel.BrowserChannelHandlerInterface} handler The host handler
 *     of the browser channel.
 * @param {buzz.channel.proto.BrowserChannelConfig} config The browser channel
 *     configuration.
 * @constructor
 * @extends goog.net.BrowserChannel.Handler
 * @implements buzz.channel.BrowserChannelInterface
 */
buzz.channel.BrowserChannelImpl = function(baseUri, handler, config) {
  goog.base(this);

  /**
   * @type {string}
   * @private
   */
  this.protocolVersion_ = '1';

  /**
   * The base uri for the browser channel's requests.
   * @type {string}
   * @private
   */
  this.baseUri_ = baseUri;

  /**
   * The authuser parameter (a 0-based cookie index) for the browser channel, or
   * {@code null}.  See:
   * https://wiki.corp.google.com/twiki/bin/view/Main/GaiaFrontendMultipleLogin
   *
   * @type {?number}
   * @private
   */
  // TODO(ghc): [bug 8072118] Remove this field once customers have pushed this
  // code.
  this.authuser_;
  if (config.hasAuthuser()) {
    this.authuser_ = config.getAuthuser();
  }

  goog.asserts.assert(config.getClientType() != null);

  /**
   * Configuration for the browser channel.
   * @type {!buzz.channel.proto.BrowserChannelConfig}
   * @private
   */
  this.config_ = config;

  /**
   * The actual browser channel connection.
   * @type {goog.net.BrowserChannel}
   * @private
   */
  this.browserChannel_;

  /**
   * The callback to the host page.
   * @type {buzz.channel.BrowserChannelHandlerInterface}
   * @private
   */
  this.handler_ = handler;

  /**
   * The state of this object.
   * @type {buzz.channel.BrowserChannelImpl.State}
   * @private
   */
  this.state_ = buzz.channel.BrowserChannelImpl.State.INIT;

  /**
   * Number of times this object's state has changed.
   * @type {number}
   * @private
   */
  this.stateVersionNumber_ = 0;

  /**
   * @type {!invalidation.util.Logger}
   * @private
   */
  this.logger_ = new invalidation.util.LoggerImpl('BrowserChannelImpl');

  /**
   * Default exponential backoff delay generator for a reconnect attempt after
   * an error.
   * @type {!invalidation.ExponentialBackoffDelayGenerator}
   * @private
   */
  this.delayGenerator_ = new invalidation.ExponentialBackoffDelayGenerator(
      Math.random,
      buzz.channel.BrowserChannelImpl.INITIAL_RETRY_DELAY_MS,
      buzz.channel.BrowserChannelImpl.MAX_BACKOFF_FACTOR);

  /**
   * Exponential backoff delay generator for a reconnect attempt after a quota-
   * exceeded error. We want to back off with larger delays in this case since
   * quota is replenshed only every hour.
   * @type {!invalidation.ExponentialBackoffDelayGenerator}
   * @private
   */
  this.delayGeneratorOnQuota_ =
      new invalidation.ExponentialBackoffDelayGenerator(
          Math.random,
          buzz.channel.BrowserChannelImpl.INITIAL_RETRY_DELAY_MS_ON_QUOTA,
          buzz.channel.BrowserChannelImpl.MAX_BACKOFF_FACTOR_ON_QUOTA);
  this.delayGeneratorOnQuota_.getNextDelay();  // skip the no-delay step

  /**
   * Authentication parameters for the channel. By default these are empty,
   * which means no special headers will be sent, so only plain cookie auth will
   * work.
   * @type {!buzz.channel.proto.AuthenticationParameters}
   * @private
   */
  this.authParams_ = new buzz.channel.proto.AuthenticationParameters();

  /**
   * The remaining number of times we'll make immediate connection
   * attempts. Reset once we connect successfully and the connection remains
   * stable for {@code buzz.channel.BrowserChannelImpl.STABLE_THRESHOLD_MS}
   * milliseconds.
   * @type {number}
   * @private
   */
  this.immediateConnectBudget_ =
      buzz.channel.BrowserChannelImpl.INITIAL_IMMEDIATE_CONNECT_BUDGET;

  /**
   * Last HTTP response status code on a channel error.
   * @type {number}
   * @private
   */
  this.lastStatusCode_ = -1;

  /**
   * Whether a reconnect is waiting for auth credentials to change (initially
   * {@code false}). It is set to {@code true} when a channel closes due to an
   * authentication error. While it is {@code true} every reconnect attempt
   * will signal error without actually attempting a connect, establishing a
   * chain of auth params updates and reconnect attempts. It is reset to
   * {@code false} either when the auth credentials change or an immediate
   * reconnect is requested by the user and is allowed.
   * @type {boolean}
   * @private
   */
  this.waitingForAuthChange_ = false;
};
goog.inherits(
    buzz.channel.BrowserChannelImpl, goog.net.BrowserChannel.Handler);

/**
 * The initial (maximum) delay (in milliseconds) when retrying to open the
 * channel.
 * @type {number}
 * @const
 */
buzz.channel.BrowserChannelImpl.INITIAL_RETRY_DELAY_MS = 10 * 1000;

/**
 * The maximum factor by which to back off on retries.
 * @type {number}
 * @const
 */
buzz.channel.BrowserChannelImpl.MAX_BACKOFF_FACTOR = 180;

/**
 * The initial (maximum) delay (in milliseconds) when retrying to open the
 * channel after a close due to exceeding quota.
 * @type {number}
 * @const
 */
buzz.channel.BrowserChannelImpl.INITIAL_RETRY_DELAY_MS_ON_QUOTA =
    1 * 60 * 1000;

/**
 * The maximum factor by which to back off on retries after exceeding quota.
 * @type {number}
 * @const
 */
buzz.channel.BrowserChannelImpl.MAX_BACKOFF_FACTOR_ON_QUOTA = 30;

/**
 * The initial/maximum budget of immediate connection attempts.
 * @type {number}
 * @const
 */
buzz.channel.BrowserChannelImpl.INITIAL_IMMEDIATE_CONNECT_BUDGET = 5;

/**
 * Possible states for the browser channel.
 * @enum {number}
 */
buzz.channel.BrowserChannelImpl.State = {
  INIT: 0,  // Object just created.
  CLOSED: 1,  // Started but browser channel not open.
  WAITING_TO_OPEN: 2,  // Waiting before attempting to open the channel.
  OPENING: 3,  // Attempting to open the browser channel.
  OPEN: 4  // Browser channel open.
};


/**
 * The duration after which we declare a connection to be "successful", allowing
 * us to reset the exponential backoff delay generator.
 */
buzz.channel.BrowserChannelImpl.STABLE_THRESHOLD_MS =
    5 * 60 * 1000;  // 5 minutes

/**
 * Uri suffix for the request to check whether we're behind a buffering proxy.
 * @type {string}
 */
buzz.channel.BrowserChannelImpl.CHECK_BUFFERING_PROXY_SUFFIX = '/cbp';

/**
 * Uri suffix for the channel 'bind' request.
 * @type {string}
 */
buzz.channel.BrowserChannelImpl.BIND_SUFFIX = '/bind';


/**
 * @return {buzz.channel.BrowserChannelImpl.State} The current state, for
 *     tests.
 */
buzz.channel.BrowserChannelImpl.prototype.getStateForTest = function() {
  return this.state_;
};


/** @return {number} The current budget of immediate reconnects, for tests. */
buzz.channel.BrowserChannelImpl.prototype.getImmediateConnectBudgetForTest =
    function() {
  return this.immediateConnectBudget_;
};


/**
 * Updates to the given state.
 * @param {buzz.channel.BrowserChannelImpl.State} state The new state.
 * @private
 */
buzz.channel.BrowserChannelImpl.prototype.updateState_ = function(state) {
  if (state != this.state_) {
    this.state_ = state;
    this.stateVersionNumber_++;
  }
};


/**
 * @inheritDoc
 */
buzz.channel.BrowserChannelImpl.prototype.updateAuthParams = function(
    authParams) {
  var hasAuthChanged = (!this.authParams_ ||
      this.authParams_.getToken() !== authParams.getToken());
  this.authParams_ = authParams.clone();

  if (this.authuser_) {
    this.authParams_.setAuthuser(this.authuser_);
  }

  var extraParams = {};
  var extraHeaders = {};
  buzz.channel.BrowserChannelImpl.addExtraParamsAndHeadersForAuth_(
      this.authParams_, extraParams, extraHeaders);
  if (this.browserChannel_) {
    this.browserChannel_.setExtraHeaders(extraHeaders);
  }

  // If we're waiting for an auth change and auth has changed then reset the
  // wait flag and attempt an immediate reconnect (unless the immediate
  // reconnect budget is exhausted).
  if (this.waitingForAuthChange_ && hasAuthChanged) {
    this.waitingForAuthChange_ = false;
    this.tryImmediateReconnectByUserRequest();
  }
};


/**
 * @inheritDoc
 */
buzz.channel.BrowserChannelImpl.prototype.start = function() {
  goog.asserts.assert(
      this.state_ == buzz.channel.BrowserChannelImpl.State.INIT);
  this.updateState_(buzz.channel.BrowserChannelImpl.State.CLOSED);

  // Opens the channel.
  this.open(false);
};


/**
 * If the browser channel is currently closed, schedules a call to open the
 * browser channel, following a delay chosen by the randomized exponential
 * backoff delay generator.  Otherwise, has no effect.
 * @param {boolean} wasQuotaExceeded whether quota was exceeded on the
 *     previous open attempt.
 */
buzz.channel.BrowserChannelImpl.prototype.open = function(wasQuotaExceeded) {
  if (this.state_ != buzz.channel.BrowserChannelImpl.State.CLOSED) {
    this.logger_.info('Not opening since not closed (state = %s)', this.state_);
    return;
  }
  this.updateState_(
      buzz.channel.BrowserChannelImpl.State.WAITING_TO_OPEN);

  // Add the initial delay from the config, then set it to zero for subsequent
  // openings.
  var delayGenerator = (wasQuotaExceeded ?
      this.delayGeneratorOnQuota_ : this.delayGenerator_);
  var delayMs = (delayGenerator.getNextDelay() +
      this.config_.getInitDelayMsOrDefault());
  this.config_.setInitDelayMs(0);

  // Stash the current state version, so the doOpen_ call can abort if the state
  // has changed between now and when it runs.
  var stateVersionNumber = this.stateVersionNumber_;
  goog.Timer.callOnce(
      function() {
        this.doOpen_(stateVersionNumber);
      }, delayMs, this);
};


/** @inheritDoc */
buzz.channel.BrowserChannelImpl.prototype.tryImmediateReconnectByUserRequest =
    function() {
  switch (this.state_) {
    case buzz.channel.BrowserChannelImpl.State.CLOSED:
    case buzz.channel.BrowserChannelImpl.State.WAITING_TO_OPEN:
      // The channel has been started but is neither open nor in the process of
      // opening. Try to open it now if we still have budget.
      if (this.immediateConnectBudget_ > 0) {
        this.logger_.info('Opening immediately in response to user request');
        this.immediateConnectBudget_--;
        this.waitingForAuthChange_ = false;
        this.doOpen_(this.stateVersionNumber_);
      } else {
        this.logger_.info(
            'Ignoring immediate connect request open because budget exhausted');
      }
      break;

    default:
      // The channel is already either open, in the process of opening, or in a
      // state where it's not ready to be opened. Log and ignore.
      this.logger_.info(
          'Ignoring request to open immediately because already open(ing)');
      break;
  }
};


/**
 * Opens the browser channel, unless the state has changed since the call to
 * this function was scheduled.
 * @param {number} stateVersionNumber The state version number when this
 *     function was scheduled.
 * @private
 */
buzz.channel.BrowserChannelImpl.prototype.doOpen_ =
    function(stateVersionNumber) {
  goog.asserts.assert(this.config_.getClientType());
  if (this.stateVersionNumber_ != stateVersionNumber) {
    this.logger_.info('Not opening since state has changed (%s vs. %s)',
                      stateVersionNumber, this.stateVersionNumber_);
    return;
  }
  goog.asserts.assert(this.browserChannel_ == null);
  this.updateState_(buzz.channel.BrowserChannelImpl.State.OPENING);
  // The path on the server used to test whether we're behind a buffered proxy.
  var testPath = this.baseUri_ +
      buzz.channel.BrowserChannelImpl.CHECK_BUFFERING_PROXY_SUFFIX;
  // The path on the server used for binding back channel requests.
  var bindPath = this.baseUri_ +
      buzz.channel.BrowserChannelImpl.BIND_SUFFIX;
  this.browserChannel_ = new goog.net.BrowserChannel(this.protocolVersion_);
  this.browserChannel_.setHandler(this);
  var extraParams = {};
  extraParams[buzz.channel.SharedConstants.CLIENT_TYPE_PARAM] =
      this.config_.getClientType();
  if (this.config_.hasServiceOverride()) {
    extraParams[buzz.channel.SharedConstants.GAIA_SERVICE_PARAM] =
        this.config_.getServiceOverride();
  }
  var extraHeaders = {};
  buzz.channel.BrowserChannelImpl.addExtraParamsAndHeadersForAuth_(
      this.authParams_, extraParams, extraHeaders);
  this.browserChannel_.setExtraHeaders(extraHeaders);
  if (this.waitingForAuthChange_) {
    this.logger_.info('Skipping connect because waiting for auth change.');
    // Signal error (to trigger auth params update) and close (to schedule a
    // reconnect attempt).
    this.channelError(this.browserChannel_,
                      goog.net.BrowserChannel.Error.REQUEST_FAILED);
    this.channelClosed(this.browserChannel_);
  } else {
    this.browserChannel_.connect(testPath, bindPath, extraParams);
  }
};


/**
 * Adds extra parameters to {@code extraParams} and extra headers to
 * {@code extraHeaders} per the authentication parameters in {@code authParams}.
 * @param {buzz.channel.proto.AuthenticationParameters} authParams The
 *     authentication parameters for the channel.
 * @param {Object} extraParams A mapping from query parameter names to values,
 *     to which this function may add entries.
 * @param {Object} extraHeaders A mapping from header names to values, to which
 *     this function may add entries.
 * @private
 */
buzz.channel.BrowserChannelImpl.addExtraParamsAndHeadersForAuth_ = function(
    authParams, extraParams, extraHeaders) {
  if (authParams.hasAuthuser()) {
    extraParams[buzz.channel.SharedConstants.AUTHUSER] = (
        authParams.getAuthuser());
  }
  // If the authentication parameters have been supplied, then set headers to
  // allow authentication not solely based on cookies.
  if (authParams.hasToken()) {
    var authScheme = authParams.getScheme();
    var authSchemeName = goog.asserts.assert(
        buzz.channel.SharedConstants.AuthSchemeNames[authScheme],
        'Unknown auth scheme: ' + authScheme);

    extraHeaders[buzz.channel.SharedConstants.AUTHORIZATION_HEADER] = (
        authSchemeName + ' ' + authParams.getToken());
    if (authScheme != buzz.channel.proto.AuthenticationParameters.Scheme.
        OAUTH) {
      extraHeaders[buzz.channel.SharedConstants.X_ORIGIN_HEADER] = (
          authParams.getOrigin());

      // The default value of the authuser parameter is 0 (the primary login
      // session).  The protocol message default is also 0, so if authuser was
      // not specified we'll get the proper default.
      extraHeaders[buzz.channel.SharedConstants.X_GOOG_AUTHUSER_HEADER] = (
          authParams.getAuthuserOrDefault());
    }
  }
};


/**
 * @inheritDoc
 */
buzz.channel.BrowserChannelImpl.prototype.close = function() {
  // The browser channel will not reopen.
  this.updateState_(buzz.channel.BrowserChannelImpl.State.CLOSED);
  if (this.browserChannel_ != null) {
    this.browserChannel_.disconnect();
  }
};


/**
 * @inheritDoc
 */
buzz.channel.BrowserChannelImpl.prototype.sendMap = function(mapToSend) {
  if (this.browserChannel_ != null) {
    this.browserChannel_.sendMap(mapToSend);
  }
};


/** @override */
buzz.channel.BrowserChannelImpl.prototype.channelOpened =
    function(browserChannel) {
  // Check that we're being called for the BrowserChannel we handle.
  goog.asserts.assert(browserChannel == this.browserChannel_);
  this.updateState_(buzz.channel.BrowserChannelImpl.State.OPEN);

  // The browser channel is open, so we're within quota and can reset the delay
  // generator for the next time we exceed quota.
  this.delayGeneratorOnQuota_.reset();
  this.delayGeneratorOnQuota_.getNextDelay();  // skip the no delay step

  // The browser channel is open, but it's possible that our account has been
  // blacklisted at the Talk session server, which will cause our connection to
  // be terminated once the endpoint sends a ping.  If that happens, we want to
  // avoid turning around and reconnecting immediately.  So, we only reset the
  // exponential delay generator if the connection is stable (i.e., state hasn't
  // changed for a significant amount of time).
  var stateVersionNumber = this.stateVersionNumber_;
  goog.Timer.callOnce(function() {
      if (this.stateVersionNumber_ != stateVersionNumber) {
        this.logger_.info(
            'Not resetting delay generator because state changed (%d vs. %d)',
            stateVersionNumber, this.stateVersionNumber_);
        return;
      }
      this.delayGenerator_.reset();
      this.immediateConnectBudget_ =
          buzz.channel.BrowserChannelImpl.INITIAL_IMMEDIATE_CONNECT_BUDGET;
    },
    buzz.channel.BrowserChannelImpl.STABLE_THRESHOLD_MS,
    this);
  this.handler_.channelOpened();
};


/** @override */
buzz.channel.BrowserChannelImpl.prototype.channelHandleArray =
    function(browserChannel, dataArray) {
  // Check that we're being called for the BrowserChannel we handle.
  goog.asserts.assert(browserChannel == this.browserChannel_);
  this.handler_.channelHandleArray(dataArray);
};


/** @override */
buzz.channel.BrowserChannelImpl.prototype.channelError =
    function(browserChannel, error) {
  // Check that we're being called for the BrowserChannel we handle.
  goog.asserts.assert(browserChannel == this.browserChannel_);
  this.lastStatusCode_ = browserChannel.getLastStatusCode();
  this.handler_.channelError(error);
};


/** @override */
buzz.channel.BrowserChannelImpl.prototype.channelClosed =
    function(browserChannel) {
  goog.asserts.assert(browserChannel == this.browserChannel_);

  // Mark the state as closed.
  var oldState = this.state_;
  this.updateState_(buzz.channel.BrowserChannelImpl.State.CLOSED);

  // However, if we were previously open, or trying to open, then automatically
  // retry opening the channel.
  if (oldState == buzz.channel.BrowserChannelImpl.State.OPEN ||
      oldState == buzz.channel.BrowserChannelImpl.State.OPENING) {
    var wasQuotaExceeded = false;
    switch (this.lastStatusCode_) {
      case goog.net.HttpStatus.UNAUTHORIZED:
        this.waitingForAuthChange_ = true;
        break;
      case goog.net.HttpStatus.FORBIDDEN:
        wasQuotaExceeded = true;
        break;
      default:
        break;
    }
    this.open(wasQuotaExceeded);
  }
  this.lastStatusCode_ = -1;
  this.browserChannel_ = null;
  this.handler_.channelClosed();
};

//buzz/channel/javascript/internal/noniframedchannelconfigimpl.js
/**
 * @fileoverview A channel config implementation using a browser channel hosted
 *     in the same page as the client.
 */

goog.provide('buzz.channel.NonIframedChannelConfigImpl');

goog.require('buzz.channel.BrowserChannelImpl');
goog.require('buzz.channel.ChannelConfigImpl');


/**
 * @param {string} uriStr The address to which to connect. This is a fully
 *     qualified path to the iframe if xpc is used. Or it is a relative path if
 *     not. Must be on the same domain as the one from which this script was
 *     downloaded.
 * @param {string} clientType Client type value (must less than 16 characters).
 * @param {boolean} serverAssignsSessionName Whether to allow the server to
 *     assign our session names.
 * @param {number=} opt_authuser Optional authuser parameter for the channel
 *     (indicates which session to use for multi-login).
 * @param {string=} opt_gaiaServiceOverride Optional Gaia service name override
 *     (for applications and domains where Talk may be disabled).
 * @extends {buzz.channel.ChannelConfigImpl}
 * @constructor
 */
buzz.channel.NonIframedChannelConfigImpl = function(uriStr, clientType,
    serverAssignsSessionName, opt_authuser, opt_gaiaServiceOverride) {

  goog.base(this, uriStr, clientType, serverAssignsSessionName, opt_authuser,
      opt_gaiaServiceOverride);

};
goog.inherits(buzz.channel.NonIframedChannelConfigImpl,
    buzz.channel.ChannelConfigImpl);

/** @inheritDoc */
buzz.channel.NonIframedChannelConfigImpl.prototype.createBrowserChannel =
    function(handler) {
  return new buzz.channel.BrowserChannelImpl(this.getUri(), handler,
      this.toConfigProto());
};

//javascript/closure/async/delay.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines a class useful for handling functions that must be
 * invoked after a delay, especially when that delay is frequently restarted.
 * Examples include delaying before displaying a tooltip, menu hysteresis,
 * idle timers, etc.
 * @author brenneman@google.com (Shawn Brenneman)
 * @see ../demos/timers.html
 */


goog.provide('goog.Delay');
goog.provide('goog.async.Delay');

goog.require('goog.Disposable');
goog.require('goog.Timer');



/**
 * A Delay object invokes the associated function after a specified delay. The
 * interval duration can be specified once in the constructor, or can be defined
 * each time the delay is started. Calling start on an active delay will reset
 * the timer.
 *
 * @param {Function} listener Function to call when the delay completes.
 * @param {number=} opt_interval The default length of the invocation delay (in
 *     milliseconds).
 * @param {Object=} opt_handler The object scope to invoke the function in.
 * @constructor
 * @extends {goog.Disposable}
 * @final
 */
goog.async.Delay = function(listener, opt_interval, opt_handler) {
  goog.Disposable.call(this);

  /**
   * The function that will be invoked after a delay.
   * @type {Function}
   * @private
   */
  this.listener_ = listener;

  /**
   * The default amount of time to delay before invoking the callback.
   * @type {number}
   * @private
   */
  this.interval_ = opt_interval || 0;

  /**
   * The object context to invoke the callback in.
   * @type {Object|undefined}
   * @private
   */
  this.handler_ = opt_handler;


  /**
   * Cached callback function invoked when the delay finishes.
   * @type {Function}
   * @private
   */
  this.callback_ = goog.bind(this.doAction_, this);
};
goog.inherits(goog.async.Delay, goog.Disposable);



/**
 * A deprecated alias.
 * @deprecated Use goog.async.Delay instead.
 * @constructor
 * @final
 */
goog.Delay = goog.async.Delay;


/**
 * Identifier of the active delay timeout, or 0 when inactive.
 * @type {number}
 * @private
 */
goog.async.Delay.prototype.id_ = 0;


/**
 * Disposes of the object, cancelling the timeout if it is still outstanding and
 * removing all object references.
 * @override
 * @protected
 */
goog.async.Delay.prototype.disposeInternal = function() {
  goog.async.Delay.superClass_.disposeInternal.call(this);
  this.stop();
  delete this.listener_;
  delete this.handler_;
};


/**
 * Starts the delay timer. The provided listener function will be called after
 * the specified interval. Calling start on an active timer will reset the
 * delay interval.
 * @param {number=} opt_interval If specified, overrides the object's default
 *     interval with this one (in milliseconds).
 */
goog.async.Delay.prototype.start = function(opt_interval) {
  this.stop();
  this.id_ = goog.Timer.callOnce(
      this.callback_,
      goog.isDef(opt_interval) ? opt_interval : this.interval_);
};


/**
 * Stops the delay timer if it is active. No action is taken if the timer is not
 * in use.
 */
goog.async.Delay.prototype.stop = function() {
  if (this.isActive()) {
    goog.Timer.clear(this.id_);
  }
  this.id_ = 0;
};


/**
 * Fires delay's action even if timer has already gone off or has not been
 * started yet; guarantees action firing. Stops the delay timer.
 */
goog.async.Delay.prototype.fire = function() {
  this.stop();
  this.doAction_();
};


/**
 * Fires delay's action only if timer is currently active. Stops the delay
 * timer.
 */
goog.async.Delay.prototype.fireIfActive = function() {
  if (this.isActive()) {
    this.fire();
  }
};


/**
 * @return {boolean} True if the delay is currently active, false otherwise.
 */
goog.async.Delay.prototype.isActive = function() {
  return this.id_ != 0;
};


/**
 * Invokes the callback function after the delay successfully completes.
 * @private
 */
goog.async.Delay.prototype.doAction_ = function() {
  this.id_ = 0;
  if (this.listener_) {
    this.listener_.call(this.handler_);
  }
};

//javascript/closure/messaging/messagechannel.js
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview An interface for asynchronous message-passing channels.
 *
 * This interface is useful for writing code in a message-passing style that's
 * independent of the underlying communication medium. It's also useful for
 * adding decorators that wrap message channels and add extra functionality on
 * top. For example, {@link goog.messaging.BufferedChannel} enqueues messages
 * until communication is established, while {@link goog.messaging.MultiChannel}
 * splits a single underlying channel into multiple virtual ones.
 *
 * Decorators should be passed their underlying channel(s) in the constructor,
 * and should assume that those channels are already connected. Decorators are
 * responsible for disposing of the channels they wrap when the decorators
 * themselves are disposed. Decorators should also follow the APIs of the
 * individual methods listed below.
 *
 * @author nweiz@google.com (Nathan Weizenbaum)
 */


goog.provide('goog.messaging.MessageChannel');



/**
 * @interface
 */
goog.messaging.MessageChannel = function() {};


/**
 * Initiates the channel connection. When this method is called, all the
 * information needed to connect the channel has to be available.
 *
 * Implementers should only require this method to be called if the channel
 * needs to be configured in some way between when it's created and when it
 * becomes active. Otherwise, the channel should be immediately active and this
 * method should do nothing but immediately call opt_connectCb.
 *
 * @param {Function=} opt_connectCb Called when the channel has been connected
 *     and is ready to use.
 */
goog.messaging.MessageChannel.prototype.connect = function(opt_connectCb) {};


/**
 * Gets whether the channel is connected.
 *
 * If {@link #connect} is not required for this class, this should always return
 * true. Otherwise, this should return true by the time the callback passed to
 * {@link #connect} has been called and always after that.
 *
 * @return {boolean} Whether the channel is connected.
 */
goog.messaging.MessageChannel.prototype.isConnected = function() {};


/**
 * Registers a service to be called when a message is received.
 *
 * Implementers shouldn't impose any restrictions on the service names that may
 * be registered. If some services are needed as control codes,
 * {@link goog.messaging.MultiMessageChannel} can be used to safely split the
 * channel into "public" and "control" virtual channels.
 *
 * @param {string} serviceName The name of the service.
 * @param {function((string|!Object))} callback The callback to process the
 *     incoming messages. Passed the payload. If opt_objectPayload is set, the
 *     payload is decoded and passed as an object.
 * @param {boolean=} opt_objectPayload If true, incoming messages for this
 *     service are expected to contain an object, and will be deserialized from
 *     a string automatically if necessary. It's the responsibility of
 *     implementors of this class to perform the deserialization.
 */
goog.messaging.MessageChannel.prototype.registerService =
    function(serviceName, callback, opt_objectPayload) {};


/**
 * Registers a service to be called when a message is received that doesn't
 * match any other services.
 *
 * @param {function(string, (string|!Object))} callback The callback to process
 *     the incoming messages. Passed the service name and the payload. Since
 *     some channels can pass objects natively, the payload may be either an
 *     object or a string.
 */
goog.messaging.MessageChannel.prototype.registerDefaultService =
    function(callback) {};


/**
 * Sends a message over the channel.
 *
 * @param {string} serviceName The name of the service this message should be
 *     delivered to.
 * @param {string|!Object} payload The value of the message. If this is an
 *     Object, it is serialized to a string before sending if necessary. It's
 *     the responsibility of implementors of this class to perform the
 *     serialization.
 */
goog.messaging.MessageChannel.prototype.send =
    function(serviceName, payload) {};

//javascript/closure/messaging/abstractchannel.js
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview An abstract superclass for message channels that handles the
 * repetitive details of registering and dispatching to services. This is more
 * useful for full-fledged channels than for decorators, since decorators
 * generally delegate service registering anyway.
 *
 * @author nweiz@google.com (Nathan Weizenbaum)
 */


goog.provide('goog.messaging.AbstractChannel');

goog.require('goog.Disposable');
goog.require('goog.debug');
goog.require('goog.json');
goog.require('goog.log');
goog.require('goog.messaging.MessageChannel'); // interface



/**
 * Creates an abstract message channel.
 *
 * @constructor
 * @extends {goog.Disposable}
 * @implements {goog.messaging.MessageChannel}
 */
goog.messaging.AbstractChannel = function() {
  goog.base(this);

  /**
   * The services registered for this channel.
   * @type {Object.<string, {callback: function((string|!Object)),
                             objectPayload: boolean}>}
   * @private
   */
  this.services_ = {};
};
goog.inherits(goog.messaging.AbstractChannel, goog.Disposable);


/**
 * The default service to be run when no other services match.
 *
 * @type {?function(string, (string|!Object))}
 * @private
 */
goog.messaging.AbstractChannel.prototype.defaultService_;


/**
 * Logger for this class.
 * @type {goog.log.Logger}
 * @protected
 */
goog.messaging.AbstractChannel.prototype.logger =
    goog.log.getLogger('goog.messaging.AbstractChannel');


/**
 * Immediately calls opt_connectCb if given, and is otherwise a no-op. If
 * subclasses have configuration that needs to happen before the channel is
 * connected, they should override this and {@link #isConnected}.
 * @override
 */
goog.messaging.AbstractChannel.prototype.connect = function(opt_connectCb) {
  if (opt_connectCb) {
    opt_connectCb();
  }
};


/**
 * Always returns true. If subclasses have configuration that needs to happen
 * before the channel is connected, they should override this and
 * {@link #connect}.
 * @override
 */
goog.messaging.AbstractChannel.prototype.isConnected = function() {
  return true;
};


/** @override */
goog.messaging.AbstractChannel.prototype.registerService =
    function(serviceName, callback, opt_objectPayload) {
  this.services_[serviceName] = {
    callback: callback,
    objectPayload: !!opt_objectPayload
  };
};


/** @override */
goog.messaging.AbstractChannel.prototype.registerDefaultService =
    function(callback) {
  this.defaultService_ = callback;
};


/** @override */
goog.messaging.AbstractChannel.prototype.send = goog.abstractMethod;


/**
 * Delivers a message to the appropriate service. This is meant to be called by
 * subclasses when they receive messages.
 *
 * This method takes into account both explicitly-registered and default
 * services, as well as making sure that JSON payloads are decoded when
 * necessary. If the subclass is capable of passing objects as payloads, those
 * objects can be passed in to this method directly. Otherwise, the (potentially
 * JSON-encoded) strings should be passed in.
 *
 * @param {string} serviceName The name of the service receiving the message.
 * @param {string|!Object} payload The contents of the message.
 * @protected
 */
goog.messaging.AbstractChannel.prototype.deliver = function(
    serviceName, payload) {
  var service = this.getService(serviceName, payload);
  if (!service) {
    return;
  }

  var decodedPayload =
      this.decodePayload(serviceName, payload, service.objectPayload);
  if (goog.isDefAndNotNull(decodedPayload)) {
    service.callback(decodedPayload);
  }
};


/**
 * Find the service object for a given service name. If there's no service
 * explicitly registered, but there is a default service, a service object is
 * constructed for it.
 *
 * @param {string} serviceName The name of the service receiving the message.
 * @param {string|!Object} payload The contents of the message.
 * @return {?{callback: function((string|!Object)), objectPayload: boolean}} The
 *     service object for the given service, or null if none was found.
 * @protected
 */
goog.messaging.AbstractChannel.prototype.getService = function(
    serviceName, payload) {
  var service = this.services_[serviceName];
  if (service) {
    return service;
  } else if (this.defaultService_) {
    var callback = goog.partial(this.defaultService_, serviceName);
    var objectPayload = goog.isObject(payload);
    return {callback: callback, objectPayload: objectPayload};
  }

  goog.log.warning(this.logger, 'Unknown service name "' + serviceName + '"');
  return null;
};


/**
 * Converts the message payload into the format expected by the registered
 * service (either JSON or string).
 *
 * @param {string} serviceName The name of the service receiving the message.
 * @param {string|!Object} payload The contents of the message.
 * @param {boolean} objectPayload Whether the service expects an object or a
 *     plain string.
 * @return {string|Object} The payload in the format expected by the service, or
 *     null if something went wrong.
 * @protected
 */
goog.messaging.AbstractChannel.prototype.decodePayload = function(
    serviceName, payload, objectPayload) {
  if (objectPayload && goog.isString(payload)) {
    try {
      return goog.json.parse(payload);
    } catch (err) {
      goog.log.warning(this.logger,
          'Expected JSON payload for ' + serviceName +
          ', was "' + payload + '"');
      return null;
    }
  } else if (!objectPayload && !goog.isString(payload)) {
    return goog.json.serialize(payload);
  }
  return payload;
};


/** @override */
goog.messaging.AbstractChannel.prototype.disposeInternal = function() {
  goog.base(this, 'disposeInternal');
  delete this.logger;
  delete this.services_;
  delete this.defaultService_;
};

//javascript/closure/net/xpc/crosspagechannelrole.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides the enum for the role of the CrossPageChannel.
 *
 * @author mibuerge@google.com (Michael Buerge)
 */

goog.provide('goog.net.xpc.CrossPageChannelRole');


/**
 * The role of the peer.
 * @enum {number}
 */
goog.net.xpc.CrossPageChannelRole = {
  OUTER: 0,
  INNER: 1
};

//javascript/closure/net/xpc/xpc.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides the namesspace for client-side communication
 * between pages originating from different domains (it works also
 * with pages from the same domain, but doing that is kinda
 * pointless).
 *
 * The only publicly visible class is goog.net.xpc.CrossPageChannel.
 *
 * Note: The preferred name for the main class would have been
 * CrossDomainChannel.  But as there already is a class named like
 * that (which serves a different purpose) in the maps codebase,
 * CrossPageChannel was chosen to avoid confusion.
 *
 * CrossPageChannel abstracts the underlying transport mechanism to
 * provide a common interface in all browsers.
 *
 * @author mibuerge@google.com (Michael Buerge)
 */

/*
TODO(mibuerge)
- resolve fastback issues in Safari (IframeRelayTransport)
 */


/**
 * Namespace for CrossPageChannel
 */
goog.provide('goog.net.xpc');
goog.provide('goog.net.xpc.CfgFields');
goog.provide('goog.net.xpc.ChannelStates');
goog.provide('goog.net.xpc.TransportNames');
goog.provide('goog.net.xpc.TransportTypes');
goog.provide('goog.net.xpc.UriCfgFields');

goog.require('goog.log');


/**
 * Enum used to identify transport types.
 * @enum {number}
 */
goog.net.xpc.TransportTypes = {
  NATIVE_MESSAGING: 1,
  FRAME_ELEMENT_METHOD: 2,
  IFRAME_RELAY: 3,
  IFRAME_POLLING: 4,
  FLASH: 5,
  NIX: 6,
  DIRECT: 7
};


/**
 * Enum containing transport names. These need to correspond to the
 * transport class names for createTransport_() to work.
 * @type {Object}
 */
goog.net.xpc.TransportNames = {
  '1': 'NativeMessagingTransport',
  '2': 'FrameElementMethodTransport',
  '3': 'IframeRelayTransport',
  '4': 'IframePollingTransport',
  '5': 'FlashTransport',
  '6': 'NixTransport',
  '7': 'DirectTransport'
};


// TODO(jschorr): Add auth token support to other methods.


/**
 * Field names used on configuration object.
 * @type {Object}
 */
goog.net.xpc.CfgFields = {
  /**
   * Channel name identifier.
   * Both peers have to be initialized with
   * the same channel name.  If not present, a channel name is
   * generated (which then has to transferred to the peer somehow).
   */
  CHANNEL_NAME: 'cn',
  /**
   * Authorization token. If set, NIX will use this authorization token
   * to validate the setup.
   */
  AUTH_TOKEN: 'at',
  /**
   * Remote party's authorization token. If set, NIX will validate this
   * authorization token against that sent by the other party.
   */
  REMOTE_AUTH_TOKEN: 'rat',
  /**
   * The URI of the peer page.
   */
  PEER_URI: 'pu',
  /**
   * Ifame-ID identifier.
   * The id of the iframe element the peer-document lives in.
   */
  IFRAME_ID: 'ifrid',
  /**
   * Transport type identifier.
   * The transport type to use. Possible values are entries from
   * goog.net.xpc.TransportTypes. If not present, the transport is
   * determined automatically based on the useragent's capabilities.
   */
  TRANSPORT: 'tp',
  /**
   * Local relay URI identifier (IframeRelayTransport-specific).
   * The URI (can't contain a fragment identifier) used by the peer to
   * relay data through.
   */
  LOCAL_RELAY_URI: 'lru',
  /**
   * Peer relay URI identifier (IframeRelayTransport-specific).
   * The URI (can't contain a fragment identifier) used to relay data
   * to the peer.
   */
  PEER_RELAY_URI: 'pru',
  /**
   * Local poll URI identifier (IframePollingTransport-specific).
   * The URI  (can't contain a fragment identifier)which is polled
   * to receive data from the peer.
   */
  LOCAL_POLL_URI: 'lpu',
  /**
   * Local poll URI identifier (IframePollingTransport-specific).
   * The URI (can't contain a fragment identifier) used to send data
   * to the peer.
   */
  PEER_POLL_URI: 'ppu',
  /**
   * The hostname of the peer window, including protocol, domain, and port
   * (if specified). Used for security sensitive applications that make
   * use of NativeMessagingTransport (i.e. most applications).
   */
  PEER_HOSTNAME: 'ph',
  /**
   * Usually both frames using a connection initially send a SETUP message to
   * each other, and each responds with a SETUP_ACK.  A frame marks itself
   * connected when it receives that SETUP_ACK.  If this parameter is true
   * however, the channel it is passed to will not send a SETUP, but rather will
   * wait for one from its peer and mark itself connected when that arrives.
   * Peer iframes created using such a channel will send SETUP however, and will
   * wait for SETUP_ACK before marking themselves connected.  The goal is to
   * cope with a situation where the availability of the URL for the peer frame
   * cannot be relied on, eg when the application is offline.  Without this
   * setting, the primary frame will attempt to send its SETUP message every
   * 100ms, forever.  This floods the javascript console with uncatchable
   * security warnings, and fruitlessly burns CPU.  There is one scenario this
   * mode will not support, and that is reconnection by the outer frame, ie the
   * creation of a new channel object to connect to a peer iframe which was
   * already communicating with a previous channel object of the same name.  If
   * that behavior is needed, this mode should not be used.  Reconnection by
   * inner frames is supported in this mode however.
   */
  ONE_SIDED_HANDSHAKE: 'osh',
  /**
   * The frame role (inner or outer). Used to explicitly indicate the role for
   * each peer whenever the role cannot be reliably determined (e.g. the two
   * peer windows are not parent/child frames). If unspecified, the role will
   * be dynamically determined, assuming a parent/child frame setup.
   */
  ROLE: 'role',
  /**
   * Which version of the native transport startup protocol should be used, the
   * default being '2'.  Version 1 had various timing vulnerabilities, which
   * had to be compensated for by introducing delays, and is deprecated.  V1
   * and V2 are broadly compatible, although the more robust timing and lack
   * of delays is not gained unless both sides are using V2.  The only
   * unsupported case of cross-protocol interoperation is where a connection
   * starts out with V2 at both ends, and one of the ends reconnects as a V1.
   * All other initial startup and reconnection scenarios are supported.
   */
  NATIVE_TRANSPORT_PROTOCOL_VERSION: 'nativeProtocolVersion'
};


/**
 * Config properties that need to be URL sanitized.
 * @type {Array}.<string>
 */
goog.net.xpc.UriCfgFields = [
  goog.net.xpc.CfgFields.PEER_URI,
  goog.net.xpc.CfgFields.LOCAL_RELAY_URI,
  goog.net.xpc.CfgFields.PEER_RELAY_URI,
  goog.net.xpc.CfgFields.LOCAL_POLL_URI,
  goog.net.xpc.CfgFields.PEER_POLL_URI
];


/**
 * @enum {number}
 */
goog.net.xpc.ChannelStates = {
  NOT_CONNECTED: 1,
  CONNECTED: 2,
  CLOSED: 3
};


/**
 * The name of the transport service (used for internal signalling).
 * @type {string}
 * @suppress {underscore|visibility}
 */
goog.net.xpc.TRANSPORT_SERVICE_ = 'tp';


/**
 * Transport signaling message: setup.
 * @type {string}
 */
goog.net.xpc.SETUP = 'SETUP';


/**
 * Transport signaling message: setup for native transport protocol v2.
 * @type {string}
 */
goog.net.xpc.SETUP_NTPV2 = 'SETUP_NTPV2';


/**
 * Transport signaling message: setup acknowledgement.
 * @type {string}
 * @suppress {underscore|visibility}
 */
goog.net.xpc.SETUP_ACK_ = 'SETUP_ACK';


/**
 * Transport signaling message: setup acknowledgement.
 * @type {string}
 */
goog.net.xpc.SETUP_ACK_NTPV2 = 'SETUP_ACK_NTPV2';


/**
 * Object holding active channels.
 * Package private. Do not call from outside goog.net.xpc.
 *
 * @type {Object.<string, goog.net.xpc.CrossPageChannel>}
 */
goog.net.xpc.channels = {};


/**
 * Returns a random string.
 * @param {number} length How many characters the string shall contain.
 * @param {string=} opt_characters The characters used.
 * @return {string} The random string.
 */
goog.net.xpc.getRandomString = function(length, opt_characters) {
  var chars = opt_characters || goog.net.xpc.randomStringCharacters_;
  var charsLength = chars.length;
  var s = '';
  while (length-- > 0) {
    s += chars.charAt(Math.floor(Math.random() * charsLength));
  }
  return s;
};


/**
 * The default characters used for random string generation.
 * @type {string}
 * @private
 */
goog.net.xpc.randomStringCharacters_ =
    'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';


/**
 * The logger.
 * @type {goog.log.Logger}
 */
goog.net.xpc.logger = goog.log.getLogger('goog.net.xpc');

//javascript/closure/net/xpc/transport.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Contains the base class for transports.
 *
 * @author mibuerge@google.com (Michael Buerge)
 */


goog.provide('goog.net.xpc.Transport');

goog.require('goog.Disposable');
goog.require('goog.dom');
goog.require('goog.net.xpc.TransportNames');



/**
 * The base class for transports.
 * @param {goog.dom.DomHelper=} opt_domHelper The dom helper to use for
 *     finding the window objects.
 * @constructor
 * @extends {goog.Disposable};
 */
goog.net.xpc.Transport = function(opt_domHelper) {
  goog.Disposable.call(this);

  /**
   * The dom helper to use for finding the window objects to reference.
   * @type {goog.dom.DomHelper}
   * @private
   */
  this.domHelper_ = opt_domHelper || goog.dom.getDomHelper();
};
goog.inherits(goog.net.xpc.Transport, goog.Disposable);


/**
 * The transport type.
 * @type {number}
 * @protected
 */
goog.net.xpc.Transport.prototype.transportType = 0;


/**
 * @return {number} The transport type identifier.
 */
goog.net.xpc.Transport.prototype.getType = function() {
  return this.transportType;
};


/**
 * Returns the window associated with this transport instance.
 * @return {Window} The window to use.
 */
goog.net.xpc.Transport.prototype.getWindow = function() {
  return this.domHelper_.getWindow();
};


/**
 * Return the transport name.
 * @return {string} the transport name.
 */
goog.net.xpc.Transport.prototype.getName = function() {
  return goog.net.xpc.TransportNames[this.transportType] || '';
};


/**
 * Handles transport service messages (internal signalling).
 * @param {string} payload The message content.
 */
goog.net.xpc.Transport.prototype.transportServiceHandler = goog.abstractMethod;


/**
 * Connects this transport.
 * The transport implementation is expected to call
 * CrossPageChannel.prototype.notifyConnected when the channel is ready
 * to be used.
 */
goog.net.xpc.Transport.prototype.connect = goog.abstractMethod;


/**
 * Sends a message.
 * @param {string} service The name off the service the message is to be
 * delivered to.
 * @param {string} payload The message content.
 */
goog.net.xpc.Transport.prototype.send = goog.abstractMethod;

//javascript/closure/net/xpc/directtransport.js
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides an implementation of a transport that can call methods
 * directly on a frame. Useful if you want to use XPC for crossdomain messaging
 * (using another transport), or same domain messaging (using this transport).
 */


goog.provide('goog.net.xpc.DirectTransport');

goog.require('goog.Timer');
goog.require('goog.async.Deferred');
goog.require('goog.events.EventHandler');
goog.require('goog.log');
goog.require('goog.net.xpc');
goog.require('goog.net.xpc.CrossPageChannelRole');
goog.require('goog.net.xpc.Transport');
goog.require('goog.net.xpc.TransportTypes');
goog.require('goog.object');


goog.scope(function() {
var CrossPageChannelRole = goog.net.xpc.CrossPageChannelRole;
var Deferred = goog.async.Deferred;
var EventHandler = goog.events.EventHandler;
var Timer = goog.Timer;
var Transport = goog.net.xpc.Transport;



/**
 * A direct window to window method transport.
 *
 * If the windows are in the same security context, this transport calls
 * directly into the other window without using any additional mechanism. This
 * is mainly used in scenarios where you want to optionally use a cross domain
 * transport in cross security context situations, or optionally use a direct
 * transport in same security context situations.
 *
 * Note: Global properties are exported by using this transport. One to
 * communicate with the other window by, currently crosswindowmessaging.channel,
 * and by using goog.getUid on window, currently closure_uid_[0-9]+.
 *
 * @param {!goog.net.xpc.CrossPageChannel} channel The channel this
 *     transport belongs to.
 * @param {goog.dom.DomHelper=} opt_domHelper The dom helper to use for
 *     finding the correct window/document. If omitted, uses the current
 *     document.
 * @constructor
 * @extends {Transport}
 */
goog.net.xpc.DirectTransport = function(channel, opt_domHelper) {
  goog.base(this, opt_domHelper);

  /**
   * The channel this transport belongs to.
   * @private {!goog.net.xpc.CrossPageChannel}
   */
  this.channel_ = channel;

  /** @private {!EventHandler} */
  this.eventHandler_ = new EventHandler(this);
  this.registerDisposable(this.eventHandler_);

  /**
   * Timer for connection reattempts.
   * @private {!Timer}
   */
  this.maybeAttemptToConnectTimer_ = new Timer(
      DirectTransport.CONNECTION_ATTEMPT_INTERVAL_MS_,
      this.getWindow());
  this.registerDisposable(this.maybeAttemptToConnectTimer_);

  /**
   * Fires once we've received our SETUP_ACK message.
   * @private {!Deferred}
   */
  this.setupAckReceived_ = new Deferred();

  /**
   * Fires once we've sent our SETUP_ACK message.
   * @private {!Deferred}
   */
  this.setupAckSent_ = new Deferred();

  /**
   * Fires once we're marked connected.
   * @private {!Deferred}
   */
  this.connected_ = new Deferred();

  /**
   * The unique ID of this side of the connection. Used to determine when a peer
   * is reloaded.
   * @private {string}
   */
  this.endpointId_ = goog.net.xpc.getRandomString(10);

  /**
   * The unique ID of the peer. If we get a message from a peer with an ID we
   * don't expect, we reset the connection.
   * @private {?string}
   */
  this.peerEndpointId_ = null;

  /**
   * The map of sending messages.
   * @private {Object}
   */
  this.asyncSendsMap_ = {};

  /**
   * The original channel name.
   * @private {string}
   */
  this.originalChannelName_ = this.channel_.name;

  // We reconfigure the channel name to include the role so that we can
  // communicate in the same window between the different roles on the
  // same channel.
  this.channel_.updateChannelNameAndCatalog(
      DirectTransport.getRoledChannelName_(this.channel_.name,
                                           this.channel_.getRole()));

  /**
   * Flag indicating if this instance of the transport has been initialized.
   * @private {boolean}
   */
  this.initialized_ = false;

  // We don't want to mark ourselves connected until we have sent whatever
  // message will cause our counterpart in the other frame to also declare
  // itself connected, if there is such a message.  Otherwise we risk a user
  // message being sent in advance of that message, and it being discarded.

  // Two sided handshake:
  // SETUP_ACK has to have been received, and sent.
  this.connected_.awaitDeferred(this.setupAckReceived_);
  this.connected_.awaitDeferred(this.setupAckSent_);

  this.connected_.addCallback(this.notifyConnected_, this);
  this.connected_.callback(true);

  this.eventHandler_.
      listen(this.maybeAttemptToConnectTimer_, Timer.TICK,
          this.maybeAttemptToConnect_);

  goog.log.info(
      goog.net.xpc.logger,
      'DirectTransport created. role=' + this.channel_.getRole());
};
goog.inherits(goog.net.xpc.DirectTransport, Transport);
var DirectTransport = goog.net.xpc.DirectTransport;


/**
 * @private {number}
 * @const
 */
DirectTransport.CONNECTION_ATTEMPT_INTERVAL_MS_ = 100;


/**
 * @param {!Window} peerWindow The peer window to check if DirectTranport is
 *     supported on.
 * @return {boolean} Whether this transport is supported.
 */
DirectTransport.isSupported = function(peerWindow) {
  /** @preserveTry */
  try {
    return window.document.domain == peerWindow.document.domain;
  } catch (e) {
    return false;
  }
};


/**
 * Tracks the number of DirectTransport channels that have been
 * initialized but not disposed yet in a map keyed by the UID of the window
 * object.  This allows for multiple windows to be initiallized and listening
 * for messages.
 * @private {!Object.<number>}
 */
DirectTransport.activeCount_ = {};


/**
 * Path of global message proxy.
 * @private {string}
 * @const
 */
// TODO(wgrose): Make this configurable using the CfgFields.
DirectTransport.GLOBAL_TRANPORT_PATH_ = 'crosswindowmessaging.channel';


/**
 * The delimiter used for transport service messages.
 * @private {string}
 * @const
 */
DirectTransport.MESSAGE_DELIMITER_ = ',';


/**
 * Initializes this transport. Registers a method for 'message'-events in the
 * global scope.
 * @param {!Window} listenWindow The window to listen to events on.
 * @private
 */
DirectTransport.initialize_ = function(listenWindow) {
  var uid = goog.getUid(listenWindow);
  var value = DirectTransport.activeCount_[uid] || 0;
  if (value == 0) {
    // Set up a handler on the window to proxy messages to class.
    var globalProxy = goog.getObjectByName(
        DirectTransport.GLOBAL_TRANPORT_PATH_,
        listenWindow);
    if (globalProxy == null) {
      goog.exportSymbol(
          DirectTransport.GLOBAL_TRANPORT_PATH_,
          DirectTransport.messageReceivedHandler_,
          listenWindow);
    }
  }
  DirectTransport.activeCount_[uid]++;
};


/**
 * @param {string} channelName The channel name.
 * @param {string|number} role The role.
 * @return {string} The formatted channel name including role.
 * @private
 */
DirectTransport.getRoledChannelName_ = function(channelName, role) {
  return channelName + '_' + role;
};


/**
 * @param {!Object} literal The literal unrenamed message.
 * @return {boolean} Whether the message was successfully delivered to a
 *     channel.
 * @private
 */
DirectTransport.messageReceivedHandler_ = function(literal) {
  var msg = DirectTransport.Message_.fromLiteral(literal);

  var channelName = msg.channelName;
  var service = msg.service;
  var payload = msg.payload;

  goog.log.fine(goog.net.xpc.logger,
      'messageReceived: channel=' + channelName +
      ', service=' + service + ', payload=' + payload);

  // Attempt to deliver message to the channel. Keep in mind that it may not
  // exist for several reasons, including but not limited to:
  //  - a malformed message
  //  - the channel simply has not been created
  //  - channel was created in a different namespace
  //  - message was sent to the wrong window
  //  - channel has become stale (e.g. caching iframes and back clicks)
  var channel = goog.net.xpc.channels[channelName];
  if (channel) {
    channel.xpcDeliver(service, payload);
    return true;
  }

  var transportMessageType = DirectTransport.parseTransportPayload_(payload)[0];

  // Check if there are any stale channel names that can be updated.
  for (var staleChannelName in goog.net.xpc.channels) {
    var staleChannel = goog.net.xpc.channels[staleChannelName];
    if (staleChannel.getRole() == CrossPageChannelRole.INNER &&
        !staleChannel.isConnected() &&
        service == goog.net.xpc.TRANSPORT_SERVICE_ &&
        transportMessageType == goog.net.xpc.SETUP) {
      // Inner peer received SETUP message but channel names did not match.
      // Start using the channel name sent from outer peer. The channel name
      // of the inner peer can easily become out of date, as iframe's and their
      // JS state get cached in many browsers upon page reload or history
      // navigation (particularly Firefox 1.5+).
      staleChannel.updateChannelNameAndCatalog(channelName);
      staleChannel.xpcDeliver(service, payload);
      return true;
    }
  }

  // Failed to find a channel to deliver this message to, so simply ignore it.
  goog.log.info(goog.net.xpc.logger, 'channel name mismatch; message ignored.');
  return false;
};


/**
 * The transport type.
 * @type {number}
 * @override
 */
DirectTransport.prototype.transportType = goog.net.xpc.TransportTypes.DIRECT;


/**
 * Handles transport service messages.
 * @param {string} payload The message content.
 * @override
 */
DirectTransport.prototype.transportServiceHandler = function(payload) {
  var transportParts = DirectTransport.parseTransportPayload_(payload);
  var transportMessageType = transportParts[0];
  var peerEndpointId = transportParts[1];
  switch (transportMessageType) {
    case goog.net.xpc.SETUP_ACK_:
      if (!this.setupAckReceived_.hasFired()) {
        this.setupAckReceived_.callback(true);
      }
      break;
    case goog.net.xpc.SETUP:
      this.sendSetupAckMessage_();
      if ((this.peerEndpointId_ != null) &&
          (this.peerEndpointId_ != peerEndpointId)) {
        // Send a new SETUP message since the peer has been replaced.
        goog.log.info(goog.net.xpc.logger,
            'Sending SETUP and changing peer ID to: ' + peerEndpointId);
        this.sendSetupMessage_();
      }
      this.peerEndpointId_ = peerEndpointId;
      break;
  }
};


/**
 * Sends a SETUP transport service message.
 * @private
 */
DirectTransport.prototype.sendSetupMessage_ = function() {
  // Although we could send real objects, since some other transports are
  // limited to strings we also keep this requirement.
  var payload = goog.net.xpc.SETUP;
  payload += DirectTransport.MESSAGE_DELIMITER_;
  payload += this.endpointId_;
  this.send(goog.net.xpc.TRANSPORT_SERVICE_, payload);
};


/**
 * Sends a SETUP_ACK transport service message.
 * @private
 */
DirectTransport.prototype.sendSetupAckMessage_ = function() {
  this.send(goog.net.xpc.TRANSPORT_SERVICE_, goog.net.xpc.SETUP_ACK_);
  if (!this.setupAckSent_.hasFired()) {
    this.setupAckSent_.callback(true);
  }
};


/** @override */
DirectTransport.prototype.connect = function() {
  var win = this.getWindow();
  if (win) {
    DirectTransport.initialize_(win);
    this.initialized_ = true;
    this.maybeAttemptToConnect_();
  } else {
    goog.log.fine(goog.net.xpc.logger, 'connect(): no window to initialize.');
  }
};


/**
 * Connects to other peer. In the case of the outer peer, the setup messages are
 * likely sent before the inner peer is ready to receive them. Therefore, this
 * function will continue trying to send the SETUP message until the inner peer
 * responds. In the case of the inner peer, it will occasionally have its
 * channel name fall out of sync with the outer peer, particularly during
 * soft-reloads and history navigations.
 * @private
 */
DirectTransport.prototype.maybeAttemptToConnect_ = function() {
  var outerRole = this.channel_.getRole() == CrossPageChannelRole.OUTER;
  if (this.channel_.isConnected()) {
    this.maybeAttemptToConnectTimer_.stop();
    return;
  }
  this.maybeAttemptToConnectTimer_.start();
  this.sendSetupMessage_();
};


/**
 * Sends a message.
 * @param {string} service The name of the service the message is to be
 *     delivered to.
 * @param {string} payload The message content.
 * @override
 */
DirectTransport.prototype.send = function(service, payload) {
  if (!this.channel_.getPeerWindowObject()) {
    goog.log.fine(goog.net.xpc.logger, 'send(): window not ready');
    return;
  }
  var channelName = DirectTransport.getRoledChannelName_(
      this.originalChannelName_,
      this.getPeerRole_());

  var message = new DirectTransport.Message_(
      channelName,
      service,
      payload);

  // Note: goog.async.nextTick doesn't support cancelling or disposal so leaving
  // as 0ms timer, though this may have performance implications.
  this.asyncSendsMap_[goog.getUid(message)] =
      Timer.callOnce(goog.bind(this.executeScheduledSend_, this, message), 0);
};


/**
 * Sends the message asyncronously.
 * @param {!DirectTransport.Message_} message The message to send.
 * @private
 */
DirectTransport.prototype.executeScheduledSend_ = function(message) {
  delete this.asyncSendsMap_[goog.getUid(message)];

  /** @preserveTry */
  try {
    var peerProxy = goog.getObjectByName(
        DirectTransport.GLOBAL_TRANPORT_PATH_,
        this.channel_.getPeerWindowObject());
  } catch (error) {
    goog.log.warning(
        goog.net.xpc.logger,
        'Can\'t access other window, ignoring.',
        error);
    return;
  }

  if (goog.isNull(peerProxy)) {
    goog.log.warning(
        goog.net.xpc.logger,
        'Peer window had no global function.');
    return;
  }

  /** @preserveTry */
  try {
    peerProxy(message.toLiteral());
    goog.log.info(
        goog.net.xpc.logger,
        'send(): channelName=' + message.channelName +
        ' service=' + message.service +
        ' payload=' + message.payload);
  } catch (error) {
    goog.log.warning(
        goog.net.xpc.logger,
        'Error performing call, ignoring.',
        error);
  }
};


/**
 * @return {goog.net.xpc.CrossPageChannelRole} The role of peer channel (either
 *     inner or outer).
 * @private
 */
DirectTransport.prototype.getPeerRole_ = function() {
  var role = this.channel_.getRole();
  return role == goog.net.xpc.CrossPageChannelRole.OUTER ?
      goog.net.xpc.CrossPageChannelRole.INNER :
      goog.net.xpc.CrossPageChannelRole.OUTER;
};


/**
 * Notifies the channel that this transport is connected.
 * @private
 */
DirectTransport.prototype.notifyConnected_ = function() {
  this.channel_.notifyConnected();
};


/** @override */
DirectTransport.prototype.disposeInternal = function() {
  if (this.initialized_) {
    var listenWindow = this.getWindow();
    var uid = goog.getUid(listenWindow);
    var value = --DirectTransport.activeCount_[uid];
    if (value == 1) {
      goog.exportSymbol(
          DirectTransport.GLOBAL_TRANPORT_PATH_,
          null,
          listenWindow);
    }
  }

  if (this.asyncSendsMap_) {
    goog.object.forEach(this.asyncSendsMap_, function(timerId) {
      Timer.clear(timerId);
    });
    this.asyncSendsMap_ = null;
  }

  // Deferred's aren't disposables.
  if (this.setupAckReceived_) {
    this.setupAckReceived_.cancel();
    delete this.setupAckReceived_;
  }
  if (this.setupAckSent_) {
    this.setupAckSent_.cancel();
    delete this.setupAckSent_;
  }
  if (this.connected_) {
    this.connected_.cancel();
    delete this.connected_;
  }

  goog.base(this, 'disposeInternal');
};


/**
 * Parses a transport service payload message.
 * @param {string} payload The payload.
 * @return {!Array.<?string>} An array with the message type as the first member
 *     and the endpoint id as the second, if one was sent, or null otherwise.
 * @private
 */
DirectTransport.parseTransportPayload_ = function(payload) {
  var transportParts = /** @type {!Array.<?string>} */ (payload.split(
      DirectTransport.MESSAGE_DELIMITER_));
  transportParts[1] = transportParts[1] || null; // Usually endpointId.
  return transportParts;
};



/**
 * Message container that gets passed back and forth between windows.
 * @param {string} channelName The channel name to tranport messages on.
 * @param {string} service The service to send the payload to.
 * @param {string} payload The payload to send.
 * @constructor
 * @struct
 * @private
 */
DirectTransport.Message_ = function(channelName, service, payload) {
  /**
   * The name of the channel.
   * @type {string}
   */
  this.channelName = channelName;

  /**
   * The service on the channel.
   * @type {string}
   */
  this.service = service;

  /**
   * The payload.
   * @type {string}
   */
  this.payload = payload;
};


/**
 * Converts a message to a literal object.
 * @return {!Object} The message as a literal object.
 */
DirectTransport.Message_.prototype.toLiteral = function() {
  return {
    'channelName': this.channelName,
    'service': this.service,
    'payload': this.payload
  };
};


/**
 * Creates a Message_ from a literal object.
 * @param {!Object} literal The literal to convert to Message.
 * @return {!DirectTransport.Message_} The Message.
 */
DirectTransport.Message_.fromLiteral = function(literal) {
  return new DirectTransport.Message_(
      literal['channelName'],
      literal['service'],
      literal['payload']);
};

});  // goog.scope

//javascript/closure/net/xpc/frameelementmethodtransport.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Contains the frame element method transport for cross-domain
 * communication. It exploits the fact that FF lets a page in an
 * iframe call a method on the iframe-element it is contained in, even if the
 * containing page is from a different domain.
 *
 * @author mibuerge@google.com (Michael Buerge)
 */


goog.provide('goog.net.xpc.FrameElementMethodTransport');

goog.require('goog.log');
goog.require('goog.net.xpc');
goog.require('goog.net.xpc.CrossPageChannelRole');
goog.require('goog.net.xpc.Transport');
goog.require('goog.net.xpc.TransportTypes');



/**
 * Frame-element method transport.
 *
 * Firefox allows a document within an iframe to call methods on the
 * iframe-element added by the containing document.
 * NOTE(mibuerge): Tested in all FF versions starting from 1.0
 *
 * @param {goog.net.xpc.CrossPageChannel} channel The channel this transport
 *     belongs to.
 * @param {goog.dom.DomHelper=} opt_domHelper The dom helper to use for finding
 *     the correct window.
 * @constructor
 * @extends {goog.net.xpc.Transport}
 * @final
 */
goog.net.xpc.FrameElementMethodTransport = function(channel, opt_domHelper) {
  goog.base(this, opt_domHelper);

  /**
   * The channel this transport belongs to.
   * @type {goog.net.xpc.CrossPageChannel}
   * @private
   */
  this.channel_ = channel;

  // To transfer messages, this transport basically uses normal function calls,
  // which are synchronous. To avoid endless recursion, the delivery has to
  // be artificially made asynchronous.

  /**
   * Array for queued messages.
   * @type {Array}
   * @private
   */
  this.queue_ = [];

  /**
   * Callback function which wraps deliverQueued_.
   * @type {Function}
   * @private
   */
  this.deliverQueuedCb_ = goog.bind(this.deliverQueued_, this);
};
goog.inherits(goog.net.xpc.FrameElementMethodTransport, goog.net.xpc.Transport);


/**
 * The transport type.
 * @type {number}
 * @protected
 * @override
 */
goog.net.xpc.FrameElementMethodTransport.prototype.transportType =
    goog.net.xpc.TransportTypes.FRAME_ELEMENT_METHOD;


/**
 * Flag used to enforce asynchronous messaging semantics.
 * @type {boolean}
 * @private
 */
goog.net.xpc.FrameElementMethodTransport.prototype.recursive_ = false;


/**
 * Timer used to enforce asynchronous message delivery.
 * @type {number}
 * @private
 */
goog.net.xpc.FrameElementMethodTransport.prototype.timer_ = 0;


/**
 * Holds the function to send messages to the peer
 * (once it becomes available).
 * @type {Function}
 * @private
 */
goog.net.xpc.FrameElementMethodTransport.outgoing_ = null;


/**
 * Connect this transport.
 * @override
 */
goog.net.xpc.FrameElementMethodTransport.prototype.connect = function() {
  if (this.channel_.getRole() == goog.net.xpc.CrossPageChannelRole.OUTER) {
    // get shortcut to iframe-element
    this.iframeElm_ = this.channel_.getIframeElement();

    // add the gateway function to the iframe-element
    // (to be called by the peer)
    this.iframeElm_['XPC_toOuter'] = goog.bind(this.incoming_, this);

    // at this point we just have to wait for a notification from the peer...

  } else {
    this.attemptSetup_();
  }
};


/**
 * Only used from within an iframe. Attempts to attach the method
 * to be used for sending messages by the containing document. Has to
 * wait until the containing document has finished. Therefore calls
 * itself in a timeout if not successful.
 * @private
 */
goog.net.xpc.FrameElementMethodTransport.prototype.attemptSetup_ = function() {
  var retry = true;
  /** @preserveTry */
  try {
    if (!this.iframeElm_) {
      // throws security exception when called too early
      this.iframeElm_ = this.getWindow().frameElement;
    }
    // check if iframe-element and the gateway-function to the
    // outer-frame are present
    // TODO(mibuerge) Make sure the following code doesn't throw any exceptions
    if (this.iframeElm_ && this.iframeElm_['XPC_toOuter']) {
      // get a reference to the gateway function
      this.outgoing_ = this.iframeElm_['XPC_toOuter'];
      // attach the gateway function the other document will use
      this.iframeElm_['XPC_toOuter']['XPC_toInner'] =
          goog.bind(this.incoming_, this);
      // stop retrying
      retry = false;
      // notify outer frame
      this.send(goog.net.xpc.TRANSPORT_SERVICE_, goog.net.xpc.SETUP_ACK_);
      // notify channel that the transport is ready
      this.channel_.notifyConnected();
    }
  }
  catch (e) {
    goog.log.error(goog.net.xpc.logger,
        'exception caught while attempting setup: ' + e);
  }
  // retry necessary?
  if (retry) {
    if (!this.attemptSetupCb_) {
      this.attemptSetupCb_ = goog.bind(this.attemptSetup_, this);
    }
    this.getWindow().setTimeout(this.attemptSetupCb_, 100);
  }
};


/**
 * Handles transport service messages.
 * @param {string} payload The message content.
 * @override
 */
goog.net.xpc.FrameElementMethodTransport.prototype.transportServiceHandler =
    function(payload) {
  if (this.channel_.getRole() == goog.net.xpc.CrossPageChannelRole.OUTER &&
      !this.channel_.isConnected() && payload == goog.net.xpc.SETUP_ACK_) {
    // get a reference to the gateway function
    this.outgoing_ = this.iframeElm_['XPC_toOuter']['XPC_toInner'];
    // notify the channel we're ready
    this.channel_.notifyConnected();
  } else {
    throw Error('Got unexpected transport message.');
  }
};


/**
 * Process incoming message.
 * @param {string} serviceName The name of the service the message is to be
 * delivered to.
 * @param {string} payload The message to process.
 * @private
 */
goog.net.xpc.FrameElementMethodTransport.prototype.incoming_ =
    function(serviceName, payload) {
  if (!this.recursive_ && this.queue_.length == 0) {
    this.channel_.xpcDeliver(serviceName, payload);
  }
  else {
    this.queue_.push({serviceName: serviceName, payload: payload});
    if (this.queue_.length == 1) {
      this.timer_ = this.getWindow().setTimeout(this.deliverQueuedCb_, 1);
    }
  }
};


/**
 * Delivers queued messages.
 * @private
 */
goog.net.xpc.FrameElementMethodTransport.prototype.deliverQueued_ =
    function() {
  while (this.queue_.length) {
    var msg = this.queue_.shift();
    this.channel_.xpcDeliver(msg.serviceName, msg.payload);
  }
};


/**
 * Send a message
 * @param {string} service The name off the service the message is to be
 * delivered to.
 * @param {string} payload The message content.
 * @override
 */
goog.net.xpc.FrameElementMethodTransport.prototype.send =
    function(service, payload) {
  this.recursive_ = true;
  this.outgoing_(service, payload);
  this.recursive_ = false;
};


/** @override */
goog.net.xpc.FrameElementMethodTransport.prototype.disposeInternal =
    function() {
  goog.net.xpc.FrameElementMethodTransport.superClass_.disposeInternal.call(
      this);
  this.outgoing_ = null;
  this.iframeElm_ = null;
};

//javascript/closure/net/xpc/iframepollingtransport.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Contains the iframe polling transport.
 * @author mibuerge@google.com (Michael Buerge)
 */


goog.provide('goog.net.xpc.IframePollingTransport');
goog.provide('goog.net.xpc.IframePollingTransport.Receiver');
goog.provide('goog.net.xpc.IframePollingTransport.Sender');

goog.require('goog.array');
goog.require('goog.dom');
goog.require('goog.log');
goog.require('goog.log.Level');
goog.require('goog.net.xpc');
goog.require('goog.net.xpc.CfgFields');
goog.require('goog.net.xpc.CrossPageChannelRole');
goog.require('goog.net.xpc.Transport');
goog.require('goog.net.xpc.TransportTypes');
goog.require('goog.userAgent');



/**
 * Iframe polling transport. Uses hidden iframes to transfer data
 * in the fragment identifier of the URL. The peer polls the iframe's location
 * for changes.
 * Unfortunately, in Safari this screws up the history, because Safari doesn't
 * allow to call location.replace() on a window containing a document from a
 * different domain (last version tested: 2.0.4).
 *
 * @param {goog.net.xpc.CrossPageChannel} channel The channel this
 *     transport belongs to.
 * @param {goog.dom.DomHelper=} opt_domHelper The dom helper to use for finding
 *     the correct window.
 * @constructor
 * @extends {goog.net.xpc.Transport}
 * @final
 */
goog.net.xpc.IframePollingTransport = function(channel, opt_domHelper) {
  goog.base(this, opt_domHelper);

  /**
   * The channel this transport belongs to.
   * @type {goog.net.xpc.CrossPageChannel}
   * @private
   */
  this.channel_ = channel;

  /**
   * The URI used to send messages.
   * @type {string}
   * @private
   */
  this.sendUri_ =
      this.channel_.getConfig()[goog.net.xpc.CfgFields.PEER_POLL_URI];

  /**
   * The URI which is polled for incoming messages.
   * @type {string}
   * @private
   */
  this.rcvUri_ =
      this.channel_.getConfig()[goog.net.xpc.CfgFields.LOCAL_POLL_URI];

  /**
   * The queue to hold messages which can't be sent immediately.
   * @type {Array}
   * @private
   */
  this.sendQueue_ = [];
};
goog.inherits(goog.net.xpc.IframePollingTransport, goog.net.xpc.Transport);


/**
 * The number of times the inner frame will check for evidence of the outer
 * frame before it tries its reconnection sequence.  These occur at 100ms
 * intervals, making this an effective max waiting period of 500ms.
 * @type {number}
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.pollsBeforeReconnect_ = 5;


/**
 * The transport type.
 * @type {number}
 * @protected
 * @override
 */
goog.net.xpc.IframePollingTransport.prototype.transportType =
    goog.net.xpc.TransportTypes.IFRAME_POLLING;


/**
 * Sequence counter.
 * @type {number}
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.sequence_ = 0;


/**
 * Flag indicating whether we are waiting for an acknoledgement.
 * @type {boolean}
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.waitForAck_ = false;


/**
 * Flag indicating if channel has been initialized.
 * @type {boolean}
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.initialized_ = false;


/**
 * Reconnection iframe created by inner peer.
 * @type {Element}
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.reconnectFrame_ = null;


/**
 * The string used to prefix all iframe names and IDs.
 * @type {string}
 */
goog.net.xpc.IframePollingTransport.IFRAME_PREFIX = 'googlexpc';


/**
 * Returns the name/ID of the message frame.
 * @return {string} Name of message frame.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.getMsgFrameName_ = function() {
  return goog.net.xpc.IframePollingTransport.IFRAME_PREFIX + '_' +
      this.channel_.name + '_msg';
};


/**
 * Returns the name/ID of the ack frame.
 * @return {string} Name of ack frame.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.getAckFrameName_ = function() {
  return goog.net.xpc.IframePollingTransport.IFRAME_PREFIX + '_' +
      this.channel_.name + '_ack';
};


/**
 * Determines whether the channel is still available. The channel is
 * unavailable if the transport was disposed or the peer is no longer
 * available.
 * @return {boolean} Whether the channel is available.
 */
goog.net.xpc.IframePollingTransport.prototype.isChannelAvailable = function() {
  return !this.isDisposed() && this.channel_.isPeerAvailable();
};


/**
 * Safely retrieves the frames from the peer window. If an error is thrown
 * (e.g. the window is closing) an empty frame object is returned.
 * @return {!Object.<!Window>} The frames from the peer window.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.getPeerFrames_ = function() {
  try {
    if (this.isChannelAvailable()) {
      return this.channel_.getPeerWindowObject().frames || {};
    }
  } catch (e) {
    // An error may be thrown if the window is closing.
    goog.log.fine(goog.net.xpc.logger, 'error retrieving peer frames');
  }
  return {};
};


/**
 * Safely retrieves the peer frame with the specified name.
 * @param {string} frameName The name of the peer frame to retrieve.
 * @return {Window} The peer frame with the specified name.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.getPeerFrame_ = function(
    frameName) {
  return this.getPeerFrames_()[frameName];
};


/**
 * Connects this transport.
 * @override
 */
goog.net.xpc.IframePollingTransport.prototype.connect = function() {
  if (!this.isChannelAvailable()) {
    // When the channel is unavailable there is no peer to poll so stop trying
    // to connect.
    return;
  }

  goog.log.fine(goog.net.xpc.logger, 'transport connect called');
  if (!this.initialized_) {
    goog.log.fine(goog.net.xpc.logger, 'initializing...');
    this.constructSenderFrames_();
    this.initialized_ = true;
  }
  this.checkForeignFramesReady_();
};


/**
 * Creates the iframes which are used to send messages (and acknowledgements)
 * to the peer. Sender iframes contain a document from a different origin and
 * therefore their content can't be accessed.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.constructSenderFrames_ =
    function() {
  var name = this.getMsgFrameName_();
  this.msgIframeElm_ = this.constructSenderFrame_(name);
  this.msgWinObj_ = this.getWindow().frames[name];

  name = this.getAckFrameName_();
  this.ackIframeElm_ = this.constructSenderFrame_(name);
  this.ackWinObj_ = this.getWindow().frames[name];
};


/**
 * Constructs a sending frame the the given id.
 * @param {string} id The id.
 * @return {Element} The constructed frame.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.constructSenderFrame_ =
    function(id) {
  goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
      'constructing sender frame: ' + id);
  var ifr = goog.dom.createElement('iframe');
  var s = ifr.style;
  s.position = 'absolute';
  s.top = '-10px'; s.left = '10px'; s.width = '1px'; s.height = '1px';
  ifr.id = ifr.name = id;
  ifr.src = this.sendUri_ + '#INITIAL';
  this.getWindow().document.body.appendChild(ifr);
  return ifr;
};


/**
 * The protocol for reconnecting is for the inner frame to change channel
 * names, and then communicate the new channel name to the outer peer.
 * The outer peer looks in a predefined location for the channel name
 * upate. It is important to use a completely new channel name, as this
 * will ensure that all messaging iframes are not in the bfcache.
 * Otherwise, Safari may pollute the history when modifying the location
 * of bfcached iframes.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.maybeInnerPeerReconnect_ =
    function() {
  // Reconnection has been found to not function on some browsers (eg IE7), so
  // it's important that the mechanism only be triggered as a last resort.  As
  // such, we poll a number of times to find the outer iframe before triggering
  // it.
  if (this.reconnectFrame_ || this.pollsBeforeReconnect_-- > 0) {
    return;
  }

  goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
      'Inner peer reconnect triggered.');
  this.channel_.updateChannelNameAndCatalog(goog.net.xpc.getRandomString(10));
  goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
      'switching channels: ' + this.channel_.name);
  this.deconstructSenderFrames_();
  this.initialized_ = false;
  // Communicate new channel name to outer peer.
  this.reconnectFrame_ = this.constructSenderFrame_(
      goog.net.xpc.IframePollingTransport.IFRAME_PREFIX +
          '_reconnect_' + this.channel_.name);
};


/**
 * Scans inner peer for a reconnect message, which will be used to update
 * the outer peer's channel name. If a reconnect message is found, the
 * sender frames will be cleaned up to make way for the new sender frames.
 * Only called by the outer peer.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.outerPeerReconnect_ = function() {
  goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
      'outerPeerReconnect called');
  var frames = this.getPeerFrames_();
  var length = frames.length;
  for (var i = 0; i < length; i++) {
    var frameName;
    try {
      if (frames[i] && frames[i].name) {
        frameName = frames[i].name;
      }
    } catch (e) {
      // Do nothing.
    }
    if (!frameName) {
      continue;
    }
    var message = frameName.split('_');
    if (message.length == 3 &&
        message[0] == goog.net.xpc.IframePollingTransport.IFRAME_PREFIX &&
        message[1] == 'reconnect') {
      // This is a legitimate reconnect message from the peer. Start using
      // the peer provided channel name, and start a connection over from
      // scratch.
      this.channel_.name = message[2];
      this.deconstructSenderFrames_();
      this.initialized_ = false;
      break;
    }
  }
};


/**
 * Cleans up the existing sender frames owned by this peer. Only called by
 * the outer peer.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.deconstructSenderFrames_ =
    function() {
  goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
      'deconstructSenderFrames called');
  if (this.msgIframeElm_) {
    this.msgIframeElm_.parentNode.removeChild(this.msgIframeElm_);
    this.msgIframeElm_ = null;
    this.msgWinObj_ = null;
  }
  if (this.ackIframeElm_) {
    this.ackIframeElm_.parentNode.removeChild(this.ackIframeElm_);
    this.ackIframeElm_ = null;
    this.ackWinObj_ = null;
  }
};


/**
 * Checks if the frames in the peer's page are ready. These contain a
 * document from the own domain and are the ones messages are received through.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.checkForeignFramesReady_ =
    function() {
  // check if the connected iframe ready
  if (!(this.isRcvFrameReady_(this.getMsgFrameName_()) &&
        this.isRcvFrameReady_(this.getAckFrameName_()))) {
    goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
        'foreign frames not (yet) present');

    if (this.channel_.getRole() == goog.net.xpc.CrossPageChannelRole.INNER) {
      // The outer peer might need a short time to get its frames ready, as
      // CrossPageChannel prevents them from getting created until the inner
      // peer's frame has thrown its loaded event.  This method is a noop for
      // the first few times it's called, and then allows the reconnection
      // sequence to begin.
      this.maybeInnerPeerReconnect_();
    } else if (this.channel_.getRole() ==
               goog.net.xpc.CrossPageChannelRole.OUTER) {
      // The inner peer is either not loaded yet, or the receiving
      // frames are simply missing. Since we cannot discern the two cases, we
      // should scan for a reconnect message from the inner peer.
      this.outerPeerReconnect_();
    }

    // start a timer to check again
    this.getWindow().setTimeout(goog.bind(this.connect, this), 100);
  } else {
    goog.log.fine(goog.net.xpc.logger, 'foreign frames present');

    // Create receivers.
    this.msgReceiver_ = new goog.net.xpc.IframePollingTransport.Receiver(
        this,
        this.getPeerFrame_(this.getMsgFrameName_()),
        goog.bind(this.processIncomingMsg, this));
    this.ackReceiver_ = new goog.net.xpc.IframePollingTransport.Receiver(
        this,
        this.getPeerFrame_(this.getAckFrameName_()),
        goog.bind(this.processIncomingAck, this));

    this.checkLocalFramesPresent_();
  }
};


/**
 * Checks if the receiving frame is ready.
 * @param {string} frameName Which receiving frame to check.
 * @return {boolean} Whether the receiving frame is ready.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.isRcvFrameReady_ =
    function(frameName) {
  goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
      'checking for receive frame: ' + frameName);
  /** @preserveTry */
  try {
    var winObj = this.getPeerFrame_(frameName);
    if (!winObj || winObj.location.href.indexOf(this.rcvUri_) != 0) {
      return false;
    }
  } catch (e) {
    return false;
  }
  return true;
};


/**
 * Checks if the iframes created in the own document are ready.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.checkLocalFramesPresent_ =
    function() {

  // Are the sender frames ready?
  // These contain a document from the peer's domain, therefore we can only
  // check if the frame itself is present.
  var frames = this.getPeerFrames_();
  if (!(frames[this.getAckFrameName_()] &&
        frames[this.getMsgFrameName_()])) {
    // start a timer to check again
    if (!this.checkLocalFramesPresentCb_) {
      this.checkLocalFramesPresentCb_ = goog.bind(
          this.checkLocalFramesPresent_, this);
    }
    this.getWindow().setTimeout(this.checkLocalFramesPresentCb_, 100);
    goog.log.fine(goog.net.xpc.logger, 'local frames not (yet) present');
  } else {
    // Create senders.
    this.msgSender_ = new goog.net.xpc.IframePollingTransport.Sender(
        this.sendUri_, this.msgWinObj_);
    this.ackSender_ = new goog.net.xpc.IframePollingTransport.Sender(
        this.sendUri_, this.ackWinObj_);

    goog.log.fine(goog.net.xpc.logger, 'local frames ready');

    this.getWindow().setTimeout(goog.bind(function() {
      this.msgSender_.send(goog.net.xpc.SETUP);
      this.sentConnectionSetup_ = true;
      this.waitForAck_ = true;
      goog.log.fine(goog.net.xpc.logger, 'SETUP sent');
    }, this), 100);
  }
};


/**
 * Check if connection is ready.
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.checkIfConnected_ = function() {
  if (this.sentConnectionSetupAck_ && this.rcvdConnectionSetupAck_) {
    this.channel_.notifyConnected();

    if (this.deliveryQueue_) {
      goog.log.fine(goog.net.xpc.logger, 'delivering queued messages ' +
          '(' + this.deliveryQueue_.length + ')');

      for (var i = 0, m; i < this.deliveryQueue_.length; i++) {
        m = this.deliveryQueue_[i];
        this.channel_.xpcDeliver(m.service, m.payload);
      }
      delete this.deliveryQueue_;
    }
  } else {
    goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
        'checking if connected: ' +
        'ack sent:' + this.sentConnectionSetupAck_ +
        ', ack rcvd: ' + this.rcvdConnectionSetupAck_);
  }
};


/**
 * Processes an incoming message.
 * @param {string} raw The complete received string.
 */
goog.net.xpc.IframePollingTransport.prototype.processIncomingMsg =
    function(raw) {
  goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
      'msg received: ' + raw);

  if (raw == goog.net.xpc.SETUP) {
    if (!this.ackSender_) {
      // Got SETUP msg, but we can't send an ack.
      return;
    }

    this.ackSender_.send(goog.net.xpc.SETUP_ACK_);
    goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST, 'SETUP_ACK sent');

    this.sentConnectionSetupAck_ = true;
    this.checkIfConnected_();

  } else if (this.channel_.isConnected() || this.sentConnectionSetupAck_) {

    var pos = raw.indexOf('|');
    var head = raw.substring(0, pos);
    var frame = raw.substring(pos + 1);

    // check if it is a framed message
    pos = head.indexOf(',');
    if (pos == -1) {
      var seq = head;
      // send acknowledgement
      this.ackSender_.send('ACK:' + seq);
      this.deliverPayload_(frame);
    } else {
      var seq = head.substring(0, pos);
      // send acknowledgement
      this.ackSender_.send('ACK:' + seq);

      var partInfo = head.substring(pos + 1).split('/');
      var part0 = parseInt(partInfo[0], 10);
      var part1 = parseInt(partInfo[1], 10);
      // create an array to accumulate the parts if this is the
      // first frame of a message
      if (part0 == 1) {
        this.parts_ = [];
      }
      this.parts_.push(frame);
      // deliver the message if this was the last frame of a message
      if (part0 == part1) {
        this.deliverPayload_(this.parts_.join(''));
        delete this.parts_;
      }
    }
  } else {
    goog.log.warning(goog.net.xpc.logger,
        'received msg, but channel is not connected');
  }
};


/**
 * Process an incoming acknowdedgement.
 * @param {string} msgStr The incoming ack string to process.
 */
goog.net.xpc.IframePollingTransport.prototype.processIncomingAck =
    function(msgStr) {
  goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
      'ack received: ' + msgStr);

  if (msgStr == goog.net.xpc.SETUP_ACK_) {
    this.waitForAck_ = false;
    this.rcvdConnectionSetupAck_ = true;
    // send the next frame
    this.checkIfConnected_();

  } else if (this.channel_.isConnected()) {
    if (!this.waitForAck_) {
      goog.log.warning(goog.net.xpc.logger, 'got unexpected ack');
      return;
    }

    var seq = parseInt(msgStr.split(':')[1], 10);
    if (seq == this.sequence_) {
      this.waitForAck_ = false;
      this.sendNextFrame_();
    } else {
      goog.log.warning(goog.net.xpc.logger, 'got ack with wrong sequence');
    }
  } else {
    goog.log.warning(goog.net.xpc.logger,
        'received ack, but channel not connected');
  }
};


/**
 * Sends a frame (message part).
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.sendNextFrame_ = function() {
  // do nothing if we are waiting for an acknowledgement or the
  // queue is emtpy
  if (this.waitForAck_ || !this.sendQueue_.length) {
    return;
  }

  var s = this.sendQueue_.shift();
  ++this.sequence_;
  this.msgSender_.send(this.sequence_ + s);
  goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
      'msg sent: ' + this.sequence_ + s);


  this.waitForAck_ = true;
};


/**
 * Delivers a message.
 * @param {string} s The complete message string ("<service_name>:<payload>").
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.deliverPayload_ = function(s) {
  // determine the service name and the payload
  var pos = s.indexOf(':');
  var service = s.substr(0, pos);
  var payload = s.substring(pos + 1);

  // deliver the message
  if (!this.channel_.isConnected()) {
    // as valid messages can come in before a SETUP_ACK has
    // been received (because subchannels for msgs and acks are independent),
    // delay delivery of early messages until after 'connect'-event
    (this.deliveryQueue_ || (this.deliveryQueue_ = [])).
        push({service: service, payload: payload});
    goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
        'queued delivery');
  } else {
    this.channel_.xpcDeliver(service, payload);
  }
};


// ---- send message ----


/**
 * Maximal frame length.
 * @type {number}
 * @private
 */
goog.net.xpc.IframePollingTransport.prototype.MAX_FRAME_LENGTH_ = 3800;


/**
 * Sends a message. Splits it in multiple frames if too long (exceeds IE's
 * URL-length maximum.
 * Wireformat: <seq>[,<frame_no>/<#frames>]|<frame_content>
 *
 * @param {string} service Name of service this the message has to be delivered.
 * @param {string} payload The message content.
 * @override
 */
goog.net.xpc.IframePollingTransport.prototype.send =
    function(service, payload) {
  var frame = service + ':' + payload;
  // put in queue
  if (!goog.userAgent.IE || payload.length <= this.MAX_FRAME_LENGTH_) {
    this.sendQueue_.push('|' + frame);
  }
  else {
    var l = payload.length;
    var num = Math.ceil(l / this.MAX_FRAME_LENGTH_); // number of frames
    var pos = 0;
    var i = 1;
    while (pos < l) {
      this.sendQueue_.push(',' + i + '/' + num + '|' +
                           frame.substr(pos, this.MAX_FRAME_LENGTH_));
      i++;
      pos += this.MAX_FRAME_LENGTH_;
    }
  }
  this.sendNextFrame_();
};


/** @override */
goog.net.xpc.IframePollingTransport.prototype.disposeInternal = function() {
  goog.base(this, 'disposeInternal');

  var receivers = goog.net.xpc.IframePollingTransport.receivers_;
  goog.array.remove(receivers, this.msgReceiver_);
  goog.array.remove(receivers, this.ackReceiver_);
  this.msgReceiver_ = this.ackReceiver_ = null;

  goog.dom.removeNode(this.msgIframeElm_);
  goog.dom.removeNode(this.ackIframeElm_);
  this.msgIframeElm_ = this.ackIframeElm_ = null;
  this.msgWinObj_ = this.ackWinObj_ = null;
};


/**
 * Array holding all Receiver-instances.
 * @type {Array.<goog.net.xpc.IframePollingTransport.Receiver>}
 * @private
 */
goog.net.xpc.IframePollingTransport.receivers_ = [];


/**
 * Short polling interval.
 * @type {number}
 * @private
 */
goog.net.xpc.IframePollingTransport.TIME_POLL_SHORT_ = 10;


/**
 * Long polling interval.
 * @type {number}
 * @private
 */
goog.net.xpc.IframePollingTransport.TIME_POLL_LONG_ = 100;


/**
 * Period how long to use TIME_POLL_SHORT_ before raising polling-interval
 * to TIME_POLL_LONG_ after an activity.
 * @type {number}
 * @private
 */
goog.net.xpc.IframePollingTransport.TIME_SHORT_POLL_AFTER_ACTIVITY_ =
    1000;


/**
 * Polls all receivers.
 * @private
 */
goog.net.xpc.IframePollingTransport.receive_ = function() {
  var receivers = goog.net.xpc.IframePollingTransport.receivers_;
  var receiver;
  var rcvd = false;

  /** @preserveTry */
  try {
    for (var i = 0; receiver = receivers[i]; i++) {
      rcvd = rcvd || receiver.receive();
    }
  } catch (e) {
    goog.log.info(goog.net.xpc.logger, 'receive_() failed: ' + e);

    // Notify the channel that the transport had an error.
    receiver.transport_.channel_.notifyTransportError();

    // notifyTransportError() closes the channel and disposes the transport.
    // If there are no other channels present, this.receivers_ will now be empty
    // and there is no need to keep polling.
    if (!receivers.length) {
      return;
    }
  }

  var now = goog.now();
  if (rcvd) {
    goog.net.xpc.IframePollingTransport.lastActivity_ = now;
  }

  // Schedule next check.
  var t = now - goog.net.xpc.IframePollingTransport.lastActivity_ <
      goog.net.xpc.IframePollingTransport.TIME_SHORT_POLL_AFTER_ACTIVITY_ ?
      goog.net.xpc.IframePollingTransport.TIME_POLL_SHORT_ :
      goog.net.xpc.IframePollingTransport.TIME_POLL_LONG_;
  goog.net.xpc.IframePollingTransport.rcvTimer_ = window.setTimeout(
      goog.net.xpc.IframePollingTransport.receiveCb_, t);
};


/**
 * Callback that wraps receive_ to be used in timers.
 * @type {Function}
 * @private
 */
goog.net.xpc.IframePollingTransport.receiveCb_ = goog.bind(
    goog.net.xpc.IframePollingTransport.receive_,
    goog.net.xpc.IframePollingTransport);


/**
 * Starts the polling loop.
 * @private
 */
goog.net.xpc.IframePollingTransport.startRcvTimer_ = function() {
  goog.log.fine(goog.net.xpc.logger, 'starting receive-timer');
  goog.net.xpc.IframePollingTransport.lastActivity_ = goog.now();
  if (goog.net.xpc.IframePollingTransport.rcvTimer_) {
    window.clearTimeout(goog.net.xpc.IframePollingTransport.rcvTimer_);
  }
  goog.net.xpc.IframePollingTransport.rcvTimer_ = window.setTimeout(
      goog.net.xpc.IframePollingTransport.receiveCb_,
      goog.net.xpc.IframePollingTransport.TIME_POLL_SHORT_);
};



/**
 * goog.net.xpc.IframePollingTransport.Sender
 *
 * Utility class to send message-parts to a document from a different origin.
 *
 * @constructor
 * @param {string} url The url the other document will use for polling.
 * @param {Object} windowObj The frame used for sending information to.
 * @final
 */
goog.net.xpc.IframePollingTransport.Sender = function(url, windowObj) {
  /**
   * The URI used to sending messages.
   * @type {string}
   * @private
   */
  this.sendUri_ = url;

  /**
   * The window object of the iframe used to send messages.
   * The script instantiating the Sender won't have access to
   * the content of sendFrame_.
   * @type {Object}
   * @private
   */
  this.sendFrame_ = windowObj;

  /**
   * Cycle counter (used to make sure that sending two identical messages sent
   * in direct succession can be recognized as such by the receiver).
   * @type {number}
   * @private
   */
  this.cycle_ = 0;
};


/**
 * Sends a message-part (frame) to the peer.
 * The message-part is encoded and put in the fragment identifier
 * of the URL used for sending (and belongs to the origin/domain of the peer).
 * @param {string} payload The message to send.
 */
goog.net.xpc.IframePollingTransport.Sender.prototype.send = function(payload) {
  this.cycle_ = ++this.cycle_ % 2;

  var url = this.sendUri_ + '#' + this.cycle_ + encodeURIComponent(payload);

  // TODO(mibuerge) Find out if try/catch is still needed
  /** @preserveTry */
  try {
    // safari doesn't allow to call location.replace()
    if (goog.userAgent.WEBKIT) {
      this.sendFrame_.location.href = url;
    } else {
      this.sendFrame_.location.replace(url);
    }
  } catch (e) {
    goog.log.error(goog.net.xpc.logger, 'sending failed', e);
  }

  // Restart receiver timer on short polling interval, to support use-cases
  // where we need to capture responses quickly.
  goog.net.xpc.IframePollingTransport.startRcvTimer_();
};



/**
 * goog.net.xpc.IframePollingTransport.Receiver
 *
 * @constructor
 * @param {goog.net.xpc.IframePollingTransport} transport The transport to
 *     receive from.
 * @param {Object} windowObj The window-object to poll for location-changes.
 * @param {Function} callback The callback-function to be called when
 *     location has changed.
 * @final
 */
goog.net.xpc.IframePollingTransport.Receiver = function(transport,
                                                        windowObj,
                                                        callback) {
  /**
   * The transport to receive from.
   * @type {goog.net.xpc.IframePollingTransport}
   * @private
   */
  this.transport_ = transport;
  this.rcvFrame_ = windowObj;

  this.cb_ = callback;
  this.currentLoc_ = this.rcvFrame_.location.href.split('#')[0] + '#INITIAL';

  goog.net.xpc.IframePollingTransport.receivers_.push(this);
  goog.net.xpc.IframePollingTransport.startRcvTimer_();
};


/**
 * Polls the location of the receiver-frame for changes.
 * @return {boolean} Whether a change has been detected.
 */
goog.net.xpc.IframePollingTransport.Receiver.prototype.receive = function() {
  var loc = this.rcvFrame_.location.href;

  if (loc != this.currentLoc_) {
    this.currentLoc_ = loc;
    var payload = loc.split('#')[1];
    if (payload) {
      payload = payload.substr(1); // discard first character (cycle)
      this.cb_(decodeURIComponent(payload));
    }
    return true;
  } else {
    return false;
  }
};

//javascript/closure/net/xpc/iframerelaytransport.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Contains the iframe relay tranport.
 * @author mibuerge@google.com (Michael Buerge)
 */


goog.provide('goog.net.xpc.IframeRelayTransport');

goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.log');
goog.require('goog.log.Level');
goog.require('goog.net.xpc');
goog.require('goog.net.xpc.CfgFields');
goog.require('goog.net.xpc.Transport');
goog.require('goog.net.xpc.TransportTypes');
goog.require('goog.string');
goog.require('goog.userAgent');



/**
 * Iframe relay transport. Creates hidden iframes containing a document
 * from the peer's origin. Data is transferred in the fragment identifier.
 * Therefore the document loaded in the iframes can be served from the
 * browser's cache.
 *
 * @param {goog.net.xpc.CrossPageChannel} channel The channel this
 *     transport belongs to.
 * @param {goog.dom.DomHelper=} opt_domHelper The dom helper to use for finding
 *     the correct window.
 * @constructor
 * @extends {goog.net.xpc.Transport}
 * @final
 */
goog.net.xpc.IframeRelayTransport = function(channel, opt_domHelper) {
  goog.base(this, opt_domHelper);

  /**
   * The channel this transport belongs to.
   * @type {goog.net.xpc.CrossPageChannel}
   * @private
   */
  this.channel_ = channel;

  /**
   * The URI used to relay data to the peer.
   * @type {string}
   * @private
   */
  this.peerRelayUri_ =
      this.channel_.getConfig()[goog.net.xpc.CfgFields.PEER_RELAY_URI];

  /**
   * The id of the iframe the peer page lives in.
   * @type {string}
   * @private
   */
  this.peerIframeId_ =
      this.channel_.getConfig()[goog.net.xpc.CfgFields.IFRAME_ID];

  if (goog.userAgent.WEBKIT) {
    goog.net.xpc.IframeRelayTransport.startCleanupTimer_();
  }
};
goog.inherits(goog.net.xpc.IframeRelayTransport, goog.net.xpc.Transport);


if (goog.userAgent.WEBKIT) {
  /**
   * Array to keep references to the relay-iframes. Used only if
   * there is no way to detect when the iframes are loaded. In that
   * case the relay-iframes are removed after a timeout.
   * @type {Array.<Object>}
   * @private
   */
  goog.net.xpc.IframeRelayTransport.iframeRefs_ = [];


  /**
   * Interval at which iframes are destroyed.
   * @type {number}
   * @private
   */
  goog.net.xpc.IframeRelayTransport.CLEANUP_INTERVAL_ = 1000;


  /**
   * Time after which a relay-iframe is destroyed.
   * @type {number}
   * @private
   */
  goog.net.xpc.IframeRelayTransport.IFRAME_MAX_AGE_ = 3000;


  /**
   * The cleanup timer id.
   * @type {number}
   * @private
   */
  goog.net.xpc.IframeRelayTransport.cleanupTimer_ = 0;


  /**
   * Starts the cleanup timer.
   * @private
   */
  goog.net.xpc.IframeRelayTransport.startCleanupTimer_ = function() {
    if (!goog.net.xpc.IframeRelayTransport.cleanupTimer_) {
      goog.net.xpc.IframeRelayTransport.cleanupTimer_ = window.setTimeout(
          function() { goog.net.xpc.IframeRelayTransport.cleanup_(); },
          goog.net.xpc.IframeRelayTransport.CLEANUP_INTERVAL_);
    }
  };


  /**
   * Remove all relay-iframes which are older than the maximal age.
   * @param {number=} opt_maxAge The maximal age in milliseconds.
   * @private
   */
  goog.net.xpc.IframeRelayTransport.cleanup_ = function(opt_maxAge) {
    var now = goog.now();
    var maxAge =
        opt_maxAge || goog.net.xpc.IframeRelayTransport.IFRAME_MAX_AGE_;

    while (goog.net.xpc.IframeRelayTransport.iframeRefs_.length &&
           now - goog.net.xpc.IframeRelayTransport.iframeRefs_[0].timestamp >=
           maxAge) {
      var ifr = goog.net.xpc.IframeRelayTransport.iframeRefs_.
          shift().iframeElement;
      goog.dom.removeNode(ifr);
      goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST,
          'iframe removed');
    }

    goog.net.xpc.IframeRelayTransport.cleanupTimer_ = window.setTimeout(
        goog.net.xpc.IframeRelayTransport.cleanupCb_,
        goog.net.xpc.IframeRelayTransport.CLEANUP_INTERVAL_);
  };


  /**
   * Function which wraps cleanup_().
   * @private
   */
  goog.net.xpc.IframeRelayTransport.cleanupCb_ = function() {
    goog.net.xpc.IframeRelayTransport.cleanup_();
  };
}


/**
 * Maximum sendable size of a payload via a single iframe in IE.
 * @type {number}
 * @private
 */
goog.net.xpc.IframeRelayTransport.IE_PAYLOAD_MAX_SIZE_ = 1800;


/**
 * @typedef {{fragments: !Array.<string>, received: number, expected: number}}
 */
goog.net.xpc.IframeRelayTransport.FragmentInfo;


/**
 * Used to track incoming payload fragments. The implementation can process
 * incoming fragments from several channels at a time, even if data is
 * out-of-order or interleaved.
 *
 * @type {!Object.<string, !goog.net.xpc.IframeRelayTransport.FragmentInfo>}
 * @private
 */
goog.net.xpc.IframeRelayTransport.fragmentMap_ = {};


/**
 * The transport type.
 * @type {number}
 * @override
 */
goog.net.xpc.IframeRelayTransport.prototype.transportType =
    goog.net.xpc.TransportTypes.IFRAME_RELAY;


/**
 * Connects this transport.
 * @override
 */
goog.net.xpc.IframeRelayTransport.prototype.connect = function() {
  if (!this.getWindow()['xpcRelay']) {
    this.getWindow()['xpcRelay'] =
        goog.net.xpc.IframeRelayTransport.receiveMessage_;
  }

  this.send(goog.net.xpc.TRANSPORT_SERVICE_, goog.net.xpc.SETUP);
};


/**
 * Processes an incoming message.
 *
 * @param {string} channelName The name of the channel.
 * @param {string} frame The raw frame content.
 * @private
 */
goog.net.xpc.IframeRelayTransport.receiveMessage_ =
    function(channelName, frame) {
  var pos = frame.indexOf(':');
  var header = frame.substr(0, pos);
  var payload = frame.substr(pos + 1);

  if (!goog.userAgent.IE || (pos = header.indexOf('|')) == -1) {
    // First, the easy case.
    var service = header;
  } else {
    // There was a fragment id in the header, so this is a message
    // fragment, not a whole message.
    var service = header.substr(0, pos);
    var fragmentIdStr = header.substr(pos + 1);

    // Separate the message id string and the fragment number. Note that
    // there may be a single leading + in the argument to parseInt, but
    // this is harmless.
    pos = fragmentIdStr.indexOf('+');
    var messageIdStr = fragmentIdStr.substr(0, pos);
    var fragmentNum = parseInt(fragmentIdStr.substr(pos + 1), 10);
    var fragmentInfo =
        goog.net.xpc.IframeRelayTransport.fragmentMap_[messageIdStr];
    if (!fragmentInfo) {
      fragmentInfo =
          goog.net.xpc.IframeRelayTransport.fragmentMap_[messageIdStr] =
          {fragments: [], received: 0, expected: 0};
    }

    if (goog.string.contains(fragmentIdStr, '++')) {
      fragmentInfo.expected = fragmentNum + 1;
    }
    fragmentInfo.fragments[fragmentNum] = payload;
    fragmentInfo.received++;

    if (fragmentInfo.received != fragmentInfo.expected) {
      return;
    }

    // We've received all outstanding fragments; combine what we've received
    // into payload and fall out to the call to xpcDeliver.
    payload = fragmentInfo.fragments.join('');
    delete goog.net.xpc.IframeRelayTransport.fragmentMap_[messageIdStr];
  }

  goog.net.xpc.channels[channelName].
      xpcDeliver(service, decodeURIComponent(payload));
};


/**
 * Handles transport service messages (internal signalling).
 * @param {string} payload The message content.
 * @override
 */
goog.net.xpc.IframeRelayTransport.prototype.transportServiceHandler =
    function(payload) {
  if (payload == goog.net.xpc.SETUP) {
    // TODO(mibuerge) Safari swallows the SETUP_ACK from the iframe to the
    // container after hitting reload.
    this.send(goog.net.xpc.TRANSPORT_SERVICE_, goog.net.xpc.SETUP_ACK_);
    this.channel_.notifyConnected();
  }
  else if (payload == goog.net.xpc.SETUP_ACK_) {
    this.channel_.notifyConnected();
  }
};


/**
 * Sends a message.
 *
 * @param {string} service Name of service this the message has to be delivered.
 * @param {string} payload The message content.
 * @override
 */
goog.net.xpc.IframeRelayTransport.prototype.send = function(service, payload) {
  // If we're on IE and the post-encoding payload is large, split it
  // into multiple payloads and send each one separately. Otherwise,
  // just send the whole thing.
  var encodedPayload = encodeURIComponent(payload);
  var encodedLen = encodedPayload.length;
  var maxSize = goog.net.xpc.IframeRelayTransport.IE_PAYLOAD_MAX_SIZE_;

  if (goog.userAgent.IE && encodedLen > maxSize) {
    // A probabilistically-unique string used to link together all fragments
    // in this message.
    var messageIdStr = goog.string.getRandomString();

    for (var startIndex = 0, fragmentNum = 0; startIndex < encodedLen;
         fragmentNum++) {
      var payloadFragment = encodedPayload.substr(startIndex, maxSize);
      startIndex += maxSize;
      var fragmentIdStr =
          messageIdStr + (startIndex >= encodedLen ? '++' : '+') + fragmentNum;
      this.send_(service, payloadFragment, fragmentIdStr);
    }
  } else {
    this.send_(service, encodedPayload);
  }
};


/**
 * Sends an encoded message or message fragment.
 * @param {string} service Name of service this the message has to be delivered.
 * @param {string} encodedPayload The message content, URI encoded.
 * @param {string=} opt_fragmentIdStr If sending a fragment, a string that
 *     identifies the fragment.
 * @private
 */
goog.net.xpc.IframeRelayTransport.prototype.send_ =
    function(service, encodedPayload, opt_fragmentIdStr) {
  // IE requires that we create the onload attribute inline, otherwise the
  // handler is not triggered
  if (goog.userAgent.IE) {
    var div = this.getWindow().document.createElement('div');
    div.innerHTML = '<iframe onload="this.xpcOnload()"></iframe>';
    var ifr = div.childNodes[0];
    div = null;
    ifr['xpcOnload'] = goog.net.xpc.IframeRelayTransport.iframeLoadHandler_;
  } else {
    var ifr = this.getWindow().document.createElement('iframe');

    if (goog.userAgent.WEBKIT) {
      // safari doesn't fire load-events on iframes.
      // keep a reference and remove after a timeout.
      goog.net.xpc.IframeRelayTransport.iframeRefs_.push({
        timestamp: goog.now(),
        iframeElement: ifr
      });
    } else {
      goog.events.listen(ifr, 'load',
                         goog.net.xpc.IframeRelayTransport.iframeLoadHandler_);
    }
  }

  var style = ifr.style;
  style.visibility = 'hidden';
  style.width = ifr.style.height = '0px';
  style.position = 'absolute';

  var url = this.peerRelayUri_;
  url += '#' + this.channel_.name;
  if (this.peerIframeId_) {
    url += ',' + this.peerIframeId_;
  }
  url += '|' + service;
  if (opt_fragmentIdStr) {
    url += '|' + opt_fragmentIdStr;
  }
  url += ':' + encodedPayload;

  ifr.src = url;

  this.getWindow().document.body.appendChild(ifr);

  goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST, 'msg sent: ' + url);
};


/**
 * The iframe load handler. Gets called as method on the iframe element.
 * @private
 * @this Element
 */
goog.net.xpc.IframeRelayTransport.iframeLoadHandler_ = function() {
  goog.log.log(goog.net.xpc.logger, goog.log.Level.FINEST, 'iframe-load');
  goog.dom.removeNode(this);
  this.xpcOnload = null;
};


/** @override */
goog.net.xpc.IframeRelayTransport.prototype.disposeInternal = function() {
  goog.base(this, 'disposeInternal');
  if (goog.userAgent.WEBKIT) {
    goog.net.xpc.IframeRelayTransport.cleanup_(0);
  }
};

//javascript/closure/net/xpc/nativemessagingtransport.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Contains the class which uses native messaging
 * facilities for cross domain communication.
 *
 * @author mibuerge@google.com (Michael Buerge)
 */


goog.provide('goog.net.xpc.NativeMessagingTransport');

goog.require('goog.Timer');
goog.require('goog.asserts');
goog.require('goog.async.Deferred');
goog.require('goog.events');
goog.require('goog.events.EventHandler');
goog.require('goog.log');
goog.require('goog.net.xpc');
goog.require('goog.net.xpc.CrossPageChannelRole');
goog.require('goog.net.xpc.Transport');
goog.require('goog.net.xpc.TransportTypes');



/**
 * The native messaging transport
 *
 * Uses document.postMessage() to send messages to other documents.
 * Receiving is done by listening on 'message'-events on the document.
 *
 * @param {goog.net.xpc.CrossPageChannel} channel The channel this
 *     transport belongs to.
 * @param {string} peerHostname The hostname (protocol, domain, and port) of the
 *     peer.
 * @param {goog.dom.DomHelper=} opt_domHelper The dom helper to use for
 *     finding the correct window/document.
 * @param {boolean=} opt_oneSidedHandshake If this is true, only the outer
 *     transport sends a SETUP message and expects a SETUP_ACK.  The inner
 *     transport goes connected when it receives the SETUP.
 * @param {number=} opt_protocolVersion Which version of its setup protocol the
 *     transport should use.  The default is '2'.
 * @constructor
 * @extends {goog.net.xpc.Transport}
 * @final
 */
goog.net.xpc.NativeMessagingTransport = function(channel, peerHostname,
    opt_domHelper, opt_oneSidedHandshake, opt_protocolVersion) {
  goog.base(this, opt_domHelper);

  /**
   * The channel this transport belongs to.
   * @type {goog.net.xpc.CrossPageChannel}
   * @private
   */
  this.channel_ = channel;

  /**
   * Which version of the transport's protocol should be used.
   * @type {number}
   * @private
   */
  this.protocolVersion_ = opt_protocolVersion || 2;
  goog.asserts.assert(this.protocolVersion_ >= 1);
  goog.asserts.assert(this.protocolVersion_ <= 2);

  /**
   * The hostname of the peer. This parameterizes all calls to postMessage, and
   * should contain the precise protocol, domain, and port of the peer window.
   * @type {string}
   * @private
   */
  this.peerHostname_ = peerHostname || '*';

  /**
   * The event handler.
   * @type {!goog.events.EventHandler}
   * @private
   */
  this.eventHandler_ = new goog.events.EventHandler(this);

  /**
   * Timer for connection reattempts.
   * @type {!goog.Timer}
   * @private
   */
  this.maybeAttemptToConnectTimer_ = new goog.Timer(100, this.getWindow());

  /**
   * Whether one-sided handshakes are enabled.
   * @type {boolean}
   * @private
   */
  this.oneSidedHandshake_ = !!opt_oneSidedHandshake;

  /**
   * Fires once we've received our SETUP_ACK message.
   * @type {!goog.async.Deferred}
   * @private
   */
  this.setupAckReceived_ = new goog.async.Deferred();

  /**
   * Fires once we've sent our SETUP_ACK message.
   * @type {!goog.async.Deferred}
   * @private
   */
  this.setupAckSent_ = new goog.async.Deferred();

  /**
   * Fires once we're marked connected.
   * @type {!goog.async.Deferred}
   * @private
   */
  this.connected_ = new goog.async.Deferred();

  /**
   * The unique ID of this side of the connection. Used to determine when a peer
   * is reloaded.
   * @type {string}
   * @private
   */
  this.endpointId_ = goog.net.xpc.getRandomString(10);

  /**
   * The unique ID of the peer. If we get a message from a peer with an ID we
   * don't expect, we reset the connection.
   * @type {?string}
   * @private
   */
  this.peerEndpointId_ = null;

  // We don't want to mark ourselves connected until we have sent whatever
  // message will cause our counterpart in the other frame to also declare
  // itself connected, if there is such a message.  Otherwise we risk a user
  // message being sent in advance of that message, and it being discarded.
  if (this.oneSidedHandshake_) {
    if (this.channel_.getRole() == goog.net.xpc.CrossPageChannelRole.INNER) {
      // One sided handshake, inner frame:
      // SETUP_ACK must be received.
      this.connected_.awaitDeferred(this.setupAckReceived_);
    } else {
      // One sided handshake, outer frame:
      // SETUP_ACK must be sent.
      this.connected_.awaitDeferred(this.setupAckSent_);
    }
  } else {
    // Two sided handshake:
    // SETUP_ACK has to have been received, and sent.
    this.connected_.awaitDeferred(this.setupAckReceived_);
    if (this.protocolVersion_ == 2) {
      this.connected_.awaitDeferred(this.setupAckSent_);
    }
  }
  this.connected_.addCallback(this.notifyConnected_, this);
  this.connected_.callback(true);

  this.eventHandler_.
      listen(this.maybeAttemptToConnectTimer_, goog.Timer.TICK,
          this.maybeAttemptToConnect_);

  goog.log.info(goog.net.xpc.logger, 'NativeMessagingTransport created.  ' +
      'protocolVersion=' + this.protocolVersion_ + ', oneSidedHandshake=' +
      this.oneSidedHandshake_ + ', role=' + this.channel_.getRole());
};
goog.inherits(goog.net.xpc.NativeMessagingTransport, goog.net.xpc.Transport);


/**
 * Length of the delay in milliseconds between the channel being connected and
 * the connection callback being called, in cases where coverage of timing flaws
 * is required.
 * @type {number}
 * @private
 */
goog.net.xpc.NativeMessagingTransport.CONNECTION_DELAY_MS_ = 200;


/**
 * Current determination of peer's protocol version, or null for unknown.
 * @type {?number}
 * @private
 */
goog.net.xpc.NativeMessagingTransport.prototype.peerProtocolVersion_ = null;


/**
 * Flag indicating if this instance of the transport has been initialized.
 * @type {boolean}
 * @private
 */
goog.net.xpc.NativeMessagingTransport.prototype.initialized_ = false;


/**
 * The transport type.
 * @type {number}
 * @override
 */
goog.net.xpc.NativeMessagingTransport.prototype.transportType =
    goog.net.xpc.TransportTypes.NATIVE_MESSAGING;


/**
 * The delimiter used for transport service messages.
 * @type {string}
 * @private
 */
goog.net.xpc.NativeMessagingTransport.MESSAGE_DELIMITER_ = ',';


/**
 * Tracks the number of NativeMessagingTransport channels that have been
 * initialized but not disposed yet in a map keyed by the UID of the window
 * object.  This allows for multiple windows to be initiallized and listening
 * for messages.
 * @type {Object.<number>}
 * @private
 */
goog.net.xpc.NativeMessagingTransport.activeCount_ = {};


/**
 * Id of a timer user during postMessage sends.
 * @type {number}
 * @private
 */
goog.net.xpc.NativeMessagingTransport.sendTimerId_ = 0;


/**
 * Checks whether the peer transport protocol version could be as indicated.
 * @param {number} version The version to check for.
 * @return {boolean} Whether the peer transport protocol version is as
 *     indicated, or null.
 * @private
 */
goog.net.xpc.NativeMessagingTransport.prototype.couldPeerVersionBe_ =
    function(version) {
  return this.peerProtocolVersion_ == null ||
      this.peerProtocolVersion_ == version;
};


/**
 * Initializes this transport. Registers a listener for 'message'-events
 * on the document.
 * @param {Window} listenWindow The window to listen to events on.
 * @private
 */
goog.net.xpc.NativeMessagingTransport.initialize_ = function(listenWindow) {
  var uid = goog.getUid(listenWindow);
  var value = goog.net.xpc.NativeMessagingTransport.activeCount_[uid];
  if (!goog.isNumber(value)) {
    value = 0;
  }
  if (value == 0) {
    // Listen for message-events. These are fired on window in FF3 and on
    // document in Opera.
    goog.events.listen(
        listenWindow.postMessage ? listenWindow : listenWindow.document,
        'message',
        goog.net.xpc.NativeMessagingTransport.messageReceived_,
        false,
        goog.net.xpc.NativeMessagingTransport);
  }
  goog.net.xpc.NativeMessagingTransport.activeCount_[uid] = value + 1;
};


/**
 * Processes an incoming message-event.
 * @param {goog.events.BrowserEvent} msgEvt The message event.
 * @return {boolean} True if message was successfully delivered to a channel.
 * @private
 */
goog.net.xpc.NativeMessagingTransport.messageReceived_ = function(msgEvt) {
  var data = msgEvt.getBrowserEvent().data;

  if (!goog.isString(data)) {
    return false;
  }

  var headDelim = data.indexOf('|');
  var serviceDelim = data.indexOf(':');

  // make sure we got something reasonable
  if (headDelim == -1 || serviceDelim == -1) {
    return false;
  }

  var channelName = data.substring(0, headDelim);
  var service = data.substring(headDelim + 1, serviceDelim);
  var payload = data.substring(serviceDelim + 1);

  goog.log.fine(goog.net.xpc.logger,
      'messageReceived: channel=' + channelName +
      ', service=' + service + ', payload=' + payload);

  // Attempt to deliver message to the channel. Keep in mind that it may not
  // exist for several reasons, including but not limited to:
  //  - a malformed message
  //  - the channel simply has not been created
  //  - channel was created in a different namespace
  //  - message was sent to the wrong window
  //  - channel has become stale (e.g. caching iframes and back clicks)
  var channel = goog.net.xpc.channels[channelName];
  if (channel) {
    channel.xpcDeliver(service, payload, msgEvt.getBrowserEvent().origin);
    return true;
  }

  var transportMessageType =
      goog.net.xpc.NativeMessagingTransport.parseTransportPayload_(payload)[0];

  // Check if there are any stale channel names that can be updated.
  for (var staleChannelName in goog.net.xpc.channels) {
    var staleChannel = goog.net.xpc.channels[staleChannelName];
    if (staleChannel.getRole() == goog.net.xpc.CrossPageChannelRole.INNER &&
        !staleChannel.isConnected() &&
        service == goog.net.xpc.TRANSPORT_SERVICE_ &&
        (transportMessageType == goog.net.xpc.SETUP ||
        transportMessageType == goog.net.xpc.SETUP_NTPV2)) {
      // Inner peer received SETUP message but channel names did not match.
      // Start using the channel name sent from outer peer. The channel name
      // of the inner peer can easily become out of date, as iframe's and their
      // JS state get cached in many browsers upon page reload or history
      // navigation (particularly Firefox 1.5+). We can trust the outer peer,
      // since we only accept postMessage messages from the same hostname that
      // originally setup the channel.
      staleChannel.updateChannelNameAndCatalog(channelName);
      staleChannel.xpcDeliver(service, payload);
      return true;
    }
  }

  // Failed to find a channel to deliver this message to, so simply ignore it.
  goog.log.info(goog.net.xpc.logger, 'channel name mismatch; message ignored"');
  return false;
};


/**
 * Handles transport service messages.
 * @param {string} payload The message content.
 * @override
 */
goog.net.xpc.NativeMessagingTransport.prototype.transportServiceHandler =
    function(payload) {
  var transportParts =
      goog.net.xpc.NativeMessagingTransport.parseTransportPayload_(payload);
  var transportMessageType = transportParts[0];
  var peerEndpointId = transportParts[1];
  switch (transportMessageType) {
    case goog.net.xpc.SETUP_ACK_:
      this.setPeerProtocolVersion_(1);
      if (!this.setupAckReceived_.hasFired()) {
        this.setupAckReceived_.callback(true);
      }
      break;
    case goog.net.xpc.SETUP_ACK_NTPV2:
      if (this.protocolVersion_ == 2) {
        this.setPeerProtocolVersion_(2);
        if (!this.setupAckReceived_.hasFired()) {
          this.setupAckReceived_.callback(true);
        }
      }
      break;
    case goog.net.xpc.SETUP:
      this.setPeerProtocolVersion_(1);
      this.sendSetupAckMessage_(1);
      break;
    case goog.net.xpc.SETUP_NTPV2:
      if (this.protocolVersion_ == 2) {
        var prevPeerProtocolVersion = this.peerProtocolVersion_;
        this.setPeerProtocolVersion_(2);
        this.sendSetupAckMessage_(2);
        if ((prevPeerProtocolVersion == 1 || this.peerEndpointId_ != null) &&
            this.peerEndpointId_ != peerEndpointId) {
          // Send a new SETUP message since the peer has been replaced.
          goog.log.info(goog.net.xpc.logger,
              'Sending SETUP and changing peer ID to: ' + peerEndpointId);
          this.sendSetupMessage_();
        }
        this.peerEndpointId_ = peerEndpointId;
      }
      break;
  }
};


/**
 * Sends a SETUP transport service message of the correct protocol number for
 * our current situation.
 * @private
 */
goog.net.xpc.NativeMessagingTransport.prototype.sendSetupMessage_ =
    function() {
  // 'real' (legacy) v1 transports don't know about there being v2 ones out
  // there, and we shouldn't either.
  goog.asserts.assert(!(this.protocolVersion_ == 1 &&
      this.peerProtocolVersion_ == 2));

  if (this.protocolVersion_ == 2 && this.couldPeerVersionBe_(2)) {
    var payload = goog.net.xpc.SETUP_NTPV2;
    payload += goog.net.xpc.NativeMessagingTransport.MESSAGE_DELIMITER_;
    payload += this.endpointId_;
    this.send(goog.net.xpc.TRANSPORT_SERVICE_, payload);
  }

  // For backward compatibility reasons, the V1 SETUP message can be sent by
  // both V1 and V2 transports.  Once a V2 transport has 'heard' another V2
  // transport it starts ignoring V1 messages, so the V2 message must be sent
  // first.
  if (this.couldPeerVersionBe_(1)) {
    this.send(goog.net.xpc.TRANSPORT_SERVICE_, goog.net.xpc.SETUP);
  }
};


/**
 * Sends a SETUP_ACK transport service message of the correct protocol number
 * for our current situation.
 * @param {number} protocolVersion The protocol version of the SETUP message
 *     which gave rise to this ack message.
 * @private
 */
goog.net.xpc.NativeMessagingTransport.prototype.sendSetupAckMessage_ =
    function(protocolVersion) {
  goog.asserts.assert(this.protocolVersion_ != 1 || protocolVersion != 2,
      'Shouldn\'t try to send a v2 setup ack in v1 mode.');
  if (this.protocolVersion_ == 2 && this.couldPeerVersionBe_(2) &&
      protocolVersion == 2) {
    this.send(goog.net.xpc.TRANSPORT_SERVICE_, goog.net.xpc.SETUP_ACK_NTPV2);
  } else if (this.couldPeerVersionBe_(1) && protocolVersion == 1) {
    this.send(goog.net.xpc.TRANSPORT_SERVICE_, goog.net.xpc.SETUP_ACK_);
  } else {
    return;
  }

  if (!this.setupAckSent_.hasFired()) {
    this.setupAckSent_.callback(true);
  }
};


/**
 * Attempts to set the peer protocol number.  Downgrades from 2 to 1 are not
 * permitted.
 * @param {number} version The new protocol number.
 * @private
 */
goog.net.xpc.NativeMessagingTransport.prototype.setPeerProtocolVersion_ =
    function(version) {
  if (version > this.peerProtocolVersion_) {
    this.peerProtocolVersion_ = version;
  }
  if (this.peerProtocolVersion_ == 1) {
    if (!this.setupAckSent_.hasFired() && !this.oneSidedHandshake_) {
      this.setupAckSent_.callback(true);
    }
    this.peerEndpointId_ = null;
  }
};


/**
 * Connects this transport.
 * @override
 */
goog.net.xpc.NativeMessagingTransport.prototype.connect = function() {
  goog.net.xpc.NativeMessagingTransport.initialize_(this.getWindow());
  this.initialized_ = true;
  this.maybeAttemptToConnect_();
};


/**
 * Connects to other peer. In the case of the outer peer, the setup messages are
 * likely sent before the inner peer is ready to receive them. Therefore, this
 * function will continue trying to send the SETUP message until the inner peer
 * responds. In the case of the inner peer, it will occasionally have its
 * channel name fall out of sync with the outer peer, particularly during
 * soft-reloads and history navigations.
 * @private
 */
goog.net.xpc.NativeMessagingTransport.prototype.maybeAttemptToConnect_ =
    function() {
  // In a one-sided handshake, the outer frame does not send a SETUP message,
  // but the inner frame does.
  var outerFrame = this.channel_.getRole() ==
      goog.net.xpc.CrossPageChannelRole.OUTER;
  if ((this.oneSidedHandshake_ && outerFrame) ||
      this.channel_.isConnected() ||
      this.isDisposed()) {
    this.maybeAttemptToConnectTimer_.stop();
    return;
  }
  this.maybeAttemptToConnectTimer_.start();
  this.sendSetupMessage_();
};


/**
 * Sends a message.
 * @param {string} service The name off the service the message is to be
 * delivered to.
 * @param {string} payload The message content.
 * @override
 */
goog.net.xpc.NativeMessagingTransport.prototype.send = function(service,
                                                                payload) {
  var win = this.channel_.getPeerWindowObject();
  if (!win) {
    goog.log.fine(goog.net.xpc.logger, 'send(): window not ready');
    return;
  }

  this.send = function(service, payload) {
    // In IE8 (and perhaps elsewhere), it seems like postMessage is sometimes
    // implemented as a synchronous call.  That is, calling it synchronously
    // calls whatever listeners it has, and control is not returned to the
    // calling thread until those listeners are run.  This produces different
    // ordering to all other browsers, and breaks this protocol.  This timer
    // callback is introduced to produce standard behavior across all browsers.
    var transport = this;
    var channelName = this.channel_.name;
    var sendFunctor = function() {
      transport.sendTimerId_ = 0;

      try {
        // postMessage is a method of the window object, except in some
        // versions of Opera, where it is a method of the document object.  It
        // also seems that the appearance of postMessage on the peer window
        // object can sometimes be delayed.
        var obj = win.postMessage ? win : win.document;
        if (!obj.postMessage) {
          goog.log.warning(goog.net.xpc.logger,
              'Peer window had no postMessage function.');
          return;
        }

        obj.postMessage(channelName + '|' + service + ':' + payload,
            transport.peerHostname_);
        goog.log.fine(goog.net.xpc.logger, 'send(): service=' + service +
            ' payload=' + payload + ' to hostname=' + transport.peerHostname_);
      } catch (error) {
        // There is some evidence (not totally convincing) that postMessage can
        // be missing or throw errors during a narrow timing window during
        // startup.  This protects against that.
        goog.log.warning(goog.net.xpc.logger,
            'Error performing postMessage, ignoring.', error);
      }
    };
    this.sendTimerId_ = goog.Timer.callOnce(sendFunctor, 0);
  };
  this.send(service, payload);
};


/**
 * Notify the channel that this transport is connected.  If either transport is
 * protocol v1, a short delay is required to paper over timing vulnerabilities
 * in that protocol version.
 * @private
 */
goog.net.xpc.NativeMessagingTransport.prototype.notifyConnected_ =
    function() {
  var delay = (this.protocolVersion_ == 1 || this.peerProtocolVersion_ == 1) ?
      goog.net.xpc.NativeMessagingTransport.CONNECTION_DELAY_MS_ : undefined;
  this.channel_.notifyConnected(delay);
};


/** @override */
goog.net.xpc.NativeMessagingTransport.prototype.disposeInternal = function() {
  if (this.initialized_) {
    var listenWindow = this.getWindow();
    var uid = goog.getUid(listenWindow);
    var value = goog.net.xpc.NativeMessagingTransport.activeCount_[uid];
    goog.net.xpc.NativeMessagingTransport.activeCount_[uid] = value - 1;
    if (value == 1) {
      goog.events.unlisten(
          listenWindow.postMessage ? listenWindow : listenWindow.document,
          'message',
          goog.net.xpc.NativeMessagingTransport.messageReceived_,
          false,
          goog.net.xpc.NativeMessagingTransport);
    }
  }

  if (this.sendTimerId_) {
    goog.Timer.clear(this.sendTimerId_);
    this.sendTimerId_ = 0;
  }

  goog.dispose(this.eventHandler_);
  delete this.eventHandler_;

  goog.dispose(this.maybeAttemptToConnectTimer_);
  delete this.maybeAttemptToConnectTimer_;

  this.setupAckReceived_.cancel();
  delete this.setupAckReceived_;
  this.setupAckSent_.cancel();
  delete this.setupAckSent_;
  this.connected_.cancel();
  delete this.connected_;

  // Cleaning up this.send as it is an instance method, created in
  // goog.net.xpc.NativeMessagingTransport.prototype.send and has a closure over
  // this.channel_.peerWindowObject_.
  delete this.send;

  goog.base(this, 'disposeInternal');
};


/**
 * Parse a transport service payload message.  For v1, it is simply expected to
 * be 'SETUP' or 'SETUP_ACK'.  For v2, an example setup message is
 * 'SETUP_NTPV2,abc123', where the second part is the endpoint id.  The v2 setup
 * ack message is simply 'SETUP_ACK_NTPV2'.
 * @param {string} payload The payload.
 * @return {!Array.<?string>} An array with the message type as the first member
 *     and the endpoint id as the second, if one was sent, or null otherwise.
 * @private
 */
goog.net.xpc.NativeMessagingTransport.parseTransportPayload_ =
    function(payload) {
  var transportParts = /** @type {!Array.<?string>} */ (payload.split(
      goog.net.xpc.NativeMessagingTransport.MESSAGE_DELIMITER_));
  transportParts[1] = transportParts[1] || null;
  return transportParts;
};

//javascript/closure/net/xpc/nixtransport.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Contains the NIX (Native IE XDC) method transport for
 * cross-domain communication. It exploits the fact that Internet Explorer
 * allows a window that is the parent of an iframe to set said iframe window's
 * opener property to an object. This object can be a function that in turn
 * can be used to send a message despite same-origin constraints. Note that
 * this function, if a pure JavaScript object, opens up the possibilitiy of
 * gaining a hold of the context of the other window and in turn, attacking
 * it. This implementation therefore wraps the JavaScript objects used inside
 * a VBScript class. Since VBScript objects are passed in JavaScript as a COM
 * wrapper (like DOM objects), they are thus opaque to JavaScript
 * (except for the interface they expose). This therefore provides a safe
 * method of transport.
 *
 * @author jschorr@google.com (Joseph Schorr)
 *
 * Initially based on FrameElementTransport which shares some similarities
 * to this method.
 */

goog.provide('goog.net.xpc.NixTransport');

goog.require('goog.log');
goog.require('goog.net.xpc');
goog.require('goog.net.xpc.CfgFields');
goog.require('goog.net.xpc.CrossPageChannelRole');
goog.require('goog.net.xpc.Transport');
goog.require('goog.net.xpc.TransportTypes');
goog.require('goog.reflect');



/**
 * NIX method transport.
 *
 * NOTE(jschorr): NIX method tested in all IE versions starting from 6.0.
 *
 * @param {goog.net.xpc.CrossPageChannel} channel The channel this transport
 *     belongs to.
 * @param {goog.dom.DomHelper=} opt_domHelper The dom helper to use for finding
 *     the correct window.
 * @constructor
 * @extends {goog.net.xpc.Transport}
 * @final
 */
goog.net.xpc.NixTransport = function(channel, opt_domHelper) {
  goog.base(this, opt_domHelper);

  /**
   * The channel this transport belongs to.
   * @type {goog.net.xpc.CrossPageChannel}
   * @private
   */
  this.channel_ = channel;

  /**
   * The authorization token, if any, used by this transport.
   * @type {?string}
   * @private
   */
  this.authToken_ = channel[goog.net.xpc.CfgFields.AUTH_TOKEN] || '';

  /**
   * The authorization token, if any, that must be sent by the other party
   * for setup to occur.
   * @type {?string}
   * @private
   */
  this.remoteAuthToken_ =
      channel[goog.net.xpc.CfgFields.REMOTE_AUTH_TOKEN] || '';

  // Conduct the setup work for NIX in general, if need be.
  goog.net.xpc.NixTransport.conductGlobalSetup_(this.getWindow());

  // Setup aliases so that VBScript can call these methods
  // on the transport class, even if they are renamed during
  // compression.
  this[goog.net.xpc.NixTransport.NIX_HANDLE_MESSAGE] = this.handleMessage_;
  this[goog.net.xpc.NixTransport.NIX_CREATE_CHANNEL] = this.createChannel_;
};
goog.inherits(goog.net.xpc.NixTransport, goog.net.xpc.Transport);


// Consts for NIX. VBScript doesn't allow items to start with _ for some
// reason, so we need to make these names quite unique, as they will go into
// the global namespace.


/**
 * Global name of the Wrapper VBScript class.
 * Note that this class will be stored in the *global*
 * namespace (i.e. window in browsers).
 * @type {string}
 */
goog.net.xpc.NixTransport.NIX_WRAPPER = 'GCXPC____NIXVBS_wrapper';


/**
 * Global name of the GetWrapper VBScript function. This
 * constant is used by JavaScript to call this function.
 * Note that this function will be stored in the *global*
 * namespace (i.e. window in browsers).
 * @type {string}
 */
goog.net.xpc.NixTransport.NIX_GET_WRAPPER = 'GCXPC____NIXVBS_get_wrapper';


/**
 * The name of the handle message method used by the wrapper class
 * when calling the transport.
 * @type {string}
 */
goog.net.xpc.NixTransport.NIX_HANDLE_MESSAGE = 'GCXPC____NIXJS_handle_message';


/**
 * The name of the create channel method used by the wrapper class
 * when calling the transport.
 * @type {string}
 */
goog.net.xpc.NixTransport.NIX_CREATE_CHANNEL = 'GCXPC____NIXJS_create_channel';


/**
 * A "unique" identifier that is stored in the wrapper
 * class so that the wrapper can be distinguished from
 * other objects easily.
 * @type {string}
 */
goog.net.xpc.NixTransport.NIX_ID_FIELD = 'GCXPC____NIXVBS_container';


/**
 * Determines if the installed version of IE supports accessing window.opener
 * after it has been set to a non-Window/null value. NIX relies on this being
 * possible.
 * @return {boolean} Whether window.opener behavior is compatible with NIX.
 */
goog.net.xpc.NixTransport.isNixSupported = function() {
  var isSupported = false;
  try {
    var oldOpener = window.opener;
    // The compiler complains (as it should!) if we set window.opener to
    // something other than a window or null.
    window.opener = /** @type {Window} */ ({});
    isSupported = goog.reflect.canAccessProperty(window, 'opener');
    window.opener = oldOpener;
  } catch (e) { }
  return isSupported;
};


/**
 * Conducts the global setup work for the NIX transport method.
 * This function creates and then injects into the page the
 * VBScript code necessary to create the NIX wrapper class.
 * Note that this method can be called multiple times, as
 * it internally checks whether the work is necessary before
 * proceeding.
 * @param {Window} listenWindow The window containing the affected page.
 * @private
 */
goog.net.xpc.NixTransport.conductGlobalSetup_ = function(listenWindow) {
  if (listenWindow['nix_setup_complete']) {
    return;
  }

  // Inject the VBScript code needed.
  var vbscript =
      // We create a class to act as a wrapper for
      // a Javascript call, to prevent a break in of
      // the context.
      'Class ' + goog.net.xpc.NixTransport.NIX_WRAPPER + '\n ' +

      // An internal member for keeping track of the
      // transport for which this wrapper exists.
      'Private m_Transport\n' +

      // An internal member for keeping track of the
      // auth token associated with the context that
      // created this wrapper. Used for validation
      // purposes.
      'Private m_Auth\n' +

      // Method for internally setting the value
      // of the m_Transport property. We have the
      // isEmpty check to prevent the transport
      // from being overridden with an illicit
      // object by a malicious party.
      'Public Sub SetTransport(transport)\n' +
      'If isEmpty(m_Transport) Then\n' +
      'Set m_Transport = transport\n' +
      'End If\n' +
      'End Sub\n' +

      // Method for internally setting the value
      // of the m_Auth property. We have the
      // isEmpty check to prevent the transport
      // from being overridden with an illicit
      // object by a malicious party.
      'Public Sub SetAuth(auth)\n' +
      'If isEmpty(m_Auth) Then\n' +
      'm_Auth = auth\n' +
      'End If\n' +
      'End Sub\n' +

      // Returns the auth token to the gadget, so it can
      // confirm a match before initiating the connection
      'Public Function GetAuthToken()\n ' +
      'GetAuthToken = m_Auth\n' +
      'End Function\n' +

      // A wrapper method which causes a
      // message to be sent to the other context.
      'Public Sub SendMessage(service, payload)\n ' +
      'Call m_Transport.' +
      goog.net.xpc.NixTransport.NIX_HANDLE_MESSAGE + '(service, payload)\n' +
      'End Sub\n' +

      // Method for setting up the inner->outer
      // channel.
      'Public Sub CreateChannel(channel)\n ' +
      'Call m_Transport.' +
      goog.net.xpc.NixTransport.NIX_CREATE_CHANNEL + '(channel)\n' +
      'End Sub\n' +

      // An empty field with a unique identifier to
      // prevent the code from confusing this wrapper
      // with a run-of-the-mill value found in window.opener.
      'Public Sub ' + goog.net.xpc.NixTransport.NIX_ID_FIELD + '()\n ' +
      'End Sub\n' +
      'End Class\n ' +

      // Function to get a reference to the wrapper.
      'Function ' +
      goog.net.xpc.NixTransport.NIX_GET_WRAPPER + '(transport, auth)\n' +
      'Dim wrap\n' +
      'Set wrap = New ' + goog.net.xpc.NixTransport.NIX_WRAPPER + '\n' +
      'wrap.SetTransport transport\n' +
      'wrap.SetAuth auth\n' +
      'Set ' + goog.net.xpc.NixTransport.NIX_GET_WRAPPER + ' = wrap\n' +
      'End Function';

  try {
    listenWindow.execScript(vbscript, 'vbscript');
    listenWindow['nix_setup_complete'] = true;
  }
  catch (e) {
    goog.log.error(goog.net.xpc.logger,
        'exception caught while attempting global setup: ' + e);
  }
};


/**
 * The transport type.
 * @type {number}
 * @protected
 * @override
 */
goog.net.xpc.NixTransport.prototype.transportType =
    goog.net.xpc.TransportTypes.NIX;


/**
 * Keeps track of whether the local setup has completed (i.e.
 * the initial work towards setting the channel up has been
 * completed for this end).
 * @type {boolean}
 * @private
 */
goog.net.xpc.NixTransport.prototype.localSetupCompleted_ = false;


/**
 * The NIX channel used to talk to the other page. This
 * object is in fact a reference to a VBScript class
 * (see above) and as such, is in fact a COM wrapper.
 * When using this object, make sure to not access methods
 * without calling them, otherwise a COM error will be thrown.
 * @type {Object}
 * @private
 */
goog.net.xpc.NixTransport.prototype.nixChannel_ = null;


/**
 * Connect this transport.
 * @override
 */
goog.net.xpc.NixTransport.prototype.connect = function() {
  if (this.channel_.getRole() == goog.net.xpc.CrossPageChannelRole.OUTER) {
    this.attemptOuterSetup_();
  } else {
    this.attemptInnerSetup_();
  }
};


/**
 * Attempts to setup the channel from the perspective
 * of the outer (read: container) page. This method
 * will attempt to create a NIX wrapper for this transport
 * and place it into the "opener" property of the inner
 * page's window object. If it fails, it will continue
 * to loop until it does so.
 *
 * @private
 */
goog.net.xpc.NixTransport.prototype.attemptOuterSetup_ = function() {
  if (this.localSetupCompleted_) {
    return;
  }

  // Get shortcut to iframe-element that contains the inner
  // page.
  var innerFrame = this.channel_.getIframeElement();

  try {
    // Attempt to place the NIX wrapper object into the inner
    // frame's opener property.
    var theWindow = this.getWindow();
    var getWrapper = theWindow[goog.net.xpc.NixTransport.NIX_GET_WRAPPER];
    innerFrame.contentWindow.opener = getWrapper(this, this.authToken_);
    this.localSetupCompleted_ = true;
  }
  catch (e) {
    goog.log.error(goog.net.xpc.logger,
        'exception caught while attempting setup: ' + e);
  }

  // If the retry is necessary, reattempt this setup.
  if (!this.localSetupCompleted_) {
    this.getWindow().setTimeout(goog.bind(this.attemptOuterSetup_, this), 100);
  }
};


/**
 * Attempts to setup the channel from the perspective
 * of the inner (read: iframe) page. This method
 * will attempt to *read* the opener object from the
 * page's opener property. If it succeeds, this object
 * is saved into nixChannel_ and the channel is confirmed
 * with the container by calling CreateChannel with an instance
 * of a wrapper for *this* page. Note that if this method
 * fails, it will continue to loop until it succeeds.
 *
 * @private
 */
goog.net.xpc.NixTransport.prototype.attemptInnerSetup_ = function() {
  if (this.localSetupCompleted_) {
    return;
  }

  try {
    var opener = this.getWindow().opener;

    // Ensure that the object contained inside the opener
    // property is in fact a NIX wrapper.
    if (opener && goog.net.xpc.NixTransport.NIX_ID_FIELD in opener) {
      this.nixChannel_ = opener;

      // Ensure that the NIX channel given to use is valid.
      var remoteAuthToken = this.nixChannel_['GetAuthToken']();

      if (remoteAuthToken != this.remoteAuthToken_) {
        goog.log.error(goog.net.xpc.logger,
            'Invalid auth token from other party');
        return;
      }

      // Complete the construction of the channel by sending our own
      // wrapper to the container via the channel they gave us.
      var theWindow = this.getWindow();
      var getWrapper = theWindow[goog.net.xpc.NixTransport.NIX_GET_WRAPPER];
      this.nixChannel_['CreateChannel'](getWrapper(this, this.authToken_));

      this.localSetupCompleted_ = true;

      // Notify channel that the transport is ready.
      this.channel_.notifyConnected();
    }
  }
  catch (e) {
    goog.log.error(goog.net.xpc.logger,
        'exception caught while attempting setup: ' + e);
    return;
  }

  // If the retry is necessary, reattempt this setup.
  if (!this.localSetupCompleted_) {
    this.getWindow().setTimeout(goog.bind(this.attemptInnerSetup_, this), 100);
  }
};


/**
 * Internal method called by the inner page, via the
 * NIX wrapper, to complete the setup of the channel.
 *
 * @param {Object} channel The NIX wrapper of the
 *  inner page.
 * @private
 */
goog.net.xpc.NixTransport.prototype.createChannel_ = function(channel) {
  // Verify that the channel is in fact a NIX wrapper.
  if (typeof channel != 'unknown' ||
      !(goog.net.xpc.NixTransport.NIX_ID_FIELD in channel)) {
    goog.log.error(goog.net.xpc.logger,
        'Invalid NIX channel given to createChannel_');
  }

  this.nixChannel_ = channel;

  // Ensure that the NIX channel given to use is valid.
  var remoteAuthToken = this.nixChannel_['GetAuthToken']();

  if (remoteAuthToken != this.remoteAuthToken_) {
    goog.log.error(goog.net.xpc.logger, 'Invalid auth token from other party');
    return;
  }

  // Indicate to the CrossPageChannel that the channel is setup
  // and ready to use.
  this.channel_.notifyConnected();
};


/**
 * Internal method called by the other page, via the NIX wrapper,
 * to deliver a message.
 * @param {string} serviceName The name of the service the message is to be
 *   delivered to.
 * @param {string} payload The message to process.
 * @private
 */
goog.net.xpc.NixTransport.prototype.handleMessage_ =
    function(serviceName, payload) {
  /** @this {goog.net.xpc.NixTransport} */
  var deliveryHandler = function() {
    this.channel_.xpcDeliver(serviceName, payload);
  };
  this.getWindow().setTimeout(goog.bind(deliveryHandler, this), 1);
};


/**
 * Sends a message.
 * @param {string} service The name of the service the message is to be
 *   delivered to.
 * @param {string} payload The message content.
 * @override
 */
goog.net.xpc.NixTransport.prototype.send = function(service, payload) {
  // Verify that the NIX channel we have is valid.
  if (typeof(this.nixChannel_) !== 'unknown') {
    goog.log.error(goog.net.xpc.logger, 'NIX channel not connected');
  }

  // Send the message via the NIX wrapper object.
  this.nixChannel_['SendMessage'](service, payload);
};


/** @override */
goog.net.xpc.NixTransport.prototype.disposeInternal = function() {
  goog.base(this, 'disposeInternal');
  this.nixChannel_ = null;
};

//javascript/closure/net/xpc/crosspagechannel.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides the class CrossPageChannel, the main class in
 * goog.net.xpc.
 *
 * @author mibuerge@google.com (Michael Buerge)
 * @see ../../demos/xpc/index.html
 */

goog.provide('goog.net.xpc.CrossPageChannel');

goog.require('goog.Uri');
goog.require('goog.async.Deferred');
goog.require('goog.async.Delay');
goog.require('goog.dispose');
goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventType');
goog.require('goog.json');
goog.require('goog.log');
goog.require('goog.messaging.AbstractChannel');
goog.require('goog.net.xpc');
goog.require('goog.net.xpc.CfgFields');
goog.require('goog.net.xpc.ChannelStates');
goog.require('goog.net.xpc.CrossPageChannelRole');
goog.require('goog.net.xpc.DirectTransport');
goog.require('goog.net.xpc.FrameElementMethodTransport');
goog.require('goog.net.xpc.IframePollingTransport');
goog.require('goog.net.xpc.IframeRelayTransport');
goog.require('goog.net.xpc.NativeMessagingTransport');
goog.require('goog.net.xpc.NixTransport');
goog.require('goog.net.xpc.TransportTypes');
goog.require('goog.net.xpc.UriCfgFields');
goog.require('goog.string');
goog.require('goog.uri.utils');
goog.require('goog.userAgent');



/**
 * A communication channel between two documents from different domains.
 * Provides asynchronous messaging.
 *
 * @param {Object} cfg Channel configuration object.
 * @param {goog.dom.DomHelper=} opt_domHelper The optional dom helper to
 *     use for looking up elements in the dom.
 * @constructor
 * @extends {goog.messaging.AbstractChannel}
 */
goog.net.xpc.CrossPageChannel = function(cfg, opt_domHelper) {
  goog.base(this);

  for (var i = 0, uriField; uriField = goog.net.xpc.UriCfgFields[i]; i++) {
    if (uriField in cfg && !/^https?:\/\//.test(cfg[uriField])) {
      throw Error('URI ' + cfg[uriField] + ' is invalid for field ' + uriField);
    }
  }

  /**
   * The configuration for this channel.
   * @type {Object}
   * @private
   */
  this.cfg_ = cfg;

  /**
   * The name of the channel. Please use
   * <code>updateChannelNameAndCatalog</code> to change this from the transports
   * vs changing the property directly.
   * @type {string}
   */
  this.name = this.cfg_[goog.net.xpc.CfgFields.CHANNEL_NAME] ||
      goog.net.xpc.getRandomString(10);

  /**
   * The dom helper to use for accessing the dom.
   * @type {goog.dom.DomHelper}
   * @private
   */
  this.domHelper_ = opt_domHelper || goog.dom.getDomHelper();

  /**
   * Collects deferred function calls which will be made once the connection
   * has been fully set up.
   * @type {!Array.<function()>}
   * @private
   */
  this.deferredDeliveries_ = [];

  /**
   * An event handler used to listen for load events on peer iframes.
   * @type {!goog.events.EventHandler}
   * @private
   */
  this.peerLoadHandler_ = new goog.events.EventHandler(this);

  // If LOCAL_POLL_URI or PEER_POLL_URI is not available, try using
  // robots.txt from that host.
  cfg[goog.net.xpc.CfgFields.LOCAL_POLL_URI] =
      cfg[goog.net.xpc.CfgFields.LOCAL_POLL_URI] ||
      goog.uri.utils.getHost(this.domHelper_.getWindow().location.href) +
          '/robots.txt';
  // PEER_URI is sometimes undefined in tests.
  cfg[goog.net.xpc.CfgFields.PEER_POLL_URI] =
      cfg[goog.net.xpc.CfgFields.PEER_POLL_URI] ||
      goog.uri.utils.getHost(cfg[goog.net.xpc.CfgFields.PEER_URI] || '') +
          '/robots.txt';

  goog.net.xpc.channels[this.name] = this;

  if (!goog.events.getListener(window, goog.events.EventType.UNLOAD,
      goog.net.xpc.CrossPageChannel.disposeAll_)) {
    // Set listener to dispose all registered channels on page unload.
    goog.events.listenOnce(window, goog.events.EventType.UNLOAD,
        goog.net.xpc.CrossPageChannel.disposeAll_);
  }

  goog.log.info(goog.net.xpc.logger, 'CrossPageChannel created: ' + this.name);
};
goog.inherits(goog.net.xpc.CrossPageChannel, goog.messaging.AbstractChannel);


/**
 * Regexp for escaping service names.
 * @type {RegExp}
 * @private
 */
goog.net.xpc.CrossPageChannel.TRANSPORT_SERVICE_ESCAPE_RE_ =
    new RegExp('^%*' + goog.net.xpc.TRANSPORT_SERVICE_ + '$');


/**
 * Regexp for unescaping service names.
 * @type {RegExp}
 * @private
 */
goog.net.xpc.CrossPageChannel.TRANSPORT_SERVICE_UNESCAPE_RE_ =
    new RegExp('^%+' + goog.net.xpc.TRANSPORT_SERVICE_ + '$');


/**
 * A delay between the transport reporting as connected and the calling of the
 * connection callback.  Sometimes used to paper over timing vulnerabilities.
 * @type {goog.async.Delay}
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.connectionDelay_ = null;


/**
 * A deferred which is set to non-null while a peer iframe is being created
 * but has not yet thrown its load event, and which fires when that load event
 * arrives.
 * @type {goog.async.Deferred}
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.peerWindowDeferred_ = null;


/**
 * The transport.
 * @type {goog.net.xpc.Transport?}
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.transport_ = null;


/**
 * The channel state.
 * @type {number}
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.state_ =
    goog.net.xpc.ChannelStates.NOT_CONNECTED;


/**
 * @override
 * @return {boolean} Whether the channel is connected.
 */
goog.net.xpc.CrossPageChannel.prototype.isConnected = function() {
  return this.state_ == goog.net.xpc.ChannelStates.CONNECTED;
};


/**
 * Reference to the window-object of the peer page.
 * @type {Object}
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.peerWindowObject_ = null;


/**
 * Reference to the iframe-element.
 * @type {Object}
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.iframeElement_ = null;


/**
 * Returns the configuration object for this channel.
 * Package private. Do not call from outside goog.net.xpc.
 *
 * @return {Object} The configuration object for this channel.
 */
goog.net.xpc.CrossPageChannel.prototype.getConfig = function() {
  return this.cfg_;
};


/**
 * Returns a reference to the iframe-element.
 * Package private. Do not call from outside goog.net.xpc.
 *
 * @return {Object} A reference to the iframe-element.
 */
goog.net.xpc.CrossPageChannel.prototype.getIframeElement = function() {
  return this.iframeElement_;
};


/**
 * Sets the window object the foreign document resides in.
 *
 * @param {Object} peerWindowObject The window object of the peer.
 */
goog.net.xpc.CrossPageChannel.prototype.setPeerWindowObject =
    function(peerWindowObject) {
  this.peerWindowObject_ = peerWindowObject;
};


/**
 * Returns the window object the foreign document resides in.
 * Package private. Do not call from outside goog.net.xpc.
 *
 * @return {Object} The window object of the peer.
 */
goog.net.xpc.CrossPageChannel.prototype.getPeerWindowObject = function() {
  return this.peerWindowObject_;
};


/**
 * Determines whether the peer window is available (e.g. not closed).
 * Package private. Do not call from outside goog.net.xpc.
 *
 * @return {boolean} Whether the peer window is available.
 */
goog.net.xpc.CrossPageChannel.prototype.isPeerAvailable = function() {
  // NOTE(mibuerge): This check is not reliable in IE, where a document in an
  // iframe does not get unloaded when removing the iframe element from the DOM.
  // TODO(mibuerge): Find something that works in IE as well.
  // NOTE(moishel): "!this.peerWindowObject_.closed" evaluates to 'false' in IE9
  // sometimes even though typeof(this.peerWindowObject_.closed) is boolean and
  // this.peerWindowObject_.closed evaluates to 'false'. Casting it to a Boolean
  // results in sane evaluation. When this happens, it's in the inner iframe
  // when querying its parent's 'closed' status. Note that this is a different
  // case than mibuerge@'s note above.
  try {
    return !!this.peerWindowObject_ && !Boolean(this.peerWindowObject_.closed);
  } catch (e) {
    // If the window is closing, an error may be thrown.
    return false;
  }
};


/**
 * Determine which transport type to use for this channel / useragent.
 * @return {goog.net.xpc.TransportTypes|undefined} The best transport type.
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.determineTransportType_ = function() {
  var transportType;
  if (goog.isFunction(document.postMessage) ||
      goog.isFunction(window.postMessage) ||
      // IE8 supports window.postMessage, but
      // typeof window.postMessage returns "object"
      (goog.userAgent.IE && window.postMessage)) {
    transportType = goog.net.xpc.TransportTypes.NATIVE_MESSAGING;
  } else if (goog.userAgent.GECKO) {
    transportType = goog.net.xpc.TransportTypes.FRAME_ELEMENT_METHOD;
  } else if (goog.userAgent.IE &&
             this.cfg_[goog.net.xpc.CfgFields.PEER_RELAY_URI]) {
    transportType = goog.net.xpc.TransportTypes.IFRAME_RELAY;
  } else if (goog.userAgent.IE && goog.net.xpc.NixTransport.isNixSupported()) {
    transportType = goog.net.xpc.TransportTypes.NIX;
  } else {
    transportType = goog.net.xpc.TransportTypes.IFRAME_POLLING;
  }
  return transportType;
};


/**
 * Creates the transport for this channel. Chooses from the available
 * transport based on the user agent and the configuration.
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.createTransport_ = function() {
  // return, if the transport has already been created
  if (this.transport_) {
    return;
  }

  // TODO(wgrose): Use goog.scope.
  var CfgFields = goog.net.xpc.CfgFields;

  if (!this.cfg_[CfgFields.TRANSPORT]) {
    this.cfg_[CfgFields.TRANSPORT] =
        this.determineTransportType_();
  }

  switch (this.cfg_[CfgFields.TRANSPORT]) {
    case goog.net.xpc.TransportTypes.NATIVE_MESSAGING:
      var protocolVersion = this.cfg_[
          CfgFields.NATIVE_TRANSPORT_PROTOCOL_VERSION] || 2;
      this.transport_ = new goog.net.xpc.NativeMessagingTransport(
          this,
          this.cfg_[CfgFields.PEER_HOSTNAME],
          this.domHelper_,
          !!this.cfg_[CfgFields.ONE_SIDED_HANDSHAKE],
          protocolVersion);
      break;
    case goog.net.xpc.TransportTypes.NIX:
      this.transport_ = new goog.net.xpc.NixTransport(this, this.domHelper_);
      break;
    case goog.net.xpc.TransportTypes.FRAME_ELEMENT_METHOD:
      this.transport_ =
          new goog.net.xpc.FrameElementMethodTransport(this, this.domHelper_);
      break;
    case goog.net.xpc.TransportTypes.IFRAME_RELAY:
      this.transport_ =
          new goog.net.xpc.IframeRelayTransport(this, this.domHelper_);
      break;
    case goog.net.xpc.TransportTypes.IFRAME_POLLING:
      this.transport_ =
          new goog.net.xpc.IframePollingTransport(this, this.domHelper_);
      break;
    case goog.net.xpc.TransportTypes.DIRECT:
      if (this.peerWindowObject_ &&
          goog.net.xpc.DirectTransport.isSupported(/** @type {!Window} */ (
              this.peerWindowObject_))) {
        this.transport_ =
            new goog.net.xpc.DirectTransport(this, this.domHelper_);
      } else {
        goog.log.info(
            goog.net.xpc.logger,
            'DirectTransport not supported for this window, peer window in' +
            ' different security context or not set yet.');
      }
      break;
  }

  if (this.transport_) {
    goog.log.info(goog.net.xpc.logger,
        'Transport created: ' + this.transport_.getName());
  } else {
    throw Error('CrossPageChannel: No suitable transport found!');
  }
};


/**
 * Returns the transport type in use for this channel.
 * @return {number} Transport-type identifier.
 */
goog.net.xpc.CrossPageChannel.prototype.getTransportType = function() {
  return this.transport_.getType();
};


/**
 * Returns the tranport name in use for this channel.
 * @return {string} The transport name.
 */
goog.net.xpc.CrossPageChannel.prototype.getTransportName = function() {
  return this.transport_.getName();
};


/**
 * @return {Object} Configuration-object to be used by the peer to
 *     initialize the channel.
 */
goog.net.xpc.CrossPageChannel.prototype.getPeerConfiguration = function() {
  var peerCfg = {};
  peerCfg[goog.net.xpc.CfgFields.CHANNEL_NAME] = this.name;
  peerCfg[goog.net.xpc.CfgFields.TRANSPORT] =
      this.cfg_[goog.net.xpc.CfgFields.TRANSPORT];
  peerCfg[goog.net.xpc.CfgFields.ONE_SIDED_HANDSHAKE] =
      this.cfg_[goog.net.xpc.CfgFields.ONE_SIDED_HANDSHAKE];

  if (this.cfg_[goog.net.xpc.CfgFields.LOCAL_RELAY_URI]) {
    peerCfg[goog.net.xpc.CfgFields.PEER_RELAY_URI] =
        this.cfg_[goog.net.xpc.CfgFields.LOCAL_RELAY_URI];
  }
  if (this.cfg_[goog.net.xpc.CfgFields.LOCAL_POLL_URI]) {
    peerCfg[goog.net.xpc.CfgFields.PEER_POLL_URI] =
        this.cfg_[goog.net.xpc.CfgFields.LOCAL_POLL_URI];
  }
  if (this.cfg_[goog.net.xpc.CfgFields.PEER_POLL_URI]) {
    peerCfg[goog.net.xpc.CfgFields.LOCAL_POLL_URI] =
        this.cfg_[goog.net.xpc.CfgFields.PEER_POLL_URI];
  }
  var role = this.cfg_[goog.net.xpc.CfgFields.ROLE];
  if (role) {
    peerCfg[goog.net.xpc.CfgFields.ROLE] =
        role == goog.net.xpc.CrossPageChannelRole.INNER ?
            goog.net.xpc.CrossPageChannelRole.OUTER :
            goog.net.xpc.CrossPageChannelRole.INNER;
  }

  return peerCfg;
};


/**
 * Creates the iframe containing the peer page in a specified parent element.
 * This method does not connect the channel, connect() still has to be called
 * separately.
 *
 * @param {!Element} parentElm The container element the iframe is appended to.
 * @param {Function=} opt_configureIframeCb If present, this function gets
 *     called with the iframe element as parameter to allow setting properties
 *     on it before it gets added to the DOM. If absent, the iframe's width and
 *     height are set to '100%'.
 * @param {boolean=} opt_addCfgParam Whether to add the peer configuration as
 *     URL parameter (default: true).
 * @return {!HTMLIFrameElement} The iframe element.
 */
goog.net.xpc.CrossPageChannel.prototype.createPeerIframe = function(
    parentElm, opt_configureIframeCb, opt_addCfgParam) {
  goog.log.info(goog.net.xpc.logger, 'createPeerIframe()');

  var iframeId = this.cfg_[goog.net.xpc.CfgFields.IFRAME_ID];
  if (!iframeId) {
    // Create a randomized ID for the iframe element to avoid
    // bfcache-related issues.
    iframeId = this.cfg_[goog.net.xpc.CfgFields.IFRAME_ID] =
        'xpcpeer' + goog.net.xpc.getRandomString(4);
  }

  // TODO(mibuerge) Opera creates a history-entry when creating an iframe
  // programmatically as follows. Find a way which avoids this.

  var iframeElm = goog.dom.getDomHelper(parentElm).createElement('IFRAME');
  iframeElm.id = iframeElm.name = iframeId;
  if (opt_configureIframeCb) {
    opt_configureIframeCb(iframeElm);
  } else {
    iframeElm.style.width = iframeElm.style.height = '100%';
  }

  this.cleanUpIncompleteConnection_();
  this.peerWindowDeferred_ =
      new goog.async.Deferred(undefined, this);
  var peerUri = this.getPeerUri(opt_addCfgParam);
  this.peerLoadHandler_.listenOnceWithScope(iframeElm, 'load',
      this.peerWindowDeferred_.callback, false, this.peerWindowDeferred_);

  if (goog.userAgent.GECKO || goog.userAgent.WEBKIT) {
    // Appending the iframe in a timeout to avoid a weird fastback issue, which
    // is present in Safari and Gecko.
    window.setTimeout(
        goog.bind(function() {
          parentElm.appendChild(iframeElm);
          iframeElm.src = peerUri.toString();
          goog.log.info(goog.net.xpc.logger,
              'peer iframe created (' + iframeId + ')');
        }, this), 1);
  } else {
    iframeElm.src = peerUri.toString();
    parentElm.appendChild(iframeElm);
    goog.log.info(goog.net.xpc.logger,
        'peer iframe created (' + iframeId + ')');
  }

  return /** @type {!HTMLIFrameElement} */ (iframeElm);
};


/**
 * Clean up after any incomplete attempt to establish and connect to a peer
 * iframe.
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.cleanUpIncompleteConnection_ =
    function() {
  if (this.peerWindowDeferred_) {
    this.peerWindowDeferred_.cancel();
    this.peerWindowDeferred_ = null;
  }
  this.deferredDeliveries_.length = 0;
  this.peerLoadHandler_.removeAll();
};


/**
 * Returns the peer URI, with an optional URL parameter for configuring the peer
 * window.
 *
 * @param {boolean=} opt_addCfgParam Whether to add the peer configuration as
 *     URL parameter (default: true).
 * @return {!goog.Uri} The peer URI.
 */
goog.net.xpc.CrossPageChannel.prototype.getPeerUri = function(opt_addCfgParam) {
  var peerUri = this.cfg_[goog.net.xpc.CfgFields.PEER_URI];
  if (goog.isString(peerUri)) {
    peerUri = this.cfg_[goog.net.xpc.CfgFields.PEER_URI] =
        new goog.Uri(peerUri);
  }

  // Add the channel configuration used by the peer as URL parameter.
  if (opt_addCfgParam !== false) {
    peerUri.setParameterValue('xpc',
                              goog.json.serialize(
                                  this.getPeerConfiguration()));
  }

  return peerUri;
};


/**
 * Initiates connecting the channel. When this method is called, all the
 * information needed to connect the channel has to be available.
 *
 * @override
 * @param {Function=} opt_connectCb The function to be called when the
 * channel has been connected and is ready to be used.
 */
goog.net.xpc.CrossPageChannel.prototype.connect = function(opt_connectCb) {
  this.connectCb_ = opt_connectCb || goog.nullFunction;

  // If we know of a peer window whose creation has been requested but is not
  // complete, peerWindowDeferred_ will be non-null, and we should block on it.
  if (this.peerWindowDeferred_) {
    this.peerWindowDeferred_.addCallback(this.continueConnection_);
  } else {
    this.continueConnection_();
  }
};


/**
 * Continues the connection process once we're as sure as we can be that the
 * peer iframe has been created.
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.continueConnection_ = function() {
  goog.log.info(goog.net.xpc.logger, 'continueConnection_()');
  this.peerWindowDeferred_ = null;
  if (this.cfg_[goog.net.xpc.CfgFields.IFRAME_ID]) {
    this.iframeElement_ = this.domHelper_.getElement(
        this.cfg_[goog.net.xpc.CfgFields.IFRAME_ID]);
  }
  if (this.iframeElement_) {
    var winObj = this.iframeElement_.contentWindow;
    // accessing the window using contentWindow doesn't work in safari
    if (!winObj) {
      winObj = window.frames[this.cfg_[goog.net.xpc.CfgFields.IFRAME_ID]];
    }
    this.setPeerWindowObject(winObj);
  }

  // if the peer window object has not been set at this point, we assume
  // being in an iframe and the channel is meant to be to the containing page
  if (!this.peerWindowObject_) {
    // throw an error if we are in the top window (== not in an iframe)
    if (window == window.top) {
      throw Error(
          "CrossPageChannel: Can't connect, peer window-object not set.");
    } else {
      this.setPeerWindowObject(window.parent);
    }
  }

  this.createTransport_();

  this.transport_.connect();

  // Now we run any deferred deliveries collected while connection was deferred.
  while (this.deferredDeliveries_.length > 0) {
    this.deferredDeliveries_.shift()();
  }
};


/**
 * Closes the channel.
 */
goog.net.xpc.CrossPageChannel.prototype.close = function() {
  this.cleanUpIncompleteConnection_();
  this.state_ = goog.net.xpc.ChannelStates.CLOSED;
  goog.dispose(this.transport_);
  this.transport_ = null;
  this.connectCb_ = null;
  goog.dispose(this.connectionDelay_);
  this.connectionDelay_ = null;
  goog.log.info(goog.net.xpc.logger, 'Channel "' + this.name + '" closed');
};


/**
 * Package-private.
 * Called by the transport when the channel is connected.
 * @param {number=} opt_delay Delay this number of milliseconds before calling
 *     the connection callback. Usage is discouraged, but can be used to paper
 *     over timing vulnerabilities when there is no alternative.
 */
goog.net.xpc.CrossPageChannel.prototype.notifyConnected = function(opt_delay) {
  if (this.isConnected() ||
      (this.connectionDelay_ && this.connectionDelay_.isActive())) {
    return;
  }
  this.state_ = goog.net.xpc.ChannelStates.CONNECTED;
  goog.log.info(goog.net.xpc.logger, 'Channel "' + this.name + '" connected');
  goog.dispose(this.connectionDelay_);
  if (opt_delay) {
    this.connectionDelay_ =
        new goog.async.Delay(this.connectCb_, opt_delay);
    this.connectionDelay_.start();
  } else {
    this.connectionDelay_ = null;
    this.connectCb_();
  }
};


/**
 * Alias for notifyConected, for backward compatibility reasons.
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.notifyConnected_ =
    goog.net.xpc.CrossPageChannel.prototype.notifyConnected;


/**
 * Called by the transport in case of an unrecoverable failure.
 * Package private. Do not call from outside goog.net.xpc.
 */
goog.net.xpc.CrossPageChannel.prototype.notifyTransportError = function() {
  goog.log.info(goog.net.xpc.logger, 'Transport Error');
  this.close();
};


/** @override */
goog.net.xpc.CrossPageChannel.prototype.send = function(serviceName, payload) {
  if (!this.isConnected()) {
    goog.log.error(goog.net.xpc.logger, 'Can\'t send. Channel not connected.');
    return;
  }
  // Check if the peer is still around.
  if (!this.isPeerAvailable()) {
    goog.log.error(goog.net.xpc.logger, 'Peer has disappeared.');
    this.close();
    return;
  }
  if (goog.isObject(payload)) {
    payload = goog.json.serialize(payload);
  }

  // Partially URL-encode the service name because some characters (: and |) are
  // used as delimiters for some transports, and we want to allow those
  // characters in service names.
  this.transport_.send(this.escapeServiceName_(serviceName), payload);
};


/**
 * Delivers messages to the appropriate service-handler. Named xpcDeliver to
 * avoid name conflict with {@code deliver} function in superclass
 * goog.messaging.AbstractChannel.
 *
 * Package private. Do not call from outside goog.net.xpc.
 *
 * @param {string} serviceName The name of the port.
 * @param {string} payload The payload.
 * @param {string=} opt_origin An optional origin for the message, where the
 *     underlying transport makes that available.  If this is specified, and
 *     the PEER_HOSTNAME parameter was provided, they must match or the message
 *     will be rejected.
 */
goog.net.xpc.CrossPageChannel.prototype.xpcDeliver = function(
    serviceName, payload, opt_origin) {

  // This check covers the very rare (but producable) case where the inner frame
  // becomes ready and sends its setup message while the outer frame is
  // deferring its connect method waiting for the inner frame to be ready. The
  // resulting deferral ensures the message will not be processed until the
  // channel is fully configured.
  if (this.peerWindowDeferred_) {
    this.deferredDeliveries_.push(
        goog.bind(this.xpcDeliver, this, serviceName, payload, opt_origin));
    return;
  }

  // Check whether the origin of the message is as expected.
  if (!this.isMessageOriginAcceptable_(opt_origin)) {
    goog.log.warning(goog.net.xpc.logger,
        'Message received from unapproved origin "' +
        opt_origin + '" - rejected.');
    return;
  }

  if (this.isDisposed()) {
    goog.log.warning(goog.net.xpc.logger,
        'CrossPageChannel::xpcDeliver(): Disposed.');
  } else if (!serviceName ||
      serviceName == goog.net.xpc.TRANSPORT_SERVICE_) {
    this.transport_.transportServiceHandler(payload);
  } else {
    // only deliver messages if connected
    if (this.isConnected()) {
      this.deliver(this.unescapeServiceName_(serviceName), payload);
    } else {
      goog.log.info(goog.net.xpc.logger,
          'CrossPageChannel::xpcDeliver(): Not connected.');
    }
  }
};


/**
 * Escape the user-provided service name for sending across the channel. This
 * URL-encodes certain special characters so they don't conflict with delimiters
 * used by some of the transports, and adds a special prefix if the name
 * conflicts with the reserved transport service name.
 *
 * This is the opposite of {@link #unescapeServiceName_}.
 *
 * @param {string} name The name of the service to escape.
 * @return {string} The escaped service name.
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.escapeServiceName_ = function(name) {
  if (goog.net.xpc.CrossPageChannel.TRANSPORT_SERVICE_ESCAPE_RE_.test(name)) {
    name = '%' + name;
  }
  return name.replace(/[%:|]/g, encodeURIComponent);
};


/**
 * Unescape the escaped service name that was sent across the channel. This is
 * the opposite of {@link #escapeServiceName_}.
 *
 * @param {string} name The name of the service to unescape.
 * @return {string} The unescaped service name.
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.unescapeServiceName_ = function(name) {
  name = name.replace(/%[0-9a-f]{2}/gi, decodeURIComponent);
  if (goog.net.xpc.CrossPageChannel.TRANSPORT_SERVICE_UNESCAPE_RE_.test(name)) {
    return name.substring(1);
  } else {
    return name;
  }
};


/**
 * Returns the role of this channel (either inner or outer).
 * @return {number} The role of this channel.
 */
goog.net.xpc.CrossPageChannel.prototype.getRole = function() {
  var role = this.cfg_[goog.net.xpc.CfgFields.ROLE];
  if (goog.isNumber(role)) {
    return role;
  } else {
    return window.parent == this.peerWindowObject_ ?
        goog.net.xpc.CrossPageChannelRole.INNER :
        goog.net.xpc.CrossPageChannelRole.OUTER;
  }
};


/**
 * Sets the channel name. Note, this doesn't establish a unique channel to
 * communicate on.
 * @param {string} name The new channel name.
 */
goog.net.xpc.CrossPageChannel.prototype.updateChannelNameAndCatalog = function(
    name) {
  goog.log.fine(goog.net.xpc.logger, 'changing channel name to ' + name);
  delete goog.net.xpc.channels[this.name];
  this.name = name;
  goog.net.xpc.channels[name] = this;
};


/**
 * Returns whether an incoming message with the given origin is acceptable.
 * If an incoming request comes with a specified (non-empty) origin, and the
 * PEER_HOSTNAME config parameter has also been provided, the two must match,
 * or the message is unacceptable.
 * @param {string=} opt_origin The origin associated with the incoming message.
 * @return {boolean} Whether the message is acceptable.
 * @private
 */
goog.net.xpc.CrossPageChannel.prototype.isMessageOriginAcceptable_ = function(
    opt_origin) {
  var peerHostname = this.cfg_[goog.net.xpc.CfgFields.PEER_HOSTNAME];
  return goog.string.isEmptySafe(opt_origin) ||
      goog.string.isEmptySafe(peerHostname) ||
      opt_origin == this.cfg_[goog.net.xpc.CfgFields.PEER_HOSTNAME];
};


/** @override */
goog.net.xpc.CrossPageChannel.prototype.disposeInternal = function() {
  this.close();

  this.peerWindowObject_ = null;
  this.iframeElement_ = null;
  delete goog.net.xpc.channels[this.name];
  goog.dispose(this.peerLoadHandler_);
  delete this.peerLoadHandler_;
  goog.base(this, 'disposeInternal');
};


/**
 * Disposes all channels.
 * @private
 */
goog.net.xpc.CrossPageChannel.disposeAll_ = function() {
  for (var name in goog.net.xpc.channels) {
    goog.dispose(goog.net.xpc.channels[name]);
  }
};

//ipc/invalidation/javascript/utils/xpciframecreator.js
/**
 * @fileoverview A utility to create the peer iframe for an XPC channel. If the
 * channel fails to connect within a timeout, retries with exponential backoff.
 * Allows XPC channel setup to be robust to any sort of failure that might
 * prevent the iframe content from loading properly.
 */

goog.provide('invalidation.XpcIframeCreator');

goog.require('goog.Timer');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.net.xpc.CrossPageChannel');
goog.require('invalidation.ExponentialBackoffDelayGenerator');

/**
 * Creates the peer iframe for an XPC channel. If the channel fails to connect
 * within a timeout, retries with exponential backoff.
 * @param {!Object} xpcConfig Configuration for the cross-page channel. See
 *     {@code goog.net.xpc.CrossPageChannel} for more information.
 * @param {string} iframeContainerId The id of the dom element into which the
 *     iframe content is to be loaded.
 * @param {!function(!goog.net.xpc.CrossPageChannel)} connectionCallback A
 *     callback to be invoked with the successfully connected cross-page
 *     channel.
 * @constructor
 */
invalidation.XpcIframeCreator = function(xpcConfig, iframeContainerId,
    connectionCallback) {

  /**
   * Configuration for the cross-page channel.
   * @type {!Object}
   * @private
   */
  this.xpcConfig_ = xpcConfig;

  /**
   * The id of the dom element into which the iframe content is to be loaded.
   * @type {string}
   * @private
   */
  this.iframeContainerId_ = iframeContainerId;

  /**
   * A callback to be invoked when the XPC connection has been established.
   * @type {!Function}
   * @private
   */
  this.connectionCallback_ = connectionCallback;

  /**
   * Exponential backoff delay generator.
   * @type {!invalidation.ExponentialBackoffDelayGenerator}
   * @private
   */
  this.delayGenerator_ = new invalidation.ExponentialBackoffDelayGenerator(
      Math.random,
      invalidation.XpcIframeCreator.INITIAL_XPC_CONNECTION_TIMEOUT_MS_,
      invalidation.XpcIframeCreator.MAX_BACKOFF_FACTOR_);

  /**
   * The cross-page channel that we create.
   * @type {goog.net.xpc.CrossPageChannel}
   * @private
   */
  this.crossPageChannel_ = null;
};


/**
 * Initial timeout in milliseconds for the cross-page channel to be established.
 * @type {number}
 * @const
 * @private
 */
invalidation.XpcIframeCreator.INITIAL_XPC_CONNECTION_TIMEOUT_MS_ = 5000;


/**
 * Maximum backoff factor for retries of loading the iframe content for the
 * cross-page channel.
 * @type {number}
 * @const
 * @private
 */
invalidation.XpcIframeCreator.MAX_BACKOFF_FACTOR_ = 128;


/**
 * Creates a cross-page channel with the config passed to our constructor. Also
 * creates the peer iframe for the channel and attempts to connect it. Sets a
 * timer task that will retry this (with exponential backoff) if the connection
 * hasn't completed by the current timeout.
 */
invalidation.XpcIframeCreator.prototype.createCrossPageChannel = function() {
  this.crossPageChannel_ = new goog.net.xpc.CrossPageChannel(this.xpcConfig_);

  // Create the peer iframe.
  this.crossPageChannel_.createPeerIframe(
      /** @type {!Element} */ (goog.dom.getElement(this.iframeContainerId_)));

  // Set a timeout to check that the XPC connection completes within a
  // reasonable amount of time; we'll retry with exponential backoff if not.
  goog.Timer.callOnce(this.checkConnectionTimeout_,
      this.delayGenerator_.getNextDelay() +
      invalidation.XpcIframeCreator.INITIAL_XPC_CONNECTION_TIMEOUT_MS_,
      this);

  // Attempt to connect the cross-page channel, and inform the callback if and
  // when this succeeds.
  this.crossPageChannel_.connect(goog.bind(function() {
    goog.asserts.assert(this.crossPageChannel_.isConnected());
    this.connectionCallback_(this.crossPageChannel_);
  }, this));
};


/**
 * Checks whether our cross-page channel has connected successfully. If not,
 * closes the channel to clean up the incomplete connection, removes any old
 * iframe content in the container div, and retries. This logic is to address
 * an issue that arises during rolling server updates, where a new task embeds a
 * script tag for JavaScript that old tasks don't yet know about.
 * <p>
 * TODO(ghc): [bug 6337428] If and when we serve our JavaScript out of gstatic,
 * this problem should go away. However, we may want to retain this code as a
 * safeguard against unforeseen issues.
 * @private
 */
invalidation.XpcIframeCreator.prototype.checkConnectionTimeout_ = function() {
  if (!this.crossPageChannel_.isConnected()) {
    // If the cross-page channel hasn't managed to connect by now, assume
    // something has gone wrong.

    // Close the channel (to clean up the incomplete connection).
    this.crossPageChannel_.close();

    // Remove previous (probably broken) iframe content.
    var container = goog.dom.getElement(this.iframeContainerId_);
    var children = goog.dom.getChildren(container);
    for (var i = 0; i < children.length; ++i) {
      goog.dom.removeNode(children[i]);
    }

    // Call start again (which will reschedule this check with exponential
    // backoff).
    this.createCrossPageChannel();
  }
};

//buzz/channel/javascript/internal/iframedbrowserchannelclient.js
// Copyright 2012 Google Inc.  All Rights Reserved.

/**
 * @fileoverview Base class for clients of browser channels hosted in iframes.
 *
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('buzz.channel.IframedBrowserChannelClient');

goog.require('buzz.channel.BrowserChannelHandlerInterface');
goog.require('buzz.channel.BrowserChannelInterface');
goog.require('buzz.channel.XpcFunctions');
goog.require('buzz.channel.proto.AuthenticationParameters');
goog.require('goog.Uri');
goog.require('invalidation.Utils');
goog.require('invalidation.util.Logger');

/**
 * A client that connects to an iframe that hosts a browser channel
 * implementation. The client also passes upcalls to the host page handler.
 *
 * @param {string} iframeUri The uri of the iframe server.
 * @param {string} iframeContainerId The id of the element in which to load
 *     the iframe that will host the actual browser channel connection.
 * @param {buzz.channel.BrowserChannelHandlerInterface} handler The host handler
 *     of the browser channel.
 * @param {buzz.channel.proto.BrowserChannelConfig} config The browser channel
 *     configuration.
 * @constructor
 * @implements buzz.channel.BrowserChannelInterface
 */
buzz.channel.IframedBrowserChannelClient =
    function(iframeUri, iframeContainerId, handler, config) {

  /**
   * The uri to reach iframe server.
   * @type {string}
   * @protected
   */
  this.iframeUri = iframeUri;

  /**
   * The id of the element that will contain the browser channel iframe.
   * @type {string}
   * @protected
   */
  this.iframeContainerId = iframeContainerId;

  /**
   * The configuration for the browser channel.
   * @type {buzz.channel.proto.BrowserChannelConfig}
   * @private
   */
  this.config_ = config;

  /**
   * The browser channel handler.
   * @type {buzz.channel.BrowserChannelHandlerInterface}
   * @private
   */
  this.handler_ = handler;

  /**
   * Cached authentication parameters.
   * @type {buzz.channel.proto.AuthenticationParameters}
   * @private
   */
  this.authParams_ = null;
};


/**
 * @return {boolean} Whether this client is configured to authenticate with
 *     OAuth.
 * @protected
 */
buzz.channel.IframedBrowserChannelClient.prototype.isUsingOAuth = function() {
  return (this.authParams_ != null) && (this.authParams_.getScheme() ==
      buzz.channel.proto.AuthenticationParameters.Scheme.OAUTH);
};

/**
 * @inheritDoc
 */
buzz.channel.IframedBrowserChannelClient.prototype.start = goog.abstractMethod;

/**
 * Registers the given function as a service under the given name.
 * @param {string} name The name of the service to register.
 * @param {function((Object|string)):?} fn The function that implements the
 *     service.
 */
buzz.channel.IframedBrowserChannelClient.prototype.registerService =
    goog.abstractMethod;

/**
 * Calls a service on the iframed browser channel.
 * @param {string} name The name of the cross-page call to make.
 * @param {Object|string} opt_arg Argument to the call.
 */
buzz.channel.IframedBrowserChannelClient.prototype.makeCrossPageCall =
    goog.abstractMethod;

/**
 * @return {invalidation.util.Logger} A logger.
 */
buzz.channel.IframedBrowserChannelClient.prototype.getLogger =
    goog.abstractMethod;


/** Called when the cross-page channel is connected. */
buzz.channel.IframedBrowserChannelClient.prototype.onConnect = function() {
  this.getLogger().info(
      'Cross-iframe rpc mechanism ready; opening browser channel');

  // If authentication parameters were set, send those over before starting the
  // browser channel.
  if (this.authParams_) {
    this.updateAuthParams(this.authParams_);
  }

  // Get the browser channel connected.
  this.makeCrossPageCall(buzz.channel.XpcFunctions.START, []);
};


/** @return {string} The full uri for the iframe. */
buzz.channel.IframedBrowserChannelClient.prototype.getIframeUri = function() {
  var uri = new goog.Uri(this.iframeUri);
  var params = invalidation.Utils.serializeMessage(
      /** @type {!goog.proto2.Message} */ (this.config_));
  uri.setParameterValue(
      buzz.channel.SharedConstants.BROWSER_CHANNEL_CONFIG_PARAM, params);
  uri.setParameterValue(
      buzz.channel.SharedConstants.CLIENT_TYPE_PARAM,
      this.config_.getClientType());
  var gaiaServiceOverride = this.config_.getServiceOverride();
  if (gaiaServiceOverride) {
    uri.setParameterValue(
        buzz.channel.SharedConstants.GAIA_SERVICE_PARAM,
        gaiaServiceOverride);
  }
  if (this.isUsingOAuth()) {
    uri.setParameterValue(
        buzz.channel.SharedConstants.OAUTH_TOKEN_PARAM,
        this.authParams_.getToken());
  }
  return uri.toString();
};


/** Registers cross-iframe services. */
buzz.channel.IframedBrowserChannelClient.prototype.registerServices =
    function() {
  this.registerService(buzz.channel.XpcFunctions.CHANNEL_HANDLE_ARRAY,
      /** @type {function((Object|string))} */ (
          goog.bind(this.channelHandleArray, this)));
  this.registerService(buzz.channel.XpcFunctions.CHANNEL_OPENED,
      goog.bind(this.channelOpened, this));
  this.registerService(buzz.channel.XpcFunctions.CHANNEL_CLOSED,
      goog.bind(this.channelClosed, this));
  this.registerService(buzz.channel.XpcFunctions.CHANNEL_ERROR,
      /** @type {function((Object|string))} */ (
          goog.bind(this.channelError, this)));
};


/**
 * @inheritDoc
 */
buzz.channel.IframedBrowserChannelClient.prototype.close = function() {
};


/** @inheritDoc */
buzz.channel.IframedBrowserChannelClient.prototype.updateAuthParams = function(
    authParams) {
  this.authParams_ = authParams;
  var serialized = /** @type {!Object} */ (
      invalidation.Utils.ObjectSerializer.serialize(this.authParams_));
  this.makeCrossPageCall(
      buzz.channel.XpcFunctions.UPDATE_AUTH_PARAMS, serialized);
};


/**
 * @inheritDoc
 */
buzz.channel.IframedBrowserChannelClient.prototype.sendMap =
    function(mapToSend) {
  this.makeCrossPageCall(buzz.channel.XpcFunctions.SEND_MAP, mapToSend);
};


/** @inheritDoc */
buzz.channel.IframedBrowserChannelClient.prototype.
    tryImmediateReconnectByUserRequest = function() {
  this.makeCrossPageCall(buzz.channel.XpcFunctions.TRY_CONNECT_NOW, []);
};


/** Notifies that the browser channel has opened.  */
buzz.channel.IframedBrowserChannelClient.prototype.channelOpened =
    function() {
  this.handler_.channelOpened();
};


/**
 * Callback for when data arrive from the cross-page browser channel.
 * @param {Array} dataArray The data from the browser channel.
 */
buzz.channel.IframedBrowserChannelClient.prototype.channelHandleArray =
    function(dataArray) {
  this.handler_.channelHandleArray(dataArray);
};


/** Notifies that the browser channel is closed. */
buzz.channel.IframedBrowserChannelClient.prototype.channelClosed =
    function() {
  this.handler_.channelClosed();
};


/**
 * Callback for when an error occurs on the cross-page browser channel.
 * @param {goog.net.BrowserChannel.Error} error The low-level browser channel
 *     error.
 */
buzz.channel.IframedBrowserChannelClient.prototype.channelError =
    function(error) {
  this.handler_.channelError(error);
};

//buzz/channel/javascript/internal/xpcbrowserchannelclient.js
/**
 * @fileoverview Implementation of a browser channel connection via XPC-based
 * protocol wrapper. This class serves as the browser channel proxy to the host
 * page.
 */

goog.provide('buzz.channel.XpcBrowserChannelClient');

goog.require('buzz.channel.BrowserChannelHandlerInterface');
goog.require('buzz.channel.BrowserChannelInterface');
goog.require('buzz.channel.IframedBrowserChannelClient');
goog.require('buzz.channel.XpcFunctions');
goog.require('buzz.channel.proto.AuthenticationParameters');
goog.require('goog.Uri');
goog.require('goog.net.xpc.CrossPageChannel');
goog.require('invalidation.XpcIframeCreator');
goog.require('invalidation.util.Logger');
goog.require('invalidation.util.LoggerImpl');

/**
 * A client that connects to an iframe that hosts a browser channel
 * implementation. The client also passes upcalls to the host page handler.
 *
 * @param {string} iframeUri The uri of the iframe server.
 * @param {string} iframeContainerId The id of the element in which to load
 *     the iframe that will host the actual browser channel connection.
 * @param {buzz.channel.BrowserChannelHandlerInterface} handler The host handler
 *     of the browser channel.
 * @param {buzz.channel.proto.BrowserChannelConfig} config The browser channel
 *     configuration.
 * @constructor
 * @extends buzz.channel.IframedBrowserChannelClient
 * @implements buzz.channel.BrowserChannelInterface
 */
buzz.channel.XpcBrowserChannelClient =
    function(iframeUri, iframeContainerId, handler, config) {

  goog.base(this, iframeUri, iframeContainerId, handler, config);

  /**
   * The cross-page channel to the host page.
   * @type {goog.net.xpc.CrossPageChannel}
   * @private
   */
  this.crossPageChannel_ = null;

  /**
   * @type {!invalidation.util.Logger}
   * @private
   */
  this.logger_ = new invalidation.util.LoggerImpl('XpcBrowserChannelClient');
};
goog.inherits(buzz.channel.XpcBrowserChannelClient,
    buzz.channel.IframedBrowserChannelClient);


/**
 * Called by the iframe creator utility once the cross-page channel is
 * connected.
 * @param {!goog.net.xpc.CrossPageChannel} crossPageChannel The connected
 *     cross-page channel.
 * @private
 */
buzz.channel.XpcBrowserChannelClient.prototype.onXpcConnect_ = function(
    crossPageChannel) {
  this.crossPageChannel_ = crossPageChannel;
  this.registerServices();
  this.onConnect();
};


/**
 * @inheritDoc
 */
buzz.channel.XpcBrowserChannelClient.prototype.start = function() {
  goog.asserts.assert(!this.crossPageChannel_);
  this.logger_.info('Attempting to connect cross-page channel');

  // Create the xpc uri with configuration parameters.
  var uri = this.getIframeUri();

  // Configure and create the cross-page channel.
  var xpcConfig = {};
  xpcConfig[goog.net.xpc.CfgFields.PEER_URI] = uri;

  // Configuration specific to Iframe Polling transport.  As far as we know, no
  // current browser uses this.  However, the XPC code validates these
  // parameters, and the defaults can fail validation (e.g., "extension://...").
  // So, for now, we set them to values that are incorrect but should always
  // pass validation.
  // TODO(ghc): [cleanup] Come up with a better long-term solution to this.
  xpcConfig[goog.net.xpc.CfgFields.PEER_POLL_URI] = this.iframeUri +
      'xpc_blank';
  xpcConfig[goog.net.xpc.CfgFields.LOCAL_POLL_URI] = this.iframeUri +
      'xpc_blank';
  xpcConfig[goog.net.xpc.CfgFields.PEER_RELAY_URI] = this.iframeUri +
      'xpc_relay';
  xpcConfig[goog.net.xpc.CfgFields.LOCAL_RELAY_URI] = this.iframeUri +
      'xpc_relay';

  this.xpcIframeCreator_ = new invalidation.XpcIframeCreator(
      xpcConfig, this.iframeContainerId, goog.bind(this.onXpcConnect_, this));
  this.xpcIframeCreator_.createCrossPageChannel();
};


/**
 * @inheritDoc
 * @param {string} name The name of the service to register.
 * @param {function((Object|string)):?} fn The function that implements the
 *     service.
 */
buzz.channel.XpcBrowserChannelClient.prototype.registerService =
    function(name, fn) {
  this.crossPageChannel_.registerService(name, fn, true);
};


/**
 * @inheritDoc
 * @param {string} name The name of the cross-page call to make.
 * @param {Object|string} opt_arg Argument to the call.
 */
buzz.channel.XpcBrowserChannelClient.prototype.makeCrossPageCall =
    function(name, opt_arg) {
  if (this.crossPageChannel_ && this.crossPageChannel_.isConnected()) {
    this.crossPageChannel_.send(name, opt_arg || []);
  }
};


/** @inheritDoc */
buzz.channel.XpcBrowserChannelClient.prototype.getLogger = function() {
  return this.logger_;
};

//buzz/channel/javascript/internal/xpcchannelconfigimpl.js
/**
 * @fileoverview A channel config implementation using an XPC-based browser
 * channel.
 */

goog.provide('buzz.channel.XpcChannelConfigImpl');

goog.require('buzz.channel.ChannelConfigImpl');
goog.require('buzz.channel.XpcBrowserChannelClient');

/**
 * @param {string} uriStr The address to which to connect. This is a fully
 *     qualified path to the iframe if xpc is used. Or it is a relative path if
 *     not. Must be on the same domain as the one from which this script was
 *     downloaded.
 * @param {string} clientType Client type value (must less than 16 characters).
 * @param {boolean} serverAssignsSessionName Whether to allow the server to
 *     assign our session names.
 * @param {string} iframeContainerId Id of the element in which the XPC iframe
 *     should be loaded.
 * @param {number=} opt_authuser Optional authuser parameter for the channel
 *     (indicates which session to use for multi-login).
 * @param {string=} opt_gaiaServiceOverride Optional Gaia service name override
 *     (for applications and domains where Talk may be disabled).
 * @extends {buzz.channel.ChannelConfigImpl}
 * @constructor
 */
buzz.channel.XpcChannelConfigImpl = function(uriStr, clientType,
    serverAssignsSessionName, iframeContainerId, opt_authuser,
    opt_gaiaServiceOverride) {

  goog.base(this, uriStr, clientType, serverAssignsSessionName, opt_authuser,
      opt_gaiaServiceOverride);

  /**
   * Id of the element that will contain the iframe.
   * @type {string}
   * @private
   */
  this.iframeContainerId_ = iframeContainerId;
};
goog.inherits(buzz.channel.XpcChannelConfigImpl,
    buzz.channel.ChannelConfigImpl);

/** @inheritDoc */
buzz.channel.XpcChannelConfigImpl.prototype.createBrowserChannel =
    function(handler) {
  return new buzz.channel.XpcBrowserChannelClient(this.getUri(),
      this.iframeContainerId_, handler, this.toConfigProto());
};

//buzz/channel/javascript/external/factory/channelfactory.js
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Channel API, based on go/faston.  There are two concepts
 * defined in this file, Channel and Session.  A Channel is a physical
 * connection to a frontend over which several Sessions with backend services
 * may be multiplexed.  A Session can be used to send messages to the service,
 * and its Handler receives messages from the service.  A Channel also has an
 * associated Handler, which responds to events indicating changes in the
 * channel's status, such as opening, closing, and occurrences of errors.
 * <p>
 * Example usage:
 * <pre>
 * goog.require('buzz.channel.Channel');
 * goog.require('buzz.channel.ChannelConfigFactory');
 * goog.require('buzz.channel.ChannelFactory');
 * goog.require('buzz.channel.Session');
 * my.app.Network = function() {
 *   // Create a channel.
 *   var config = buzz.channel.ChannelConfigFactory.newConfigWithIframe(
 *       'https://' + buzz.channel.ChannelConfig.PRODUCTION_DOMAIN_AND_PATH,
 *       'mytype');
 *   this.channel_ = buzz.channel.ChannelFactory.newChannel(this, config);
 * };
 * my.app.Network.prototype.start = function() {
 *   this.channel_.open();  // Start opening the channel.
 * };
 * // Called when the channel finishes opening.
 * my.app.Network.prototype.onOpen = function(channel) {
 *   // Now we can create a session.
 *   this.session_ = channel.newSession(serviceUri, this.sessionHandler_);
 *   this.session_.open();  // Open the session.
 * };
 * my.app.Network.prototype.onAddressAssigned = function(session, address) {
 *   // Make call to service, providing 'address'.
 *   some.api.callFunction(otherArgs, address);
 * };
 * // Called when the service sends a message back to the client.
 * my.app.Network.prototype.receive = function(session, data) {
 *   // Parse and process the data.
 * };
 * </pre>.
 *
 * @author ghc@google.com (Greg Cooper)
 * @author mharris@google.com (Matthew Harris)
 * @author xiaolan@google.com (Joy Zhang)
 */

goog.provide('buzz.channel.ChannelConfigFactory');
goog.provide('buzz.channel.ChannelFactory');

goog.require('buzz.channel.Channel');
goog.require('buzz.channel.ChannelConfig');
goog.require('buzz.channel.ChannelConfigImpl');
goog.require('buzz.channel.HangingGetChannel');
goog.require('buzz.channel.NonIframedChannelConfigImpl');
goog.require('buzz.channel.XpcChannelConfigImpl');

/**
 * Constructs a Channel through IFrame.
 * @param {!buzz.channel.ChannelHandler} handler Application handler for
 *     channel events.
 * @param {!buzz.channel.ChannelConfig} config The config object that specifies
 *     all channel parameters, i.e., uri, client type, authuser, etc.
 * @return {!buzz.channel.Channel} The new channel.
 */
buzz.channel.ChannelFactory.newChannel = function(handler, config) {
  // The ChannelConfig interface that we expose to applications is empty.
  // However, any actual implementation of it will be created by this factory
  // and be an instance of ChannelConfigImpl. Check that this is the case.
  goog.asserts.assert(config instanceof buzz.channel.ChannelConfigImpl);
  return new buzz.channel.HangingGetChannel(handler, config);
};


/**
 * Whether to have the server assign session names. Once server-side support for
 * this is pushed, we'll flip this to true, and then we can remove the code
 * where the client assigns the name.
 */
buzz.channel.ChannelFactory.SERVER_ASSIGNS_SESSION_NAME = true;


/**
 * Construct a config class for Marmoset browser channel with an iframe.
 * @param {string} uri The fully qualified path to the channel address to which
 *     to connect.
 * @param {string} clientType Client type value (must less than 16 characters).
 * @param {number=} opt_authuser Optional authuser parameter for the channel
 *     (indicates which session to use for multi-login).
 * @param {string=} opt_gaiaServiceOverride An optional Gaia service override.
 * @return {!buzz.channel.ChannelConfig} The new channel config.
 */
buzz.channel.ChannelConfigFactory.newConfigWithIframe = function(
    uri, clientType, opt_authuser, opt_gaiaServiceOverride) {
  return new buzz.channel.XpcChannelConfigImpl(
      uri, clientType,
      buzz.channel.ChannelFactory.SERVER_ASSIGNS_SESSION_NAME, 'lcsclient',
      opt_authuser, opt_gaiaServiceOverride);
};


/**
 * Construct a config class for production Marmoset browser channel without
 * an iframe.
 * @param {string} uri The uri for the channel (may be relative or absolute).
 * @param {string} clientType Client type value (must less than 16 characters).
 * @param {number=} opt_authuser Optional authuser parameter for the channel
 *     (indicates which session to use for multi-login).
 * @param {string=} opt_gaiaServiceOverride An optional Gaia service override.
 * @return {!buzz.channel.ChannelConfig} The new channel config.
 */
buzz.channel.ChannelConfigFactory.newConfigWithoutIframe = function(
    uri, clientType, opt_authuser, opt_gaiaServiceOverride) {
  return new buzz.channel.NonIframedChannelConfigImpl(
      uri, clientType,
      buzz.channel.ChannelFactory.SERVER_ASSIGNS_SESSION_NAME, opt_authuser,
      opt_gaiaServiceOverride);
};

//ipc/invalidation/javascript/internal/channel/gatewaysender.js
/**
 * @fileoverview Sends messages to the Tango gateway.
 *
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('invalidation.GatewaySender');
goog.provide('invalidation.GatewaySender.Handler');

goog.require('goog.Uri');
goog.require('goog.net.XhrIo');

/**
 * A client that connects to an iframe that hosts a HTTP sender to Tango
 * gateway. The client also passes upcalls to the host page handler.
 * @param {string} servletUri The URI of the Tango gateway servlet.
 * @param {number} authuser Value for the authuser query parameter (for Gaia
 *     multi-signin).
 * @param {!invalidation.GatewaySender.Handler} handler An object with callbacks
 *     for the client.
 * @constructor
 */
invalidation.GatewaySender = function(servletUri, authuser, handler) {

  // Parse the Uri and set the authuser query parameter to the provided value.
  var uri = new goog.Uri(servletUri);
  if (authuser != 0) {
    uri.setParameterValue('authuser', authuser);
  }

  /**
   * The uri to the Tango gateway's inbound message servlet.
   * @type {string}
   * @protected
   */
  this.servletUri = uri.toString();

  /**
   * The client's callback object.
   * @type {!invalidation.GatewaySender.Handler}
   * @protected
   */
  this.handler = handler;

  /**
   * The id of the next request to be sent.
   * @type {number}
   * @protected
   */
  this.nextRequestId = 0;
};


/** Starts the sender. */
invalidation.GatewaySender.prototype.start = function() {
  // Nothing to do here. Just tell the handler we're ready.
  this.handler.onReady();
};


/**
 * Sends an HTTP request with message.
 * @param {string} message The message to send.
 * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the
 *     request.
 */
invalidation.GatewaySender.prototype.send = function(message, opt_headers) {
  // Send the message directly to the Gateway.
  goog.net.XhrIo.send(
      this.servletUri,
      goog.bind(this.handleSendResult_, this, this.nextRequestId++), 'POST',
      message, opt_headers);
};


/**
 * Handles the result of a send request.
 * @param {number} requestId The id of this request.
 * @param {!goog.events.Event} result The result of the XHR request.
 * @private
 */
invalidation.GatewaySender.prototype.handleSendResult_ = function(
    requestId, result) {
  var xhr = result.target;
  if (xhr.isSuccess()) {
    this.handler.onSuccess(requestId);
  } else {
    this.handler.onFailure(requestId, xhr.getResponseText());
  }
};


/**
 * Interface for callbacks from the sender to its client.
 * @interface
 */
invalidation.GatewaySender.Handler = goog.nullFunction;

/** Indicates that the channel is ready for sending messages. */
invalidation.GatewaySender.Handler.prototype.onReady = goog.abstractMethod;

/**
 * Indicates that the server returned a "success" (20x) response to one of our
 * requests.
 * @param {number} requestId The id of the request that succeeded.
 */
invalidation.GatewaySender.Handler.prototype.onSuccess = goog.abstractMethod;


/**
 * Indicates that the server returned.
 * @param {number} requestId The id of the request that failed.
 * @param {string} errorMessage The error messages.
 */
invalidation.GatewaySender.Handler.prototype.onFailure = goog.abstractMethod;

//ipc/invalidation/proto/v2/channel_common.pb.js
// Protocol Buffer 2 Copyright 2008 Google Inc.
// All other code copyright its respective owners.

/**
 * @fileoverview Generated Protocol Buffer code for file
 * ipc/invalidation/proto/v2/channel_common.proto.
 */

goog.provide('invalidation.proto.ChannelMessageEncoding');
goog.provide('invalidation.proto.ChannelMessageEncoding.MessageEncoding');
goog.provide('invalidation.proto.NetworkEndpointId');
goog.provide('invalidation.proto.NetworkEndpointId.NetworkAddress');

goog.require('goog.proto2.Message');



/**
 * Message ChannelMessageEncoding.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ChannelMessageEncoding = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ChannelMessageEncoding, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ChannelMessageEncoding} The cloned message.
 * @override
 */
invalidation.proto.ChannelMessageEncoding.prototype.clone;


/**
 * Enumeration MessageEncoding.
 * @enum {number}
 */
invalidation.proto.ChannelMessageEncoding.MessageEncoding = {
  PROTOBUF_BINARY_FORMAT: 1,
  PROTOBUF_JSON_FORMAT: 2
};



/**
 * Message NetworkEndpointId.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.NetworkEndpointId = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.NetworkEndpointId, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.NetworkEndpointId} The cloned message.
 * @override
 */
invalidation.proto.NetworkEndpointId.prototype.clone;


/**
 * Gets the value of the network_address field.
 * @return {?invalidation.proto.NetworkEndpointId.NetworkAddress} The value.
 */
invalidation.proto.NetworkEndpointId.prototype.getNetworkAddress = function() {
  return /** @type {?invalidation.proto.NetworkEndpointId.NetworkAddress} */ (this.get$Value(1));
};


/**
 * Gets the value of the network_address field or the default value if not set.
 * @return {invalidation.proto.NetworkEndpointId.NetworkAddress} The value.
 */
invalidation.proto.NetworkEndpointId.prototype.getNetworkAddressOrDefault = function() {
  return /** @type {invalidation.proto.NetworkEndpointId.NetworkAddress} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the network_address field.
 * @param {invalidation.proto.NetworkEndpointId.NetworkAddress} value The value.
 */
invalidation.proto.NetworkEndpointId.prototype.setNetworkAddress = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the network_address field has a value.
 */
invalidation.proto.NetworkEndpointId.prototype.hasNetworkAddress = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the network_address field.
 */
invalidation.proto.NetworkEndpointId.prototype.networkAddressCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the network_address field.
 */
invalidation.proto.NetworkEndpointId.prototype.clearNetworkAddress = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the client_address field.
 * @return {?string} The value.
 */
invalidation.proto.NetworkEndpointId.prototype.getClientAddress = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the client_address field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.NetworkEndpointId.prototype.getClientAddressOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the client_address field.
 * @param {string} value The value.
 */
invalidation.proto.NetworkEndpointId.prototype.setClientAddress = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the client_address field has a value.
 */
invalidation.proto.NetworkEndpointId.prototype.hasClientAddress = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the client_address field.
 */
invalidation.proto.NetworkEndpointId.prototype.clientAddressCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the client_address field.
 */
invalidation.proto.NetworkEndpointId.prototype.clearClientAddress = function() {
  this.clear$Field(2);
};


/**
 * Enumeration NetworkAddress.
 * @enum {number}
 */
invalidation.proto.NetworkEndpointId.NetworkAddress = {
  TEST: 1,
  BUZZ: 111,
  STUBBY: 112,
  ANDROID: 113,
  LCS: 114,
  TIPS_STUBBY: 115
};


goog.proto2.Message.set$Metadata(invalidation.proto.ChannelMessageEncoding, {
  0: {
    name: 'ChannelMessageEncoding',
    fullName: 'ipc.invalidation.ChannelMessageEncoding'
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.NetworkEndpointId, {
  0: {
    name: 'NetworkEndpointId',
    fullName: 'ipc.invalidation.NetworkEndpointId'
  },
  1: {
    name: 'network_address',
    fieldType: goog.proto2.Message.FieldType.ENUM,
    defaultValue: invalidation.proto.NetworkEndpointId.NetworkAddress.TEST,
    type: invalidation.proto.NetworkEndpointId.NetworkAddress
  },
  2: {
    name: 'client_address',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  }
});

//ipc/invalidation/proto/v2/client_protocol.pb.js
// Protocol Buffer 2 Copyright 2008 Google Inc.
// All other code copyright its respective owners.

/**
 * @fileoverview Generated Protocol Buffer code for file
 * ipc/invalidation/proto/v2/client_protocol.proto.
 */

goog.provide('invalidation.proto.Version');
goog.provide('invalidation.proto.ProtocolVersion');
goog.provide('invalidation.proto.ClientVersion');
goog.provide('invalidation.proto.StatusP');
goog.provide('invalidation.proto.StatusP.Code');
goog.provide('invalidation.proto.ObjectIdP');
goog.provide('invalidation.proto.ApplicationClientIdP');
goog.provide('invalidation.proto.InvalidationP');
goog.provide('invalidation.proto.RegistrationP');
goog.provide('invalidation.proto.RegistrationP.OpType');
goog.provide('invalidation.proto.RegistrationSummary');
goog.provide('invalidation.proto.ClientHeader');
goog.provide('invalidation.proto.ClientToServerMessage');
goog.provide('invalidation.proto.InitializeMessage');
goog.provide('invalidation.proto.InitializeMessage.DigestSerializationType');
goog.provide('invalidation.proto.RegistrationMessage');
goog.provide('invalidation.proto.RegistrationSyncMessage');
goog.provide('invalidation.proto.RegistrationSubtree');
goog.provide('invalidation.proto.InfoMessage');
goog.provide('invalidation.proto.PropertyRecord');
goog.provide('invalidation.proto.ServerHeader');
goog.provide('invalidation.proto.ServerToClientMessage');
goog.provide('invalidation.proto.TokenControlMessage');
goog.provide('invalidation.proto.RegistrationStatus');
goog.provide('invalidation.proto.RegistrationStatusMessage');
goog.provide('invalidation.proto.RegistrationSyncRequestMessage');
goog.provide('invalidation.proto.InvalidationMessage');
goog.provide('invalidation.proto.InfoRequestMessage');
goog.provide('invalidation.proto.InfoRequestMessage.InfoType');
goog.provide('invalidation.proto.RateLimitP');
goog.provide('invalidation.proto.ProtocolHandlerConfigP');
goog.provide('invalidation.proto.ClientConfigP');
goog.provide('invalidation.proto.ConfigChangeMessage');
goog.provide('invalidation.proto.ErrorMessage');
goog.provide('invalidation.proto.ErrorMessage.Code');

goog.require('goog.proto2.Message');



/**
 * Message Version.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.Version = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.Version, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.Version} The cloned message.
 * @override
 */
invalidation.proto.Version.prototype.clone;


/**
 * Gets the value of the major_version field.
 * @return {?number} The value.
 */
invalidation.proto.Version.prototype.getMajorVersion = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the major_version field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.Version.prototype.getMajorVersionOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the major_version field.
 * @param {number} value The value.
 */
invalidation.proto.Version.prototype.setMajorVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the major_version field has a value.
 */
invalidation.proto.Version.prototype.hasMajorVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the major_version field.
 */
invalidation.proto.Version.prototype.majorVersionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the major_version field.
 */
invalidation.proto.Version.prototype.clearMajorVersion = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the minor_version field.
 * @return {?number} The value.
 */
invalidation.proto.Version.prototype.getMinorVersion = function() {
  return /** @type {?number} */ (this.get$Value(2));
};


/**
 * Gets the value of the minor_version field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.Version.prototype.getMinorVersionOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the minor_version field.
 * @param {number} value The value.
 */
invalidation.proto.Version.prototype.setMinorVersion = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the minor_version field has a value.
 */
invalidation.proto.Version.prototype.hasMinorVersion = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the minor_version field.
 */
invalidation.proto.Version.prototype.minorVersionCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the minor_version field.
 */
invalidation.proto.Version.prototype.clearMinorVersion = function() {
  this.clear$Field(2);
};



/**
 * Message ProtocolVersion.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ProtocolVersion = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ProtocolVersion, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ProtocolVersion} The cloned message.
 * @override
 */
invalidation.proto.ProtocolVersion.prototype.clone;


/**
 * Gets the value of the version field.
 * @return {invalidation.proto.Version} The value.
 */
invalidation.proto.ProtocolVersion.prototype.getVersion = function() {
  return /** @type {invalidation.proto.Version} */ (this.get$Value(1));
};


/**
 * Gets the value of the version field or the default value if not set.
 * @return {!invalidation.proto.Version} The value.
 */
invalidation.proto.ProtocolVersion.prototype.getVersionOrDefault = function() {
  return /** @type {!invalidation.proto.Version} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the version field.
 * @param {!invalidation.proto.Version} value The value.
 */
invalidation.proto.ProtocolVersion.prototype.setVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the version field has a value.
 */
invalidation.proto.ProtocolVersion.prototype.hasVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the version field.
 */
invalidation.proto.ProtocolVersion.prototype.versionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the version field.
 */
invalidation.proto.ProtocolVersion.prototype.clearVersion = function() {
  this.clear$Field(1);
};



/**
 * Message ClientVersion.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ClientVersion = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ClientVersion, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ClientVersion} The cloned message.
 * @override
 */
invalidation.proto.ClientVersion.prototype.clone;


/**
 * Gets the value of the version field.
 * @return {invalidation.proto.Version} The value.
 */
invalidation.proto.ClientVersion.prototype.getVersion = function() {
  return /** @type {invalidation.proto.Version} */ (this.get$Value(1));
};


/**
 * Gets the value of the version field or the default value if not set.
 * @return {!invalidation.proto.Version} The value.
 */
invalidation.proto.ClientVersion.prototype.getVersionOrDefault = function() {
  return /** @type {!invalidation.proto.Version} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the version field.
 * @param {!invalidation.proto.Version} value The value.
 */
invalidation.proto.ClientVersion.prototype.setVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the version field has a value.
 */
invalidation.proto.ClientVersion.prototype.hasVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the version field.
 */
invalidation.proto.ClientVersion.prototype.versionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the version field.
 */
invalidation.proto.ClientVersion.prototype.clearVersion = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the platform field.
 * @return {?string} The value.
 */
invalidation.proto.ClientVersion.prototype.getPlatform = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the platform field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ClientVersion.prototype.getPlatformOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the platform field.
 * @param {string} value The value.
 */
invalidation.proto.ClientVersion.prototype.setPlatform = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the platform field has a value.
 */
invalidation.proto.ClientVersion.prototype.hasPlatform = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the platform field.
 */
invalidation.proto.ClientVersion.prototype.platformCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the platform field.
 */
invalidation.proto.ClientVersion.prototype.clearPlatform = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the language field.
 * @return {?string} The value.
 */
invalidation.proto.ClientVersion.prototype.getLanguage = function() {
  return /** @type {?string} */ (this.get$Value(3));
};


/**
 * Gets the value of the language field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ClientVersion.prototype.getLanguageOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the language field.
 * @param {string} value The value.
 */
invalidation.proto.ClientVersion.prototype.setLanguage = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the language field has a value.
 */
invalidation.proto.ClientVersion.prototype.hasLanguage = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the language field.
 */
invalidation.proto.ClientVersion.prototype.languageCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the language field.
 */
invalidation.proto.ClientVersion.prototype.clearLanguage = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the application_info field.
 * @return {?string} The value.
 */
invalidation.proto.ClientVersion.prototype.getApplicationInfo = function() {
  return /** @type {?string} */ (this.get$Value(4));
};


/**
 * Gets the value of the application_info field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ClientVersion.prototype.getApplicationInfoOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the application_info field.
 * @param {string} value The value.
 */
invalidation.proto.ClientVersion.prototype.setApplicationInfo = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the application_info field has a value.
 */
invalidation.proto.ClientVersion.prototype.hasApplicationInfo = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the application_info field.
 */
invalidation.proto.ClientVersion.prototype.applicationInfoCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the application_info field.
 */
invalidation.proto.ClientVersion.prototype.clearApplicationInfo = function() {
  this.clear$Field(4);
};



/**
 * Message StatusP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.StatusP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.StatusP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.StatusP} The cloned message.
 * @override
 */
invalidation.proto.StatusP.prototype.clone;


/**
 * Gets the value of the code field.
 * @return {?invalidation.proto.StatusP.Code} The value.
 */
invalidation.proto.StatusP.prototype.getCode = function() {
  return /** @type {?invalidation.proto.StatusP.Code} */ (this.get$Value(1));
};


/**
 * Gets the value of the code field or the default value if not set.
 * @return {invalidation.proto.StatusP.Code} The value.
 */
invalidation.proto.StatusP.prototype.getCodeOrDefault = function() {
  return /** @type {invalidation.proto.StatusP.Code} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the code field.
 * @param {invalidation.proto.StatusP.Code} value The value.
 */
invalidation.proto.StatusP.prototype.setCode = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the code field has a value.
 */
invalidation.proto.StatusP.prototype.hasCode = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the code field.
 */
invalidation.proto.StatusP.prototype.codeCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the code field.
 */
invalidation.proto.StatusP.prototype.clearCode = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the description field.
 * @return {?string} The value.
 */
invalidation.proto.StatusP.prototype.getDescription = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the description field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.StatusP.prototype.getDescriptionOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the description field.
 * @param {string} value The value.
 */
invalidation.proto.StatusP.prototype.setDescription = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the description field has a value.
 */
invalidation.proto.StatusP.prototype.hasDescription = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the description field.
 */
invalidation.proto.StatusP.prototype.descriptionCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the description field.
 */
invalidation.proto.StatusP.prototype.clearDescription = function() {
  this.clear$Field(2);
};


/**
 * Enumeration Code.
 * @enum {number}
 */
invalidation.proto.StatusP.Code = {
  SUCCESS: 1,
  TRANSIENT_FAILURE: 2,
  PERMANENT_FAILURE: 3
};



/**
 * Message ObjectIdP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ObjectIdP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ObjectIdP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ObjectIdP} The cloned message.
 * @override
 */
invalidation.proto.ObjectIdP.prototype.clone;


/**
 * Gets the value of the source field.
 * @return {?number} The value.
 */
invalidation.proto.ObjectIdP.prototype.getSource = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the source field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ObjectIdP.prototype.getSourceOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the source field.
 * @param {number} value The value.
 */
invalidation.proto.ObjectIdP.prototype.setSource = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the source field has a value.
 */
invalidation.proto.ObjectIdP.prototype.hasSource = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the source field.
 */
invalidation.proto.ObjectIdP.prototype.sourceCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the source field.
 */
invalidation.proto.ObjectIdP.prototype.clearSource = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the name field.
 * @return {?string} The value.
 */
invalidation.proto.ObjectIdP.prototype.getName = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the name field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ObjectIdP.prototype.getNameOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the name field.
 * @param {string} value The value.
 */
invalidation.proto.ObjectIdP.prototype.setName = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the name field has a value.
 */
invalidation.proto.ObjectIdP.prototype.hasName = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the name field.
 */
invalidation.proto.ObjectIdP.prototype.nameCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the name field.
 */
invalidation.proto.ObjectIdP.prototype.clearName = function() {
  this.clear$Field(2);
};



/**
 * Message ApplicationClientIdP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ApplicationClientIdP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ApplicationClientIdP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ApplicationClientIdP} The cloned message.
 * @override
 */
invalidation.proto.ApplicationClientIdP.prototype.clone;


/**
 * Gets the value of the client_type field.
 * @return {?number} The value.
 */
invalidation.proto.ApplicationClientIdP.prototype.getClientType = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the client_type field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ApplicationClientIdP.prototype.getClientTypeOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the client_type field.
 * @param {number} value The value.
 */
invalidation.proto.ApplicationClientIdP.prototype.setClientType = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the client_type field has a value.
 */
invalidation.proto.ApplicationClientIdP.prototype.hasClientType = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the client_type field.
 */
invalidation.proto.ApplicationClientIdP.prototype.clientTypeCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the client_type field.
 */
invalidation.proto.ApplicationClientIdP.prototype.clearClientType = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the client_name field.
 * @return {?string} The value.
 */
invalidation.proto.ApplicationClientIdP.prototype.getClientName = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the client_name field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ApplicationClientIdP.prototype.getClientNameOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the client_name field.
 * @param {string} value The value.
 */
invalidation.proto.ApplicationClientIdP.prototype.setClientName = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the client_name field has a value.
 */
invalidation.proto.ApplicationClientIdP.prototype.hasClientName = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the client_name field.
 */
invalidation.proto.ApplicationClientIdP.prototype.clientNameCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the client_name field.
 */
invalidation.proto.ApplicationClientIdP.prototype.clearClientName = function() {
  this.clear$Field(2);
};



/**
 * Message InvalidationP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.InvalidationP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.InvalidationP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.InvalidationP} The cloned message.
 * @override
 */
invalidation.proto.InvalidationP.prototype.clone;


/**
 * Gets the value of the object_id field.
 * @return {invalidation.proto.ObjectIdP} The value.
 */
invalidation.proto.InvalidationP.prototype.getObjectId = function() {
  return /** @type {invalidation.proto.ObjectIdP} */ (this.get$Value(1));
};


/**
 * Gets the value of the object_id field or the default value if not set.
 * @return {!invalidation.proto.ObjectIdP} The value.
 */
invalidation.proto.InvalidationP.prototype.getObjectIdOrDefault = function() {
  return /** @type {!invalidation.proto.ObjectIdP} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the object_id field.
 * @param {!invalidation.proto.ObjectIdP} value The value.
 */
invalidation.proto.InvalidationP.prototype.setObjectId = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the object_id field has a value.
 */
invalidation.proto.InvalidationP.prototype.hasObjectId = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the object_id field.
 */
invalidation.proto.InvalidationP.prototype.objectIdCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the object_id field.
 */
invalidation.proto.InvalidationP.prototype.clearObjectId = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the is_known_version field.
 * @return {?boolean} The value.
 */
invalidation.proto.InvalidationP.prototype.getIsKnownVersion = function() {
  return /** @type {?boolean} */ (this.get$Value(2));
};


/**
 * Gets the value of the is_known_version field or the default value if not set.
 * @return {boolean} The value.
 */
invalidation.proto.InvalidationP.prototype.getIsKnownVersionOrDefault = function() {
  return /** @type {boolean} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the is_known_version field.
 * @param {boolean} value The value.
 */
invalidation.proto.InvalidationP.prototype.setIsKnownVersion = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the is_known_version field has a value.
 */
invalidation.proto.InvalidationP.prototype.hasIsKnownVersion = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the is_known_version field.
 */
invalidation.proto.InvalidationP.prototype.isKnownVersionCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the is_known_version field.
 */
invalidation.proto.InvalidationP.prototype.clearIsKnownVersion = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the version field.
 * @return {?number} The value.
 */
invalidation.proto.InvalidationP.prototype.getVersion = function() {
  return /** @type {?number} */ (this.get$Value(3));
};


/**
 * Gets the value of the version field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.InvalidationP.prototype.getVersionOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the version field.
 * @param {number} value The value.
 */
invalidation.proto.InvalidationP.prototype.setVersion = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the version field has a value.
 */
invalidation.proto.InvalidationP.prototype.hasVersion = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the version field.
 */
invalidation.proto.InvalidationP.prototype.versionCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the version field.
 */
invalidation.proto.InvalidationP.prototype.clearVersion = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the is_trickle_restart field.
 * @return {?boolean} The value.
 */
invalidation.proto.InvalidationP.prototype.getIsTrickleRestart = function() {
  return /** @type {?boolean} */ (this.get$Value(6));
};


/**
 * Gets the value of the is_trickle_restart field or the default value if not set.
 * @return {boolean} The value.
 */
invalidation.proto.InvalidationP.prototype.getIsTrickleRestartOrDefault = function() {
  return /** @type {boolean} */ (this.get$ValueOrDefault(6));
};


/**
 * Sets the value of the is_trickle_restart field.
 * @param {boolean} value The value.
 */
invalidation.proto.InvalidationP.prototype.setIsTrickleRestart = function(value) {
  this.set$Value(6, value);
};


/**
 * @return {boolean} Whether the is_trickle_restart field has a value.
 */
invalidation.proto.InvalidationP.prototype.hasIsTrickleRestart = function() {
  return this.has$Value(6);
};


/**
 * @return {number} The number of values in the is_trickle_restart field.
 */
invalidation.proto.InvalidationP.prototype.isTrickleRestartCount = function() {
  return this.count$Values(6);
};


/**
 * Clears the values in the is_trickle_restart field.
 */
invalidation.proto.InvalidationP.prototype.clearIsTrickleRestart = function() {
  this.clear$Field(6);
};


/**
 * Gets the value of the payload field.
 * @return {?string} The value.
 */
invalidation.proto.InvalidationP.prototype.getPayload = function() {
  return /** @type {?string} */ (this.get$Value(4));
};


/**
 * Gets the value of the payload field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.InvalidationP.prototype.getPayloadOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the payload field.
 * @param {string} value The value.
 */
invalidation.proto.InvalidationP.prototype.setPayload = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the payload field has a value.
 */
invalidation.proto.InvalidationP.prototype.hasPayload = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the payload field.
 */
invalidation.proto.InvalidationP.prototype.payloadCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the payload field.
 */
invalidation.proto.InvalidationP.prototype.clearPayload = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the bridge_arrival_time_ms_deprecated field.
 * @return {?string} The value.
 */
invalidation.proto.InvalidationP.prototype.getBridgeArrivalTimeMsDeprecated = function() {
  return /** @type {?string} */ (this.get$Value(5));
};


/**
 * Gets the value of the bridge_arrival_time_ms_deprecated field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.InvalidationP.prototype.getBridgeArrivalTimeMsDeprecatedOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the bridge_arrival_time_ms_deprecated field.
 * @param {string} value The value.
 */
invalidation.proto.InvalidationP.prototype.setBridgeArrivalTimeMsDeprecated = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the bridge_arrival_time_ms_deprecated field has a value.
 */
invalidation.proto.InvalidationP.prototype.hasBridgeArrivalTimeMsDeprecated = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the bridge_arrival_time_ms_deprecated field.
 */
invalidation.proto.InvalidationP.prototype.bridgeArrivalTimeMsDeprecatedCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the bridge_arrival_time_ms_deprecated field.
 */
invalidation.proto.InvalidationP.prototype.clearBridgeArrivalTimeMsDeprecated = function() {
  this.clear$Field(5);
};



/**
 * Message RegistrationP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.RegistrationP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.RegistrationP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.RegistrationP} The cloned message.
 * @override
 */
invalidation.proto.RegistrationP.prototype.clone;


/**
 * Gets the value of the object_id field.
 * @return {invalidation.proto.ObjectIdP} The value.
 */
invalidation.proto.RegistrationP.prototype.getObjectId = function() {
  return /** @type {invalidation.proto.ObjectIdP} */ (this.get$Value(1));
};


/**
 * Gets the value of the object_id field or the default value if not set.
 * @return {!invalidation.proto.ObjectIdP} The value.
 */
invalidation.proto.RegistrationP.prototype.getObjectIdOrDefault = function() {
  return /** @type {!invalidation.proto.ObjectIdP} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the object_id field.
 * @param {!invalidation.proto.ObjectIdP} value The value.
 */
invalidation.proto.RegistrationP.prototype.setObjectId = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the object_id field has a value.
 */
invalidation.proto.RegistrationP.prototype.hasObjectId = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the object_id field.
 */
invalidation.proto.RegistrationP.prototype.objectIdCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the object_id field.
 */
invalidation.proto.RegistrationP.prototype.clearObjectId = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the op_type field.
 * @return {?invalidation.proto.RegistrationP.OpType} The value.
 */
invalidation.proto.RegistrationP.prototype.getOpType = function() {
  return /** @type {?invalidation.proto.RegistrationP.OpType} */ (this.get$Value(2));
};


/**
 * Gets the value of the op_type field or the default value if not set.
 * @return {invalidation.proto.RegistrationP.OpType} The value.
 */
invalidation.proto.RegistrationP.prototype.getOpTypeOrDefault = function() {
  return /** @type {invalidation.proto.RegistrationP.OpType} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the op_type field.
 * @param {invalidation.proto.RegistrationP.OpType} value The value.
 */
invalidation.proto.RegistrationP.prototype.setOpType = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the op_type field has a value.
 */
invalidation.proto.RegistrationP.prototype.hasOpType = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the op_type field.
 */
invalidation.proto.RegistrationP.prototype.opTypeCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the op_type field.
 */
invalidation.proto.RegistrationP.prototype.clearOpType = function() {
  this.clear$Field(2);
};


/**
 * Enumeration OpType.
 * @enum {number}
 */
invalidation.proto.RegistrationP.OpType = {
  REGISTER: 1,
  UNREGISTER: 2
};



/**
 * Message RegistrationSummary.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.RegistrationSummary = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.RegistrationSummary, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.RegistrationSummary} The cloned message.
 * @override
 */
invalidation.proto.RegistrationSummary.prototype.clone;


/**
 * Gets the value of the num_registrations field.
 * @return {?number} The value.
 */
invalidation.proto.RegistrationSummary.prototype.getNumRegistrations = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the num_registrations field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.RegistrationSummary.prototype.getNumRegistrationsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the num_registrations field.
 * @param {number} value The value.
 */
invalidation.proto.RegistrationSummary.prototype.setNumRegistrations = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the num_registrations field has a value.
 */
invalidation.proto.RegistrationSummary.prototype.hasNumRegistrations = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the num_registrations field.
 */
invalidation.proto.RegistrationSummary.prototype.numRegistrationsCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the num_registrations field.
 */
invalidation.proto.RegistrationSummary.prototype.clearNumRegistrations = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the registration_digest field.
 * @return {?string} The value.
 */
invalidation.proto.RegistrationSummary.prototype.getRegistrationDigest = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the registration_digest field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.RegistrationSummary.prototype.getRegistrationDigestOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the registration_digest field.
 * @param {string} value The value.
 */
invalidation.proto.RegistrationSummary.prototype.setRegistrationDigest = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the registration_digest field has a value.
 */
invalidation.proto.RegistrationSummary.prototype.hasRegistrationDigest = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the registration_digest field.
 */
invalidation.proto.RegistrationSummary.prototype.registrationDigestCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the registration_digest field.
 */
invalidation.proto.RegistrationSummary.prototype.clearRegistrationDigest = function() {
  this.clear$Field(2);
};



/**
 * Message ClientHeader.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ClientHeader = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ClientHeader, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ClientHeader} The cloned message.
 * @override
 */
invalidation.proto.ClientHeader.prototype.clone;


/**
 * Gets the value of the protocol_version field.
 * @return {invalidation.proto.ProtocolVersion} The value.
 */
invalidation.proto.ClientHeader.prototype.getProtocolVersion = function() {
  return /** @type {invalidation.proto.ProtocolVersion} */ (this.get$Value(1));
};


/**
 * Gets the value of the protocol_version field or the default value if not set.
 * @return {!invalidation.proto.ProtocolVersion} The value.
 */
invalidation.proto.ClientHeader.prototype.getProtocolVersionOrDefault = function() {
  return /** @type {!invalidation.proto.ProtocolVersion} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the protocol_version field.
 * @param {!invalidation.proto.ProtocolVersion} value The value.
 */
invalidation.proto.ClientHeader.prototype.setProtocolVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the protocol_version field has a value.
 */
invalidation.proto.ClientHeader.prototype.hasProtocolVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the protocol_version field.
 */
invalidation.proto.ClientHeader.prototype.protocolVersionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the protocol_version field.
 */
invalidation.proto.ClientHeader.prototype.clearProtocolVersion = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the client_token field.
 * @return {?string} The value.
 */
invalidation.proto.ClientHeader.prototype.getClientToken = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the client_token field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ClientHeader.prototype.getClientTokenOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the client_token field.
 * @param {string} value The value.
 */
invalidation.proto.ClientHeader.prototype.setClientToken = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the client_token field has a value.
 */
invalidation.proto.ClientHeader.prototype.hasClientToken = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the client_token field.
 */
invalidation.proto.ClientHeader.prototype.clientTokenCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the client_token field.
 */
invalidation.proto.ClientHeader.prototype.clearClientToken = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the registration_summary field.
 * @return {invalidation.proto.RegistrationSummary} The value.
 */
invalidation.proto.ClientHeader.prototype.getRegistrationSummary = function() {
  return /** @type {invalidation.proto.RegistrationSummary} */ (this.get$Value(3));
};


/**
 * Gets the value of the registration_summary field or the default value if not set.
 * @return {!invalidation.proto.RegistrationSummary} The value.
 */
invalidation.proto.ClientHeader.prototype.getRegistrationSummaryOrDefault = function() {
  return /** @type {!invalidation.proto.RegistrationSummary} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the registration_summary field.
 * @param {!invalidation.proto.RegistrationSummary} value The value.
 */
invalidation.proto.ClientHeader.prototype.setRegistrationSummary = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the registration_summary field has a value.
 */
invalidation.proto.ClientHeader.prototype.hasRegistrationSummary = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the registration_summary field.
 */
invalidation.proto.ClientHeader.prototype.registrationSummaryCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the registration_summary field.
 */
invalidation.proto.ClientHeader.prototype.clearRegistrationSummary = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the client_time_ms field.
 * @return {?number} The value.
 */
invalidation.proto.ClientHeader.prototype.getClientTimeMs = function() {
  return /** @type {?number} */ (this.get$Value(4));
};


/**
 * Gets the value of the client_time_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ClientHeader.prototype.getClientTimeMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the client_time_ms field.
 * @param {number} value The value.
 */
invalidation.proto.ClientHeader.prototype.setClientTimeMs = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the client_time_ms field has a value.
 */
invalidation.proto.ClientHeader.prototype.hasClientTimeMs = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the client_time_ms field.
 */
invalidation.proto.ClientHeader.prototype.clientTimeMsCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the client_time_ms field.
 */
invalidation.proto.ClientHeader.prototype.clearClientTimeMs = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the max_known_server_time_ms field.
 * @return {?number} The value.
 */
invalidation.proto.ClientHeader.prototype.getMaxKnownServerTimeMs = function() {
  return /** @type {?number} */ (this.get$Value(5));
};


/**
 * Gets the value of the max_known_server_time_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ClientHeader.prototype.getMaxKnownServerTimeMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the max_known_server_time_ms field.
 * @param {number} value The value.
 */
invalidation.proto.ClientHeader.prototype.setMaxKnownServerTimeMs = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the max_known_server_time_ms field has a value.
 */
invalidation.proto.ClientHeader.prototype.hasMaxKnownServerTimeMs = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the max_known_server_time_ms field.
 */
invalidation.proto.ClientHeader.prototype.maxKnownServerTimeMsCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the max_known_server_time_ms field.
 */
invalidation.proto.ClientHeader.prototype.clearMaxKnownServerTimeMs = function() {
  this.clear$Field(5);
};


/**
 * Gets the value of the message_id field.
 * @return {?string} The value.
 */
invalidation.proto.ClientHeader.prototype.getMessageId = function() {
  return /** @type {?string} */ (this.get$Value(6));
};


/**
 * Gets the value of the message_id field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ClientHeader.prototype.getMessageIdOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(6));
};


/**
 * Sets the value of the message_id field.
 * @param {string} value The value.
 */
invalidation.proto.ClientHeader.prototype.setMessageId = function(value) {
  this.set$Value(6, value);
};


/**
 * @return {boolean} Whether the message_id field has a value.
 */
invalidation.proto.ClientHeader.prototype.hasMessageId = function() {
  return this.has$Value(6);
};


/**
 * @return {number} The number of values in the message_id field.
 */
invalidation.proto.ClientHeader.prototype.messageIdCount = function() {
  return this.count$Values(6);
};


/**
 * Clears the values in the message_id field.
 */
invalidation.proto.ClientHeader.prototype.clearMessageId = function() {
  this.clear$Field(6);
};


/**
 * Gets the value of the client_type field.
 * @return {?number} The value.
 */
invalidation.proto.ClientHeader.prototype.getClientType = function() {
  return /** @type {?number} */ (this.get$Value(7));
};


/**
 * Gets the value of the client_type field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ClientHeader.prototype.getClientTypeOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(7));
};


/**
 * Sets the value of the client_type field.
 * @param {number} value The value.
 */
invalidation.proto.ClientHeader.prototype.setClientType = function(value) {
  this.set$Value(7, value);
};


/**
 * @return {boolean} Whether the client_type field has a value.
 */
invalidation.proto.ClientHeader.prototype.hasClientType = function() {
  return this.has$Value(7);
};


/**
 * @return {number} The number of values in the client_type field.
 */
invalidation.proto.ClientHeader.prototype.clientTypeCount = function() {
  return this.count$Values(7);
};


/**
 * Clears the values in the client_type field.
 */
invalidation.proto.ClientHeader.prototype.clearClientType = function() {
  this.clear$Field(7);
};



/**
 * Message ClientToServerMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ClientToServerMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ClientToServerMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ClientToServerMessage} The cloned message.
 * @override
 */
invalidation.proto.ClientToServerMessage.prototype.clone;


/**
 * Gets the value of the header field.
 * @return {invalidation.proto.ClientHeader} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getHeader = function() {
  return /** @type {invalidation.proto.ClientHeader} */ (this.get$Value(1));
};


/**
 * Gets the value of the header field or the default value if not set.
 * @return {!invalidation.proto.ClientHeader} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getHeaderOrDefault = function() {
  return /** @type {!invalidation.proto.ClientHeader} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the header field.
 * @param {!invalidation.proto.ClientHeader} value The value.
 */
invalidation.proto.ClientToServerMessage.prototype.setHeader = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the header field has a value.
 */
invalidation.proto.ClientToServerMessage.prototype.hasHeader = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the header field.
 */
invalidation.proto.ClientToServerMessage.prototype.headerCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the header field.
 */
invalidation.proto.ClientToServerMessage.prototype.clearHeader = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the initialize_message field.
 * @return {invalidation.proto.InitializeMessage} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getInitializeMessage = function() {
  return /** @type {invalidation.proto.InitializeMessage} */ (this.get$Value(2));
};


/**
 * Gets the value of the initialize_message field or the default value if not set.
 * @return {!invalidation.proto.InitializeMessage} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getInitializeMessageOrDefault = function() {
  return /** @type {!invalidation.proto.InitializeMessage} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the initialize_message field.
 * @param {!invalidation.proto.InitializeMessage} value The value.
 */
invalidation.proto.ClientToServerMessage.prototype.setInitializeMessage = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the initialize_message field has a value.
 */
invalidation.proto.ClientToServerMessage.prototype.hasInitializeMessage = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the initialize_message field.
 */
invalidation.proto.ClientToServerMessage.prototype.initializeMessageCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the initialize_message field.
 */
invalidation.proto.ClientToServerMessage.prototype.clearInitializeMessage = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the registration_message field.
 * @return {invalidation.proto.RegistrationMessage} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getRegistrationMessage = function() {
  return /** @type {invalidation.proto.RegistrationMessage} */ (this.get$Value(3));
};


/**
 * Gets the value of the registration_message field or the default value if not set.
 * @return {!invalidation.proto.RegistrationMessage} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getRegistrationMessageOrDefault = function() {
  return /** @type {!invalidation.proto.RegistrationMessage} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the registration_message field.
 * @param {!invalidation.proto.RegistrationMessage} value The value.
 */
invalidation.proto.ClientToServerMessage.prototype.setRegistrationMessage = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the registration_message field has a value.
 */
invalidation.proto.ClientToServerMessage.prototype.hasRegistrationMessage = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the registration_message field.
 */
invalidation.proto.ClientToServerMessage.prototype.registrationMessageCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the registration_message field.
 */
invalidation.proto.ClientToServerMessage.prototype.clearRegistrationMessage = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the registration_sync_message field.
 * @return {invalidation.proto.RegistrationSyncMessage} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getRegistrationSyncMessage = function() {
  return /** @type {invalidation.proto.RegistrationSyncMessage} */ (this.get$Value(4));
};


/**
 * Gets the value of the registration_sync_message field or the default value if not set.
 * @return {!invalidation.proto.RegistrationSyncMessage} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getRegistrationSyncMessageOrDefault = function() {
  return /** @type {!invalidation.proto.RegistrationSyncMessage} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the registration_sync_message field.
 * @param {!invalidation.proto.RegistrationSyncMessage} value The value.
 */
invalidation.proto.ClientToServerMessage.prototype.setRegistrationSyncMessage = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the registration_sync_message field has a value.
 */
invalidation.proto.ClientToServerMessage.prototype.hasRegistrationSyncMessage = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the registration_sync_message field.
 */
invalidation.proto.ClientToServerMessage.prototype.registrationSyncMessageCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the registration_sync_message field.
 */
invalidation.proto.ClientToServerMessage.prototype.clearRegistrationSyncMessage = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the invalidation_ack_message field.
 * @return {invalidation.proto.InvalidationMessage} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getInvalidationAckMessage = function() {
  return /** @type {invalidation.proto.InvalidationMessage} */ (this.get$Value(5));
};


/**
 * Gets the value of the invalidation_ack_message field or the default value if not set.
 * @return {!invalidation.proto.InvalidationMessage} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getInvalidationAckMessageOrDefault = function() {
  return /** @type {!invalidation.proto.InvalidationMessage} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the invalidation_ack_message field.
 * @param {!invalidation.proto.InvalidationMessage} value The value.
 */
invalidation.proto.ClientToServerMessage.prototype.setInvalidationAckMessage = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the invalidation_ack_message field has a value.
 */
invalidation.proto.ClientToServerMessage.prototype.hasInvalidationAckMessage = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the invalidation_ack_message field.
 */
invalidation.proto.ClientToServerMessage.prototype.invalidationAckMessageCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the invalidation_ack_message field.
 */
invalidation.proto.ClientToServerMessage.prototype.clearInvalidationAckMessage = function() {
  this.clear$Field(5);
};


/**
 * Gets the value of the info_message field.
 * @return {invalidation.proto.InfoMessage} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getInfoMessage = function() {
  return /** @type {invalidation.proto.InfoMessage} */ (this.get$Value(6));
};


/**
 * Gets the value of the info_message field or the default value if not set.
 * @return {!invalidation.proto.InfoMessage} The value.
 */
invalidation.proto.ClientToServerMessage.prototype.getInfoMessageOrDefault = function() {
  return /** @type {!invalidation.proto.InfoMessage} */ (this.get$ValueOrDefault(6));
};


/**
 * Sets the value of the info_message field.
 * @param {!invalidation.proto.InfoMessage} value The value.
 */
invalidation.proto.ClientToServerMessage.prototype.setInfoMessage = function(value) {
  this.set$Value(6, value);
};


/**
 * @return {boolean} Whether the info_message field has a value.
 */
invalidation.proto.ClientToServerMessage.prototype.hasInfoMessage = function() {
  return this.has$Value(6);
};


/**
 * @return {number} The number of values in the info_message field.
 */
invalidation.proto.ClientToServerMessage.prototype.infoMessageCount = function() {
  return this.count$Values(6);
};


/**
 * Clears the values in the info_message field.
 */
invalidation.proto.ClientToServerMessage.prototype.clearInfoMessage = function() {
  this.clear$Field(6);
};



/**
 * Message InitializeMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.InitializeMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.InitializeMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.InitializeMessage} The cloned message.
 * @override
 */
invalidation.proto.InitializeMessage.prototype.clone;


/**
 * Gets the value of the client_type field.
 * @return {?number} The value.
 */
invalidation.proto.InitializeMessage.prototype.getClientType = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the client_type field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.InitializeMessage.prototype.getClientTypeOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the client_type field.
 * @param {number} value The value.
 */
invalidation.proto.InitializeMessage.prototype.setClientType = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the client_type field has a value.
 */
invalidation.proto.InitializeMessage.prototype.hasClientType = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the client_type field.
 */
invalidation.proto.InitializeMessage.prototype.clientTypeCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the client_type field.
 */
invalidation.proto.InitializeMessage.prototype.clearClientType = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the nonce field.
 * @return {?string} The value.
 */
invalidation.proto.InitializeMessage.prototype.getNonce = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the nonce field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.InitializeMessage.prototype.getNonceOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the nonce field.
 * @param {string} value The value.
 */
invalidation.proto.InitializeMessage.prototype.setNonce = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the nonce field has a value.
 */
invalidation.proto.InitializeMessage.prototype.hasNonce = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the nonce field.
 */
invalidation.proto.InitializeMessage.prototype.nonceCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the nonce field.
 */
invalidation.proto.InitializeMessage.prototype.clearNonce = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the application_client_id field.
 * @return {invalidation.proto.ApplicationClientIdP} The value.
 */
invalidation.proto.InitializeMessage.prototype.getApplicationClientId = function() {
  return /** @type {invalidation.proto.ApplicationClientIdP} */ (this.get$Value(3));
};


/**
 * Gets the value of the application_client_id field or the default value if not set.
 * @return {!invalidation.proto.ApplicationClientIdP} The value.
 */
invalidation.proto.InitializeMessage.prototype.getApplicationClientIdOrDefault = function() {
  return /** @type {!invalidation.proto.ApplicationClientIdP} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the application_client_id field.
 * @param {!invalidation.proto.ApplicationClientIdP} value The value.
 */
invalidation.proto.InitializeMessage.prototype.setApplicationClientId = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the application_client_id field has a value.
 */
invalidation.proto.InitializeMessage.prototype.hasApplicationClientId = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the application_client_id field.
 */
invalidation.proto.InitializeMessage.prototype.applicationClientIdCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the application_client_id field.
 */
invalidation.proto.InitializeMessage.prototype.clearApplicationClientId = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the digest_serialization_type field.
 * @return {?invalidation.proto.InitializeMessage.DigestSerializationType} The value.
 */
invalidation.proto.InitializeMessage.prototype.getDigestSerializationType = function() {
  return /** @type {?invalidation.proto.InitializeMessage.DigestSerializationType} */ (this.get$Value(4));
};


/**
 * Gets the value of the digest_serialization_type field or the default value if not set.
 * @return {invalidation.proto.InitializeMessage.DigestSerializationType} The value.
 */
invalidation.proto.InitializeMessage.prototype.getDigestSerializationTypeOrDefault = function() {
  return /** @type {invalidation.proto.InitializeMessage.DigestSerializationType} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the digest_serialization_type field.
 * @param {invalidation.proto.InitializeMessage.DigestSerializationType} value The value.
 */
invalidation.proto.InitializeMessage.prototype.setDigestSerializationType = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the digest_serialization_type field has a value.
 */
invalidation.proto.InitializeMessage.prototype.hasDigestSerializationType = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the digest_serialization_type field.
 */
invalidation.proto.InitializeMessage.prototype.digestSerializationTypeCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the digest_serialization_type field.
 */
invalidation.proto.InitializeMessage.prototype.clearDigestSerializationType = function() {
  this.clear$Field(4);
};


/**
 * Enumeration DigestSerializationType.
 * @enum {number}
 */
invalidation.proto.InitializeMessage.DigestSerializationType = {
  BYTE_BASED: 1,
  NUMBER_BASED: 2
};



/**
 * Message RegistrationMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.RegistrationMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.RegistrationMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.RegistrationMessage} The cloned message.
 * @override
 */
invalidation.proto.RegistrationMessage.prototype.clone;


/**
 * Gets the value of the registration field at the index given.
 * @param {number} index The index to lookup.
 * @return {invalidation.proto.RegistrationP} The value.
 */
invalidation.proto.RegistrationMessage.prototype.getRegistration = function(index) {
  return /** @type {invalidation.proto.RegistrationP} */ (this.get$Value(1, index));
};


/**
 * Gets the value of the registration field at the index given or the default value if not set.
 * @param {number} index The index to lookup.
 * @return {!invalidation.proto.RegistrationP} The value.
 */
invalidation.proto.RegistrationMessage.prototype.getRegistrationOrDefault = function(index) {
  return /** @type {!invalidation.proto.RegistrationP} */ (this.get$ValueOrDefault(1, index));
};


/**
 * Adds a value to the registration field.
 * @param {!invalidation.proto.RegistrationP} value The value to add.
 */
invalidation.proto.RegistrationMessage.prototype.addRegistration = function(value) {
  this.add$Value(1, value);
};


/**
 * Returns the array of values in the registration field.
 * @return {!Array.<!invalidation.proto.RegistrationP>} The values in the field.
 */
invalidation.proto.RegistrationMessage.prototype.registrationArray = function() {
  return /** @type {!Array.<!invalidation.proto.RegistrationP>} */ (this.array$Values(1));
};


/**
 * @return {boolean} Whether the registration field has a value.
 */
invalidation.proto.RegistrationMessage.prototype.hasRegistration = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the registration field.
 */
invalidation.proto.RegistrationMessage.prototype.registrationCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the registration field.
 */
invalidation.proto.RegistrationMessage.prototype.clearRegistration = function() {
  this.clear$Field(1);
};



/**
 * Message RegistrationSyncMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.RegistrationSyncMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.RegistrationSyncMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.RegistrationSyncMessage} The cloned message.
 * @override
 */
invalidation.proto.RegistrationSyncMessage.prototype.clone;


/**
 * Gets the value of the subtree field at the index given.
 * @param {number} index The index to lookup.
 * @return {invalidation.proto.RegistrationSubtree} The value.
 */
invalidation.proto.RegistrationSyncMessage.prototype.getSubtree = function(index) {
  return /** @type {invalidation.proto.RegistrationSubtree} */ (this.get$Value(1, index));
};


/**
 * Gets the value of the subtree field at the index given or the default value if not set.
 * @param {number} index The index to lookup.
 * @return {!invalidation.proto.RegistrationSubtree} The value.
 */
invalidation.proto.RegistrationSyncMessage.prototype.getSubtreeOrDefault = function(index) {
  return /** @type {!invalidation.proto.RegistrationSubtree} */ (this.get$ValueOrDefault(1, index));
};


/**
 * Adds a value to the subtree field.
 * @param {!invalidation.proto.RegistrationSubtree} value The value to add.
 */
invalidation.proto.RegistrationSyncMessage.prototype.addSubtree = function(value) {
  this.add$Value(1, value);
};


/**
 * Returns the array of values in the subtree field.
 * @return {!Array.<!invalidation.proto.RegistrationSubtree>} The values in the field.
 */
invalidation.proto.RegistrationSyncMessage.prototype.subtreeArray = function() {
  return /** @type {!Array.<!invalidation.proto.RegistrationSubtree>} */ (this.array$Values(1));
};


/**
 * @return {boolean} Whether the subtree field has a value.
 */
invalidation.proto.RegistrationSyncMessage.prototype.hasSubtree = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the subtree field.
 */
invalidation.proto.RegistrationSyncMessage.prototype.subtreeCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the subtree field.
 */
invalidation.proto.RegistrationSyncMessage.prototype.clearSubtree = function() {
  this.clear$Field(1);
};



/**
 * Message RegistrationSubtree.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.RegistrationSubtree = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.RegistrationSubtree, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.RegistrationSubtree} The cloned message.
 * @override
 */
invalidation.proto.RegistrationSubtree.prototype.clone;


/**
 * Gets the value of the registered_object field at the index given.
 * @param {number} index The index to lookup.
 * @return {invalidation.proto.ObjectIdP} The value.
 */
invalidation.proto.RegistrationSubtree.prototype.getRegisteredObject = function(index) {
  return /** @type {invalidation.proto.ObjectIdP} */ (this.get$Value(1, index));
};


/**
 * Gets the value of the registered_object field at the index given or the default value if not set.
 * @param {number} index The index to lookup.
 * @return {!invalidation.proto.ObjectIdP} The value.
 */
invalidation.proto.RegistrationSubtree.prototype.getRegisteredObjectOrDefault = function(index) {
  return /** @type {!invalidation.proto.ObjectIdP} */ (this.get$ValueOrDefault(1, index));
};


/**
 * Adds a value to the registered_object field.
 * @param {!invalidation.proto.ObjectIdP} value The value to add.
 */
invalidation.proto.RegistrationSubtree.prototype.addRegisteredObject = function(value) {
  this.add$Value(1, value);
};


/**
 * Returns the array of values in the registered_object field.
 * @return {!Array.<!invalidation.proto.ObjectIdP>} The values in the field.
 */
invalidation.proto.RegistrationSubtree.prototype.registeredObjectArray = function() {
  return /** @type {!Array.<!invalidation.proto.ObjectIdP>} */ (this.array$Values(1));
};


/**
 * @return {boolean} Whether the registered_object field has a value.
 */
invalidation.proto.RegistrationSubtree.prototype.hasRegisteredObject = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the registered_object field.
 */
invalidation.proto.RegistrationSubtree.prototype.registeredObjectCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the registered_object field.
 */
invalidation.proto.RegistrationSubtree.prototype.clearRegisteredObject = function() {
  this.clear$Field(1);
};



/**
 * Message InfoMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.InfoMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.InfoMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.InfoMessage} The cloned message.
 * @override
 */
invalidation.proto.InfoMessage.prototype.clone;


/**
 * Gets the value of the client_version field.
 * @return {invalidation.proto.ClientVersion} The value.
 */
invalidation.proto.InfoMessage.prototype.getClientVersion = function() {
  return /** @type {invalidation.proto.ClientVersion} */ (this.get$Value(1));
};


/**
 * Gets the value of the client_version field or the default value if not set.
 * @return {!invalidation.proto.ClientVersion} The value.
 */
invalidation.proto.InfoMessage.prototype.getClientVersionOrDefault = function() {
  return /** @type {!invalidation.proto.ClientVersion} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the client_version field.
 * @param {!invalidation.proto.ClientVersion} value The value.
 */
invalidation.proto.InfoMessage.prototype.setClientVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the client_version field has a value.
 */
invalidation.proto.InfoMessage.prototype.hasClientVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the client_version field.
 */
invalidation.proto.InfoMessage.prototype.clientVersionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the client_version field.
 */
invalidation.proto.InfoMessage.prototype.clearClientVersion = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the config_parameter field at the index given.
 * @param {number} index The index to lookup.
 * @return {invalidation.proto.PropertyRecord} The value.
 */
invalidation.proto.InfoMessage.prototype.getConfigParameter = function(index) {
  return /** @type {invalidation.proto.PropertyRecord} */ (this.get$Value(2, index));
};


/**
 * Gets the value of the config_parameter field at the index given or the default value if not set.
 * @param {number} index The index to lookup.
 * @return {!invalidation.proto.PropertyRecord} The value.
 */
invalidation.proto.InfoMessage.prototype.getConfigParameterOrDefault = function(index) {
  return /** @type {!invalidation.proto.PropertyRecord} */ (this.get$ValueOrDefault(2, index));
};


/**
 * Adds a value to the config_parameter field.
 * @param {!invalidation.proto.PropertyRecord} value The value to add.
 */
invalidation.proto.InfoMessage.prototype.addConfigParameter = function(value) {
  this.add$Value(2, value);
};


/**
 * Returns the array of values in the config_parameter field.
 * @return {!Array.<!invalidation.proto.PropertyRecord>} The values in the field.
 */
invalidation.proto.InfoMessage.prototype.configParameterArray = function() {
  return /** @type {!Array.<!invalidation.proto.PropertyRecord>} */ (this.array$Values(2));
};


/**
 * @return {boolean} Whether the config_parameter field has a value.
 */
invalidation.proto.InfoMessage.prototype.hasConfigParameter = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the config_parameter field.
 */
invalidation.proto.InfoMessage.prototype.configParameterCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the config_parameter field.
 */
invalidation.proto.InfoMessage.prototype.clearConfigParameter = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the performance_counter field at the index given.
 * @param {number} index The index to lookup.
 * @return {invalidation.proto.PropertyRecord} The value.
 */
invalidation.proto.InfoMessage.prototype.getPerformanceCounter = function(index) {
  return /** @type {invalidation.proto.PropertyRecord} */ (this.get$Value(3, index));
};


/**
 * Gets the value of the performance_counter field at the index given or the default value if not set.
 * @param {number} index The index to lookup.
 * @return {!invalidation.proto.PropertyRecord} The value.
 */
invalidation.proto.InfoMessage.prototype.getPerformanceCounterOrDefault = function(index) {
  return /** @type {!invalidation.proto.PropertyRecord} */ (this.get$ValueOrDefault(3, index));
};


/**
 * Adds a value to the performance_counter field.
 * @param {!invalidation.proto.PropertyRecord} value The value to add.
 */
invalidation.proto.InfoMessage.prototype.addPerformanceCounter = function(value) {
  this.add$Value(3, value);
};


/**
 * Returns the array of values in the performance_counter field.
 * @return {!Array.<!invalidation.proto.PropertyRecord>} The values in the field.
 */
invalidation.proto.InfoMessage.prototype.performanceCounterArray = function() {
  return /** @type {!Array.<!invalidation.proto.PropertyRecord>} */ (this.array$Values(3));
};


/**
 * @return {boolean} Whether the performance_counter field has a value.
 */
invalidation.proto.InfoMessage.prototype.hasPerformanceCounter = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the performance_counter field.
 */
invalidation.proto.InfoMessage.prototype.performanceCounterCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the performance_counter field.
 */
invalidation.proto.InfoMessage.prototype.clearPerformanceCounter = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the server_registration_summary_requested field.
 * @return {?boolean} The value.
 */
invalidation.proto.InfoMessage.prototype.getServerRegistrationSummaryRequested = function() {
  return /** @type {?boolean} */ (this.get$Value(4));
};


/**
 * Gets the value of the server_registration_summary_requested field or the default value if not set.
 * @return {boolean} The value.
 */
invalidation.proto.InfoMessage.prototype.getServerRegistrationSummaryRequestedOrDefault = function() {
  return /** @type {boolean} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the server_registration_summary_requested field.
 * @param {boolean} value The value.
 */
invalidation.proto.InfoMessage.prototype.setServerRegistrationSummaryRequested = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the server_registration_summary_requested field has a value.
 */
invalidation.proto.InfoMessage.prototype.hasServerRegistrationSummaryRequested = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the server_registration_summary_requested field.
 */
invalidation.proto.InfoMessage.prototype.serverRegistrationSummaryRequestedCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the server_registration_summary_requested field.
 */
invalidation.proto.InfoMessage.prototype.clearServerRegistrationSummaryRequested = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the client_config field.
 * @return {invalidation.proto.ClientConfigP} The value.
 */
invalidation.proto.InfoMessage.prototype.getClientConfig = function() {
  return /** @type {invalidation.proto.ClientConfigP} */ (this.get$Value(5));
};


/**
 * Gets the value of the client_config field or the default value if not set.
 * @return {!invalidation.proto.ClientConfigP} The value.
 */
invalidation.proto.InfoMessage.prototype.getClientConfigOrDefault = function() {
  return /** @type {!invalidation.proto.ClientConfigP} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the client_config field.
 * @param {!invalidation.proto.ClientConfigP} value The value.
 */
invalidation.proto.InfoMessage.prototype.setClientConfig = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the client_config field has a value.
 */
invalidation.proto.InfoMessage.prototype.hasClientConfig = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the client_config field.
 */
invalidation.proto.InfoMessage.prototype.clientConfigCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the client_config field.
 */
invalidation.proto.InfoMessage.prototype.clearClientConfig = function() {
  this.clear$Field(5);
};



/**
 * Message PropertyRecord.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.PropertyRecord = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.PropertyRecord, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.PropertyRecord} The cloned message.
 * @override
 */
invalidation.proto.PropertyRecord.prototype.clone;


/**
 * Gets the value of the name field.
 * @return {?string} The value.
 */
invalidation.proto.PropertyRecord.prototype.getName = function() {
  return /** @type {?string} */ (this.get$Value(1));
};


/**
 * Gets the value of the name field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.PropertyRecord.prototype.getNameOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the name field.
 * @param {string} value The value.
 */
invalidation.proto.PropertyRecord.prototype.setName = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the name field has a value.
 */
invalidation.proto.PropertyRecord.prototype.hasName = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the name field.
 */
invalidation.proto.PropertyRecord.prototype.nameCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the name field.
 */
invalidation.proto.PropertyRecord.prototype.clearName = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the value field.
 * @return {?number} The value.
 */
invalidation.proto.PropertyRecord.prototype.getValue = function() {
  return /** @type {?number} */ (this.get$Value(2));
};


/**
 * Gets the value of the value field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.PropertyRecord.prototype.getValueOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the value field.
 * @param {number} value The value.
 */
invalidation.proto.PropertyRecord.prototype.setValue = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the value field has a value.
 */
invalidation.proto.PropertyRecord.prototype.hasValue = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the value field.
 */
invalidation.proto.PropertyRecord.prototype.valueCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the value field.
 */
invalidation.proto.PropertyRecord.prototype.clearValue = function() {
  this.clear$Field(2);
};



/**
 * Message ServerHeader.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ServerHeader = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ServerHeader, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ServerHeader} The cloned message.
 * @override
 */
invalidation.proto.ServerHeader.prototype.clone;


/**
 * Gets the value of the protocol_version field.
 * @return {invalidation.proto.ProtocolVersion} The value.
 */
invalidation.proto.ServerHeader.prototype.getProtocolVersion = function() {
  return /** @type {invalidation.proto.ProtocolVersion} */ (this.get$Value(1));
};


/**
 * Gets the value of the protocol_version field or the default value if not set.
 * @return {!invalidation.proto.ProtocolVersion} The value.
 */
invalidation.proto.ServerHeader.prototype.getProtocolVersionOrDefault = function() {
  return /** @type {!invalidation.proto.ProtocolVersion} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the protocol_version field.
 * @param {!invalidation.proto.ProtocolVersion} value The value.
 */
invalidation.proto.ServerHeader.prototype.setProtocolVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the protocol_version field has a value.
 */
invalidation.proto.ServerHeader.prototype.hasProtocolVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the protocol_version field.
 */
invalidation.proto.ServerHeader.prototype.protocolVersionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the protocol_version field.
 */
invalidation.proto.ServerHeader.prototype.clearProtocolVersion = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the client_token field.
 * @return {?string} The value.
 */
invalidation.proto.ServerHeader.prototype.getClientToken = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the client_token field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ServerHeader.prototype.getClientTokenOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the client_token field.
 * @param {string} value The value.
 */
invalidation.proto.ServerHeader.prototype.setClientToken = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the client_token field has a value.
 */
invalidation.proto.ServerHeader.prototype.hasClientToken = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the client_token field.
 */
invalidation.proto.ServerHeader.prototype.clientTokenCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the client_token field.
 */
invalidation.proto.ServerHeader.prototype.clearClientToken = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the registration_summary field.
 * @return {invalidation.proto.RegistrationSummary} The value.
 */
invalidation.proto.ServerHeader.prototype.getRegistrationSummary = function() {
  return /** @type {invalidation.proto.RegistrationSummary} */ (this.get$Value(3));
};


/**
 * Gets the value of the registration_summary field or the default value if not set.
 * @return {!invalidation.proto.RegistrationSummary} The value.
 */
invalidation.proto.ServerHeader.prototype.getRegistrationSummaryOrDefault = function() {
  return /** @type {!invalidation.proto.RegistrationSummary} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the registration_summary field.
 * @param {!invalidation.proto.RegistrationSummary} value The value.
 */
invalidation.proto.ServerHeader.prototype.setRegistrationSummary = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the registration_summary field has a value.
 */
invalidation.proto.ServerHeader.prototype.hasRegistrationSummary = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the registration_summary field.
 */
invalidation.proto.ServerHeader.prototype.registrationSummaryCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the registration_summary field.
 */
invalidation.proto.ServerHeader.prototype.clearRegistrationSummary = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the server_time_ms field.
 * @return {?number} The value.
 */
invalidation.proto.ServerHeader.prototype.getServerTimeMs = function() {
  return /** @type {?number} */ (this.get$Value(4));
};


/**
 * Gets the value of the server_time_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ServerHeader.prototype.getServerTimeMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the server_time_ms field.
 * @param {number} value The value.
 */
invalidation.proto.ServerHeader.prototype.setServerTimeMs = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the server_time_ms field has a value.
 */
invalidation.proto.ServerHeader.prototype.hasServerTimeMs = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the server_time_ms field.
 */
invalidation.proto.ServerHeader.prototype.serverTimeMsCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the server_time_ms field.
 */
invalidation.proto.ServerHeader.prototype.clearServerTimeMs = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the message_id field.
 * @return {?string} The value.
 */
invalidation.proto.ServerHeader.prototype.getMessageId = function() {
  return /** @type {?string} */ (this.get$Value(5));
};


/**
 * Gets the value of the message_id field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ServerHeader.prototype.getMessageIdOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the message_id field.
 * @param {string} value The value.
 */
invalidation.proto.ServerHeader.prototype.setMessageId = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the message_id field has a value.
 */
invalidation.proto.ServerHeader.prototype.hasMessageId = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the message_id field.
 */
invalidation.proto.ServerHeader.prototype.messageIdCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the message_id field.
 */
invalidation.proto.ServerHeader.prototype.clearMessageId = function() {
  this.clear$Field(5);
};



/**
 * Message ServerToClientMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ServerToClientMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ServerToClientMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ServerToClientMessage} The cloned message.
 * @override
 */
invalidation.proto.ServerToClientMessage.prototype.clone;


/**
 * Gets the value of the header field.
 * @return {invalidation.proto.ServerHeader} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getHeader = function() {
  return /** @type {invalidation.proto.ServerHeader} */ (this.get$Value(1));
};


/**
 * Gets the value of the header field or the default value if not set.
 * @return {!invalidation.proto.ServerHeader} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getHeaderOrDefault = function() {
  return /** @type {!invalidation.proto.ServerHeader} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the header field.
 * @param {!invalidation.proto.ServerHeader} value The value.
 */
invalidation.proto.ServerToClientMessage.prototype.setHeader = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the header field has a value.
 */
invalidation.proto.ServerToClientMessage.prototype.hasHeader = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the header field.
 */
invalidation.proto.ServerToClientMessage.prototype.headerCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the header field.
 */
invalidation.proto.ServerToClientMessage.prototype.clearHeader = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the token_control_message field.
 * @return {invalidation.proto.TokenControlMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getTokenControlMessage = function() {
  return /** @type {invalidation.proto.TokenControlMessage} */ (this.get$Value(2));
};


/**
 * Gets the value of the token_control_message field or the default value if not set.
 * @return {!invalidation.proto.TokenControlMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getTokenControlMessageOrDefault = function() {
  return /** @type {!invalidation.proto.TokenControlMessage} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the token_control_message field.
 * @param {!invalidation.proto.TokenControlMessage} value The value.
 */
invalidation.proto.ServerToClientMessage.prototype.setTokenControlMessage = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the token_control_message field has a value.
 */
invalidation.proto.ServerToClientMessage.prototype.hasTokenControlMessage = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the token_control_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.tokenControlMessageCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the token_control_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.clearTokenControlMessage = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the invalidation_message field.
 * @return {invalidation.proto.InvalidationMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getInvalidationMessage = function() {
  return /** @type {invalidation.proto.InvalidationMessage} */ (this.get$Value(3));
};


/**
 * Gets the value of the invalidation_message field or the default value if not set.
 * @return {!invalidation.proto.InvalidationMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getInvalidationMessageOrDefault = function() {
  return /** @type {!invalidation.proto.InvalidationMessage} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the invalidation_message field.
 * @param {!invalidation.proto.InvalidationMessage} value The value.
 */
invalidation.proto.ServerToClientMessage.prototype.setInvalidationMessage = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the invalidation_message field has a value.
 */
invalidation.proto.ServerToClientMessage.prototype.hasInvalidationMessage = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the invalidation_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.invalidationMessageCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the invalidation_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.clearInvalidationMessage = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the registration_status_message field.
 * @return {invalidation.proto.RegistrationStatusMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getRegistrationStatusMessage = function() {
  return /** @type {invalidation.proto.RegistrationStatusMessage} */ (this.get$Value(4));
};


/**
 * Gets the value of the registration_status_message field or the default value if not set.
 * @return {!invalidation.proto.RegistrationStatusMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getRegistrationStatusMessageOrDefault = function() {
  return /** @type {!invalidation.proto.RegistrationStatusMessage} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the registration_status_message field.
 * @param {!invalidation.proto.RegistrationStatusMessage} value The value.
 */
invalidation.proto.ServerToClientMessage.prototype.setRegistrationStatusMessage = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the registration_status_message field has a value.
 */
invalidation.proto.ServerToClientMessage.prototype.hasRegistrationStatusMessage = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the registration_status_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.registrationStatusMessageCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the registration_status_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.clearRegistrationStatusMessage = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the registration_sync_request_message field.
 * @return {invalidation.proto.RegistrationSyncRequestMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getRegistrationSyncRequestMessage = function() {
  return /** @type {invalidation.proto.RegistrationSyncRequestMessage} */ (this.get$Value(5));
};


/**
 * Gets the value of the registration_sync_request_message field or the default value if not set.
 * @return {!invalidation.proto.RegistrationSyncRequestMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getRegistrationSyncRequestMessageOrDefault = function() {
  return /** @type {!invalidation.proto.RegistrationSyncRequestMessage} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the registration_sync_request_message field.
 * @param {!invalidation.proto.RegistrationSyncRequestMessage} value The value.
 */
invalidation.proto.ServerToClientMessage.prototype.setRegistrationSyncRequestMessage = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the registration_sync_request_message field has a value.
 */
invalidation.proto.ServerToClientMessage.prototype.hasRegistrationSyncRequestMessage = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the registration_sync_request_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.registrationSyncRequestMessageCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the registration_sync_request_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.clearRegistrationSyncRequestMessage = function() {
  this.clear$Field(5);
};


/**
 * Gets the value of the config_change_message field.
 * @return {invalidation.proto.ConfigChangeMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getConfigChangeMessage = function() {
  return /** @type {invalidation.proto.ConfigChangeMessage} */ (this.get$Value(6));
};


/**
 * Gets the value of the config_change_message field or the default value if not set.
 * @return {!invalidation.proto.ConfigChangeMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getConfigChangeMessageOrDefault = function() {
  return /** @type {!invalidation.proto.ConfigChangeMessage} */ (this.get$ValueOrDefault(6));
};


/**
 * Sets the value of the config_change_message field.
 * @param {!invalidation.proto.ConfigChangeMessage} value The value.
 */
invalidation.proto.ServerToClientMessage.prototype.setConfigChangeMessage = function(value) {
  this.set$Value(6, value);
};


/**
 * @return {boolean} Whether the config_change_message field has a value.
 */
invalidation.proto.ServerToClientMessage.prototype.hasConfigChangeMessage = function() {
  return this.has$Value(6);
};


/**
 * @return {number} The number of values in the config_change_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.configChangeMessageCount = function() {
  return this.count$Values(6);
};


/**
 * Clears the values in the config_change_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.clearConfigChangeMessage = function() {
  this.clear$Field(6);
};


/**
 * Gets the value of the info_request_message field.
 * @return {invalidation.proto.InfoRequestMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getInfoRequestMessage = function() {
  return /** @type {invalidation.proto.InfoRequestMessage} */ (this.get$Value(7));
};


/**
 * Gets the value of the info_request_message field or the default value if not set.
 * @return {!invalidation.proto.InfoRequestMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getInfoRequestMessageOrDefault = function() {
  return /** @type {!invalidation.proto.InfoRequestMessage} */ (this.get$ValueOrDefault(7));
};


/**
 * Sets the value of the info_request_message field.
 * @param {!invalidation.proto.InfoRequestMessage} value The value.
 */
invalidation.proto.ServerToClientMessage.prototype.setInfoRequestMessage = function(value) {
  this.set$Value(7, value);
};


/**
 * @return {boolean} Whether the info_request_message field has a value.
 */
invalidation.proto.ServerToClientMessage.prototype.hasInfoRequestMessage = function() {
  return this.has$Value(7);
};


/**
 * @return {number} The number of values in the info_request_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.infoRequestMessageCount = function() {
  return this.count$Values(7);
};


/**
 * Clears the values in the info_request_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.clearInfoRequestMessage = function() {
  this.clear$Field(7);
};


/**
 * Gets the value of the error_message field.
 * @return {invalidation.proto.ErrorMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getErrorMessage = function() {
  return /** @type {invalidation.proto.ErrorMessage} */ (this.get$Value(8));
};


/**
 * Gets the value of the error_message field or the default value if not set.
 * @return {!invalidation.proto.ErrorMessage} The value.
 */
invalidation.proto.ServerToClientMessage.prototype.getErrorMessageOrDefault = function() {
  return /** @type {!invalidation.proto.ErrorMessage} */ (this.get$ValueOrDefault(8));
};


/**
 * Sets the value of the error_message field.
 * @param {!invalidation.proto.ErrorMessage} value The value.
 */
invalidation.proto.ServerToClientMessage.prototype.setErrorMessage = function(value) {
  this.set$Value(8, value);
};


/**
 * @return {boolean} Whether the error_message field has a value.
 */
invalidation.proto.ServerToClientMessage.prototype.hasErrorMessage = function() {
  return this.has$Value(8);
};


/**
 * @return {number} The number of values in the error_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.errorMessageCount = function() {
  return this.count$Values(8);
};


/**
 * Clears the values in the error_message field.
 */
invalidation.proto.ServerToClientMessage.prototype.clearErrorMessage = function() {
  this.clear$Field(8);
};



/**
 * Message TokenControlMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.TokenControlMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.TokenControlMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.TokenControlMessage} The cloned message.
 * @override
 */
invalidation.proto.TokenControlMessage.prototype.clone;


/**
 * Gets the value of the new_token field.
 * @return {?string} The value.
 */
invalidation.proto.TokenControlMessage.prototype.getNewToken = function() {
  return /** @type {?string} */ (this.get$Value(1));
};


/**
 * Gets the value of the new_token field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.TokenControlMessage.prototype.getNewTokenOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the new_token field.
 * @param {string} value The value.
 */
invalidation.proto.TokenControlMessage.prototype.setNewToken = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the new_token field has a value.
 */
invalidation.proto.TokenControlMessage.prototype.hasNewToken = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the new_token field.
 */
invalidation.proto.TokenControlMessage.prototype.newTokenCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the new_token field.
 */
invalidation.proto.TokenControlMessage.prototype.clearNewToken = function() {
  this.clear$Field(1);
};



/**
 * Message RegistrationStatus.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.RegistrationStatus = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.RegistrationStatus, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.RegistrationStatus} The cloned message.
 * @override
 */
invalidation.proto.RegistrationStatus.prototype.clone;


/**
 * Gets the value of the registration field.
 * @return {invalidation.proto.RegistrationP} The value.
 */
invalidation.proto.RegistrationStatus.prototype.getRegistration = function() {
  return /** @type {invalidation.proto.RegistrationP} */ (this.get$Value(1));
};


/**
 * Gets the value of the registration field or the default value if not set.
 * @return {!invalidation.proto.RegistrationP} The value.
 */
invalidation.proto.RegistrationStatus.prototype.getRegistrationOrDefault = function() {
  return /** @type {!invalidation.proto.RegistrationP} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the registration field.
 * @param {!invalidation.proto.RegistrationP} value The value.
 */
invalidation.proto.RegistrationStatus.prototype.setRegistration = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the registration field has a value.
 */
invalidation.proto.RegistrationStatus.prototype.hasRegistration = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the registration field.
 */
invalidation.proto.RegistrationStatus.prototype.registrationCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the registration field.
 */
invalidation.proto.RegistrationStatus.prototype.clearRegistration = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the status field.
 * @return {invalidation.proto.StatusP} The value.
 */
invalidation.proto.RegistrationStatus.prototype.getStatus = function() {
  return /** @type {invalidation.proto.StatusP} */ (this.get$Value(2));
};


/**
 * Gets the value of the status field or the default value if not set.
 * @return {!invalidation.proto.StatusP} The value.
 */
invalidation.proto.RegistrationStatus.prototype.getStatusOrDefault = function() {
  return /** @type {!invalidation.proto.StatusP} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the status field.
 * @param {!invalidation.proto.StatusP} value The value.
 */
invalidation.proto.RegistrationStatus.prototype.setStatus = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the status field has a value.
 */
invalidation.proto.RegistrationStatus.prototype.hasStatus = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the status field.
 */
invalidation.proto.RegistrationStatus.prototype.statusCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the status field.
 */
invalidation.proto.RegistrationStatus.prototype.clearStatus = function() {
  this.clear$Field(2);
};



/**
 * Message RegistrationStatusMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.RegistrationStatusMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.RegistrationStatusMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.RegistrationStatusMessage} The cloned message.
 * @override
 */
invalidation.proto.RegistrationStatusMessage.prototype.clone;


/**
 * Gets the value of the registration_status field at the index given.
 * @param {number} index The index to lookup.
 * @return {invalidation.proto.RegistrationStatus} The value.
 */
invalidation.proto.RegistrationStatusMessage.prototype.getRegistrationStatus = function(index) {
  return /** @type {invalidation.proto.RegistrationStatus} */ (this.get$Value(1, index));
};


/**
 * Gets the value of the registration_status field at the index given or the default value if not set.
 * @param {number} index The index to lookup.
 * @return {!invalidation.proto.RegistrationStatus} The value.
 */
invalidation.proto.RegistrationStatusMessage.prototype.getRegistrationStatusOrDefault = function(index) {
  return /** @type {!invalidation.proto.RegistrationStatus} */ (this.get$ValueOrDefault(1, index));
};


/**
 * Adds a value to the registration_status field.
 * @param {!invalidation.proto.RegistrationStatus} value The value to add.
 */
invalidation.proto.RegistrationStatusMessage.prototype.addRegistrationStatus = function(value) {
  this.add$Value(1, value);
};


/**
 * Returns the array of values in the registration_status field.
 * @return {!Array.<!invalidation.proto.RegistrationStatus>} The values in the field.
 */
invalidation.proto.RegistrationStatusMessage.prototype.registrationStatusArray = function() {
  return /** @type {!Array.<!invalidation.proto.RegistrationStatus>} */ (this.array$Values(1));
};


/**
 * @return {boolean} Whether the registration_status field has a value.
 */
invalidation.proto.RegistrationStatusMessage.prototype.hasRegistrationStatus = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the registration_status field.
 */
invalidation.proto.RegistrationStatusMessage.prototype.registrationStatusCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the registration_status field.
 */
invalidation.proto.RegistrationStatusMessage.prototype.clearRegistrationStatus = function() {
  this.clear$Field(1);
};



/**
 * Message RegistrationSyncRequestMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.RegistrationSyncRequestMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.RegistrationSyncRequestMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.RegistrationSyncRequestMessage} The cloned message.
 * @override
 */
invalidation.proto.RegistrationSyncRequestMessage.prototype.clone;



/**
 * Message InvalidationMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.InvalidationMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.InvalidationMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.InvalidationMessage} The cloned message.
 * @override
 */
invalidation.proto.InvalidationMessage.prototype.clone;


/**
 * Gets the value of the invalidation field at the index given.
 * @param {number} index The index to lookup.
 * @return {invalidation.proto.InvalidationP} The value.
 */
invalidation.proto.InvalidationMessage.prototype.getInvalidation = function(index) {
  return /** @type {invalidation.proto.InvalidationP} */ (this.get$Value(1, index));
};


/**
 * Gets the value of the invalidation field at the index given or the default value if not set.
 * @param {number} index The index to lookup.
 * @return {!invalidation.proto.InvalidationP} The value.
 */
invalidation.proto.InvalidationMessage.prototype.getInvalidationOrDefault = function(index) {
  return /** @type {!invalidation.proto.InvalidationP} */ (this.get$ValueOrDefault(1, index));
};


/**
 * Adds a value to the invalidation field.
 * @param {!invalidation.proto.InvalidationP} value The value to add.
 */
invalidation.proto.InvalidationMessage.prototype.addInvalidation = function(value) {
  this.add$Value(1, value);
};


/**
 * Returns the array of values in the invalidation field.
 * @return {!Array.<!invalidation.proto.InvalidationP>} The values in the field.
 */
invalidation.proto.InvalidationMessage.prototype.invalidationArray = function() {
  return /** @type {!Array.<!invalidation.proto.InvalidationP>} */ (this.array$Values(1));
};


/**
 * @return {boolean} Whether the invalidation field has a value.
 */
invalidation.proto.InvalidationMessage.prototype.hasInvalidation = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the invalidation field.
 */
invalidation.proto.InvalidationMessage.prototype.invalidationCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the invalidation field.
 */
invalidation.proto.InvalidationMessage.prototype.clearInvalidation = function() {
  this.clear$Field(1);
};



/**
 * Message InfoRequestMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.InfoRequestMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.InfoRequestMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.InfoRequestMessage} The cloned message.
 * @override
 */
invalidation.proto.InfoRequestMessage.prototype.clone;


/**
 * Gets the value of the info_type field at the index given.
 * @param {number} index The index to lookup.
 * @return {?invalidation.proto.InfoRequestMessage.InfoType} The value.
 */
invalidation.proto.InfoRequestMessage.prototype.getInfoType = function(index) {
  return /** @type {?invalidation.proto.InfoRequestMessage.InfoType} */ (this.get$Value(1, index));
};


/**
 * Gets the value of the info_type field at the index given or the default value if not set.
 * @param {number} index The index to lookup.
 * @return {invalidation.proto.InfoRequestMessage.InfoType} The value.
 */
invalidation.proto.InfoRequestMessage.prototype.getInfoTypeOrDefault = function(index) {
  return /** @type {invalidation.proto.InfoRequestMessage.InfoType} */ (this.get$ValueOrDefault(1, index));
};


/**
 * Adds a value to the info_type field.
 * @param {invalidation.proto.InfoRequestMessage.InfoType} value The value to add.
 */
invalidation.proto.InfoRequestMessage.prototype.addInfoType = function(value) {
  this.add$Value(1, value);
};


/**
 * Returns the array of values in the info_type field.
 * @return {!Array.<invalidation.proto.InfoRequestMessage.InfoType>} The values in the field.
 */
invalidation.proto.InfoRequestMessage.prototype.infoTypeArray = function() {
  return /** @type {!Array.<invalidation.proto.InfoRequestMessage.InfoType>} */ (this.array$Values(1));
};


/**
 * @return {boolean} Whether the info_type field has a value.
 */
invalidation.proto.InfoRequestMessage.prototype.hasInfoType = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the info_type field.
 */
invalidation.proto.InfoRequestMessage.prototype.infoTypeCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the info_type field.
 */
invalidation.proto.InfoRequestMessage.prototype.clearInfoType = function() {
  this.clear$Field(1);
};


/**
 * Enumeration InfoType.
 * @enum {number}
 */
invalidation.proto.InfoRequestMessage.InfoType = {
  GET_PERFORMANCE_COUNTERS: 1
};



/**
 * Message RateLimitP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.RateLimitP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.RateLimitP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.RateLimitP} The cloned message.
 * @override
 */
invalidation.proto.RateLimitP.prototype.clone;


/**
 * Gets the value of the window_ms field.
 * @return {?number} The value.
 */
invalidation.proto.RateLimitP.prototype.getWindowMs = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the window_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.RateLimitP.prototype.getWindowMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the window_ms field.
 * @param {number} value The value.
 */
invalidation.proto.RateLimitP.prototype.setWindowMs = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the window_ms field has a value.
 */
invalidation.proto.RateLimitP.prototype.hasWindowMs = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the window_ms field.
 */
invalidation.proto.RateLimitP.prototype.windowMsCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the window_ms field.
 */
invalidation.proto.RateLimitP.prototype.clearWindowMs = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the count field.
 * @return {?number} The value.
 */
invalidation.proto.RateLimitP.prototype.getCount = function() {
  return /** @type {?number} */ (this.get$Value(2));
};


/**
 * Gets the value of the count field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.RateLimitP.prototype.getCountOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the count field.
 * @param {number} value The value.
 */
invalidation.proto.RateLimitP.prototype.setCount = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the count field has a value.
 */
invalidation.proto.RateLimitP.prototype.hasCount = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the count field.
 */
invalidation.proto.RateLimitP.prototype.countCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the count field.
 */
invalidation.proto.RateLimitP.prototype.clearCount = function() {
  this.clear$Field(2);
};



/**
 * Message ProtocolHandlerConfigP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ProtocolHandlerConfigP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ProtocolHandlerConfigP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ProtocolHandlerConfigP} The cloned message.
 * @override
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.clone;


/**
 * Gets the value of the batching_delay_ms field.
 * @return {?number} The value.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.getBatchingDelayMs = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the batching_delay_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.getBatchingDelayMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the batching_delay_ms field.
 * @param {number} value The value.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.setBatchingDelayMs = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the batching_delay_ms field has a value.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.hasBatchingDelayMs = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the batching_delay_ms field.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.batchingDelayMsCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the batching_delay_ms field.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.clearBatchingDelayMs = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the rate_limit field at the index given.
 * @param {number} index The index to lookup.
 * @return {invalidation.proto.RateLimitP} The value.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.getRateLimit = function(index) {
  return /** @type {invalidation.proto.RateLimitP} */ (this.get$Value(2, index));
};


/**
 * Gets the value of the rate_limit field at the index given or the default value if not set.
 * @param {number} index The index to lookup.
 * @return {!invalidation.proto.RateLimitP} The value.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.getRateLimitOrDefault = function(index) {
  return /** @type {!invalidation.proto.RateLimitP} */ (this.get$ValueOrDefault(2, index));
};


/**
 * Adds a value to the rate_limit field.
 * @param {!invalidation.proto.RateLimitP} value The value to add.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.addRateLimit = function(value) {
  this.add$Value(2, value);
};


/**
 * Returns the array of values in the rate_limit field.
 * @return {!Array.<!invalidation.proto.RateLimitP>} The values in the field.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.rateLimitArray = function() {
  return /** @type {!Array.<!invalidation.proto.RateLimitP>} */ (this.array$Values(2));
};


/**
 * @return {boolean} Whether the rate_limit field has a value.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.hasRateLimit = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the rate_limit field.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.rateLimitCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the rate_limit field.
 */
invalidation.proto.ProtocolHandlerConfigP.prototype.clearRateLimit = function() {
  this.clear$Field(2);
};



/**
 * Message ClientConfigP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ClientConfigP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ClientConfigP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ClientConfigP} The cloned message.
 * @override
 */
invalidation.proto.ClientConfigP.prototype.clone;


/**
 * Gets the value of the version field.
 * @return {invalidation.proto.Version} The value.
 */
invalidation.proto.ClientConfigP.prototype.getVersion = function() {
  return /** @type {invalidation.proto.Version} */ (this.get$Value(1));
};


/**
 * Gets the value of the version field or the default value if not set.
 * @return {!invalidation.proto.Version} The value.
 */
invalidation.proto.ClientConfigP.prototype.getVersionOrDefault = function() {
  return /** @type {!invalidation.proto.Version} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the version field.
 * @param {!invalidation.proto.Version} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setVersion = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the version field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasVersion = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the version field.
 */
invalidation.proto.ClientConfigP.prototype.versionCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the version field.
 */
invalidation.proto.ClientConfigP.prototype.clearVersion = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the network_timeout_delay_ms field.
 * @return {?number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getNetworkTimeoutDelayMs = function() {
  return /** @type {?number} */ (this.get$Value(2));
};


/**
 * Gets the value of the network_timeout_delay_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getNetworkTimeoutDelayMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the network_timeout_delay_ms field.
 * @param {number} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setNetworkTimeoutDelayMs = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the network_timeout_delay_ms field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasNetworkTimeoutDelayMs = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the network_timeout_delay_ms field.
 */
invalidation.proto.ClientConfigP.prototype.networkTimeoutDelayMsCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the network_timeout_delay_ms field.
 */
invalidation.proto.ClientConfigP.prototype.clearNetworkTimeoutDelayMs = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the write_retry_delay_ms field.
 * @return {?number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getWriteRetryDelayMs = function() {
  return /** @type {?number} */ (this.get$Value(3));
};


/**
 * Gets the value of the write_retry_delay_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getWriteRetryDelayMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the write_retry_delay_ms field.
 * @param {number} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setWriteRetryDelayMs = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the write_retry_delay_ms field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasWriteRetryDelayMs = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the write_retry_delay_ms field.
 */
invalidation.proto.ClientConfigP.prototype.writeRetryDelayMsCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the write_retry_delay_ms field.
 */
invalidation.proto.ClientConfigP.prototype.clearWriteRetryDelayMs = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the heartbeat_interval_ms field.
 * @return {?number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getHeartbeatIntervalMs = function() {
  return /** @type {?number} */ (this.get$Value(4));
};


/**
 * Gets the value of the heartbeat_interval_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getHeartbeatIntervalMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the heartbeat_interval_ms field.
 * @param {number} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setHeartbeatIntervalMs = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the heartbeat_interval_ms field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasHeartbeatIntervalMs = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the heartbeat_interval_ms field.
 */
invalidation.proto.ClientConfigP.prototype.heartbeatIntervalMsCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the heartbeat_interval_ms field.
 */
invalidation.proto.ClientConfigP.prototype.clearHeartbeatIntervalMs = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the perf_counter_delay_ms field.
 * @return {?number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getPerfCounterDelayMs = function() {
  return /** @type {?number} */ (this.get$Value(5));
};


/**
 * Gets the value of the perf_counter_delay_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getPerfCounterDelayMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the perf_counter_delay_ms field.
 * @param {number} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setPerfCounterDelayMs = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the perf_counter_delay_ms field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasPerfCounterDelayMs = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the perf_counter_delay_ms field.
 */
invalidation.proto.ClientConfigP.prototype.perfCounterDelayMsCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the perf_counter_delay_ms field.
 */
invalidation.proto.ClientConfigP.prototype.clearPerfCounterDelayMs = function() {
  this.clear$Field(5);
};


/**
 * Gets the value of the max_exponential_backoff_factor field.
 * @return {?number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getMaxExponentialBackoffFactor = function() {
  return /** @type {?number} */ (this.get$Value(6));
};


/**
 * Gets the value of the max_exponential_backoff_factor field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getMaxExponentialBackoffFactorOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(6));
};


/**
 * Sets the value of the max_exponential_backoff_factor field.
 * @param {number} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setMaxExponentialBackoffFactor = function(value) {
  this.set$Value(6, value);
};


/**
 * @return {boolean} Whether the max_exponential_backoff_factor field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasMaxExponentialBackoffFactor = function() {
  return this.has$Value(6);
};


/**
 * @return {number} The number of values in the max_exponential_backoff_factor field.
 */
invalidation.proto.ClientConfigP.prototype.maxExponentialBackoffFactorCount = function() {
  return this.count$Values(6);
};


/**
 * Clears the values in the max_exponential_backoff_factor field.
 */
invalidation.proto.ClientConfigP.prototype.clearMaxExponentialBackoffFactor = function() {
  this.clear$Field(6);
};


/**
 * Gets the value of the smear_percent field.
 * @return {?number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getSmearPercent = function() {
  return /** @type {?number} */ (this.get$Value(7));
};


/**
 * Gets the value of the smear_percent field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getSmearPercentOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(7));
};


/**
 * Sets the value of the smear_percent field.
 * @param {number} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setSmearPercent = function(value) {
  this.set$Value(7, value);
};


/**
 * @return {boolean} Whether the smear_percent field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasSmearPercent = function() {
  return this.has$Value(7);
};


/**
 * @return {number} The number of values in the smear_percent field.
 */
invalidation.proto.ClientConfigP.prototype.smearPercentCount = function() {
  return this.count$Values(7);
};


/**
 * Clears the values in the smear_percent field.
 */
invalidation.proto.ClientConfigP.prototype.clearSmearPercent = function() {
  this.clear$Field(7);
};


/**
 * Gets the value of the is_transient field.
 * @return {?boolean} The value.
 */
invalidation.proto.ClientConfigP.prototype.getIsTransient = function() {
  return /** @type {?boolean} */ (this.get$Value(8));
};


/**
 * Gets the value of the is_transient field or the default value if not set.
 * @return {boolean} The value.
 */
invalidation.proto.ClientConfigP.prototype.getIsTransientOrDefault = function() {
  return /** @type {boolean} */ (this.get$ValueOrDefault(8));
};


/**
 * Sets the value of the is_transient field.
 * @param {boolean} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setIsTransient = function(value) {
  this.set$Value(8, value);
};


/**
 * @return {boolean} Whether the is_transient field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasIsTransient = function() {
  return this.has$Value(8);
};


/**
 * @return {number} The number of values in the is_transient field.
 */
invalidation.proto.ClientConfigP.prototype.isTransientCount = function() {
  return this.count$Values(8);
};


/**
 * Clears the values in the is_transient field.
 */
invalidation.proto.ClientConfigP.prototype.clearIsTransient = function() {
  this.clear$Field(8);
};


/**
 * Gets the value of the initial_persistent_heartbeat_delay_ms field.
 * @return {?number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getInitialPersistentHeartbeatDelayMs = function() {
  return /** @type {?number} */ (this.get$Value(9));
};


/**
 * Gets the value of the initial_persistent_heartbeat_delay_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getInitialPersistentHeartbeatDelayMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(9));
};


/**
 * Sets the value of the initial_persistent_heartbeat_delay_ms field.
 * @param {number} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setInitialPersistentHeartbeatDelayMs = function(value) {
  this.set$Value(9, value);
};


/**
 * @return {boolean} Whether the initial_persistent_heartbeat_delay_ms field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasInitialPersistentHeartbeatDelayMs = function() {
  return this.has$Value(9);
};


/**
 * @return {number} The number of values in the initial_persistent_heartbeat_delay_ms field.
 */
invalidation.proto.ClientConfigP.prototype.initialPersistentHeartbeatDelayMsCount = function() {
  return this.count$Values(9);
};


/**
 * Clears the values in the initial_persistent_heartbeat_delay_ms field.
 */
invalidation.proto.ClientConfigP.prototype.clearInitialPersistentHeartbeatDelayMs = function() {
  this.clear$Field(9);
};


/**
 * Gets the value of the protocol_handler_config field.
 * @return {invalidation.proto.ProtocolHandlerConfigP} The value.
 */
invalidation.proto.ClientConfigP.prototype.getProtocolHandlerConfig = function() {
  return /** @type {invalidation.proto.ProtocolHandlerConfigP} */ (this.get$Value(10));
};


/**
 * Gets the value of the protocol_handler_config field or the default value if not set.
 * @return {!invalidation.proto.ProtocolHandlerConfigP} The value.
 */
invalidation.proto.ClientConfigP.prototype.getProtocolHandlerConfigOrDefault = function() {
  return /** @type {!invalidation.proto.ProtocolHandlerConfigP} */ (this.get$ValueOrDefault(10));
};


/**
 * Sets the value of the protocol_handler_config field.
 * @param {!invalidation.proto.ProtocolHandlerConfigP} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setProtocolHandlerConfig = function(value) {
  this.set$Value(10, value);
};


/**
 * @return {boolean} Whether the protocol_handler_config field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasProtocolHandlerConfig = function() {
  return this.has$Value(10);
};


/**
 * @return {number} The number of values in the protocol_handler_config field.
 */
invalidation.proto.ClientConfigP.prototype.protocolHandlerConfigCount = function() {
  return this.count$Values(10);
};


/**
 * Clears the values in the protocol_handler_config field.
 */
invalidation.proto.ClientConfigP.prototype.clearProtocolHandlerConfig = function() {
  this.clear$Field(10);
};


/**
 * Gets the value of the channel_supports_offline_delivery field.
 * @return {?boolean} The value.
 */
invalidation.proto.ClientConfigP.prototype.getChannelSupportsOfflineDelivery = function() {
  return /** @type {?boolean} */ (this.get$Value(11));
};


/**
 * Gets the value of the channel_supports_offline_delivery field or the default value if not set.
 * @return {boolean} The value.
 */
invalidation.proto.ClientConfigP.prototype.getChannelSupportsOfflineDeliveryOrDefault = function() {
  return /** @type {boolean} */ (this.get$ValueOrDefault(11));
};


/**
 * Sets the value of the channel_supports_offline_delivery field.
 * @param {boolean} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setChannelSupportsOfflineDelivery = function(value) {
  this.set$Value(11, value);
};


/**
 * @return {boolean} Whether the channel_supports_offline_delivery field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasChannelSupportsOfflineDelivery = function() {
  return this.has$Value(11);
};


/**
 * @return {number} The number of values in the channel_supports_offline_delivery field.
 */
invalidation.proto.ClientConfigP.prototype.channelSupportsOfflineDeliveryCount = function() {
  return this.count$Values(11);
};


/**
 * Clears the values in the channel_supports_offline_delivery field.
 */
invalidation.proto.ClientConfigP.prototype.clearChannelSupportsOfflineDelivery = function() {
  this.clear$Field(11);
};


/**
 * Gets the value of the offline_heartbeat_threshold_ms field.
 * @return {?number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getOfflineHeartbeatThresholdMs = function() {
  return /** @type {?number} */ (this.get$Value(12));
};


/**
 * Gets the value of the offline_heartbeat_threshold_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ClientConfigP.prototype.getOfflineHeartbeatThresholdMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(12));
};


/**
 * Sets the value of the offline_heartbeat_threshold_ms field.
 * @param {number} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setOfflineHeartbeatThresholdMs = function(value) {
  this.set$Value(12, value);
};


/**
 * @return {boolean} Whether the offline_heartbeat_threshold_ms field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasOfflineHeartbeatThresholdMs = function() {
  return this.has$Value(12);
};


/**
 * @return {number} The number of values in the offline_heartbeat_threshold_ms field.
 */
invalidation.proto.ClientConfigP.prototype.offlineHeartbeatThresholdMsCount = function() {
  return this.count$Values(12);
};


/**
 * Clears the values in the offline_heartbeat_threshold_ms field.
 */
invalidation.proto.ClientConfigP.prototype.clearOfflineHeartbeatThresholdMs = function() {
  this.clear$Field(12);
};


/**
 * Gets the value of the allow_suppression field.
 * @return {?boolean} The value.
 */
invalidation.proto.ClientConfigP.prototype.getAllowSuppression = function() {
  return /** @type {?boolean} */ (this.get$Value(13));
};


/**
 * Gets the value of the allow_suppression field or the default value if not set.
 * @return {boolean} The value.
 */
invalidation.proto.ClientConfigP.prototype.getAllowSuppressionOrDefault = function() {
  return /** @type {boolean} */ (this.get$ValueOrDefault(13));
};


/**
 * Sets the value of the allow_suppression field.
 * @param {boolean} value The value.
 */
invalidation.proto.ClientConfigP.prototype.setAllowSuppression = function(value) {
  this.set$Value(13, value);
};


/**
 * @return {boolean} Whether the allow_suppression field has a value.
 */
invalidation.proto.ClientConfigP.prototype.hasAllowSuppression = function() {
  return this.has$Value(13);
};


/**
 * @return {number} The number of values in the allow_suppression field.
 */
invalidation.proto.ClientConfigP.prototype.allowSuppressionCount = function() {
  return this.count$Values(13);
};


/**
 * Clears the values in the allow_suppression field.
 */
invalidation.proto.ClientConfigP.prototype.clearAllowSuppression = function() {
  this.clear$Field(13);
};



/**
 * Message ConfigChangeMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ConfigChangeMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ConfigChangeMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ConfigChangeMessage} The cloned message.
 * @override
 */
invalidation.proto.ConfigChangeMessage.prototype.clone;


/**
 * Gets the value of the next_message_delay_ms field.
 * @return {?number} The value.
 */
invalidation.proto.ConfigChangeMessage.prototype.getNextMessageDelayMs = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the next_message_delay_ms field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ConfigChangeMessage.prototype.getNextMessageDelayMsOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the next_message_delay_ms field.
 * @param {number} value The value.
 */
invalidation.proto.ConfigChangeMessage.prototype.setNextMessageDelayMs = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the next_message_delay_ms field has a value.
 */
invalidation.proto.ConfigChangeMessage.prototype.hasNextMessageDelayMs = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the next_message_delay_ms field.
 */
invalidation.proto.ConfigChangeMessage.prototype.nextMessageDelayMsCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the next_message_delay_ms field.
 */
invalidation.proto.ConfigChangeMessage.prototype.clearNextMessageDelayMs = function() {
  this.clear$Field(1);
};



/**
 * Message ErrorMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ErrorMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ErrorMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ErrorMessage} The cloned message.
 * @override
 */
invalidation.proto.ErrorMessage.prototype.clone;


/**
 * Gets the value of the code field.
 * @return {?invalidation.proto.ErrorMessage.Code} The value.
 */
invalidation.proto.ErrorMessage.prototype.getCode = function() {
  return /** @type {?invalidation.proto.ErrorMessage.Code} */ (this.get$Value(1));
};


/**
 * Gets the value of the code field or the default value if not set.
 * @return {invalidation.proto.ErrorMessage.Code} The value.
 */
invalidation.proto.ErrorMessage.prototype.getCodeOrDefault = function() {
  return /** @type {invalidation.proto.ErrorMessage.Code} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the code field.
 * @param {invalidation.proto.ErrorMessage.Code} value The value.
 */
invalidation.proto.ErrorMessage.prototype.setCode = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the code field has a value.
 */
invalidation.proto.ErrorMessage.prototype.hasCode = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the code field.
 */
invalidation.proto.ErrorMessage.prototype.codeCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the code field.
 */
invalidation.proto.ErrorMessage.prototype.clearCode = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the description field.
 * @return {?string} The value.
 */
invalidation.proto.ErrorMessage.prototype.getDescription = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the description field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ErrorMessage.prototype.getDescriptionOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the description field.
 * @param {string} value The value.
 */
invalidation.proto.ErrorMessage.prototype.setDescription = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the description field has a value.
 */
invalidation.proto.ErrorMessage.prototype.hasDescription = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the description field.
 */
invalidation.proto.ErrorMessage.prototype.descriptionCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the description field.
 */
invalidation.proto.ErrorMessage.prototype.clearDescription = function() {
  this.clear$Field(2);
};


/**
 * Enumeration Code.
 * @enum {number}
 */
invalidation.proto.ErrorMessage.Code = {
  AUTH_FAILURE: 1,
  UNKNOWN_FAILURE: 10000
};


goog.proto2.Message.set$Metadata(invalidation.proto.Version, {
  0: {
    name: 'Version',
    fullName: 'ipc.invalidation.Version'
  },
  1: {
    name: 'major_version',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  },
  2: {
    name: 'minor_version',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ProtocolVersion, {
  0: {
    name: 'ProtocolVersion',
    fullName: 'ipc.invalidation.ProtocolVersion'
  },
  1: {
    name: 'version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.Version
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ClientVersion, {
  0: {
    name: 'ClientVersion',
    fullName: 'ipc.invalidation.ClientVersion'
  },
  1: {
    name: 'version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.Version
  },
  2: {
    name: 'platform',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  3: {
    name: 'language',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  4: {
    name: 'application_info',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.StatusP, {
  0: {
    name: 'StatusP',
    fullName: 'ipc.invalidation.StatusP'
  },
  1: {
    name: 'code',
    fieldType: goog.proto2.Message.FieldType.ENUM,
    defaultValue: invalidation.proto.StatusP.Code.SUCCESS,
    type: invalidation.proto.StatusP.Code
  },
  2: {
    name: 'description',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ObjectIdP, {
  0: {
    name: 'ObjectIdP',
    fullName: 'ipc.invalidation.ObjectIdP'
  },
  1: {
    name: 'source',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  },
  2: {
    name: 'name',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ApplicationClientIdP, {
  0: {
    name: 'ApplicationClientIdP',
    fullName: 'ipc.invalidation.ApplicationClientIdP'
  },
  1: {
    name: 'client_type',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  },
  2: {
    name: 'client_name',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.InvalidationP, {
  0: {
    name: 'InvalidationP',
    fullName: 'ipc.invalidation.InvalidationP'
  },
  1: {
    name: 'object_id',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ObjectIdP
  },
  2: {
    name: 'is_known_version',
    fieldType: goog.proto2.Message.FieldType.BOOL,
    type: Boolean
  },
  3: {
    name: 'version',
    fieldType: goog.proto2.Message.FieldType.INT64,
    type: Number
  },
  6: {
    name: 'is_trickle_restart',
    fieldType: goog.proto2.Message.FieldType.BOOL,
    defaultValue: true,
    type: Boolean
  },
  4: {
    name: 'payload',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  },
  5: {
    name: 'bridge_arrival_time_ms_deprecated',
    fieldType: goog.proto2.Message.FieldType.INT64,
    type: String
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.RegistrationP, {
  0: {
    name: 'RegistrationP',
    fullName: 'ipc.invalidation.RegistrationP'
  },
  1: {
    name: 'object_id',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ObjectIdP
  },
  2: {
    name: 'op_type',
    fieldType: goog.proto2.Message.FieldType.ENUM,
    defaultValue: invalidation.proto.RegistrationP.OpType.REGISTER,
    type: invalidation.proto.RegistrationP.OpType
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.RegistrationSummary, {
  0: {
    name: 'RegistrationSummary',
    fullName: 'ipc.invalidation.RegistrationSummary'
  },
  1: {
    name: 'num_registrations',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  },
  2: {
    name: 'registration_digest',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ClientHeader, {
  0: {
    name: 'ClientHeader',
    fullName: 'ipc.invalidation.ClientHeader'
  },
  1: {
    name: 'protocol_version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ProtocolVersion
  },
  2: {
    name: 'client_token',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  },
  3: {
    name: 'registration_summary',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationSummary
  },
  4: {
    name: 'client_time_ms',
    fieldType: goog.proto2.Message.FieldType.INT64,
    type: Number
  },
  5: {
    name: 'max_known_server_time_ms',
    fieldType: goog.proto2.Message.FieldType.INT64,
    type: Number
  },
  6: {
    name: 'message_id',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  7: {
    name: 'client_type',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ClientToServerMessage, {
  0: {
    name: 'ClientToServerMessage',
    fullName: 'ipc.invalidation.ClientToServerMessage'
  },
  1: {
    name: 'header',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ClientHeader
  },
  2: {
    name: 'initialize_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.InitializeMessage
  },
  3: {
    name: 'registration_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationMessage
  },
  4: {
    name: 'registration_sync_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationSyncMessage
  },
  5: {
    name: 'invalidation_ack_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.InvalidationMessage
  },
  6: {
    name: 'info_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.InfoMessage
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.InitializeMessage, {
  0: {
    name: 'InitializeMessage',
    fullName: 'ipc.invalidation.InitializeMessage'
  },
  1: {
    name: 'client_type',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  },
  2: {
    name: 'nonce',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  },
  3: {
    name: 'application_client_id',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ApplicationClientIdP
  },
  4: {
    name: 'digest_serialization_type',
    fieldType: goog.proto2.Message.FieldType.ENUM,
    defaultValue: invalidation.proto.InitializeMessage.DigestSerializationType.BYTE_BASED,
    type: invalidation.proto.InitializeMessage.DigestSerializationType
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.RegistrationMessage, {
  0: {
    name: 'RegistrationMessage',
    fullName: 'ipc.invalidation.RegistrationMessage'
  },
  1: {
    name: 'registration',
    repeated: true,
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationP
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.RegistrationSyncMessage, {
  0: {
    name: 'RegistrationSyncMessage',
    fullName: 'ipc.invalidation.RegistrationSyncMessage'
  },
  1: {
    name: 'subtree',
    repeated: true,
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationSubtree
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.RegistrationSubtree, {
  0: {
    name: 'RegistrationSubtree',
    fullName: 'ipc.invalidation.RegistrationSubtree'
  },
  1: {
    name: 'registered_object',
    repeated: true,
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ObjectIdP
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.InfoMessage, {
  0: {
    name: 'InfoMessage',
    fullName: 'ipc.invalidation.InfoMessage'
  },
  1: {
    name: 'client_version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ClientVersion
  },
  2: {
    name: 'config_parameter',
    repeated: true,
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.PropertyRecord
  },
  3: {
    name: 'performance_counter',
    repeated: true,
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.PropertyRecord
  },
  4: {
    name: 'server_registration_summary_requested',
    fieldType: goog.proto2.Message.FieldType.BOOL,
    type: Boolean
  },
  5: {
    name: 'client_config',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ClientConfigP
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.PropertyRecord, {
  0: {
    name: 'PropertyRecord',
    fullName: 'ipc.invalidation.PropertyRecord'
  },
  1: {
    name: 'name',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  },
  2: {
    name: 'value',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ServerHeader, {
  0: {
    name: 'ServerHeader',
    fullName: 'ipc.invalidation.ServerHeader'
  },
  1: {
    name: 'protocol_version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ProtocolVersion
  },
  2: {
    name: 'client_token',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  },
  3: {
    name: 'registration_summary',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationSummary
  },
  4: {
    name: 'server_time_ms',
    fieldType: goog.proto2.Message.FieldType.INT64,
    type: Number
  },
  5: {
    name: 'message_id',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ServerToClientMessage, {
  0: {
    name: 'ServerToClientMessage',
    fullName: 'ipc.invalidation.ServerToClientMessage'
  },
  1: {
    name: 'header',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ServerHeader
  },
  2: {
    name: 'token_control_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.TokenControlMessage
  },
  3: {
    name: 'invalidation_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.InvalidationMessage
  },
  4: {
    name: 'registration_status_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationStatusMessage
  },
  5: {
    name: 'registration_sync_request_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationSyncRequestMessage
  },
  6: {
    name: 'config_change_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ConfigChangeMessage
  },
  7: {
    name: 'info_request_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.InfoRequestMessage
  },
  8: {
    name: 'error_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ErrorMessage
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.TokenControlMessage, {
  0: {
    name: 'TokenControlMessage',
    fullName: 'ipc.invalidation.TokenControlMessage'
  },
  1: {
    name: 'new_token',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.RegistrationStatus, {
  0: {
    name: 'RegistrationStatus',
    fullName: 'ipc.invalidation.RegistrationStatus'
  },
  1: {
    name: 'registration',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationP
  },
  2: {
    name: 'status',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.StatusP
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.RegistrationStatusMessage, {
  0: {
    name: 'RegistrationStatusMessage',
    fullName: 'ipc.invalidation.RegistrationStatusMessage'
  },
  1: {
    name: 'registration_status',
    repeated: true,
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationStatus
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.RegistrationSyncRequestMessage, {
  0: {
    name: 'RegistrationSyncRequestMessage',
    fullName: 'ipc.invalidation.RegistrationSyncRequestMessage'
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.InvalidationMessage, {
  0: {
    name: 'InvalidationMessage',
    fullName: 'ipc.invalidation.InvalidationMessage'
  },
  1: {
    name: 'invalidation',
    repeated: true,
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.InvalidationP
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.InfoRequestMessage, {
  0: {
    name: 'InfoRequestMessage',
    fullName: 'ipc.invalidation.InfoRequestMessage'
  },
  1: {
    name: 'info_type',
    repeated: true,
    fieldType: goog.proto2.Message.FieldType.ENUM,
    defaultValue: invalidation.proto.InfoRequestMessage.InfoType.GET_PERFORMANCE_COUNTERS,
    type: invalidation.proto.InfoRequestMessage.InfoType
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.RateLimitP, {
  0: {
    name: 'RateLimitP',
    fullName: 'ipc.invalidation.RateLimitP'
  },
  1: {
    name: 'window_ms',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  },
  2: {
    name: 'count',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ProtocolHandlerConfigP, {
  0: {
    name: 'ProtocolHandlerConfigP',
    fullName: 'ipc.invalidation.ProtocolHandlerConfigP'
  },
  1: {
    name: 'batching_delay_ms',
    fieldType: goog.proto2.Message.FieldType.INT32,
    defaultValue: 500,
    type: Number
  },
  2: {
    name: 'rate_limit',
    repeated: true,
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RateLimitP
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ClientConfigP, {
  0: {
    name: 'ClientConfigP',
    fullName: 'ipc.invalidation.ClientConfigP'
  },
  1: {
    name: 'version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.Version
  },
  2: {
    name: 'network_timeout_delay_ms',
    fieldType: goog.proto2.Message.FieldType.INT32,
    defaultValue: 60000,
    type: Number
  },
  3: {
    name: 'write_retry_delay_ms',
    fieldType: goog.proto2.Message.FieldType.INT32,
    defaultValue: 10000,
    type: Number
  },
  4: {
    name: 'heartbeat_interval_ms',
    fieldType: goog.proto2.Message.FieldType.INT32,
    defaultValue: 1200000,
    type: Number
  },
  5: {
    name: 'perf_counter_delay_ms',
    fieldType: goog.proto2.Message.FieldType.INT32,
    defaultValue: 21600000,
    type: Number
  },
  6: {
    name: 'max_exponential_backoff_factor',
    fieldType: goog.proto2.Message.FieldType.INT32,
    defaultValue: 500,
    type: Number
  },
  7: {
    name: 'smear_percent',
    fieldType: goog.proto2.Message.FieldType.INT32,
    defaultValue: 20,
    type: Number
  },
  8: {
    name: 'is_transient',
    fieldType: goog.proto2.Message.FieldType.BOOL,
    defaultValue: false,
    type: Boolean
  },
  9: {
    name: 'initial_persistent_heartbeat_delay_ms',
    fieldType: goog.proto2.Message.FieldType.INT32,
    defaultValue: 2000,
    type: Number
  },
  10: {
    name: 'protocol_handler_config',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ProtocolHandlerConfigP
  },
  11: {
    name: 'channel_supports_offline_delivery',
    fieldType: goog.proto2.Message.FieldType.BOOL,
    defaultValue: false,
    type: Boolean
  },
  12: {
    name: 'offline_heartbeat_threshold_ms',
    fieldType: goog.proto2.Message.FieldType.INT32,
    defaultValue: 60000,
    type: Number
  },
  13: {
    name: 'allow_suppression',
    fieldType: goog.proto2.Message.FieldType.BOOL,
    defaultValue: true,
    type: Boolean
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ConfigChangeMessage, {
  0: {
    name: 'ConfigChangeMessage',
    fullName: 'ipc.invalidation.ConfigChangeMessage'
  },
  1: {
    name: 'next_message_delay_ms',
    fieldType: goog.proto2.Message.FieldType.INT64,
    type: Number
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ErrorMessage, {
  0: {
    name: 'ErrorMessage',
    fullName: 'ipc.invalidation.ErrorMessage'
  },
  1: {
    name: 'code',
    fieldType: goog.proto2.Message.FieldType.ENUM,
    defaultValue: invalidation.proto.ErrorMessage.Code.AUTH_FAILURE,
    type: invalidation.proto.ErrorMessage.Code
  },
  2: {
    name: 'description',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});

//ipc/invalidation/proto/v2/client.pb.js
// Protocol Buffer 2 Copyright 2008 Google Inc.
// All other code copyright its respective owners.

/**
 * @fileoverview Generated Protocol Buffer code for file
 * ipc/invalidation/proto/v2/client.proto.
 */

goog.provide('invalidation.proto.AckHandleP');
goog.provide('invalidation.proto.PersistentTiclState');
goog.provide('invalidation.proto.PersistentStateBlob');
goog.provide('invalidation.proto.RunStateP');
goog.provide('invalidation.proto.RunStateP.State');
goog.provide('invalidation.proto.ExponentialBackoffState');

goog.require('goog.proto2.Message');
goog.require('invalidation.proto.InvalidationP');



/**
 * Message AckHandleP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.AckHandleP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.AckHandleP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.AckHandleP} The cloned message.
 * @override
 */
invalidation.proto.AckHandleP.prototype.clone;


/**
 * Gets the value of the invalidation field.
 * @return {invalidation.proto.InvalidationP} The value.
 */
invalidation.proto.AckHandleP.prototype.getInvalidation = function() {
  return /** @type {invalidation.proto.InvalidationP} */ (this.get$Value(1));
};


/**
 * Gets the value of the invalidation field or the default value if not set.
 * @return {!invalidation.proto.InvalidationP} The value.
 */
invalidation.proto.AckHandleP.prototype.getInvalidationOrDefault = function() {
  return /** @type {!invalidation.proto.InvalidationP} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the invalidation field.
 * @param {!invalidation.proto.InvalidationP} value The value.
 */
invalidation.proto.AckHandleP.prototype.setInvalidation = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the invalidation field has a value.
 */
invalidation.proto.AckHandleP.prototype.hasInvalidation = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the invalidation field.
 */
invalidation.proto.AckHandleP.prototype.invalidationCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the invalidation field.
 */
invalidation.proto.AckHandleP.prototype.clearInvalidation = function() {
  this.clear$Field(1);
};



/**
 * Message PersistentTiclState.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.PersistentTiclState = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.PersistentTiclState, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.PersistentTiclState} The cloned message.
 * @override
 */
invalidation.proto.PersistentTiclState.prototype.clone;


/**
 * Gets the value of the client_token field.
 * @return {?string} The value.
 */
invalidation.proto.PersistentTiclState.prototype.getClientToken = function() {
  return /** @type {?string} */ (this.get$Value(1));
};


/**
 * Gets the value of the client_token field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.PersistentTiclState.prototype.getClientTokenOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the client_token field.
 * @param {string} value The value.
 */
invalidation.proto.PersistentTiclState.prototype.setClientToken = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the client_token field has a value.
 */
invalidation.proto.PersistentTiclState.prototype.hasClientToken = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the client_token field.
 */
invalidation.proto.PersistentTiclState.prototype.clientTokenCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the client_token field.
 */
invalidation.proto.PersistentTiclState.prototype.clearClientToken = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the last_message_send_time_ms field.
 * @return {?string} The value.
 */
invalidation.proto.PersistentTiclState.prototype.getLastMessageSendTimeMs = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the last_message_send_time_ms field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.PersistentTiclState.prototype.getLastMessageSendTimeMsOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the last_message_send_time_ms field.
 * @param {string} value The value.
 */
invalidation.proto.PersistentTiclState.prototype.setLastMessageSendTimeMs = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the last_message_send_time_ms field has a value.
 */
invalidation.proto.PersistentTiclState.prototype.hasLastMessageSendTimeMs = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the last_message_send_time_ms field.
 */
invalidation.proto.PersistentTiclState.prototype.lastMessageSendTimeMsCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the last_message_send_time_ms field.
 */
invalidation.proto.PersistentTiclState.prototype.clearLastMessageSendTimeMs = function() {
  this.clear$Field(2);
};



/**
 * Message PersistentStateBlob.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.PersistentStateBlob = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.PersistentStateBlob, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.PersistentStateBlob} The cloned message.
 * @override
 */
invalidation.proto.PersistentStateBlob.prototype.clone;


/**
 * Gets the value of the ticl_state field.
 * @return {invalidation.proto.PersistentTiclState} The value.
 */
invalidation.proto.PersistentStateBlob.prototype.getTiclState = function() {
  return /** @type {invalidation.proto.PersistentTiclState} */ (this.get$Value(1));
};


/**
 * Gets the value of the ticl_state field or the default value if not set.
 * @return {!invalidation.proto.PersistentTiclState} The value.
 */
invalidation.proto.PersistentStateBlob.prototype.getTiclStateOrDefault = function() {
  return /** @type {!invalidation.proto.PersistentTiclState} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the ticl_state field.
 * @param {!invalidation.proto.PersistentTiclState} value The value.
 */
invalidation.proto.PersistentStateBlob.prototype.setTiclState = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the ticl_state field has a value.
 */
invalidation.proto.PersistentStateBlob.prototype.hasTiclState = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the ticl_state field.
 */
invalidation.proto.PersistentStateBlob.prototype.ticlStateCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the ticl_state field.
 */
invalidation.proto.PersistentStateBlob.prototype.clearTiclState = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the authentication_code field.
 * @return {?string} The value.
 */
invalidation.proto.PersistentStateBlob.prototype.getAuthenticationCode = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the authentication_code field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.PersistentStateBlob.prototype.getAuthenticationCodeOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the authentication_code field.
 * @param {string} value The value.
 */
invalidation.proto.PersistentStateBlob.prototype.setAuthenticationCode = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the authentication_code field has a value.
 */
invalidation.proto.PersistentStateBlob.prototype.hasAuthenticationCode = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the authentication_code field.
 */
invalidation.proto.PersistentStateBlob.prototype.authenticationCodeCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the authentication_code field.
 */
invalidation.proto.PersistentStateBlob.prototype.clearAuthenticationCode = function() {
  this.clear$Field(2);
};



/**
 * Message RunStateP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.RunStateP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.RunStateP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.RunStateP} The cloned message.
 * @override
 */
invalidation.proto.RunStateP.prototype.clone;


/**
 * Gets the value of the state field.
 * @return {?invalidation.proto.RunStateP.State} The value.
 */
invalidation.proto.RunStateP.prototype.getState = function() {
  return /** @type {?invalidation.proto.RunStateP.State} */ (this.get$Value(1));
};


/**
 * Gets the value of the state field or the default value if not set.
 * @return {invalidation.proto.RunStateP.State} The value.
 */
invalidation.proto.RunStateP.prototype.getStateOrDefault = function() {
  return /** @type {invalidation.proto.RunStateP.State} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the state field.
 * @param {invalidation.proto.RunStateP.State} value The value.
 */
invalidation.proto.RunStateP.prototype.setState = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the state field has a value.
 */
invalidation.proto.RunStateP.prototype.hasState = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the state field.
 */
invalidation.proto.RunStateP.prototype.stateCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the state field.
 */
invalidation.proto.RunStateP.prototype.clearState = function() {
  this.clear$Field(1);
};


/**
 * Enumeration State.
 * @enum {number}
 */
invalidation.proto.RunStateP.State = {
  NOT_STARTED: 1,
  STARTED: 2,
  STOPPED: 3
};



/**
 * Message ExponentialBackoffState.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ExponentialBackoffState = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ExponentialBackoffState, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ExponentialBackoffState} The cloned message.
 * @override
 */
invalidation.proto.ExponentialBackoffState.prototype.clone;


/**
 * Gets the value of the current_max_delay field.
 * @return {?number} The value.
 */
invalidation.proto.ExponentialBackoffState.prototype.getCurrentMaxDelay = function() {
  return /** @type {?number} */ (this.get$Value(1));
};


/**
 * Gets the value of the current_max_delay field or the default value if not set.
 * @return {number} The value.
 */
invalidation.proto.ExponentialBackoffState.prototype.getCurrentMaxDelayOrDefault = function() {
  return /** @type {number} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the current_max_delay field.
 * @param {number} value The value.
 */
invalidation.proto.ExponentialBackoffState.prototype.setCurrentMaxDelay = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the current_max_delay field has a value.
 */
invalidation.proto.ExponentialBackoffState.prototype.hasCurrentMaxDelay = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the current_max_delay field.
 */
invalidation.proto.ExponentialBackoffState.prototype.currentMaxDelayCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the current_max_delay field.
 */
invalidation.proto.ExponentialBackoffState.prototype.clearCurrentMaxDelay = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the in_retry_mode field.
 * @return {?boolean} The value.
 */
invalidation.proto.ExponentialBackoffState.prototype.getInRetryMode = function() {
  return /** @type {?boolean} */ (this.get$Value(2));
};


/**
 * Gets the value of the in_retry_mode field or the default value if not set.
 * @return {boolean} The value.
 */
invalidation.proto.ExponentialBackoffState.prototype.getInRetryModeOrDefault = function() {
  return /** @type {boolean} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the in_retry_mode field.
 * @param {boolean} value The value.
 */
invalidation.proto.ExponentialBackoffState.prototype.setInRetryMode = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the in_retry_mode field has a value.
 */
invalidation.proto.ExponentialBackoffState.prototype.hasInRetryMode = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the in_retry_mode field.
 */
invalidation.proto.ExponentialBackoffState.prototype.inRetryModeCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the in_retry_mode field.
 */
invalidation.proto.ExponentialBackoffState.prototype.clearInRetryMode = function() {
  this.clear$Field(2);
};


goog.proto2.Message.set$Metadata(invalidation.proto.AckHandleP, {
  0: {
    name: 'AckHandleP',
    fullName: 'ipc.invalidation.AckHandleP'
  },
  1: {
    name: 'invalidation',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.InvalidationP
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.PersistentTiclState, {
  0: {
    name: 'PersistentTiclState',
    fullName: 'ipc.invalidation.PersistentTiclState'
  },
  1: {
    name: 'client_token',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  },
  2: {
    name: 'last_message_send_time_ms',
    fieldType: goog.proto2.Message.FieldType.INT64,
    defaultValue: '0',
    type: String
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.PersistentStateBlob, {
  0: {
    name: 'PersistentStateBlob',
    fullName: 'ipc.invalidation.PersistentStateBlob'
  },
  1: {
    name: 'ticl_state',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.PersistentTiclState
  },
  2: {
    name: 'authentication_code',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.RunStateP, {
  0: {
    name: 'RunStateP',
    fullName: 'ipc.invalidation.RunStateP'
  },
  1: {
    name: 'state',
    fieldType: goog.proto2.Message.FieldType.ENUM,
    defaultValue: invalidation.proto.RunStateP.State.NOT_STARTED,
    type: invalidation.proto.RunStateP.State
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ExponentialBackoffState, {
  0: {
    name: 'ExponentialBackoffState',
    fullName: 'ipc.invalidation.ExponentialBackoffState'
  },
  1: {
    name: 'current_max_delay',
    fieldType: goog.proto2.Message.FieldType.INT32,
    type: Number
  },
  2: {
    name: 'in_retry_mode',
    fieldType: goog.proto2.Message.FieldType.BOOL,
    type: Boolean
  }
});

//ipc/invalidation/proto/v2/client_gateway.pb.js
// Protocol Buffer 2 Copyright 2008 Google Inc.
// All other code copyright its respective owners.

/**
 * @fileoverview Generated Protocol Buffer code for file
 * ipc/invalidation/proto/v2/client_gateway.proto.
 */

goog.provide('invalidation.proto.ClientGatewayMessage');
goog.provide('invalidation.proto.ClientGatewayMessage.MessageType');

goog.require('goog.proto2.Message');
goog.require('invalidation.proto.ChannelMessageEncoding.MessageEncoding');
goog.require('invalidation.proto.NetworkEndpointId');
goog.require('invalidation.proto.ProtocolVersion');



/**
 * Message ClientGatewayMessage.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ClientGatewayMessage = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ClientGatewayMessage, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ClientGatewayMessage} The cloned message.
 * @override
 */
invalidation.proto.ClientGatewayMessage.prototype.clone;


/**
 * Gets the value of the is_client_to_server field.
 * @return {?boolean} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getIsClientToServer = function() {
  return /** @type {?boolean} */ (this.get$Value(1));
};


/**
 * Gets the value of the is_client_to_server field or the default value if not set.
 * @return {boolean} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getIsClientToServerOrDefault = function() {
  return /** @type {boolean} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the is_client_to_server field.
 * @param {boolean} value The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.setIsClientToServer = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the is_client_to_server field has a value.
 */
invalidation.proto.ClientGatewayMessage.prototype.hasIsClientToServer = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the is_client_to_server field.
 */
invalidation.proto.ClientGatewayMessage.prototype.isClientToServerCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the is_client_to_server field.
 */
invalidation.proto.ClientGatewayMessage.prototype.clearIsClientToServer = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the service_context field.
 * @return {?string} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getServiceContext = function() {
  return /** @type {?string} */ (this.get$Value(2));
};


/**
 * Gets the value of the service_context field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getServiceContextOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the service_context field.
 * @param {string} value The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.setServiceContext = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the service_context field has a value.
 */
invalidation.proto.ClientGatewayMessage.prototype.hasServiceContext = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the service_context field.
 */
invalidation.proto.ClientGatewayMessage.prototype.serviceContextCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the service_context field.
 */
invalidation.proto.ClientGatewayMessage.prototype.clearServiceContext = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the rpc_scheduling_hash field.
 * @return {?string} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getRpcSchedulingHash = function() {
  return /** @type {?string} */ (this.get$Value(3));
};


/**
 * Gets the value of the rpc_scheduling_hash field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getRpcSchedulingHashOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the rpc_scheduling_hash field.
 * @param {string} value The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.setRpcSchedulingHash = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the rpc_scheduling_hash field has a value.
 */
invalidation.proto.ClientGatewayMessage.prototype.hasRpcSchedulingHash = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the rpc_scheduling_hash field.
 */
invalidation.proto.ClientGatewayMessage.prototype.rpcSchedulingHashCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the rpc_scheduling_hash field.
 */
invalidation.proto.ClientGatewayMessage.prototype.clearRpcSchedulingHash = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the protocol_version field.
 * @return {invalidation.proto.ProtocolVersion} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getProtocolVersion = function() {
  return /** @type {invalidation.proto.ProtocolVersion} */ (this.get$Value(5));
};


/**
 * Gets the value of the protocol_version field or the default value if not set.
 * @return {!invalidation.proto.ProtocolVersion} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getProtocolVersionOrDefault = function() {
  return /** @type {!invalidation.proto.ProtocolVersion} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the protocol_version field.
 * @param {!invalidation.proto.ProtocolVersion} value The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.setProtocolVersion = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the protocol_version field has a value.
 */
invalidation.proto.ClientGatewayMessage.prototype.hasProtocolVersion = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the protocol_version field.
 */
invalidation.proto.ClientGatewayMessage.prototype.protocolVersionCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the protocol_version field.
 */
invalidation.proto.ClientGatewayMessage.prototype.clearProtocolVersion = function() {
  this.clear$Field(5);
};


/**
 * Gets the value of the message_type field.
 * @return {?invalidation.proto.ClientGatewayMessage.MessageType} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getMessageType = function() {
  return /** @type {?invalidation.proto.ClientGatewayMessage.MessageType} */ (this.get$Value(6));
};


/**
 * Gets the value of the message_type field or the default value if not set.
 * @return {invalidation.proto.ClientGatewayMessage.MessageType} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getMessageTypeOrDefault = function() {
  return /** @type {invalidation.proto.ClientGatewayMessage.MessageType} */ (this.get$ValueOrDefault(6));
};


/**
 * Sets the value of the message_type field.
 * @param {invalidation.proto.ClientGatewayMessage.MessageType} value The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.setMessageType = function(value) {
  this.set$Value(6, value);
};


/**
 * @return {boolean} Whether the message_type field has a value.
 */
invalidation.proto.ClientGatewayMessage.prototype.hasMessageType = function() {
  return this.has$Value(6);
};


/**
 * @return {number} The number of values in the message_type field.
 */
invalidation.proto.ClientGatewayMessage.prototype.messageTypeCount = function() {
  return this.count$Values(6);
};


/**
 * Clears the values in the message_type field.
 */
invalidation.proto.ClientGatewayMessage.prototype.clearMessageType = function() {
  this.clear$Field(6);
};


/**
 * Gets the value of the encoding field.
 * @return {?invalidation.proto.ChannelMessageEncoding.MessageEncoding} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getEncoding = function() {
  return /** @type {?invalidation.proto.ChannelMessageEncoding.MessageEncoding} */ (this.get$Value(7));
};


/**
 * Gets the value of the encoding field or the default value if not set.
 * @return {invalidation.proto.ChannelMessageEncoding.MessageEncoding} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getEncodingOrDefault = function() {
  return /** @type {invalidation.proto.ChannelMessageEncoding.MessageEncoding} */ (this.get$ValueOrDefault(7));
};


/**
 * Sets the value of the encoding field.
 * @param {invalidation.proto.ChannelMessageEncoding.MessageEncoding} value The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.setEncoding = function(value) {
  this.set$Value(7, value);
};


/**
 * @return {boolean} Whether the encoding field has a value.
 */
invalidation.proto.ClientGatewayMessage.prototype.hasEncoding = function() {
  return this.has$Value(7);
};


/**
 * @return {number} The number of values in the encoding field.
 */
invalidation.proto.ClientGatewayMessage.prototype.encodingCount = function() {
  return this.count$Values(7);
};


/**
 * Clears the values in the encoding field.
 */
invalidation.proto.ClientGatewayMessage.prototype.clearEncoding = function() {
  this.clear$Field(7);
};


/**
 * Gets the value of the client_endpoint_id field.
 * @return {invalidation.proto.NetworkEndpointId} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getClientEndpointId = function() {
  return /** @type {invalidation.proto.NetworkEndpointId} */ (this.get$Value(8));
};


/**
 * Gets the value of the client_endpoint_id field or the default value if not set.
 * @return {!invalidation.proto.NetworkEndpointId} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getClientEndpointIdOrDefault = function() {
  return /** @type {!invalidation.proto.NetworkEndpointId} */ (this.get$ValueOrDefault(8));
};


/**
 * Sets the value of the client_endpoint_id field.
 * @param {!invalidation.proto.NetworkEndpointId} value The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.setClientEndpointId = function(value) {
  this.set$Value(8, value);
};


/**
 * @return {boolean} Whether the client_endpoint_id field has a value.
 */
invalidation.proto.ClientGatewayMessage.prototype.hasClientEndpointId = function() {
  return this.has$Value(8);
};


/**
 * @return {number} The number of values in the client_endpoint_id field.
 */
invalidation.proto.ClientGatewayMessage.prototype.clientEndpointIdCount = function() {
  return this.count$Values(8);
};


/**
 * Clears the values in the client_endpoint_id field.
 */
invalidation.proto.ClientGatewayMessage.prototype.clearClientEndpointId = function() {
  this.clear$Field(8);
};


/**
 * Gets the value of the service_endpoint_id field.
 * @return {?string} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getServiceEndpointId = function() {
  return /** @type {?string} */ (this.get$Value(9));
};


/**
 * Gets the value of the service_endpoint_id field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getServiceEndpointIdOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(9));
};


/**
 * Sets the value of the service_endpoint_id field.
 * @param {string} value The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.setServiceEndpointId = function(value) {
  this.set$Value(9, value);
};


/**
 * @return {boolean} Whether the service_endpoint_id field has a value.
 */
invalidation.proto.ClientGatewayMessage.prototype.hasServiceEndpointId = function() {
  return this.has$Value(9);
};


/**
 * @return {number} The number of values in the service_endpoint_id field.
 */
invalidation.proto.ClientGatewayMessage.prototype.serviceEndpointIdCount = function() {
  return this.count$Values(9);
};


/**
 * Clears the values in the service_endpoint_id field.
 */
invalidation.proto.ClientGatewayMessage.prototype.clearServiceEndpointId = function() {
  this.clear$Field(9);
};


/**
 * Gets the value of the network_message field.
 * @return {?string} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getNetworkMessage = function() {
  return /** @type {?string} */ (this.get$Value(4));
};


/**
 * Gets the value of the network_message field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getNetworkMessageOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the network_message field.
 * @param {string} value The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.setNetworkMessage = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the network_message field has a value.
 */
invalidation.proto.ClientGatewayMessage.prototype.hasNetworkMessage = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the network_message field.
 */
invalidation.proto.ClientGatewayMessage.prototype.networkMessageCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the network_message field.
 */
invalidation.proto.ClientGatewayMessage.prototype.clearNetworkMessage = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the debug_info field.
 * @return {?string} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getDebugInfo = function() {
  return /** @type {?string} */ (this.get$Value(10));
};


/**
 * Gets the value of the debug_info field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.getDebugInfoOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(10));
};


/**
 * Sets the value of the debug_info field.
 * @param {string} value The value.
 */
invalidation.proto.ClientGatewayMessage.prototype.setDebugInfo = function(value) {
  this.set$Value(10, value);
};


/**
 * @return {boolean} Whether the debug_info field has a value.
 */
invalidation.proto.ClientGatewayMessage.prototype.hasDebugInfo = function() {
  return this.has$Value(10);
};


/**
 * @return {number} The number of values in the debug_info field.
 */
invalidation.proto.ClientGatewayMessage.prototype.debugInfoCount = function() {
  return this.count$Values(10);
};


/**
 * Clears the values in the debug_info field.
 */
invalidation.proto.ClientGatewayMessage.prototype.clearDebugInfo = function() {
  this.clear$Field(10);
};


/**
 * Enumeration MessageType.
 * @enum {number}
 */
invalidation.proto.ClientGatewayMessage.MessageType = {
  CLIENT_TO_SERVER: 1,
  SERVER_TO_CLIENT: 2,
  DISCONNECT: 3,
  TIPS_CLIENT_TO_SERVER: 4,
  SERVER_TO_TIPS_CLIENT: 5
};


goog.proto2.Message.set$Metadata(invalidation.proto.ClientGatewayMessage, {
  0: {
    name: 'ClientGatewayMessage',
    fullName: 'ipc.invalidation.ClientGatewayMessage'
  },
  1: {
    name: 'is_client_to_server',
    fieldType: goog.proto2.Message.FieldType.BOOL,
    type: Boolean
  },
  2: {
    name: 'service_context',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  },
  3: {
    name: 'rpc_scheduling_hash',
    fieldType: goog.proto2.Message.FieldType.INT64,
    type: String
  },
  5: {
    name: 'protocol_version',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ProtocolVersion
  },
  6: {
    name: 'message_type',
    fieldType: goog.proto2.Message.FieldType.ENUM,
    defaultValue: invalidation.proto.ClientGatewayMessage.MessageType.CLIENT_TO_SERVER,
    type: invalidation.proto.ClientGatewayMessage.MessageType
  },
  7: {
    name: 'encoding',
    fieldType: goog.proto2.Message.FieldType.ENUM,
    defaultValue: invalidation.proto.ChannelMessageEncoding.MessageEncoding.PROTOBUF_BINARY_FORMAT,
    type: invalidation.proto.ChannelMessageEncoding.MessageEncoding
  },
  8: {
    name: 'client_endpoint_id',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.NetworkEndpointId
  },
  9: {
    name: 'service_endpoint_id',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  },
  4: {
    name: 'network_message',
    fieldType: goog.proto2.Message.FieldType.BYTES,
    type: String
  },
  10: {
    name: 'debug_info',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});

//ipc/invalidation/public/proto/types.pb.js
// Protocol Buffer 2 Copyright 2008 Google Inc.
// All other code copyright its respective owners.

/**
 * @fileoverview Generated Protocol Buffer code for file
 * ipc/invalidation/public/proto/types.proto.
 */

goog.provide('invalidation.proto.ClientType');
goog.provide('invalidation.proto.ClientType.Type');
goog.provide('invalidation.proto.ObjectSource');
goog.provide('invalidation.proto.ObjectSource.Type');
goog.provide('invalidation.proto.Constants');
goog.provide('invalidation.proto.Constants.ObjectVersion');

goog.require('goog.proto2.Message');



/**
 * Message ClientType.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ClientType = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ClientType, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ClientType} The cloned message.
 * @override
 */
invalidation.proto.ClientType.prototype.clone;


/**
 * Gets the value of the type field.
 * @return {?invalidation.proto.ClientType.Type} The value.
 */
invalidation.proto.ClientType.prototype.getType = function() {
  return /** @type {?invalidation.proto.ClientType.Type} */ (this.get$Value(1));
};


/**
 * Gets the value of the type field or the default value if not set.
 * @return {invalidation.proto.ClientType.Type} The value.
 */
invalidation.proto.ClientType.prototype.getTypeOrDefault = function() {
  return /** @type {invalidation.proto.ClientType.Type} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the type field.
 * @param {invalidation.proto.ClientType.Type} value The value.
 */
invalidation.proto.ClientType.prototype.setType = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the type field has a value.
 */
invalidation.proto.ClientType.prototype.hasType = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the type field.
 */
invalidation.proto.ClientType.prototype.typeCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the type field.
 */
invalidation.proto.ClientType.prototype.clearType = function() {
  this.clear$Field(1);
};


/**
 * Enumeration Type.
 * @enum {number}
 */
invalidation.proto.ClientType.Type = {
  INTERNAL: 1,
  TEST: 2,
  UNKNOWN: 3,
  DEMO: 4,
  INVALID: 100,
  CALENDAR: 1000,
  CONTACTS: 1001,
  BLACKBERRY_ENTERPRISE: 1002,
  CONTRAIL: 1003,
  CHROME_SYNC: 1004,
  THUNDARR: 1005,
  DART_SEARCH: 1008,
  MTRX: 1009,
  SKYJAM: 1010,
  PLUS: 1011,
  APIARY: 1012,
  PORTAL: 1013,
  MTRX_WEB: 1014,
  MTRX_ANDROID: 1015,
  DRIVE_SYNC: 1016,
  BRIGHTLY: 1017,
  CHROME_SYNC_ANDROID: 1018,
  PORTAL_ANDROID: 1019,
  TIMEPASS: 1020,
  BIZBUILDER: 1021,
  PORTAL_IOS: 1023,
  CLOUD_VIEW: 1024,
  ANDROID_ATHOME: 1026,
  DOPLAR_EVENT_BROKER: 1027,
  HELLO_DOT_COM: 1028,
  ADS_MEDIA_PLANNER: 1029,
  AFFILIATE_NETWORK: 1030,
  MEMENTO: 1032,
  WINDOWSHOP: 1033,
  CHAT: 1034,
  TEE: 1035,
  CONFUCIUS: 1036,
  CLOUD_PRINT: 1037,
  CHROME_SYNC_IOS: 1038,
  NOVA: 1039,
  DEVINFRA: 1040,
  ENDER: 1041,
  HELPOUTS: 1042,
  CLOUD_DEVICES: 1043,
  SALES_REPORT_MANAGER: 1044,
  POTLUCK: 1045,
  CLOUD_CONSOLE: 1046,
  DCA: 1047,
  CHROME_DEVTOOLS: 1051,
  THIRD_PARTY: 2000
};



/**
 * Message ObjectSource.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.ObjectSource = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.ObjectSource, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.ObjectSource} The cloned message.
 * @override
 */
invalidation.proto.ObjectSource.prototype.clone;


/**
 * Gets the value of the type field.
 * @return {?invalidation.proto.ObjectSource.Type} The value.
 */
invalidation.proto.ObjectSource.prototype.getType = function() {
  return /** @type {?invalidation.proto.ObjectSource.Type} */ (this.get$Value(1));
};


/**
 * Gets the value of the type field or the default value if not set.
 * @return {invalidation.proto.ObjectSource.Type} The value.
 */
invalidation.proto.ObjectSource.prototype.getTypeOrDefault = function() {
  return /** @type {invalidation.proto.ObjectSource.Type} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the type field.
 * @param {invalidation.proto.ObjectSource.Type} value The value.
 */
invalidation.proto.ObjectSource.prototype.setType = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the type field has a value.
 */
invalidation.proto.ObjectSource.prototype.hasType = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the type field.
 */
invalidation.proto.ObjectSource.prototype.typeCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the type field.
 */
invalidation.proto.ObjectSource.prototype.clearType = function() {
  this.clear$Field(1);
};


/**
 * Enumeration Type.
 * @enum {number}
 */
invalidation.proto.ObjectSource.Type = {
  INTERNAL: 1,
  TEST: 2,
  UNKNOWN_VERSION_DO_NOT_USE: 3,
  DEMO: 4,
  DEMO_TRICKLES: 5,
  INVALID: 100,
  CALENDAR: 1000,
  CONTACTS: 1001,
  MAIL: 1002,
  CONTRAIL: 1003,
  CHROME_SYNC: 1004,
  BIGSTORE_DEPRECATED: 1005,
  CHROME_SYNC_QA: 1006,
  PHOTOS: 1007,
  DART_SEARCH: 1008,
  MTRX: 1009,
  SKYJAM: 1010,
  PLUS: 1011,
  APIARY: 1012,
  PORTAL: 1013,
  COSMO_CHANGELOG: 1014,
  BRIGHTLY: 1017,
  TIMEPASS: 1020,
  BIZBUILDER: 1021,
  CLOUD_VIEW: 1024,
  CHROME_COMPONENTS: 1025,
  ANDROID_ATHOME: 1026,
  DOPLAR_EVENT_BROKER: 1027,
  HELLO_DOT_COM: 1028,
  ADS_MEDIA_PLANNER: 1029,
  CHROME_PUSH_MESSAGING: 1030,
  AFFILIATE_NETWORK: 1031,
  MEMENTO: 1032,
  WINDOWSHOP: 1033,
  CHAT: 1034,
  TEE: 1035,
  CONFUCIUS: 1036,
  CLOUD_PRINT: 1037,
  NOVA: 1039,
  DEVINFRA: 1040,
  ENDER: 1041,
  HELPOUTS: 1042,
  CLOUD_DEVICES: 1043,
  SALES_REPORT_MANAGER: 1044,
  POTLUCK: 1045,
  CLOUD_CONSOLE: 1046,
  DCA: 1047,
  DCA_DEV: 1048,
  DCA_USERS: 1049,
  DCA_USERS_DEV: 1050,
  CHROME_DEVTOOLS: 1051,
  THIRD_PARTY: 2000
};



/**
 * Message Constants.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.Constants = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.Constants, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.Constants} The cloned message.
 * @override
 */
invalidation.proto.Constants.prototype.clone;


/**
 * Enumeration ObjectVersion.
 * @enum {number}
 */
invalidation.proto.Constants.ObjectVersion = {
  UNKNOWN: 0
};


goog.proto2.Message.set$Metadata(invalidation.proto.ClientType, {
  0: {
    name: 'ClientType',
    fullName: 'ipc.invalidation.ClientType'
  },
  1: {
    name: 'type',
    fieldType: goog.proto2.Message.FieldType.ENUM,
    defaultValue: invalidation.proto.ClientType.Type.INTERNAL,
    type: invalidation.proto.ClientType.Type
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.ObjectSource, {
  0: {
    name: 'ObjectSource',
    fullName: 'ipc.invalidation.ObjectSource'
  },
  1: {
    name: 'type',
    fieldType: goog.proto2.Message.FieldType.ENUM,
    defaultValue: invalidation.proto.ObjectSource.Type.INTERNAL,
    type: invalidation.proto.ObjectSource.Type
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.Constants, {
  0: {
    name: 'Constants',
    fullName: 'ipc.invalidation.Constants'
  }
});

//ipc/invalidation/javascript/internal/client/buildconstants.js
// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.provide('invalidation.BuildConstants');

/** Build constant definitions. */
invalidation.BuildConstants.BUILD_DATESTAMP = 20131112;

//ipc/invalidation/javascript/internal/client/constants.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview Constants used in invalidation client.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.Constants');

goog.require('invalidation.BuildConstants');
goog.require('invalidation.proto.ObjectIdP');
goog.require('invalidation.proto.ObjectSource');
goog.require('invalidation.proto.ProtocolVersion');
goog.require('invalidation.proto.Version');

/**
 * Returns a new protocol version with the default major and minor versions.
 *
 * @return {!invalidation.proto.ProtocolVersion} The returned protocol version.
 */
invalidation.Constants.getProtocolVersion = function() {
  var result = new invalidation.proto.ProtocolVersion();
  var version = new invalidation.proto.Version();
  version.setMajorVersion(invalidation.Constants.PROTOCOL_MAJOR_VERSION);
  version.setMinorVersion(invalidation.Constants.PROTOCOL_MINOR_VERSION);
  result.setVersion(version);
  return result;
};


/**
 * Returns a protocol version string: <major-version>.<minor-version>
 *
 * @return {!string} The returned protocol version.
 */
invalidation.Constants.getProtocolVersionString = function() {
  return invalidation.Constants.PROTOCOL_MAJOR_VERSION + '.' +
      invalidation.Constants.PROTOCOL_MINOR_VERSION;
};


/**
 * Returns a new client version with the default major and minor versions.
 *
 * @return {!invalidation.proto.Version} The returned client version.
 */
invalidation.Constants.getClientVersion = function() {
  var result = new invalidation.proto.Version();
  result.setMajorVersion(invalidation.Constants.CLIENT_MAJOR_VERSION);
  result.setMinorVersion(invalidation.Constants.CLIENT_MINOR_VERSION);
  return result;
};

/**
 * Returns a new config version with the default major and minor versions.
 *
 * @return {!invalidation.proto.Version} The returned config version.
 */
invalidation.Constants.getConfigVersion = function() {
  var result = new invalidation.proto.Version();
  result.setMajorVersion(invalidation.Constants.CONFIG_MAJOR_VERSION);
  result.setMinorVersion(invalidation.Constants.CONFIG_MINOR_VERSION);
  return result;
};

/**
 * Major version of the client library.
 * @type {number}
 */
invalidation.Constants.CLIENT_MAJOR_VERSION = 3;

/**
 * Minor version of the client library, defined to be equal to the
 * datestamp of the build (e.g. 20130401).
 * @type {number}
 */
invalidation.Constants.CLIENT_MINOR_VERSION =
    invalidation.BuildConstants.BUILD_DATESTAMP;

/**
 * Major version of the protocol between the client and the server.
 * @type {number}
 */
invalidation.Constants.PROTOCOL_MAJOR_VERSION = 3;

/**
 * Minor version of the protocol between the client and the server.
 * @type {number}
 */
invalidation.Constants.PROTOCOL_MINOR_VERSION = 2;

/**
 * Major version of the client config.
 * @type {number}
 */
invalidation.Constants.CONFIG_MAJOR_VERSION = 3;

/**
 * Minor version of the client config.
 * @type {number}
 */
invalidation.Constants.CONFIG_MINOR_VERSION = 2;

/**
 * Version of the protocol currently being used by the client/server for
 * V2 clients.
 * @type {!invalidation.proto.ProtocolVersion}
 */
invalidation.Constants.PROTOCOL_VERSION =
    invalidation.Constants.getProtocolVersion();

/**
 * Version of the config currently being used by the client.
 *
 * @type {!invalidation.proto.Version}
 */
invalidation.Constants.CONFIG_VERSION_VALUE =
    invalidation.Constants.getConfigVersion();

/**
 * Version of the client currently being used by the client.
 *
 * @type {!invalidation.proto.Version}
 */
invalidation.Constants.CLIENT_VERSION_VALUE =
    invalidation.Constants.getClientVersion();

/**
 * Object id used to trigger a refresh of all cached objects
 * ("invalidate-all").
 *
 * @type {!invalidation.proto.ObjectIdP}
 */
invalidation.Constants.ALL_OBJECT_ID = function() {
  var allObjectId = new invalidation.proto.ObjectIdP();
  allObjectId.setName('');
  allObjectId.setSource(invalidation.proto.ObjectSource.Type.INTERNAL);
  return allObjectId;
}();

//ipc/invalidation/javascript/internal/client/commonprotos.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview  Utilities for creating protocol buffers.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.CommonProtos');

goog.require('invalidation.Constants');
goog.require('invalidation.proto.AckHandleP');
goog.require('invalidation.proto.ApplicationClientIdP');
goog.require('invalidation.proto.ClientConfigP');
goog.require('invalidation.proto.ClientGatewayMessage');
goog.require('invalidation.proto.ClientGatewayMessage.MessageType');
goog.require('invalidation.proto.ClientVersion');
goog.require('invalidation.proto.InfoMessage');
goog.require('invalidation.proto.InitializeMessage');
goog.require('invalidation.proto.InvalidationMessage');
goog.require('invalidation.proto.InvalidationP');
goog.require('invalidation.proto.NetworkEndpointId');
goog.require('invalidation.proto.ObjectIdP');
goog.require('invalidation.proto.PersistentStateBlob');
goog.require('invalidation.proto.PersistentTiclState');
goog.require('invalidation.proto.PropertyRecord');
goog.require('invalidation.proto.ProtocolVersion');
goog.require('invalidation.proto.RateLimitP');
goog.require('invalidation.proto.RegistrationMessage');
goog.require('invalidation.proto.RegistrationP');
goog.require('invalidation.proto.RegistrationStatus');
goog.require('invalidation.proto.RegistrationSummary');
goog.require('invalidation.proto.RegistrationSyncMessage');
goog.require('invalidation.proto.StatusP');
goog.require('invalidation.proto.Version');
/**
 * Returns true iff {@code status} corresponds to success.
 *
 * @param {invalidation.proto.StatusP} status The status code to be checked.
 * @return {boolean} Whether status corresponds to success or not.
 */
invalidation.CommonProtos.isSuccess = function(status) {
  return status.getCode() == invalidation.proto.StatusP.Code.SUCCESS;
};

/**
 * Returns true iff status corresponds to permanent failure.
 *
 * @param {!invalidation.proto.StatusP} status Status code being checked.
 * @return {boolean} Whether the status corresponds to permanent failure.
 */
invalidation.CommonProtos.isPermanentFailure = function(status) {
  return status.getCode() == invalidation.proto.StatusP.Code.PERMANENT_FAILURE;
};

/**
 * Returns a property record for the given name value information.
 *
 * @param {string} name Key for the property.
 * @param {number} value Value of the given property.
 * @return {!invalidation.proto.PropertyRecord} The returned record.
 */
invalidation.CommonProtos.newPropertyRecord = function(name, value) {
  var propertyRecord = new invalidation.proto.PropertyRecord();
  propertyRecord.setName(name);
  propertyRecord.setValue(value);
  return propertyRecord;
};

/**
 * Returns a new status proto for a given status code.
 *
 * @param {!invalidation.proto.StatusP.Code} statusCode The status code
 *     for which the status proto is being return.
 * @return {!invalidation.proto.StatusP} The returned status.
 */
invalidation.CommonProtos.newStatusP = function(statusCode) {
  var status = new invalidation.proto.StatusP();
  status.setCode(statusCode);
  return status;
};

/**
 * Returns an object id for a given source and name.
 *
 * @param {number} source The object source type.
 * @param {string} name The unique name of the object for the given source.
 * @return {!invalidation.proto.ObjectIdP} The returned object id.
 */
invalidation.CommonProtos.newObjectIdP = function(source, name) {
  var objectId = new invalidation.proto.ObjectIdP();
  objectId.setSource(source);
  objectId.setName(name);
  return objectId;
};

/**
 * Returns an invalidation for a given object and known version.
 *
 * @param {!invalidation.proto.ObjectIdP} objectId The object id for which
 *     the invalidation is being generated.
 * @param {number} version The version of the object.
 * @param {string=} opt_payload Optional payload for the object.
 * @param {boolean} opt_isTrickleRestart Whether the trickle restarts with this
 *     invalidation. Defaults to true if omitted.
 * @return {!invalidation.proto.InvalidationP} The invalidation for the object.
 */
invalidation.CommonProtos.newInvalidationP = function(objectId, version,
      opt_payload, opt_isTrickleRestart) {
  var inv = new invalidation.proto.InvalidationP();
  inv.setObjectId(objectId);
  inv.setIsKnownVersion(true);
  inv.setVersion(version);
  if (opt_payload) {
    inv.setPayload(opt_payload);
  }
  if (opt_isTrickleRestart != null) {
    inv.setIsTrickleRestart(opt_isTrickleRestart);
  } else {
    inv.setIsTrickleRestart(true);
  }
  return inv;
};

/**
 * Returns a new rate limit for the given window time and count
 *
 * @param {number} windowMs The size of the window over which the rate limit
 *     applies.
 * @param {number} count The number of events allowed within a given window.
 * @return {!invalidation.proto.RateLimitP} The createdrate limit.
 */
invalidation.CommonProtos.newRateLimitP = function(windowMs, count) {
  var rateLimit = new invalidation.proto.RateLimitP();
  rateLimit.setWindowMs(windowMs);
  rateLimit.setCount(count);
  return rateLimit;
};

/**
 * Returns an application id for a given client name.
 *
 * @param {number} clientType Client type code.
 * @param {string} clientName The name of a particular client name as
 *     determined by an application.
 * @return {!invalidation.proto.ApplicationClientIdP} The appid for the client.
 */
invalidation.CommonProtos.newApplicationClientIdP = function(clientType,
    clientName) {
  var appClientId = new invalidation.proto.ApplicationClientIdP();
  appClientId.setClientType(clientType);
  appClientId.setClientName(clientName);
  return appClientId;
};

/**
 * Returns a network endpoint id for a given network address type and serialized
 * client address.
 *
 * @param {!invalidation.proto.NetworkEndpointId.NetworkAddress} networkAddress
 *     The network address enum type.
 * @param {!string} clientAddress The serialized client address.
 * @return {!invalidation.proto.NetworkEndpointId} The endpoint id.
 */
invalidation.CommonProtos.newNetworkEndpointId = function(networkAddress,
    clientAddress) {
  var endpointId = new invalidation.proto.NetworkEndpointId();
  endpointId.setNetworkAddress(networkAddress);
  endpointId.setClientAddress(clientAddress);
  return endpointId;
};

/**
 * Returns a client to server gateway message with standard message encoding and
 * default protocol version.
 *
 * @param {!string} clientMessage The network message (typically a serialized
 *     client to server message from ticl.).
 * @param {!invalidation.proto.NetworkEndpointId} clientEndpointId The address
 *     of the client for Tango.
 * @param {string} messageId The client to gateway message ID for debugging.
 * @return {!invalidation.proto.ClientGatewayMessage} The client to gateway
 *     message.
 */
invalidation.CommonProtos.newClientToGatewayMessage = function(clientMessage,
    clientEndpointId, messageId) {
  // Create protocol version according to
  // java/com/google/ipc/invalidation/common/CommonInvalidationConstants2.java.
  var version = new invalidation.proto.Version();
  version.setMinorVersion(2);
  version.setMajorVersion(3);
  var protocolVersion = new invalidation.proto.ProtocolVersion();
  protocolVersion.setVersion(version);

  var message = new invalidation.proto.ClientGatewayMessage();
  message.setProtocolVersion(protocolVersion);
  message.setMessageType(
      invalidation.proto.ClientGatewayMessage.MessageType.CLIENT_TO_SERVER);
  message.setEncoding(
      invalidation.proto.ChannelMessageEncoding.MessageEncoding.
      PROTOBUF_JSON_FORMAT);
  message.setNetworkMessage(clientMessage);
  message.setClientEndpointId(clientEndpointId);
  message.setIsClientToServer(true);
  message.setDebugInfo(messageId);
  return message;
};

/**
 * Returns a new registration operation.
 *
 * @param {!invalidation.proto.ObjectIdP} oid Object id to be (un)registered.
 * @param {boolean} isReg If the operation is a registration op or not.
 * @return {!invalidation.proto.RegistrationP} The reg op for the object.
 */
invalidation.CommonProtos.newRegistrationP = function(oid, isReg) {
  var registration = new invalidation.proto.RegistrationP();
  registration.setObjectId(oid);
  registration.setOpType(isReg ?
      invalidation.proto.RegistrationP.OpType.REGISTER :
      invalidation.proto.RegistrationP.OpType.UNREGISTER);
  return registration;
};

/**
 * Returns a new registration status protobuf for an object.
 *
 * @param {!invalidation.proto.ObjectIdP} oid The object id for which the
 *     registration status is being generated.
 * @param {boolean} isReg Whether it is a registration or unregistration op.
 * @param {!invalidation.proto.StatusP.Code} statusCode The result of the
 *     registration operation.
 * @return {!invalidation.proto.RegistrationStatus} The reg status for the oid.
 */
invalidation.CommonProtos.newRegistrationStatus = function(oid, isReg,
      statusCode) {
  var registrationStatus = new invalidation.proto.RegistrationStatus();
  var registration = invalidation.CommonProtos.newRegistrationP(oid, isReg);
  registrationStatus.setRegistration(registration);
  registrationStatus.setStatus(
     invalidation.CommonProtos.newStatusP(statusCode));
  return registrationStatus;
};

/**
 * Returns the registration summary for a client.
 *
 * @param {number} numRegistrations Number of registered objects for a client.
 * @param {string} digest The digest for the registered objects.
 * @return {!invalidation.proto.RegistrationSummary} The client's reg summary.
 */
invalidation.CommonProtos.newRegistrationSummary = function(numRegistrations,
      digest) {
  var summary = new invalidation.proto.RegistrationSummary();
  summary.setNumRegistrations(numRegistrations);
  summary.setRegistrationDigest(digest);
  return summary;
};

/**
 * Returns a client version protobuf for a given client.
 *
 * @param {string} platform Information about the client operating system or
 *     platform.
 * @param {string} language The language in which the library is written, i.e.,
 *     JS (Javascript).
 * @param {string} applicationInfo Name of the application using the library
 *     (for debugging/monitoring).
 * @return {!invalidation.proto.ClientVersion} The client's info.
 */
invalidation.CommonProtos.newClientVersion = function(platform, language,
    applicationInfo) {
  var clientVersion = new invalidation.proto.ClientVersion();
  clientVersion.setVersion(invalidation.Constants.CLIENT_VERSION_VALUE);
  clientVersion.setPlatform(platform);
  clientVersion.setLanguage(language);
  clientVersion.setApplicationInfo(applicationInfo);
  return clientVersion;
};

/**
 * Returns a ack handle for an invalidation (for the Ticl's acknowledge call).
 *
 * @param {!invalidation.proto.InvalidationP} inv The invalidation for which
 *     the ack handle is being generated.
 * @return {!invalidation.proto.AckHandleP} The ack handle for the invalidation.
 */
invalidation.CommonProtos.newAckHandleP = function(inv) {
  var ackHandle = new invalidation.proto.AckHandleP();
  ackHandle.setInvalidation(inv);
  return ackHandle;
};

/**
 * Returns the persistent ticl state corresponding to {@code clientToken}.
 *
 * @param {string} clientToken The client's token provided by the server.
 * @return {!invalidation.proto.PersistentTiclState} The ticl state.
 */
invalidation.CommonProtos.newPersistentTiclState = function(clientToken) {
  var ticlState = new invalidation.proto.PersistentTiclState();
  ticlState.setClientToken(clientToken);
  return ticlState;
};

/**
 * Returns a blob for the ticl state that can be stored persistently.
 *
 * @param {!invalidation.proto.PersistentTiclState} state The Ticl's state that
 *     needs to be persistted.
 *  @param {string} mac The authentication code/digest for the Ticl state.
 * @return {!invalidation.proto.PersistentStateBlob} The blob corresponding to
 *     the ticl state and its blob.
 */
invalidation.CommonProtos.newPersistentStateBlob = function(state, mac) {
  var blob = new invalidation.proto.PersistentStateBlob();
  blob.setTiclState(state);
  blob.setAuthenticationCode(mac);
  return blob;
};

/**
 * Returns an initialization message to send to the server.
 *
 * @param {number} clientType Client type code.
 * @param {!invalidation.proto.ApplicationClientIdP} applicationClientId The
 *     application client id used to identify this particular client by the app.
 * @param {string} nonce A unique string to identify this request.
 * @param {!invalidation.proto.InitializeMessage.DigestSerializationType}
 *     digestSerializationType Type of serialization used for the reg digest.
 * @return {!invalidation.proto.InitializeMessage} The initialization message.
 */
invalidation.CommonProtos.newInitializeMessage = function(clientType,
    applicationClientId, nonce, digestSerializationType) {
  var initializeMessage = new invalidation.proto.InitializeMessage();
  initializeMessage.setClientType(clientType);
  initializeMessage.setApplicationClientId(applicationClientId);
  initializeMessage.setDigestSerializationType(digestSerializationType);
  initializeMessage.setNonce(nonce);
  return initializeMessage;
};

/**
 * Returns a new invalidation message.
 *
 * @param {!Array.<!invalidation.proto.InvalidationP>} invalidations The
 *     invalidations that need to be sent.
 * @return {!invalidation.proto.InvalidationMessage} The invalidation message.
 */
invalidation.CommonProtos.newInvalidationMessage = function(invalidations) {
  var message = new invalidation.proto.InvalidationMessage();
  for (var i = 0; i < invalidations.length; i++) {
    message.addInvalidation(invalidations[i]);
  }
  return message;
};

/**
 * Returns a new info message to be sent to the server.
 *
 * @param {boolean} requestSummary If the server's summary is needed.
 * @param {!invalidation.proto.ClientVersion} clientVersion The client's
 *     information, e.g., platform, etc.
 * @param {invalidation.proto.ClientConfigP} clientConfig The configuration
 *     parameters for the client, if any.
 * @param {!goog.structs.Map.<string, number>} perfCounters The performance
 *     counters for this client, if any.
 * @return {!invalidation.proto.InfoMessage} The client's info message.
 */
invalidation.CommonProtos.newInfoMessage = function(requestSummary,
    clientVersion, clientConfig, perfCounters) {
  var message = new invalidation.proto.InfoMessage();
  message.setServerRegistrationSummaryRequested(requestSummary);
  message.setClientVersion(clientVersion);

  if (clientConfig != null) {
    message.setClientConfig(clientConfig);
  }

  // Get all the key, value pairs for the perf counters - add them
  // to the info message.

  var keys = perfCounters.getKeys();
  for (var i = 0; i < keys.length; i++) {
    var rec = invalidation.CommonProtos.newPropertyRecord(keys[i],
        /** @type {number} */ (perfCounters.get(keys[i])));
    message.addPerformanceCounter(rec);
  }
  return message;
};

/**
 * Returns a new registration message.
 *
 * @param {!Array.<!invalidation.proto.RegistrationP>} registrations The
 *     registration ops for which the message is being generated.
 * @return {!invalidation.proto.RegistrationMessage} The registration message.
 */
invalidation.CommonProtos.newRegistrationMessage = function(registrations) {
  var message = new invalidation.proto.RegistrationMessage();
  for (var i = 0; i < registrations.length; i++) {
    message.addRegistration(registrations[i]);
  }
  return message;
};

/**
 * Returns a new registration sync message.
 *
 * @param {!Array.<!invalidation.proto.RegistrationSubtree>} subtrees The
 *     subtree information for objects registered at the client.
 * @return {!invalidation.proto.RegistrationSyncMessage} The reg sync message.
 */
invalidation.CommonProtos.newRegistrationSyncMessage = function(subtrees) {
  var message = new invalidation.proto.RegistrationSyncMessage();
  for (var i = 0; i < subtrees.length; i++) {
    message.addSubtree(subtrees[i]);
  }
  return message;
};

//ipc/invalidation/javascript/internal/marmoset/sharedconstants.js
// Copyright 2012 Google Inc. All rights reserved.

/**
 * @fileoverview Crosspage channel constants.
 *
 * @author xiaolan@google.com (Joy Zhang)
 */

goog.provide('invalidation.XpcSenderFunctions');

/**
 * Constants identifying functions in the browser channel API when split across
 * an iframe via xpc.
 * @enum {string}
 */
invalidation.XpcSenderFunctions = {
  // Host => iframe.
  SEND: 's',

  // Iframe => host.
  SEND_SUCCEEDED: 'ss',
  SEND_FAILED: 'sf'
};

//ipc/invalidation/javascript/internal/marmoset/xpcsenderclient.js
/**
 * @fileoverview Implementation of a Marmoset to Tango gateway HTTP request
 * sender client via XPC-based protocol wrapper.
 * This class serves as the Marmoset gateway sender proxy to the host page.
 *
 * @author xiaolan@google.com (Joy Zhang)
 */

goog.provide('invalidation.XpcSenderClient');

goog.require('goog.Timer');
goog.require('goog.Uri');
goog.require('goog.net.xpc.CrossPageChannel');
goog.require('invalidation.ExponentialBackoffDelayGenerator');
goog.require('invalidation.GatewaySender');
goog.require('invalidation.XpcIframeCreator');
goog.require('invalidation.XpcSenderFunctions');
goog.require('invalidation.util.Logger');
goog.require('invalidation.util.LoggerImpl');


/**
 * A client that connects to an iframe that hosts a HTTP sender to Tango
 * gateway. The client also passes upcalls to the host page handler.
 * @param {string} servletUri The uri of the servlet that provides an iframe
 *     that can make requests back to the gateway.
 * @param {string} iframeContainerId The id of the element in which to load
 *     the iframe that will host the actual browser channel connection.
 * @param {?string} oauthToken An OAuth token to be sent with requests (both for
 *     data and for the initial iframe content).
 * @param {number} authuser Value to use for the authuser query paramter (for
 *     multi-signin).
 * @param {!invalidation.GatewaySender.Handler} handler The handler
 *     for the status of xpc and send request.
 * @constructor
 * @extends {invalidation.GatewaySender}
 */
invalidation.XpcSenderClient = function(
    servletUri, iframeContainerId, oauthToken, authuser, handler) {
  goog.base(this, servletUri, authuser, handler);

  // Create the xpc uri with configuration parameters.
  var uri = new goog.Uri(this.servletUri);

  // If we're using OAuth (and don't have Gaia cookies), then we need to send an
  // OAuth credential in order to load the iframe content.
  if (oauthToken != null) {
    uri.setParameterValue('oauth_token', oauthToken);
  }

  // Configure and create the cross-page channel.
  var xpcConfig = {};
  xpcConfig[goog.net.xpc.CfgFields.PEER_URI] = uri.toString();

  // Configuration specific to Iframe Polling transport. As far as we know, no
  // current browser uses this. However, the XPC code validates these
  // parameters, and the defaults can fail validation (e.g., "extension://...").
  // So, for now, we set them to values that are incorrect but should always
  // pass validation.
  // TODO(ghc): [cleanup] Come up with a better long-term solution to this.
  xpcConfig[goog.net.xpc.CfgFields.PEER_POLL_URI] = this.servletUri +
      'xpc_blank';
  xpcConfig[goog.net.xpc.CfgFields.LOCAL_POLL_URI] = this.servletUri +
      'xpc_blank';
  xpcConfig[goog.net.xpc.CfgFields.PEER_RELAY_URI] = this.servletUri +
      'xpc_relay';
  xpcConfig[goog.net.xpc.CfgFields.LOCAL_RELAY_URI] = this.servletUri +
      'xpc_relay';

  this.xpcIframeCreator_ = new invalidation.XpcIframeCreator(
      xpcConfig, iframeContainerId, goog.bind(this.onXpcConnect_, this));

  /**
   * The cross-page channel to the host page.
   * @type {goog.net.xpc.CrossPageChannel}
   * @private
   */
  this.crossPageChannel_ = null;

  /**
   * @type {!invalidation.util.Logger}
   * @private
   */
  this.logger_ = new invalidation.util.LoggerImpl('XpcSenderClient');
};
goog.inherits(invalidation.XpcSenderClient, invalidation.GatewaySender);


/**
 * Called by the xpc iframe creator once the cross-page channel is connected.
 * Registers services on the cross-page channel and calls the application's
 * handler to indicate that the connection is ready.
 * @param {!goog.net.xpc.CrossPageChannel} crossPageChannel The connected
 *     cross-page channel.
 * @private
 */
invalidation.XpcSenderClient.prototype.onXpcConnect_ =
    function(crossPageChannel) {
  this.crossPageChannel_ = crossPageChannel;

  this.crossPageChannel_.registerService(
      invalidation.XpcSenderFunctions.SEND_SUCCEEDED,
      goog.bind(this.sendSucceeded, this));
  this.crossPageChannel_.registerService(
      invalidation.XpcSenderFunctions.SEND_FAILED,
      /** @type {function((Object|string))} */
      (goog.bind(this.sendFailed, this)), true);

  this.handler.onReady();
};


/** @override */
invalidation.XpcSenderClient.prototype.start = function() {
  this.logger_.info('Attempting to connect cross-page channel');

  this.xpcIframeCreator_.createCrossPageChannel();
};


/** @override */
invalidation.XpcSenderClient.prototype.send = function(message, opt_headers) {
  var mapToSend = [message, opt_headers || null];
  this.crossPageChannel_.send(invalidation.XpcSenderFunctions.SEND, mapToSend);
};


/**
 * Called when a request succeeds.
 * @param {Object|string} result An object with information about the successful
 *     request. For now, this just contains the request id in key 0.
 */
invalidation.XpcSenderClient.prototype.sendSucceeded = function(result) {
  this.handler.onSuccess(/** @type {number} */ (result[0]));
};


/**
 * Called when a request fails.
 * @param {Object|string} result An object with information about the failed
 *     request. For now, this just contains the request id in field 0 and an
 *     error message in field 1.
 */
invalidation.XpcSenderClient.prototype.sendFailed = function(result) {
  this.handler.onFailure(/** @type {number} */ (result[0]),
      /** @type {string} */ (result[1]));
};

//ipc/invalidation/javascript/utils/namedfunction.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview A callback/function abstraction with a name.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.NamedFunction');

/**
 * Creates a named function with the given name and function.
 *
 * @param {string} name The name of the function.
 * @param {function()} operation The function whose name is {@code name}.
 *
 * @constructor
 */
invalidation.NamedFunction = function(name, operation) {

  /**
   * Name of the function.
   * @type {string}
   * @private
   */
  this.name_ = name;

  /**
   * The actual function object.
   * @type {function()}
   * @private
   */
  this.operation_ = operation;
};

/**
 * Returns the name of the function.
 *
 * @return {string} Function's name.
 */
invalidation.NamedFunction.prototype.getName = function() {
  return this.name_;
};

/**
 * Runs the function bound in this.
 */
invalidation.NamedFunction.prototype.run = function() {
  this.operation_();
};

/**
 * Returns a human-readable representation of the named funtion.
 *
 * @return {string} The human-readable representation.
 * @override
 */
invalidation.NamedFunction.prototype.toString = function() {
  return this.name_;
};

//ipc/invalidation/public/javascript/v2/interface/internalbase.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview A base class that other classes can derive from to get
 * useful functions such as toString, etc.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.InternalBase');

goog.require('goog.string.StringBuffer');

/**
 * @constructor
 */
invalidation.InternalBase = function() {
};

/**
 * Returns a human-readable corresponding to the non-function fields in this.
 *
 * @return {string} Human-readable representation of the state.
 * @override
 */
invalidation.InternalBase.prototype.toString = function() {
  var buffer = new goog.string.StringBuffer();
  var isFirst = true;
  for (var key in this) {
    var value = this[key];
    if (!goog.isFunction(value)) {
      if (!isFirst) {
        buffer.append(', ');
      }
      isFirst = false;
      buffer.append(key + ' = ' + value);
    }
  }
  return buffer.toString();
};

//ipc/invalidation/public/javascript/v2/interface/invalidationtypes.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview Various types used with the Tango invalidation client library.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.Types.AckHandle');
goog.provide('invalidation.Types.ApplicationClientId');
goog.provide('invalidation.Types.ErrorContext');
goog.provide('invalidation.Types.ErrorInfo');
goog.provide('invalidation.Types.ErrorInfo.ErrorReason');
goog.provide('invalidation.Types.Invalidation');
goog.provide('invalidation.Types.NumberContext');
goog.provide('invalidation.Types.ObjectId');
goog.provide('invalidation.Types.Status');
goog.provide('invalidation.Types.Status.Code');

goog.require('goog.asserts');
goog.require('invalidation.InternalBase');

//
// ObjectId
//

/**
 * A class to represent a unique object id that an application can register or
 * unregister for.
 * @constructor
 * @extends {invalidation.InternalBase}
 *
 * @param {number} source The invalidation source type.
 * @param {string} name The name of the object for which to register.
 *     Requires that {@code name} be an ASCII string, i.e., all code
 *     points for characters in {@code name} are between 0 and 127.
 * @export
 */
invalidation.Types.ObjectId = function(source, name) {

  /**
   * The invalidation source type.
   * @type {number}
   * @private
   */
  this.source_ = source;

  /**
   * The name/unique id for the object.
   * @type {string}
   * @private
   */
  this.name_ = name;

  // Check that the objectName is ASCII.
  for (var i = 0; i < name.length; i++) {
    goog.asserts.assert(name.charCodeAt(i) <= 127, 'Bad object name ' + name);
  }
};
goog.inherits(invalidation.Types.ObjectId, invalidation.InternalBase);

/**
 * @return {number} The object source type.
 * @export
 */
invalidation.Types.ObjectId.prototype.getSource = function() {
  return this.source_;
};

/**
 * @return {string} The name/id of the object.
 * @export
 */
invalidation.Types.ObjectId.prototype.getName = function() {
  return this.name_;
};

/**
 * Returns true iff this is equal to {@code other} in terms of having the same
 * source and name.
 *
 * @param {invalidation.Types.ObjectId} other The object being compared with.
 * @return {boolean} Whether this and other are equivalent.
 */
invalidation.Types.ObjectId.prototype.equals = function(other) {
  if (this == other) {
    return true;
  }
  return (this.source_ == other.source_) && (this.name_ == other.name_);
};

//
// Invalidation
//

/**
 * A class to represent an invalidation for a given object/version and an
 * optional payload.
 *
 * @constructor
 * @extends {invalidation.InternalBase}
 *
 * @param {!invalidation.Types.ObjectId} objectId The object being
 * invalidated/updated.
 * @param {number} version The new version of the object.
 * @param {string=} opt_payload Optional payload for the object.
 * @param {boolean=} opt_isTrickleRestart Whether the trickle restarts
*  at this invalidation, defaults to true.
 * @export
 */
invalidation.Types.Invalidation = function(objectId, version, opt_payload,
                                           opt_isTrickleRestart) {

  /**
   * @type {!invalidation.Types.ObjectId}
   * @private
   */
  this.objectId_ = objectId;

  /**
   * @type {number}
   * @private
   */
  this.version_ = version;

  /**
   * @type {?string}
   * @private
   */
  this.payload_ = opt_payload || null;

  /**
   * @type {boolean}
   * @private
   */
  this.isTrickleRestart_ = (opt_isTrickleRestart !== undefined) ?
      opt_isTrickleRestart : true;
};
goog.inherits(invalidation.Types.Invalidation, invalidation.InternalBase);

/**
 * @return {!invalidation.Types.ObjectId} The object being invalidated.
 * @export
 */
invalidation.Types.Invalidation.prototype.getObjectId = function() {
  return this.objectId_;
};

/**
 * @return {number} The new version of the object.
 * @export
 */
invalidation.Types.Invalidation.prototype.getVersion = function() {
  return this.version_;
};

/**
 * @return {boolean} Whether the trickle restarts with this invalidation.
 * @export
 */
invalidation.Types.Invalidation.prototype.getIsTrickleRestartForInternalUse =
    function() {
  return this.isTrickleRestart_;
};

/**
 * @return {?string} Returns a payload if any; else returns null.
 * @export
 */
invalidation.Types.Invalidation.prototype.getPayload = function() {
  return this.payload_;
};

//
// Status and Status.Code
//

/**
 * Information given to about a operation - success, temporary or permanent
 * failure.
 *
 * @constructor
 * @extends {invalidation.InternalBase}
 *
 * @param {!invalidation.Types.Status.Code} code Indicates whether
 *     the operation was successful or had a permanent/transient failure.
 * @param {?string} message A human-readable description of the error or
 *     success message.
 * @export
 */
invalidation.Types.Status = function(code, message) {

  /**
   * Whether the operation was successful or not.
   * @type {!invalidation.Types.Status.Code}
   * @private
   */
  this.code_ = code;

  /**
   * Description of the status.
   * @type {?string}
   * @private
   */
  this.message_ = message;
};
goog.inherits(invalidation.Types.Status, invalidation.InternalBase);

/**
 * @return {!invalidation.Types.Status} A status object corresponding to the
 *     SUCCESS code.
 * @export
 */
invalidation.Types.newSuccessStatus = function() {
  return new invalidation.Types.Status(invalidation.Types.Status.Code.SUCCESS,
      '');
};

/**
 * @param {string} message The error message for the failure.
 * @return {!invalidation.Types.Status} A status object corresponding to the
 *     TRANSIENT_FAILURE code.
 * @export
 */
invalidation.Types.newTransientFailureStatus = function(message) {
  return new invalidation.Types.Status(
      invalidation.Types.Status.Code.TRANSIENT_FAILURE, message);
};

/**
 * @param {string} message The error message for the failure.
 * @return {!invalidation.Types.Status} A status object corresponding to the
 *     PERMANENT_FAILURE code.
 * @export
 */
invalidation.Types.newPermanentFailureStatus = function(message) {
  return new invalidation.Types.Status(
      invalidation.Types.Status.Code.PERMANENT_FAILURE, message);
};

/**
 * @return {!invalidation.Types.Status.Code} The status of the
 *     operation, whether successful, or permanent/temporary failure.
 * @export
 */
invalidation.Types.Status.prototype.getCode = function() {
  return this.code_;
};

/**
 * @return {?string} Human-readable description of the error/success if any.
 * @export
 */
invalidation.Types.Status.prototype.getMessage = function() {
  return this.message_;
};

/**
 * Returns true iff the status corresponds to a successful completion of the
 * operation.
 *
 * @return {boolean} Whether the operation was successful or not.
 */
invalidation.Types.Status.prototype.isSuccess = function() {
  return this.code_ == invalidation.Types.Status.Code.SUCCESS;
};

/**
 * Actual status of the operation: Whether successful, transient or permanent
 * failure.
 * @enum {number}
 * @export
 */
invalidation.Types.Status.Code = {
  /**
   * Operation was successful.
   */
  SUCCESS: 0,

  /**
   * Operation had a transient failure. The application can retry the failed
   * operation later - if it chooses to do so, it must use a sensible backoff
   * policy such as exponential backoff.
   */
  TRANSIENT_FAILURE: 1,

  /**
   * Operation has a permanent failure. Application must not automatically retry
   * without fixing the situation (e.g., by presenting a dialog box to the
   * user).
   */
  PERMANENT_FAILURE: 2
};

//
// ErrorInfo and ErrorInfo.ErrorReason
//

/**
 * Information about an error given to the application.
 *
 * @constructor
 * @extends {invalidation.InternalBase}
 *
 * @param {!invalidation.Types.ErrorInfo.ErrorReason} errorReason The
 *     cause of the error.
 * @param {boolean} isTransient Is the error transient or permanent. See
 *     discussion in {@code Status.Code} for permanent and transient failure
 *     handling.
 * @param {?string} errorMessage Human-readable description of the error.
 * @param {invalidation.Types.ErrorContext} context Extra information about the
 *     error (if any) cast to appropriate object as specified in the ErrorReason
 *     enum.
 * @export
 */
invalidation.Types.ErrorInfo = function(errorReason, isTransient, errorMessage,
    context) {

  /**
   * Cause of the error.
   * @type {!invalidation.Types.ErrorInfo.ErrorReason}
   * @private
   */
  this.errorReason_ = errorReason;

  /**
   * Is the error transient or permanent.
   * @type {boolean}
   * @private
   */
  this.isTransient_ = isTransient;

  /**
   * Human readable description of the error.
   * @type {?string}
   * @private
   */
  this.errorMessage_ = errorMessage;

  /**
   * Extra context for the error.
   * @type {?Object}
   * @private
   */
  this.context_ = context;
};
goog.inherits(invalidation.Types.ErrorInfo, invalidation.InternalBase);

/**
 * @return {!invalidation.Types.ErrorInfo.ErrorReason} The cause of
 *     the error.
 * @export
 */
invalidation.Types.ErrorInfo.prototype.getErrorReason = function() {
  return this.errorReason_;
};

/**
 * @return {boolean} Whether is transient or permanent (See discussion in
 * {@code Status.Code} for permanent and transient failure handling.
 * @export
 */
invalidation.Types.ErrorInfo.prototype.isTransient = function() {
  return this.isTransient_;
};

/**
 * @return {?string} Human-readable description of the error.
 * @export
 */
invalidation.Types.ErrorInfo.prototype.getErrorMessage = function() {
  return this.errorMessage_;
};

/**
 * @return {?Object} Extra context for this error. See description in
 * constructor and the enum ErrorReason.
 * @export
 */
invalidation.Types.ErrorInfo.prototype.getContext = function() {
  return this.context_;
};

/**
 * Extra information about the error in {@code ErrorInfo} - cast to appropriate
 * subtype as specified for the given reason.
 *
 * @interface
 * @export
 */
invalidation.Types.ErrorContext = function() {};

/**
 * A context with numeric data.
 *
 * @constructor
 * @implements {invalidation.Types.ErrorContext}
 */
invalidation.Types.NumberContext = function() {

  /**
   * The number being encapsulated by the NumberContext.
   * @type {number}
   */
  this.number = 0;
};

/**
 * Possible reasons for error in {@code invalidation.Listener.informError}. The
 * application writer must NOT assume that this is complete list since error
 * codes may be added later. That is, for error codes that it cannot handle, it
 * should not necessarily just crash the code. It may want to present a dialog
 * box to the user (say). For each ErrorReason, the ErrorInfo object has a
 * context object. We describe the type and meaning of the context for each enum
 * value below.
 *
 * @enum {number}
 * @export
 */
invalidation.Types.ErrorInfo.ErrorReason = {
  /**
   * The provided authentication/authorization token is not valid for use.
   */
  AUTH_FAILURE: 1,

  /**
   * An unknown failure - more human-readable information is in the error
   * message.
   */
  UNKNOWN_FAILURE: -1
};

//
// ApplicationClientId
//

/**
 * An identifier for application clients in an application-defined way. I.e., a
 * client name in an application naming scheme. This is not interpreted by the
 * invalidation system - however, it is used opaquely to squelch invalidations
 * for the cient causing an update, e.g., if a client C whose app client id is
 * C.appClientId changes object X and the backend store informs the backend
 * invalidation sytsem that X was modified by X.appClientId, the invalidation to
 * C can then be squelched by the invalidation system.
 *
 * @constructor
 * @extends {invalidation.InternalBase}
 *
 * @param {string} clientName The application-chosen name or unique id.
 * @export
 */
invalidation.Types.ApplicationClientId = function(clientName) {

  /**
   * The application-specified client name or unique id.
   * @type {string}
   * @private
   */
  this.clientName_ = clientName;
};
goog.inherits(invalidation.Types.ApplicationClientId,
    invalidation.InternalBase);


/**
 * @return {string} The client name or unique id chosen by the application.
 * @export
 */
invalidation.Types.ApplicationClientId.prototype.getClientName = function() {
  return this.clientName_;
};

//
// AckHandle
//

/**
 * Represents an opaque handle that can be used to acknowledge an invalidation
 * event by calling invalidation.Client.acknowledge(AckHandle) to indicate that
 * the client has successfully handled the event.
 *
 * @constructor
 * @extends {invalidation.InternalBase}
 *
 * @param {string} handleData The opaque data for the acknowledgement handle.
 * @export
 */
invalidation.Types.AckHandle = function(handleData) {

  /**
   * The opaque data for the handle.
   * @type {string}
   * @private
   */
  this.handleData_ = handleData;
};
goog.inherits(invalidation.Types.AckHandle, invalidation.InternalBase);

/**
 * @return {string} The internal opaque data for the handle.
 * @export
 */
invalidation.Types.AckHandle.prototype.getHandleData = function() {
  return this.handleData_;
};

/**
 * Compares this ack handle with another one for value equality..
 * @param {!invalidation.Types.AckHandle} ackHandle The handle to compare with.
 * @return {boolean} True if this and ack handle have the same handleData..
 * @export
 */
invalidation.Types.AckHandle.prototype.equals = function(ackHandle) {
  return (ackHandle instanceof invalidation.Types.AckHandle) &&
      (this.handleData_ === ackHandle.getHandleData());
};

//ipc/invalidation/public/javascript/v2/interface/systemresources.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview Interfaces for the system resources used by the Ticl. System
 * resources are an abstraction layer over the host operating system that
 * provides the Ticl with the ability to schedule events, send network messages,
 * store data, and perform logging.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.SystemResources');
goog.provide('invalidation.SystemResources.Logger');
goog.provide('invalidation.SystemResources.NetworkChannel');
goog.provide('invalidation.SystemResources.ResourceComponent');
goog.provide('invalidation.SystemResources.Scheduler');
goog.provide('invalidation.SystemResources.Storage');

goog.require('goog.debug.Logger.Level');
goog.require('invalidation.NamedFunction');
goog.require('invalidation.Types.Status');
goog.require('invalidation.util.Logger');

/**
 * Interface for the SystemResources.
 *
 * @interface
 * @export
 */
invalidation.SystemResources = function() {};

/**
 * Starts the resources.
 * <p>
 * REQUIRES: This method is called before the resources are used.
 * @export
 */
invalidation.SystemResources.prototype.start = goog.abstractMethod;

/**
 * Stops the resources. After this point, all the resources will eventually stop
 * doing any work (e.g., scheduling, sending/receiving messages from the network
 * etc). They will eventually convert any further operations to no-ops.
 * <p>
 * REQUIRES: Start has been called.
 * @export
 */
invalidation.SystemResources.prototype.stop = goog.abstractMethod;

/**
 * @return {boolean} Whether the resources are started.
 * @export
 */
invalidation.SystemResources.prototype.isStarted = goog.abstractMethod;

/**
 * @return {string} Information about the client operating system/platform,
 * e.g., Windows, ChromeOS (for debugging/monitoring purposes).
 * @export
 */
invalidation.SystemResources.prototype.getPlatform = goog.abstractMethod;

/**
 * @return {!invalidation.SystemResources.Logger} An object that can be used to
 * do logging.
 * @export
 */
invalidation.SystemResources.prototype.getLogger = goog.abstractMethod;

/**
 * @return {!invalidation.SystemResources.Storage} An object that can be used to
 * persist data locally.
 * @export
 */
invalidation.SystemResources.prototype.getStorage = goog.abstractMethod;

/**
 * @return {!invalidation.SystemResources.NetworkChannel} An object that can be
 * used to send and receive messages.
 * @export
 */
invalidation.SystemResources.prototype.getNetwork = goog.abstractMethod;

/**
 * @return {!invalidation.SystemResources.Scheduler} An object that can be used
 * by the client library to schedule its internal events.
 * @export
 */
invalidation.SystemResources.prototype.getInternalScheduler =
    goog.abstractMethod;

/**
 * @return {!invalidation.SystemResources.Scheduler} An object that can be used
 * to schedule events for the application.
 * @export
 */
invalidation.SystemResources.prototype.getListenerScheduler =
    goog.abstractMethod;

//
// ResourceComponent
//

/**
 * Interface for a component of a {@code SystemResources} implementation
 * constructed by calls to set* methods of {@code SystemResourcesBuilder}.
 * <p>
 * The {@code SystemResourcesBuilder} allows applications to create a single
 * {@code SystemResources} implementation by composing individual building
 * blocks, each of which implements one of the four required interfaces
 * ({@code Logger}, {@code Storage}, {@code NetworkChannel}, {@code Scheduler}).
 * <p>
 * However, each interface implementation may require functionality from
 * another. For example, the network implementation may need to do logging. In
 * order to allow this, we require that the interface implementations also
 * implement {@code ResourceComponent}, which specifies the single method
 * {@code setSystemResources}. It is guaranteed that this method will be
 * invoked exactly once on each interface implementation and before any other
 * calls are made. Implementations can then save a reference to the provided
 * resources for later use.
 * <p>
 * Note: for the obvious reasons of infinite recursion, implementations should
 * not attempt to access themselves through the provided
 * {@code SystemResources}.
 *
 * @interface
 * @export
 */
invalidation.SystemResources.ResourceComponent = function() {};

/**
 * Sets the system resources to be {@code resources}.
 *
 * @param {!invalidation.SystemResources} resources The resources being set.
 */
invalidation.SystemResources.ResourceComponent.prototype.setSystemResources =
    goog.abstractMethod;


//
// Logger
//

/**
 * Interface specifying the logging functionality provided by
 * {@code SystemResources}.
 *
 * @interface
 * @extends invalidation.SystemResources.ResourceComponent
 * @extends invalidation.util.Logger
 * @export
 */
invalidation.SystemResources.Logger = function() {};

/**
 * @override
 */
invalidation.SystemResources.Logger.prototype.setSystemResources =
    goog.abstractMethod;

/**
 * Logs a message.
 *
 * @param {!goog.debug.Logger.Level} level The level for logging the message.
 * @param {string} template the string to log, optionally containing %
 *     sequences allowed in {@code goog.string.format}.
 * @param {...string|number|boolean} var_args variables to substitute for
 *      % sequences in {@code template}.
 * @export
 * @override
 */
invalidation.SystemResources.Logger.prototype.log = goog.abstractMethod;

/**
 * Logs a message at the severe level.
 *
 * @param {string} template See specs for the {@code log} method.
 * @param {...} var_args See specs for the {@code log}
 *      method.
 * @export
 * @override
 */
invalidation.SystemResources.Logger.prototype.severe = goog.abstractMethod;

/**
 * Logs a message at the warning level.
 *
 * @param {string} template See specs for the {@code log} method.
 * @param {...} var_args See specs for the {@code log} method.
 * @export
 * @override
 */
invalidation.SystemResources.Logger.prototype.warning = goog.abstractMethod;

/**
 * Logs a message at the info level.
 *
 * @param {string} template See specs for the {@code log} method.
 * @param {...} var_args See specs for the {@code log} method.
 * @export
 * @override
 */
invalidation.SystemResources.Logger.prototype.info = goog.abstractMethod;

/**
 * Logs a message at the fine level.
 *
 * @param {string} template See specs for the {@code log} method.
 * @param {...} var_args See specs for the {@code log} method.
 * @export
 * @override
 */
invalidation.SystemResources.Logger.prototype.fine = goog.abstractMethod;

/**
 * @param {!goog.debug.Logger.Level} level The level at which to log the
 *  message.
 * @return {boolean} Whether the statements at this level are being logged.
 * @export
 * @override
 */
invalidation.SystemResources.Logger.prototype.isLoggable = goog.abstractMethod;

/**
 * Sets the level for the logger.
 *
 * @param {goog.debug.Logger.Level} level The level to be set.
 * @override
 */
invalidation.SystemResources.Logger.prototype.setLevel = goog.abstractMethod;

//
// Scheduler
//

/**
 * Interface specifying the scheduling functionality provided by
 * {@code SystemResources}.
 *
 * @interface
 * @extends invalidation.SystemResources.ResourceComponent
 * @export
 */
invalidation.SystemResources.Scheduler = function() {};

/**
 * @override
 */
invalidation.SystemResources.Scheduler.prototype.setSystemResources =
    goog.abstractMethod;

/**
 * Schedules {@code runnable} to be run on scheduler's thread after at least
 * {@code delayMs} milliseconds.
 *
 * @param {number} delayMs How long to wait (msec) before calling the function.
 * @param {!invalidation.NamedFunction} function The function to call.
 * @export
 */
invalidation.SystemResources.Scheduler.prototype.schedule = goog.abstractMethod;

/**
 * @return {number} Returns the current time in milliseconds since <i>some</i>
 *     epoch (NOT necessarily the UNIX epoch). The only requirement is that this
 *     time advance at the rate of real time.
 * @export
 */
invalidation.SystemResources.Scheduler.prototype.getCurrentTimeMs =
    goog.abstractMethod;

//
// Network Channel
//

/**
 * Interface specifying the network functionality provided by
 * {@code SystemResources}.
 *
 * @interface
 * @extends invalidation.SystemResources.ResourceComponent
 * @export
 */
invalidation.SystemResources.NetworkChannel = function() {};

/**
 * @override
 */
invalidation.SystemResources.NetworkChannel.prototype.setSystemResources =
    goog.abstractMethod;

/**
 * Sends {@code outgoingMessage} to the data center.
 *
 * @param {string} outgoingMessage The message to be sent to the data center.
 * @export
 */
invalidation.SystemResources.NetworkChannel.prototype.sendMessage =
    goog.abstractMethod;

/**
 * Sets the receiver to which messages from the data center will be delivered.
 *
 * @param {!function(string)} incomingReceiver The receiver of messages from the
 *     data center.
 * @export
 */
invalidation.SystemResources.NetworkChannel.prototype.setMessageReceiver =
    goog.abstractMethod;

/**
 * Informs the network channel that {@code networkStatusReceiver} be informed
 * about changes to network status changes. If the network is connected, the
 * channel should call {@code networkStatusReceiver.accept(true)} and when the
 * network is disconnected, it should call
 * {@code networkStatusReceiver.accept(false)}. Note that multiple receivers can
 * be registered with the channel to receive such status updates.
 * <p>
 * The informing of the status to the {@code networkStatusReceiver} can be
 * implemented in a best-effort manner with the caveat that indicating
 * incorrectly that the network is connected can result in unnecessary calls for
 * {@code NetworkChannel.sendMessage}. Incorrect information that the network is
 * disconnected can result in messages not being sent by the client library.
 *
 * @param {!function(boolean)} networkStatusReceiver The receiver of network
 *     status changes.
 * @export
 */
invalidation.SystemResources.NetworkChannel.prototype.addNetworkStatusReceiver =
    goog.abstractMethod;

//
// Storage
//

/**
 * Interface specifying the storage functionality provided by
 * {@code SystemResources}. Basically, the required functionality is a small
 * subset of the method of a regular hash map.
 *
 * @interface
 * @extends invalidation.SystemResources.ResourceComponent
 * @export
 */
invalidation.SystemResources.Storage = function() {};

/**
 * @override
 */
invalidation.SystemResources.Storage.prototype.setSystemResources =
    goog.abstractMethod;

/**
 * Attempts to persist {@code value} for the given {@code key}. Invokes
 * {@code done} when finished, passing a value that indicates whether it was
 * successful.
 * <p>
 * Note: If a wrie W1 finishes unsuccessfully and then W2 is issued for the same
 * key and W2 finishes successfully, W1 must NOT later overwrite W2.
 * <p>
 * REQUIRES: Neither {@code key} nor {@code value} is null.
 *
 * @param {string} key The key for which the value is being written.
 * @param {string} value The value being written for the given key.
 * @param {!function(!invalidation.Types.Status)} doneCallback The callback
 *     invoked when the operation is done.
 * @export
 */
invalidation.SystemResources.Storage.prototype.writeKey =
    goog.abstractMethod;

/**
 * Reads all the keys from the underlying store and then calls
 * {@code keyCallback} with each key that was written earlier and not deleted.
 * When all the keys are done, calls {@code keyCallback} with {@code null}.
 * With each key, the code can indicate a failed status, in which case the
 * iteration stops.
 *
 * @param {string} key The key being read.
 * @param {!function(!invalidation.Types.Status, ?string)} doneCallback The
 *     result of the read.
 * @export
 */
invalidation.SystemResources.Storage.prototype.readKey =
    goog.abstractMethod;

/**
 * Deletes the key, value pair corresponding to {@code key}. If the deletion
 * succeeds, calls {@code done} with true; else calls it with false.
 *
 * @param {string} key The key whose value is being deleted.
 * @param {!function(boolean)} doneCallback The callback invoked when the
 *     operation is done.
 * @export
 */
invalidation.SystemResources.Storage.prototype.deleteKey =
    goog.abstractMethod;

/**
 * Reads all the keys from the underlying store that keeps calling {@code done}
 * with all the keys that were written earlier and not deleted. When all the
 * keys are done, calls done with {@code null}. With each key, the code can
 * indicate a failed status, in which case the iteration stops.
 *
 * @param {!function(!invalidation.Types.Status, string)} keyCallback
 *     The callback invoked whenever a key is available.
 * @export
 */
invalidation.SystemResources.Storage.prototype.readAllKeys =
    goog.abstractMethod;

//ipc/invalidation/public/javascript/v2/contrib/lcspushchannel.js
/**
 * @fileoverview A channel using the Lightweight Connection Server.
 *
 * @author ghc@google.com (Greg Cooper)
 * @author xiaolan@google.com (Joy Zhang)
 */

goog.provide('invalidation.LcsPushChannel');
goog.provide('invalidation.LcsPushChannelBase');

goog.require('buzz.channel.Channel');
goog.require('buzz.channel.ChannelConfigFactory');
goog.require('buzz.channel.ChannelFactory');
goog.require('buzz.channel.Session');
goog.require('goog.array');
goog.require('goog.json');
goog.require('invalidation.CommonProtos');
goog.require('invalidation.GatewaySender.Handler');
goog.require('invalidation.SystemResources.Logger');
goog.require('invalidation.SystemResources.NetworkChannel');
goog.require('invalidation.XpcSenderClient');
goog.require('invalidation.proto.NetworkEndpointId');
goog.require('invalidation.util.Logger');
goog.require('invalidation.util.LoggerImpl');


/**
 * Channel object that manages the bidirectional channel from client to Tango.
 * The channel uses Lightweight Connection Server (Marmoset)
 * browser channel for server-client notification and HTTP post for
 * client-server path.
 * @param {!buzz.channel.ChannelConfig} channelConfig Channel configuration.
 * @param {string} senderUri The uri for the sender's iframe hosting page.
 * @param {number=} opt_authuser Optional authuser parameter.
 * @param {boolean=} opt_noIframe Pass {@code true} to disable loading the LCS
 *     and gateway sender iframes (won't work for ordinary tabs).
 * @param {string=} opt_iframeContainerId The id of the element in which to load
 *     the iframe that will host the actual HTTP connection (defaults
 *     to 'lcssenderclient').
 * @param {string=} opt_initOAuthToken An initial OAuth token, needed to fetch
 *     the LCS client iframe code.
 * @constructor
 * @implements {invalidation.SystemResources.NetworkChannel}
 * @implements {invalidation.GatewaySender.Handler}
 * @implements {buzz.channel.ChannelHandler}
 * @implements {buzz.channel.SessionErrorHandler}
 * @implements {buzz.channel.SessionHandler}
 */
invalidation.LcsPushChannelBase = function(
    channelConfig, senderUri, opt_authuser, opt_noIframe, opt_iframeContainerId,
    opt_initOAuthToken) {

  goog.asserts.assert(channelConfig instanceof buzz.channel.ChannelConfigImpl);

  /**
   * The receiver of messages from the server.
   * @type {?function(string)}
   * @private
   */
  this.incomingReceiver_ = null;

  /**
   * A collection of receivers of network status updates.
   * @type {!Array.<function(boolean)>}
   * @private
   */
  this.networkStatusReceivers_ = [];

  /**
   * A logger that can be set to use the system resource logger or a
   * default tango logger impl.
   * @type {!invalidation.util.Logger}
   * @private
   */
  this.logger_ = new invalidation.util.LoggerImpl('LcsPushChannel');

  /**
   * Keeps track of whether we're online.
   * @type {boolean}
   * @private
   */
  this.isOnline_ = false;


  /**
   * Keeps track of whether cross-page channel is opened.
   * @type {boolean}
   * @private
   */
  this.xpcOpen_ = false;

  /**
   * The uri for the sender's GSE.
   * @type {string}
   * @private
   */
  this.senderUri_ = senderUri;

  /**
   * The id of the element that will contain the sender iframe.
   * @type {string}
   * @private
   */
  this.iframeContainerId_ = opt_iframeContainerId || 'lcssenderclient';

  /**
   * A collection of buffered messages, which were sent by the Ticl while we
   * were offline (with the BUFFER_SIZE_ limit given below).
   * @type {!Array.<string>}
   * @private
   */
  this.bufferedMessages_ = [];

  /**
   * Optional OAuth token to be sent with channel requests.
   * @type {?string}
   * @private
   */
  this.oauthToken_ = opt_initOAuthToken || null;

  /**
   * Handler supplied by the application, to which (if set) we'll forward
   * callbacks about the status of the channel.
   * @type {buzz.channel.ChannelHandler}
   * @private
   */
  this.channelHandler_ = null;

  /**
   * The underlying browser channel.
   * @type {!buzz.channel.Channel}
   * @private
   */
  this.channel_ = buzz.channel.ChannelFactory.newChannel(
      this, channelConfig);
  if (this.oauthToken_ != null) {
    this.channel_.setOAuthToken(this.oauthToken_);
  }
  this.channel_.open();

  /**
   * The session with Tango.
   * @type {buzz.channel.Session}
   * @private
   */
  this.session_ = null;

  /**
   * The address of the session.
   * @type {?string}
   * @private
   */
  this.address_ = null;

  /**
   * Message counter for debugging. Reset on each new session.
   * @type {number}
   * @private
   */
  this.counter_ = 0;

  /**
   * The gateway sender client.
   * @type {!invalidation.GatewaySender}
   * @private
   */
  this.gatewaySender_;

  // The Gateway sender clients require an authuser parameter; in case our
  // caller didn't supply one, the appropriate default is 0.
  var authuser = opt_authuser || 0;
  if (opt_noIframe) {
    this.gatewaySender_ = new invalidation.GatewaySender(
        this.senderUri_, authuser, this);
  } else {
    this.gatewaySender_ = new invalidation.XpcSenderClient(
        this.senderUri_, this.iframeContainerId_, this.oauthToken_, authuser,
        this);
  }
  this.gatewaySender_.start();
};


/**
 * Maximum size of {@code this.bufferedMessages_}.
 * @type {number}
 * @private
 */
invalidation.LcsPushChannelBase.BUFFER_SIZE_ = 10;


/**
 * Sets or updates an OAuth token to be sent on all channel requests.
 * @param {string} token The OAuth access token to use.
 */
invalidation.LcsPushChannelBase.prototype.setOAuthToken = function(token) {
  this.oauthToken_ = token;
  this.channel_.setOAuthToken(token);
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.onOpen =
    function(channel, opt_metadata) {
  goog.asserts.assert(this.channel_ == channel);

  // Open a session to Tango. The service name is tango_service. Only do this
  // once, since the LCS client will automatically re-establish sessions when
  // the channel disconnects and reconnects.
  if (!this.address_) {
    this.session_ = channel.newSession('tango_service', this);
    this.session_.open();
  }

  // Forward the call to the application's channel handler.
  if (this.channelHandler_ != null) {
    this.channelHandler_.onOpen(channel, opt_metadata);
  }

  this.logger_.info('LCS push-only channel opened');
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.setSystemResources =
    function(resources) {
  this.logger_ = /** @type {!invalidation.util.Logger} */
      (resources.getLogger());
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.setMessageReceiver =
    function(incomingReceiver) {
  this.incomingReceiver_ = incomingReceiver;
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.sendMessage =
    function(outgoingMessage) {
  // Try to deliver the message, whether or not we think we're connected.
  if (this.isOnline_) {
    this.sendMessage_(outgoingMessage);
  } else {
    // If we think we're not connected, also buffer the most recent message
    // so we can resend it once we're confident we're online.
    if (this.bufferedMessages_.length >=
        invalidation.LcsPushChannelBase.BUFFER_SIZE_) {
      // Move all messages up by 1. The buffer is small and rarely expected
      // to be full (unless offline). So the cost of moving up should not be
      // that high.
      this.bufferedMessages_.shift();
    }
    this.bufferedMessages_.push(outgoingMessage);
    this.logger_.info('not online. Buffer message ' + outgoingMessage);
  }
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.addNetworkStatusReceiver =
    function(networkStatusReceiver) {
  this.networkStatusReceivers_.push(networkStatusReceiver);
};


/**
 * Sends any buffered messages to the talk infrastructure and clears that array.
 * @private
 */
invalidation.LcsPushChannelBase.prototype.sendBufferedMessages_ = function() {
  if (!goog.array.isEmpty(this.bufferedMessages_)) {
    for (var i = 0; i < this.bufferedMessages_.length; i++) {
      this.sendMessage_(this.bufferedMessages_[i]);
    }
    goog.array.clear(this.bufferedMessages_);
  }
};


/**
 * Sends the given data along HTTP post.
 * @param {string} data The data to send.
 * @private
 */
invalidation.LcsPushChannelBase.prototype.sendMessage_ = function(data) {
  if (this.isOnline_) {
    // Create Tango network endpoint with given serialized client address.
    var endpoint = invalidation.CommonProtos.newNetworkEndpointId(
        invalidation.proto.NetworkEndpointId.NetworkAddress.LCS,
        /** @type {string} */ (this.address_));

    // Compose ClientGatewayMessage
    var clientGatewayMessage =
        invalidation.CommonProtos.newClientToGatewayMessage(
            data, endpoint, this.counter_.toString());
    this.counter_++;

    this.logger_.info('sending ' + clientGatewayMessage);

    // Serialize the message into a JSON string.
    var message = invalidation.Utils.serializeMessage(clientGatewayMessage);

    // Create a map of headers to specify the content type and, if present, an
    // OAuth token.
    var headers = {'Content-Type': 'application/json'};
    if (this.oauthToken_ != null) {
      headers['Authorization'] = 'OAuth ' + this.oauthToken_;
    }

    // Message the http request.
    this.gatewaySender_.send(message, headers);
  } else {
    this.logger_.warning('no session yet: not sending ' + data);
  }
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.receive = function(session, data) {
  if (this.incomingReceiver_) {
    this.incomingReceiver_(data);
  }
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.onError = function(channel, error) {
  // Forward the call to the application's channel handler.
  if (this.channelHandler_ != null) {
    this.channelHandler_.onError(channel, error);
  }

  this.logger_.warning('channel error: %s', error);
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.onClose = function(channel) {
  this.updateNetworkStatus_(false);

  // Forward the call to the application's channel handler.
  if (this.channelHandler_ != null) {
    this.channelHandler_.onClose(channel);
  }

  this.logger_.info('channel closed');
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.onAddressAssigned =
    function(session, address) {
  this.logger_.info('session open');
  this.address_ = address;
  this.updateNetworkStatus_(true);
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.onSessionError =
    function(session, errorInfo) {
  this.logger_.warning('failed to create session: %s', errorInfo.description);
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.onReady = function() {
  this.logger_.info('cross-page channel open');
  this.xpcOpen_ = true;
  this.updateNetworkStatus_(true);
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.onSuccess = function() {
  this.logger_.info('post success.');
};


/** @inheritDoc */
invalidation.LcsPushChannelBase.prototype.onFailure = function(errorMessage) {
  this.logger_.warning('error during post: ' + errorMessage);
};


/**
 * Takes appropriate action in response to a change in network status.
 * @param {boolean} isOnline Whether the network connection should be online.
 *     The network status will be online iff session and xpc both are opened.
 * @private
 */
invalidation.LcsPushChannelBase.prototype.updateNetworkStatus_ = function(
    isOnline) {
  this.isOnline_ = isOnline && (this.address_ != null) && this.xpcOpen_;
  if (this.isOnline_) {
    this.sendBufferedMessages_();
  }
  for (var i = 0; i < this.networkStatusReceivers_.length; ++i) {
    this.networkStatusReceivers_[i](this.isOnline_);
  }
};


/**
 * Sets an application channel handler. The LcsPushChannel's internal handler
 * will forward calls to this handler (if it's not {@code null}).
 * @param {buzz.channel.ChannelHandler} channelHandler A handler to which
 *     channel status-related calls will be forwarded.
 */
invalidation.LcsPushChannelBase.prototype.setChannelHandler =
    function(channelHandler) {
  this.channelHandler_ = channelHandler;
};

/**
 * Channel object that manages the bidirectional channel from client to Tango.
 * The channel uses Lightweight Connection Server (Marmoset)
 * browser channel for server-client notification and HTTP post for
 * client-server path.
 * @param {string} channelUri The uri for the Marmoset client library.
 * @param {string} senderUri The uri for the sender's iframe hosting page.
 * @param {string} clientType the type of the client for this channel.
 * @param {number=} opt_authuser An optional authuser index. Used by config
 *     classes and default to null.
 * @param {boolean=} opt_noIframe Pass {@code true} to disable loading the LCS
 *     and gateway sender iframes (won't work for ordinary tabs).
 * @param {string=} opt_iframeContainerId The id of the element in which to load
 *     the iframe that will host the actual HTTP connection (defaults
 *     to 'lcssenderclient').
 * @param {string=} opt_initOAuthToken An initial OAuth token, needed to fetch
 *     the LCS client iframe code.
 * @param {string=} opt_gaiaServiceOverride Optional Gaia service name override
 *     (for applications and domains where Talk may be disabled).
 * @constructor
 * @extends {invalidation.LcsPushChannelBase}
 * @implements {invalidation.SystemResources.NetworkChannel}
 * @implements {invalidation.GatewaySender.Handler}
 * @implements {buzz.channel.ChannelHandler}
 * @implements {buzz.channel.SessionHandler}
 */
invalidation.LcsPushChannel = function(
    channelUri, senderUri, clientType, opt_authuser, opt_noIframe,
    opt_iframeContainerId, opt_initOAuthToken, opt_gaiaServiceOverride) {
  var configMaker = (opt_noIframe ?
      buzz.channel.ChannelConfigFactory.newConfigWithoutIframe :
      buzz.channel.ChannelConfigFactory.newConfigWithIframe);
  var config = configMaker(
      channelUri, clientType, opt_authuser, opt_gaiaServiceOverride);
  goog.base(this, config, senderUri, opt_authuser, opt_noIframe,
      opt_iframeContainerId, opt_initOAuthToken);
};
goog.inherits(invalidation.LcsPushChannel, invalidation.LcsPushChannelBase);

//ipc/invalidation/public/javascript/v2/interface/invalidationclient.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview Interface for the Tango invalidation client library.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.Client');

goog.require('invalidation.Types.AckHandle');
goog.require('invalidation.Types.ObjectId');
goog.require('invalidation.proto.ApplicationClientIdP');
goog.require('invalidation.proto.ClientConfigP');

/**
 * Interface for the Tango Invalidation Client Library (Ticl).
 *
 * @interface
 * @export
 */
invalidation.Client = function() {};

/**
 * Starts the client. This method MUST be called before any other method is
 * invoked. The client is considered to be started after
 * {@link Listener#ready} has been received by the application.
 * <p>
 * REQUIRES: start has not already been called.
 * Also, the resources given to the client must have been started by the caller.
 * @export
 */
invalidation.Client.prototype.start = goog.abstractMethod;

/**
 * Stops the client. After this method has been called, it is an error to call
 * any other method.
 * <p>
 * REQUIRES: start has already been called.
 *
 * Does not stop the resources bound to this client.
 * @export
 */
invalidation.Client.prototype.stop = goog.abstractMethod;

/**
 * Requests that the Ticl register to receive notifications for the object with
 * ids {@code objectIds}.
 * <p>
 * The library guarantees that the caller will be
 * informed of the results of this call either via
 * {@link Listener#informRegistrationStatus} or
 * {@link Listener#informRegistrationFailure} unless the library informs the
 * caller of a connection failure via {@code Listener.informError}. The caller
 * should consider the registration to have succeeded only if it gets a call
 * {@link Listener#informRegistrationStatus} for {@code objectId} with
 * {@link Listener.RegistrationState.REGISTERED}. Note that if the network is
 * disconnected, the listener events will probably show up after the network
 * connection is repaired.
 * <p>
 * REQUIRES: start has been called and and {@link Listener.ready} has been
 * received by the application's listener.
 *
 * @param {...!invalidation.Types.ObjectId} objectIds The object ids being
 *     registered.
 * @export
 */
invalidation.Client.prototype.register = goog.abstractMethod;

/**
 * Unregisters to receive notifications for the object
 * with ids {@code objectIds}. The library guarantees that the caller will be
 * informed of the results of this call either via
 * {@link Listener#informRegistrationStatus} or
 * {@link Listener#informRegistrationFailure} unless the library informs the
 * caller of a connection failure via {@link Listener#informError}. The caller
 * should consider the unregistration to have succeeded only if it gets a call
 * {@link Listener#informRegistrationStatus} for {@code objectId} with
 * {@link Listener.RegistrationState.UNREGISTERED}. Note that if the network is
 * disconnected, the listener events will probably show up when the network
 * connection is repaired.
 * <p>
 * REQUIRES: start has been called and and {@code Listener.ready} has been
 * received by the application's listener.
 *
 * @param {...!invalidation.Types.ObjectId} objectIds The object ids being
 *     unregistered.
 * @export
 */
invalidation.Client.prototype.unregister = goog.abstractMethod;

/**
 * Acknowledges the {@link Listener} event that was delivered with the provided
 * acknowledgement handle. This indicates that the client has accepted
 * responsibility for processing the event and it does not need to be
 * redelivered later.
 * <p>
 * REQUIRES: {@link start} has been called and and {@link Listener.ready} has
 * been received by the application's listener.
 *
 * @param {!invalidation.Types.AckHandle} ackHandle The acknowledgement handle
 *     for the event being acknowledged.
 * @export
 */
invalidation.Client.prototype.acknowledge = goog.abstractMethod;

/**
 * Returns the app client id, for tests only.
 *
 * @return {!invalidation.proto.ApplicationClientIdP}
 * @export
 */
invalidation.Client.prototype.getAppClientIdForTest =
    goog.abstractMethod;

/**
 * Returns the client config, for tests only.
 *
 * @return {!invalidation.proto.ClientConfigP}
 * @export
 */
invalidation.Client.prototype.getConfigForTest = goog.abstractMethod;


//ipc/invalidation/public/javascript/v2/interface/invalidationlistener.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview Interface for the Tango Invalidation Listener that application
 * writers must implement to receive invalidations from Tango.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.Listener');

goog.require('invalidation.Client');

/**
 * Listener Interface that must be implemented by Tango clients to receive
 * object invalidations, registration status events, and error events.
 * <p>
 * After the application publishes an invalidation (oid, version) to Tango,
 * Tango guarantees to send at least one of the following events to listeners
 * that have registered for oid:
 * <ol>
 *   <li> Invalidate(oid, version)
 *   <li> Invalidate(oid, laterVersion) where laterVersion >= version
 *   <li> InvalidateUnknownVersion(oid)
 * </ol>
 * <p>
 * Each invalidation must be acknowledged by the application. Each includes
 * an AckHandle that the application must pass to
 * {@link InvalidationClient#acknowledge} after it is done handling
 * that event.
 * <p>
 * Please see http://go/tango-api for additional information on the Tango API
 * and semantics.
 * <p>
 * Please see {@code simplelistener.js} for a base class that implements some
 * events on behalf of the application.
 *
 * @interface
 */
invalidation.Listener = function() {};

/**
 * Possible registration states for an object.
 * @enum {number}
 */
invalidation.Listener.RegistrationState = {
  REGISTERED: 0,

  UNREGISTERED: 1
};

/**
 * Called in response to the {@code Client.start} call. Indicates that the
 * {@code Client} is now ready for use, i.e., calls such as register/unregister
 * can be performed on that object.
 * <p>
 * The application MUST NOT issue calls such as register/unregister on the
 * InvalidationClient before receiving this event.
 *
 * @param {!invalidation.Client} client The {@code invalidation.Client} invoking
 *     the listener.
 */
invalidation.Listener.prototype.ready = goog.abstractMethod;

/**
 * Indicates that an object has been updated to a particular version.
 * <ul>
 *   <li> When it receives this call, the application MUST hit its
 *   backend to fetch the updated state of the object, unless it
 *   already has has a version at least as recent as that of the
 *   invalidation.
 *
 *   <li> Tango MAY choose to drop older versions of invalidations, as
 *   long as it calls {@link #invalidate} with a later version of the
 *   same object, or calls {@link #invalidateUnknownVersion}.
 *
 *   <li> Tango MAY reorder or duplicate invalidations.
 *
 *   <li> Tango MAY drop a published payload without notice.
 *
 *   <li> The application MUST acknowledge this event by calling
 *   {@link InvalidationClient#acknowledge} with the provided
 *   {@code ackHandle}, otherwise the event will be redelivered.
 * </ul>
 *
 * @param {!invalidation.Client} client The {@code invalidation.Client} invoking
 *     the listener.
 * @param {!invalidation.Types.Invalidation} invalidation The invalidation being
 *     delivered to the application.
 * @param {!invalidation.Types.AckHandle} ackHandle Event ack handle.
 */
invalidation.Listener.prototype.invalidate = goog.abstractMethod;

/**
 * Indicates that an object has been updated, but the version number
 * and payload are unknown.
 *
 * <ul>

 * <li> When it receives this call, the application MUST hit its
 *  backend to fetch the updated state of the object, regardless of
 *  what version it has in its cache.
 *
 *   <li> The application MUST acknowledge this event by calling
 *   {@link InvalidationClient#acknowledge} with the provided
 *   {@code ackHandle}, otherwise the event will be redelivered.
 * </ul>
 *
 * @param {!invalidation.Client} client The client invoking the listener.
 * @param {!invalidation.Types.ObjectId} objectId The object being invalidated.
 * @param {!invalidation.Types.AckHandle} ackHandle Event ack handle.
 */
invalidation.Listener.prototype.invalidateUnknownVersion = goog.abstractMethod;

/**
 * Indicates that the application should consider all objects to have
 * changed. This event is sent extremely rarely.
 *
 * <ul>
 *   <li> The application MUST hit its backend to fetch the updated
 *   state of all objects, regardless of what version it has in its
 *   cache.
 *
 *   <li> The application MUST acknowledge this event by calling
 *   {@link InvalidationClient#acknowledge} with the provided
 *   {@code ackHandle}, otherwise the event will be redelivered.
 * </ul>
 *
 * @param {!invalidation.Client} client The client invoking the listener.
 * @param {!invalidation.Types.AckHandle} ackHandle Event ack handle.
 */
invalidation.Listener.prototype.invalidateAll = goog.abstractMethod;

/**
 * Indicates that the registration state of an object has changed.
 *
 * @param {!invalidation.Client} client The client invoking the listener.
 * @param {!invalidation.Types.ObjectId} objectId The object whose registration
 *     status is being informed.
 * @param {!invalidation.Listener.RegistrationState} regState The registration
 *     status of the object.
 */
invalidation.Listener.prototype.informRegistrationStatus = goog.abstractMethod;

/**
 * Indicates that an object registration or unregistration operation may have
 * failed.
 * <p>
 * For transient failures, the application MAY retry the registration later. If
 * it chooses to do so, it MUST use exponential backoff or other sensible
 * backoff policy.
 * <p>
 * For permanent failures, the application MUST NOT automatically retry without
 * fixing the situation (e.g., by presenting a dialog box to the user).
 *
 * @param {!invalidation.Client} client The client invoking the listener.
 * @param {!invalidation.Types.ObjectId} objectId The object whose registration
 *     status is being informed.
 * @param {boolean} isTransient Whether the error is transient or permanent.
 * @param {string} errorMessage Extra information about the message.
 */
invalidation.Listener.prototype.informRegistrationFailure = goog.abstractMethod;

/**
 * Indicates that all registrations for the client are in an unknown
 * state (e.g., Tango may have dropped registrations.)
 *
 * The application MUST call {@link InvalidationClient#register} for
 * all objects that it wishes to be registered for.
 *
 * @param {!invalidation.Client} client The client invoking the listener.
 * @param {string} ignored Ignore, reserved for future expansion.
 * @param {number} ignored2 Ignore, reservered for future expansion.
 */
invalidation.Listener.prototype.reissueRegistrations = goog.abstractMethod;

/**
 * Informs the listener about errors that have occurred in the backend.
 *
 * If the error reason is AUTH_FAILURE, the application may notify the
 * user.  Otherwise, the application should log the error info for
 * debugging purposes but take no other action.
 */
invalidation.Listener.prototype.informError = goog.abstractMethod;

//javascript/closure/crypt/base64.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Base64 en/decoding. Not much to say here except that we
 * work with decoded values in arrays of bytes. By "byte" I mean a number
 * in [0, 255].
 *
 * @author doughtie@google.com (Gavin Doughtie)
 * @author fschneider@google.com (Fritz Schneider)
 */

goog.provide('goog.crypt.base64');
goog.require('goog.crypt');
goog.require('goog.userAgent');

// Static lookup maps, lazily populated by init_()


/**
 * Maps bytes to characters.
 * @type {Object}
 * @private
 */
goog.crypt.base64.byteToCharMap_ = null;


/**
 * Maps characters to bytes.
 * @type {Object}
 * @private
 */
goog.crypt.base64.charToByteMap_ = null;


/**
 * Maps bytes to websafe characters.
 * @type {Object}
 * @private
 */
goog.crypt.base64.byteToCharMapWebSafe_ = null;


/**
 * Maps websafe characters to bytes.
 * @type {Object}
 * @private
 */
goog.crypt.base64.charToByteMapWebSafe_ = null;


/**
 * Our default alphabet, shared between
 * ENCODED_VALS and ENCODED_VALS_WEBSAFE
 * @type {string}
 */
goog.crypt.base64.ENCODED_VALS_BASE =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
    'abcdefghijklmnopqrstuvwxyz' +
    '0123456789';


/**
 * Our default alphabet. Value 64 (=) is special; it means "nothing."
 * @type {string}
 */
goog.crypt.base64.ENCODED_VALS =
    goog.crypt.base64.ENCODED_VALS_BASE + '+/=';


/**
 * Our websafe alphabet.
 * @type {string}
 */
goog.crypt.base64.ENCODED_VALS_WEBSAFE =
    goog.crypt.base64.ENCODED_VALS_BASE + '-_.';


/**
 * Whether this browser supports the atob and btoa functions. This extension
 * started at Mozilla but is now implemented by many browsers. We use the
 * ASSUME_* variables to avoid pulling in the full useragent detection library
 * but still allowing the standard per-browser compilations.
 *
 * @type {boolean}
 */
goog.crypt.base64.HAS_NATIVE_SUPPORT = goog.userAgent.GECKO ||
                                       goog.userAgent.WEBKIT ||
                                       goog.userAgent.OPERA ||
                                       typeof(goog.global.atob) == 'function';


/**
 * Base64-encode an array of bytes.
 *
 * @param {Array.<number>|Uint8Array} input An array of bytes (numbers with
 *     value in [0, 255]) to encode.
 * @param {boolean=} opt_webSafe Boolean indicating we should use the
 *     alternative alphabet.
 * @return {string} The base64 encoded string.
 */
goog.crypt.base64.encodeByteArray = function(input, opt_webSafe) {
  if (!goog.isArrayLike(input)) {
    throw Error('encodeByteArray takes an array as a parameter');
  }

  goog.crypt.base64.init_();

  var byteToCharMap = opt_webSafe ?
                      goog.crypt.base64.byteToCharMapWebSafe_ :
                      goog.crypt.base64.byteToCharMap_;

  var output = [];

  for (var i = 0; i < input.length; i += 3) {
    var byte1 = input[i];
    var haveByte2 = i + 1 < input.length;
    var byte2 = haveByte2 ? input[i + 1] : 0;
    var haveByte3 = i + 2 < input.length;
    var byte3 = haveByte3 ? input[i + 2] : 0;

    var outByte1 = byte1 >> 2;
    var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
    var outByte3 = ((byte2 & 0x0F) << 2) | (byte3 >> 6);
    var outByte4 = byte3 & 0x3F;

    if (!haveByte3) {
      outByte4 = 64;

      if (!haveByte2) {
        outByte3 = 64;
      }
    }

    output.push(byteToCharMap[outByte1],
                byteToCharMap[outByte2],
                byteToCharMap[outByte3],
                byteToCharMap[outByte4]);
  }

  return output.join('');
};


/**
 * Base64-encode a string.
 *
 * @param {string} input A string to encode.
 * @param {boolean=} opt_webSafe If true, we should use the
 *     alternative alphabet.
 * @return {string} The base64 encoded string.
 */
goog.crypt.base64.encodeString = function(input, opt_webSafe) {
  // Shortcut for Mozilla browsers that implement
  // a native base64 encoder in the form of "btoa/atob"
  if (goog.crypt.base64.HAS_NATIVE_SUPPORT && !opt_webSafe) {
    return goog.global.btoa(input);
  }
  return goog.crypt.base64.encodeByteArray(
      goog.crypt.stringToByteArray(input), opt_webSafe);
};


/**
 * Base64-decode a string.
 *
 * @param {string} input to decode.
 * @param {boolean=} opt_webSafe True if we should use the
 *     alternative alphabet.
 * @return {string} string representing the decoded value.
 */
goog.crypt.base64.decodeString = function(input, opt_webSafe) {
  // Shortcut for Mozilla browsers that implement
  // a native base64 encoder in the form of "btoa/atob"
  if (goog.crypt.base64.HAS_NATIVE_SUPPORT && !opt_webSafe) {
    return goog.global.atob(input);
  }
  return goog.crypt.byteArrayToString(
      goog.crypt.base64.decodeStringToByteArray(input, opt_webSafe));
};


/**
 * Base64-decode a string.
 *
 * @param {string} input to decode (length not required to be a multiple of 4).
 * @param {boolean=} opt_webSafe True if we should use the
 *     alternative alphabet.
 * @return {!Array} bytes representing the decoded value.
 */
goog.crypt.base64.decodeStringToByteArray = function(input, opt_webSafe) {
  goog.crypt.base64.init_();

  var charToByteMap = opt_webSafe ?
                      goog.crypt.base64.charToByteMapWebSafe_ :
                      goog.crypt.base64.charToByteMap_;

  var output = [];

  for (var i = 0; i < input.length; ) {
    var byte1 = charToByteMap[input.charAt(i++)];

    var haveByte2 = i < input.length;
    var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
    ++i;

    var haveByte3 = i < input.length;
    var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 0;
    ++i;

    var haveByte4 = i < input.length;
    var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 0;
    ++i;

    if (byte1 == null || byte2 == null ||
        byte3 == null || byte4 == null) {
      throw Error();
    }

    var outByte1 = (byte1 << 2) | (byte2 >> 4);
    output.push(outByte1);

    if (byte3 != 64) {
      var outByte2 = ((byte2 << 4) & 0xF0) | (byte3 >> 2);
      output.push(outByte2);

      if (byte4 != 64) {
        var outByte3 = ((byte3 << 6) & 0xC0) | byte4;
        output.push(outByte3);
      }
    }
  }

  return output;
};


/**
 * Lazy static initialization function. Called before
 * accessing any of the static map variables.
 * @private
 */
goog.crypt.base64.init_ = function() {
  if (!goog.crypt.base64.byteToCharMap_) {
    goog.crypt.base64.byteToCharMap_ = {};
    goog.crypt.base64.charToByteMap_ = {};
    goog.crypt.base64.byteToCharMapWebSafe_ = {};
    goog.crypt.base64.charToByteMapWebSafe_ = {};

    // We want quick mappings back and forth, so we precompute two maps.
    for (var i = 0; i < goog.crypt.base64.ENCODED_VALS.length; i++) {
      goog.crypt.base64.byteToCharMap_[i] =
          goog.crypt.base64.ENCODED_VALS.charAt(i);
      goog.crypt.base64.charToByteMap_[goog.crypt.base64.byteToCharMap_[i]] = i;
      goog.crypt.base64.byteToCharMapWebSafe_[i] =
          goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(i);
      goog.crypt.base64.charToByteMapWebSafe_[
          goog.crypt.base64.byteToCharMapWebSafe_[i]] = i;
    }
  }
};

//ipc/invalidation/javascript/internal/client/digestfunction.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview Interface specifying a function to compute digests.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.DigestFunction');
goog.provide('invalidation.DigestFunction.Digest');

goog.require('goog.crypt.base64');

/**
 * Interface specifying a function to compute digests.
 *
 * @interface
 * @export
 */
invalidation.DigestFunction = function() {};

/** Clears the digest state. */
invalidation.DigestFunction.prototype.reset = goog.abstractMethod;

/**
 * Adds {@code data} to the digest being computed.
 *
 * @param {Array.<number>|string} data The data to be added for digest
 *     computation.
 */
invalidation.DigestFunction.prototype.update = goog.abstractMethod;

/**
 * Returns the digest of the data added by {@code update}. After this call has
 * been made, reset must be called before {@code update} and {@code getDigest}
 * can be called.
 *
 * @return {!invalidation.DigestFunction.Digest} The computed digest.
 */
invalidation.DigestFunction.prototype.getDigest = goog.abstractMethod;

/**
 * A class to keep a digest computed using the DigestFunction. It allows
 * the caller to serialize the digest as a base-64 encoded string for sending
 * on the wire.
 *
 * @param {!Array.<number>} value The digest value.
 * @constructor
 */
invalidation.DigestFunction.Digest = function(value) {
  /**
   * The original provided digest value.
   * @type {!Array.<number>}
   * @private
   */
  this.value_ = value;
};

/**
 * Returns the actual value of the digest.
 *
 * @return {!Array.<number>} The digest value.
 */
invalidation.DigestFunction.Digest.prototype.getRawValue = function() {
  return this.value_;
};

/**
 * Returns a base64-encoded version of the digest.
 *
 * @return {string} Serialized digest.
 */
invalidation.DigestFunction.Digest.prototype.serialize = function() {
  return goog.crypt.base64.encodeByteArray(this.value_);
};

/**
 * Returns true iff this's value and {@code other}'s value are the same.
 *
 * @param {!invalidation.DigestFunction.Digest} other Value being compared.
 * @return {boolean} Whether {@code other} is the same as this.
 */
invalidation.DigestFunction.Digest.prototype.equals = function(other) {
  return goog.array.equals(this.value_, other.value_);
};

/**
 * Returns a Digest given a base64-encoded version of the digest, if valid.
 * Otherwise, returns null.
 *
 * @param {string} serialized Digest in base-64 serialized form.
 * @return {invalidation.DigestFunction.Digest} The deserialized digest.
 */
invalidation.DigestFunction.Digest.deserialize = function(serialized) {
  try {
    var deserialized = goog.crypt.base64.decodeStringToByteArray(serialized);
    return new invalidation.DigestFunction.Digest(
        /** @type {!Array} */ (deserialized));
  } catch (error) {
    return null;
  }
};

/**
 * @override
 */
invalidation.DigestFunction.Digest.prototype.toString = function() {
  return goog.string.format('Digest: <%s, %s>', this.serialize(),
      this.value_.toString());
};

/**
 * Comparison function used to compare two digests.
 *
 * @param {!invalidation.DigestFunction.Digest} a The first digest.
 * @param {!invalidation.DigestFunction.Digest} b The second digest.
 * @return {number} -1 if a < b, 1 if a > b, 0 if a = b.
 */
invalidation.DigestFunction.Digest.Compare = function(a, b) {
  return goog.array.compare3(a.value_, b.value_);
};

//ipc/invalidation/javascript/internal/client/objectiddigestutils.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview Digest-related utilities for object ids.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.ObjectIdDigestUtils');
goog.provide('invalidation.Sha1DigestFunction');

goog.require('goog.crypt.Sha1');
goog.require('invalidation.DigestFunction');
goog.require('invalidation.DigestFunction.Digest');

/**
 * Implementation of {@code DigestFunction} using SHA-1.
 *
 * @implements {invalidation.DigestFunction}
 * @constructor
 */
invalidation.Sha1DigestFunction = function() {
  /**
   * Digest implementation.
   * @type {!goog.crypt.Sha1}
   * @private
   */
  this.sha1_ = new goog.crypt.Sha1();

  /**
   * Whether the {@link #reset()} method needs to be called. This is set to true
   * when {@code getDigest} is called and aims to prevent subtle bugs caused by
   * failing to reset the object before computing a new digest.
   * @type {boolean}
   * @private
   */
  this.resetNeeded_ = false;
};

/**
 * @override
 */
invalidation.Sha1DigestFunction.prototype.reset = function() {
  this.resetNeeded_ = false;
  this.sha1_.reset();
};

/**
 * @override
 */
invalidation.Sha1DigestFunction.prototype.update = function(data) {
  goog.asserts.assert(!this.resetNeeded_);
  this.sha1_.update(data);
};

/**
 * @override
 */
invalidation.Sha1DigestFunction.prototype.getDigest = function() {
  goog.asserts.assert(!this.resetNeeded_);
  this.resetNeeded_ = true;
  var digest = /** @type {!Array.<number>} */ (this.sha1_.digest());
  return new invalidation.DigestFunction.Digest(digest);
};

/**
 * Returns the digest of {@code objectIdDigests} using {@code digestFn}.
 * <p>
 * REQUIRES: {@code objectIdDigests} iterate in sorted order.
 *
 * @param {!Array.<!invalidation.DigestFunction.Digest>} objectIdDigests The
 *     objectid digests over which the digest is computed.
 * @param {!invalidation.DigestFunction} digestFn The digest function used
 *     to compute the digest.
 * @return {!invalidation.DigestFunction.Digest} The resulting digest.
 */
invalidation.ObjectIdDigestUtils.getDigest = function(objectIdDigests,
    digestFn) {
  digestFn.reset();
  for (var i = 0; i < objectIdDigests.length; i++) {
    digestFn.update(objectIdDigests[i].getRawValue());
  }
  return digestFn.getDigest();
};

/**
 * Returns the digest of {@code objectId} using {@code digestFn}.
 *
 * @param {!invalidation.proto.ObjectIdP} objectId The object whose digest is
 *     being computed.
 * @param {!invalidation.DigestFunction} digestFn The function used to compute
 *     the digest.
 * @return {!invalidation.DigestFunction.Digest} The digest for the object.
 */
invalidation.ObjectIdDigestUtils.getObjectDigest = function(objectId,
    digestFn) {
  digestFn.reset();

  // Get the source in little-endian format.
  var sourceArray = [];
  var source = objectId.getSource();
  for (var i = 0; i < 4; i++) {
    sourceArray[i] = source & 255;
    source = source >> 8;
  }

  // Now compute the digest on the little endian source format and the name.
  digestFn.update(sourceArray);
  digestFn.update(/** @type {string} */ (objectId.getName()));
  return digestFn.getDigest();
};

//ipc/invalidation/javascript/internal/client/persistenceutils.js
// Copyright 2010 Google Inc. All Rights Reserved.

/**
 * @fileoverview Utility methods for handling the Ticl persistent state.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.PersistenceUtils');

goog.require('invalidation.CommonProtos');
goog.require('invalidation.Utils');

/**
 * Serializes a Ticl state blob.
 *
 * @param {!invalidation.proto.PersistentTiclState} state The client state to
 *     be serialized.
 * @param {!invalidation.DigestFunction} digestFn The function used to compute
 *     the digest of the client state.
 * @return {string} The serialized state.
 */
invalidation.PersistenceUtils.serializeState = function(state,
     digestFn) {
  var digest = invalidation.PersistenceUtils.generateDigest(state, digestFn);
  var blob = invalidation.CommonProtos.newPersistentStateBlob(state,
      digest.serialize());
  return invalidation.Utils.serializeMessage(blob);
};

/**
 * Deserializes a Ticl state blob. Returns either the parsed state or
 * {@code null} if it could not be parsed.
 *
 * @param {invalidation.SystemResources.Logger} logger For logging errors.
 * @param {string} stateBlobBytes Serialized Ticl state.
 * @param {!invalidation.DigestFunction} digestFn The function used to compute
 *     the digest of the client state.
 * @return {invalidation.proto.PersistentTiclState} The deserialized Ticl state.
 */
invalidation.PersistenceUtils.deserializeState = function(logger,
    stateBlobBytes, digestFn) {
  // Try parsing the envelope protocol buffer.
  var desc = invalidation.proto.PersistentStateBlob.getDescriptor();
  var stateBlob = invalidation.Utils.deserializeMessage(desc, stateBlobBytes,
      logger);

  // Check the envelope's digest against the recomputed digest from the state.
  var ticlState = (stateBlob == null) ? null : stateBlob.getTiclState();
  if (ticlState == null) {
    return null;
  }
  var digest =
      invalidation.PersistenceUtils.generateDigest(ticlState, digestFn);
  var serializedDigest = digest.serialize();
  if (serializedDigest != stateBlob.getAuthenticationCode()) {
    if (logger) {
      logger.warning('Ticl state failed MAC check: computed %s vs %s',
          digest, stateBlob.getAuthenticationCode());
    }
    return null;
  }
  return ticlState;
};

/**
 * Returns a message authentication code over {@code state}.
 *
 * @param {!invalidation.proto.PersistentTiclState} state The client state to
 *     be serialized.
 * @param {!invalidation.DigestFunction} digestFn The function used to compute
 *     the digest of the client state.
 * @return {!invalidation.DigestFunction.Digest} The mac/digest for the state.
 */
invalidation.PersistenceUtils.generateDigest = function(state, digestFn) {
  digestFn.reset();
  digestFn.update(invalidation.Utils.serializeMessage(state));
  return digestFn.getDigest();
};

//ipc/invalidation/javascript/internal/client/digeststore.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview  Interface for a store that allows objects to be added/removed
 *     along with the ability to get the digest for the whole or partial set of
 *     those objects.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.DigestStore');

goog.require('invalidation.proto.ObjectIdP');

/**
 * Interface for a digest store used for tracking a set of object ids.
 *
 * @interface
 * @export
 */
invalidation.DigestStore = function() {};

/**
 * Returns the number of elements.
 *
 * @return {number} The number of elements.
 */
invalidation.DigestStore.prototype.size = goog.abstractMethod;

/**
 * Returns whether {@code element} is in the store.
 *
 * @param {!invalidation.proto.ObjectIdP} element The object to be checked.
 * @return {boolean} Whether the element is present.
 */
invalidation.DigestStore.prototype.contains = goog.abstractMethod;

/**
 * Returns a digest of the desired objects.
 * <p>
 * NOTE: the digest computations <b>MUST NOT</b> depend on the order in which
 * the elements were added.
 *
 * @return {!invalidation.DigestFunction.Digest} The digest of the registered
 *     objects.
 */
invalidation.DigestStore.prototype.getDigest = goog.abstractMethod;

/**
 * Returns the elements whose digest prefixes begin with the bit prefix
 * {@code digestPrefix}. {@code prefixLen} is the length of {@code digestPrefix}
 * in bits, which may be less than {@code digestPrefix.length} (and may be 0).
 * The implementing class can return *more* objects than what has been specified
 * by {@code digestPrefix}, e.g., it could return all the objects in the store.
 *
 * @param {string} digestPrefix The prefix for which the digest is needed.
 * @param {number} prefixLen The length of the prefix in {@code digestPrefix}.
 * @return {!Array.<!invalidation.proto.ObjectIdP>} Elements for that prefix.
 *
 */
invalidation.DigestStore.prototype.getElements = goog.abstractMethod;

/**
 * Adds {@code elements} to the store. If any element in {@code elements} is
 * already present, the addition is a no-op for that element.
 *
 * @param {!Array.<!invalidation.proto.ObjectIdP>} elements The elements to be
 *     added.
 * @return {!Array.<!invalidation.proto.ObjectIdP>} The elements that were
 *     added.
 */
invalidation.DigestStore.prototype.add = goog.abstractMethod;

/**
 * Remove {@code elements} to the store. If any element in {@code elements} is
 * not present, the addition is a no-op for that element.
 *
 * @param {!Array.<!invalidation.proto.ObjectIdP>} elements The elements to be
 *     removed.
 * @return {!Array.<!invalidation.proto.ObjectIdP>} The elements that were
 *     removed.
 */
invalidation.DigestStore.prototype.remove = goog.abstractMethod;

/**
 * Removes all elements in this and returns them.
 *
 * @return {!Array.<!invalidation.proto.ObjectIdP>} The removed elements.
 */
invalidation.DigestStore.prototype.removeAll = goog.abstractMethod;

//ipc/invalidation/javascript/internal/client/recurringtask.js
// Copyright 2011 Google Inc. All Rights Reserved.

/**
 * @fileoverview An abstraction for scheduling recurring tasks. Combines
 * idempotent scheduling and smearing with conditional retries and exponential
 * backoff. Does not implement throttling. Designed to support a variety of use
 * cases, including the following capabilities.
 *
 * <ul>
 * <li>Idempotent scheduling, e.g., ensuring that a batching task is scheduled
 *  exactly once.
 * <li>Recurring tasks, e.g., periodic heartbeats.
 * <li>Retriable actions aimed at state change, e.g., sending initialization
 *  messages.
 * </ul>
 * Each instance of this class manages the state for a single task. See
 * invalidationclientimpl.js for examples.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.RecurringTask');

goog.require('invalidation.ExponentialBackoffDelayGenerator');
goog.require('invalidation.InternalBase');
goog.require('invalidation.NamedFunction');

/**
 * Implements a recurring task. The created task is first scheduled with a
 * smeared delay of {@code initialDelayMs}. If the {@code this.run()} returns
 * true on its execution, the task is rescheduled after a {@code timeoutDelayMs}
 * + smeared delay of {@code initialDelayMs} or {@code timeoutDelayMs} +
 * {@code delayGenerator.getNextDelay()} depending on whether the
 * {@code delayGenerator} is null or not.
 * <p>
 * @param {string} name Name of the task (for debugging purposes mostly).
 * @param {!invalidation.SystemResources.Scheduler} scheduler Scheduler for the
 *     scheduling the task as needed.
 * @param {!invalidation.SystemResources.Logger} logger A logger.
 * @param {!invalidation.Smearer} smearer For spreading/randomizing the delays.
 * @param {invalidation.ExponentialBackoffDelayGenerator} delayGenerator An
 *     exponential backoff generator for task retries.
 * @param {number} initialDelayMs The initial delay for scheduling the task.
 * @param {number} timeoutDelayMs The minimum time after which the task is
 *     rescheduled for a retry.
 *
 * @constructor
 * @extends {invalidation.InternalBase}
 */
invalidation.RecurringTask = function(name, scheduler, logger, smearer,
      delayGenerator, initialDelayMs, timeoutDelayMs) {

  // Cannot use goog.base since this code will not work with Rhino.
  invalidation.InternalBase.call(this);

  // For the specs of the instance variables that are specified in the
  // constructor, please see the specs there.

  /**
   * @type {string}
   * @private
   */
  this.name_ = name;

  /**
   * @type {!invalidation.SystemResources.Logger}
   * Visible to subclass.
   */
  this.logger = logger;

  /**
   * @type {!invalidation.SystemResources.Scheduler}
   * Visible to subclass.
   */
  this.scheduler = scheduler;

  /**
   * @type {number}
   * @private
   */
  this.initialDelayMs_ = initialDelayMs;

  /**
   * @type {number}
   * @private
   */
  this.timeoutDelayMs_ = timeoutDelayMs;

  /**
   * @type {!invalidation.Smearer}
   * Visible to subclass.
   */
  this.smearer = smearer;

   /**
    * @type {invalidation.ExponentialBackoffDelayGenerator}
    * @private
    */
  this.delayGenerator_ = delayGenerator;

  /**
   * @type {boolean}
   * @private
   */
  this.isScheduled_ = false;

  /**
   * The function that is scheduled for the task.
   * @type {!invalidation.NamedFunction}
   * @private
   */
  this.task_ = new invalidation.NamedFunction(name,
    goog.bind(function() {
      this.isScheduled_ = false;
      if (this.runTask()) {
        // The task asked to be rescheduled, so reschedule it after a timeout
        // has occured.
        goog.asserts.assert((this.delayGenerator_ != null) ||
          (this.initialDelayMs_ != 0),
            'Spinning: No exp back off and initialdelay is zero');
          this.ensureScheduled_(true, 'Retry');
        } else if (delayGenerator != null) {
          // The task asked not to be rescheduled. Treat it as having
          // 'succeeded' and reset the delay generator.
          this.delayGenerator_.reset();
        }
      }, this));
};
goog.inherits(invalidation.RecurringTask, invalidation.InternalBase);

/**
 * Run the task and return true if the task should be rescheduled after a
 * timeout. If false is returned, the task is not scheduled again until
 * {@code ensureScheduled} is called again.
 *
 * @return {boolean} Returns true iff the task should be rescheduled.
 */
invalidation.RecurringTask.prototype.runTask = goog.abstractMethod;

/**
 * @return {!invalidation.Smearer} The smearer used for randomizing delays.
 */
invalidation.RecurringTask.prototype.getSmearer = function() {
  return this.smearer;
};

/**
 * @return {invalidation.ExponentialBackoffDelayGenerator} The delay generator,
 *     if any.
 */
invalidation.RecurringTask.prototype.getDelayGenerator = function() {
  return this.delayGenerator_;
};

/**
 * Ensures that the task is scheduled (with {@code debugReason} as the reason to
 * be printed for debugging purposes). If the task has been scheduled, it is not
 * scheduled again.
 * <p>
 * REQUIRES: Must be called from the scheduler thread
 *
 * @param {string} debugReason A reason to be printed for debugging purposes.
 */
invalidation.RecurringTask.prototype.ensureScheduled = function(debugReason) {
  this.ensureScheduled_(false, debugReason);
};

/**
 * Ensures that the task is scheduled if it is already not scheduled. If already
 * scheduled, this method is a no-op.
 *
 * @param {boolean} isRetry If this is {@code false}, smears the {@code
 *     initialDelayMs} and uses that delay for scheduling. If {@code isRetry} is
 *     true, it determines the new delay to be {@code timeoutDelayMs} + {@code
 *     delayGenerator.getNextDelay()} if {@code delayGenerator} is non-null. If
 *     {@code delayGenerator} is null, schedules the task after a delay of
 *     {@code timeoutDelayMs} + smeared value of {@code initialDelayMs}.
 * @param {string} debugReason A reason to be printed for debugging purposes.
 * @private
 */
invalidation.RecurringTask.prototype.ensureScheduled_ =
    function(isRetry, debugReason) {
  if (this.isScheduled_) {
    return;
  }
  var delayMs;

  if (isRetry) {
    // For a retried task, determine the delay to be timeout + extra delay
    // (depending on whether a delay generator was provided or not).
    if (this.delayGenerator_ != null) {
        delayMs = this.timeoutDelayMs_ + this.delayGenerator_.getNextDelay();
      } else {
        delayMs = this.timeoutDelayMs_ +
            this.smearer.getSmearedDelay(this.initialDelayMs_);
      }
    } else {
      delayMs = this.smearer.getSmearedDelay(this.initialDelayMs_);
    }

    this.logger.fine('[%s] Scheduling %s with a delay %s, Now = %s',
        debugReason, this.name_, delayMs, this.scheduler.getCurrentTimeMs());
    this.scheduler.schedule(delayMs, this.task_);
    this.isScheduled_ = true;
};

//ipc/invalidation/javascript/internal/client/runstate.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview An abstraction that keeps track of whether the caller is
 * started or stopped and only allows the following transitions:
 * NOT_STARTED -> STARTED -> STOPPED.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.RunState');
goog.require('invalidation.proto.RunStateP');

/**
 * Constructs a {@code RunState} object in the {@code NOT_STARTED} state.
 *
 * @constructor
 */
invalidation.RunState = function() {

  /**
   * Current running state.
   *
   * @type {!invalidation.proto.RunStateP.State}
   * @private
   */
  this.currentState_ = invalidation.proto.RunStateP.State.NOT_STARTED;
};

/**
 * Marks the current state to be STARTED.
 * <p>
 * REQUIRES: Current state is NOT_STARTED.
 */
invalidation.RunState.prototype.start = function() {
  goog.asserts.assert(
    this.currentState_ == invalidation.proto.RunStateP.State.NOT_STARTED,
    'Cannot start: ', this.currentState_);
  this.currentState_ = invalidation.proto.RunStateP.State.STARTED;
};

/**
 * Marks the current state to be STOPPED.
 * <p>
 * REQUIRES: Current state is STARTED.
 */
invalidation.RunState.prototype.stop = function() {
  goog.asserts.assert(
    this.currentState_ == invalidation.proto.RunStateP.State.STARTED,
    'Cannot stop: ', this.currentState_);
  this.currentState_ = invalidation.proto.RunStateP.State.STOPPED;
};

/**
 * @return {boolean} Returns true iff {@code start} has been called on this but
 *     {@code stop} has not been called.
 */
invalidation.RunState.prototype.isStarted = function() {
  return this.currentState_ == invalidation.proto.RunStateP.State.STARTED;
};

/**
 * @return {boolean} Returns true iff {@code start} and {@code stop} have been
 *    called on this object.
 */
invalidation.RunState.prototype.isStopped = function() {
  return this.currentState_ == invalidation.proto.RunStateP.State.STOPPED;
};

//ipc/invalidation/javascript/internal/client/statistics.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview Statistics for the Ticl, e.g., number of registration calls,
 *    number of token mismatches, etc.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.Statistics');

goog.require('goog.structs.Map');

// Implementation: To classify the statistics a bit better, we have a few enums
// to track different types of statistics, e.g., sent message types, errors,
// etc. For each statistic type, we create a map and provide a method to record
// an event for each type of statistic.

/**
 * @constructor
 */
invalidation.Statistics = function() {

  // Maps for each type of Statistic to keep track of how many times each event
  // has occurred.

  /**
   * Types of messages sent to the server.
   * @type {!goog.structs.Map.<string, number>}
   * @private
   */
  this.sentMessageTypes_ = new goog.structs.Map();

  /**
   * Types of messages received from the server.
   * @type {!goog.structs.Map.<string, number>}
   * @private
   */
  this.receivedMessageTypes_ = new goog.structs.Map();

  /**
   * Types of operations received from the application.
   * @type {!goog.structs.Map.<string, number>}
   * @private
   */
  this.incomingOperationTypes_ = new goog.structs.Map();

  /**
   * Types of upcalls made by the Ticl to the application.
   * @type {!goog.structs.Map.<string, number>}
   * @private
   */
  this.listenerEventTypes_ = new goog.structs.Map();

  /**
   * Types of errors encountered by the Ticl.
   * @type {!goog.structs.Map.<string, number>}
   * @private
   */
  this.clientErrorTypes_ = new goog.structs.Map();

  // Initialize all the enum maps
  invalidation.Statistics.initializeMap(this.sentMessageTypes_,
      goog.object.getValues(invalidation.Statistics.SentMessageType));
  invalidation.Statistics.initializeMap(this.receivedMessageTypes_,
      goog.object.getValues(invalidation.Statistics.ReceivedMessageType));
  invalidation.Statistics.initializeMap(this.incomingOperationTypes_,
      goog.object.getValues(invalidation.Statistics.IncomingOperationType));
  invalidation.Statistics.initializeMap(this.listenerEventTypes_,
      goog.object.getValues(invalidation.Statistics.ListenerEventType));
  invalidation.Statistics.initializeMap(this.clientErrorTypes_,
      goog.object.getValues(invalidation.Statistics.ClientErrorType));
};

/**
 * Initialzes all values for {@code keys} in {@code map} to be 0.
 *
 * @param {!goog.structs.Map.<number, number>} map Map to be initialized.
 * @param {!Array.<number>} keys Keys in the map that need to be initialized.
 */
invalidation.Statistics.initializeMap = function(map, keys) {
  for (var i = 0; i < keys.length; i++) {
    map.set(keys[i], 0);
  }
};

/**
 * Returns a copy of this.
 *
 * @return {!invalidation.Statistics} Copy of statistics.
 */
invalidation.Statistics.prototype.getCopyForTest = function() {
  var statistics = new invalidation.Statistics();
  statistics.sentMessageTypes_.addAll(this.sentMessageTypes_);
  statistics.receivedMessageTypes_.addAll(this.receivedMessageTypes_);
  statistics.incomingOperationTypes_.addAll(this.incomingOperationTypes_);
  statistics.listenerEventTypes_.addAll(this.listenerEventTypes_);
  statistics.clientErrorTypes_.addAll(this.clientErrorTypes_);
  return statistics;
};

/**
 * Returns the counter value for {@code clientErrorType}.
 *
 * @param {!invalidation.Statistics.ClientErrorType} clientErrorType The type of
 *     client error for which information is needed.
 * @return {number} The counter value for {@code clientErrorType}.
 */
invalidation.Statistics.prototype.getClientErrorCounterForTest =
    function(clientErrorType) {
  return /** @type {number} */ (this.clientErrorTypes_.get(clientErrorType));
};

/**
 * Returns the counter value for {@code receivedMessageType}.
 *
 * @param {!invalidation.Statistics.ReceivedMessageType} receivedMessageType The
 *     type of received message for which information is needed.
 * @return {number} The counter value for {@code receivedMessageType}.
 */
invalidation.Statistics.prototype.getReceivedMessageCounterForTest =
    function(receivedMessageType) {
  return /** @type {number} */ (this.receivedMessageTypes_.get(
      receivedMessageType));
};

/**
 * Records the fact that a message of type {@code sentMessageType} has been
 * sent.
 *
 * @param {!invalidation.Statistics.SentMessageType} sentMessageType Type of
 *     the sent message.
 **/
invalidation.Statistics.prototype.recordSentMessage =
    function(sentMessageType) {
  invalidation.Statistics.incrementValue(this.sentMessageTypes_,
      sentMessageType);
};

/**
 * Records the fact that a message of type {@code receivedMessageType} has
 * been received.
 *
 * @param {!invalidation.Statistics.ReceivedMessageType} receivedMessageType
 *     Type of the received message.
 */
invalidation.Statistics.prototype.recordReceivedMessage =
    function(receivedMessageType) {
  invalidation.Statistics.incrementValue(this.receivedMessageTypes_,
      receivedMessageType);
};

/**
 * Records the fact that the application has made a call of type
 * {@code incomingOperationType}.
 *
 * @param {!invalidation.Statistics.IncomingOperationType} incomingOperationType
 *     Type of operation received from the application.
 */
invalidation.Statistics.prototype.recordIncomingOperation =
    function(incomingOperationType) {
  invalidation.Statistics.incrementValue(this.incomingOperationTypes_,
      incomingOperationType);
};

/**
 * Records the fact that the listener has issued an event of type
 * {@code listenerEventType}.
 *
 * @param {!invalidation.Statistics.ListenerEventType} listenerEventType Type of
 *     listener event invoked on the application.
 */
invalidation.Statistics.prototype.recordListenerEvent =
    function(listenerEventType) {
  invalidation.Statistics.incrementValue(this.listenerEventTypes_,
      listenerEventType);
};

 /**
  * Records the fact that the client has observed an error of type
  * {@code clientErrorType}.
  *
  * @param {!invalidation.Statistics.ClientErrorType} clientErrorType Type of
  *     error encountered at the client.
  */
invalidation.Statistics.prototype.recordError = function(clientErrorType) {
  invalidation.Statistics.incrementValue(this.clientErrorTypes_,
      clientErrorType);
};

/**
 * Modifies {@code performanceCounters} to contain all the statistics that are
 * non-zero. Each pair has the name of the statistic event and the number of
 * times that event has occurred since the client started.
 *
 * @param {!goog.structs.Map.<string,number>} performanceCounters The
 *     performance counters that are filled with non-zero values.
 */
invalidation.Statistics.prototype.getNonZeroStatistics =
    function(performanceCounters) {
  // Add the non-zero values from the different maps to performanceCounters.
  invalidation.Statistics.fillWithNonZeroStatistics(this.sentMessageTypes_,
      performanceCounters, 'SentMessageType');
  invalidation.Statistics.fillWithNonZeroStatistics(this.receivedMessageTypes_,
      performanceCounters, 'ReceivedMessageType');
  invalidation.Statistics.fillWithNonZeroStatistics(
      this.incomingOperationTypes_, performanceCounters,
      'IncomingOperationType');
  invalidation.Statistics.fillWithNonZeroStatistics(this.listenerEventTypes_,
      performanceCounters, 'ListenerEventType');
  invalidation.Statistics.fillWithNonZeroStatistics(this.clientErrorTypes_,
      performanceCounters, 'ClientErrorType');
};

/**
 * Modifies {@code result} to contain those statistics from {@code map} whose
 * value is > 0.
 *
 * @param {!goog.structs.Map.<string, number>} map Map whose data is extraced.
 * @param {!goog.structs.Map.<string, number>} destination Map in which data is
 *     added.
 * @param {string} prefix The string used to prefix every key from {@code map}
 *     before adding to {@code destination}.
 */
invalidation.Statistics.fillWithNonZeroStatistics = function(map, destination,
    prefix) {
  var keys = map.getKeys();
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var statisticValue = /** @type {number} */ (map.get(key));
    var destinationKey = prefix + '.' + key;
    if (statisticValue > 0) {
      destination.set(destinationKey, statisticValue);
    }
  }
};

/**
 * Increments the value of {@code map}[{@code key}] by 1.
 *
 * @param {!goog.structs.Map.<string, number>} map The map to mutate.
 * @param {string} key The key whose value is incremented.
 */
invalidation.Statistics.incrementValue = function(map, key) {
  map.set(key, map.get(key) + 1);
};

/**
 * Types of messages sent to the server: {@code ClientToServerMessage} for
 * their description.
 *
 * @enum {string}
 */
invalidation.Statistics.SentMessageType = {
  INFO: 'INFO',

  INITIALIZE: 'INITIALIZE',

  INVALIDATION_ACK: 'INVALIDATION_ACK',

  REGISTRATION: 'REGISTRATION',

  REGISTRATION_SYNC: 'REGISTRATION_SYNC',

  /**
   * Refers to the actual ClientToServerMessage message sent on the network.
   */
  TOTAL: 'TOTAL'
};

/**
 * Types of messages received from the server: {@code ServerToClientMessage} for
 * their description.
 *
 * @enum {string}
 */
invalidation.Statistics.ReceivedMessageType = {
  INFO_REQUEST: 'INFO_REQUEST',

  INVALIDATION: 'INVALIDATION',

  REGISTRATION_STATUS: 'REGISTRATION_STATUS',

  REGISTRATION_SYNC_REQUEST: 'REGISTRATION_SYNC_REQUEST',

  TOKEN_CONTROL: 'TOKEN_CONTROL',

  ERROR: 'ERROR',

  CONFIG_CHANGE: 'CONFIG_CHANGE',

  /**
   * Refers to the actual ServerToClientMessage messages received from the
   * network.
   */
  TOTAL: 'TOTAL'
};

/**
 * Interesting API calls coming from the application
 * ({@code InvalidationClient}).
 *
 * @enum {string}
 */
invalidation.Statistics.IncomingOperationType = {
  ACKNOWLEDGE: 'ACKNOWLEDGE',

  REGISTRATION: 'REGISTRATION',

  UNREGISTRATION: 'UNREGISTRATION'
};

/**
 * Different types of events issued by the {@code InvalidationListener}).
 *
 *  @enum {string}
 */
invalidation.Statistics.ListenerEventType = {

  INFORM_ERROR: 'INFORM_ERROR',

  INFORM_REGISTRATION_FAILURE: 'INFORM_REGISTRATION_FAILURE',

  INFORM_REGISTRATION_STATUS: 'INFORM_REGISTRATION_STATUS',

  INVALIDATE: 'INVALIDATE',

  INVALIDATE_ALL: 'INVALIDATE_ALL',

  INVALIDATE_UNKNOWN: 'INVALIDATE_UNKNOWN',

  REISSUE_REGISTRATIONS: 'REISSUE_REGISTRATIONS'
};

/** Different types of errors observed by the Ticl.
 *
 *  @enum {string}
 */
invalidation.Statistics.ClientErrorType = {
  /**
   * Acknowledge call received from client with a bad handle.
   */
  ACKNOWLEDGE_HANDLE_FAILURE: 'ACKNOWLEDGE_HANDLE_FAILURE',

  /**
   * Incoming message dropped due to parsing, validation problems.
   */
  INCOMING_MESSAGE_FAILURE: 'INCOMING_MESSAGE_FAILURE',

  /**
   * Tried to send an outgoing message that was invalid.
   */
  OUTGOING_MESSAGE_FAILURE: 'OUTGOING_MESSAGE_FAILURE',

  /**
   * Persistent state failed to deserialize correctly.
   */
  PERSISTENT_DESERIALIZATION_FAILURE: 'PERSISTENT_DESERIALIZATION_FAILURE',

  /**
   * Read of blob from persistent state failed.
   */
  PERSISTENT_READ_FAILURE: 'PERSISTENT_READ_FAILURE',

  /**
   * Write of blob from persistent state failed.
   */
  PERSISTENT_WRITE_FAILURE: 'PERSISTENT_WRITE_FAILURE',

  /**
   * Message received with incompatible protocol version.
   */
  PROTOCOL_VERSION_FAILURE: 'PROTOCOL_VERSION_FAILURE',

  /**
   * Registration at client and server is different, e.g., client thinks it is
   * registered while the server says it is unregistered (of course, sync will
   * fix it).
   */
  REGISTRATION_DISCREPANCY: 'REGISTRATION_DISCREPANCY',

  /**
   * The nonce from the server did not match the current nonce by the client.
   */
  NONCE_MISMATCH: 'NONCE_MISMATCH',

  /**
   * The current token at the client is different from the token in the
   * incoming message.
   */
  TOKEN_MISMATCH: 'TOKEN_MISMATCH',

  /**
   * No message sent due to token missing.
   */
  TOKEN_MISSING_FAILURE: 'TOKEN_MISSING_FAILURE',

  /**
   * Received a message with a token (transient) failure.
   */
  TOKEN_TRANSIENT_FAILURE: 'TOKEN_TRANSIENT_FAILURE'
};

//ipc/invalidation/javascript/internal/client/ticlmessagevalidator.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview  Validator for Ticl-Registrar messages.
 *
 * @author adya@google.com (Atul Adya)
 * @author ghc@google.com (Greg Cooper)
 */

goog.provide('invalidation.TiclMessageValidator');

goog.require('invalidation.util.MessageValidator');

/**
 * Message validator for the Ticl.
 * @constructor
 *
 * @param {!invalidation.SystemResources.Logger} logger The logger
 *     used by the validator.
 * @extends {invalidation.util.MessageValidator}
 */
invalidation.TiclMessageValidator = function(logger) {
  invalidation.util.MessageValidator.call(this, logger);

  // Local bindings for constraints, to make specifications more readable.

  /**
   * Allows a field to be present.  This is a vacuous constraint which is
   * defined solely to make validation specs clearer to read.
   *
   * @param {!goog.proto2.FieldDescriptor} field The allowed field.
   * @param {!goog.proto2.Message} message A message.
   * @return {boolean} To indicate the field is allowed.
   */
  var allowed = function(field, message) {
    return true;
  };

  /**
   * Requires a field to be present.
   *
   * @type {!invalidation.util.Constraint}
   */
  var required = goog.bind(this.required, this);

  /**
   * Given a number {@code value}, returns a constraint that requires a field,
   * if present, to be greater than or equal to {@code value}.
   *
   * @type {function(number): !invalidation.util.Constraint}
   */
  var greaterOrEqualTo = goog.bind(function(value) {
      // Return a partially-instantiated call to this.greaterOrEqualTo.
      return goog.bind(this.greaterOrEqualTo, this, value);
    }, this);

  /**
   * Requires a field value, if present, to be non-negative.
   *
   * @type {!invalidation.util.Constraint}
   */
  var nonNegative = greaterOrEqualTo(0);

  /**
   * Requires a string field, if present, to be non-empty.
   *
   * @type {!invalidation.util.Constraint}
   */
  var nonEmpty = goog.bind(this.nonEmpty, this);

  /**
   * Allows any number of occurrences of a repeated field.  This is equivalent
   * to {@code allowed} but defined separately to improve readability for
   * repeated fields.
   *
   * @type {!invalidation.util.Constraint}
   */
  var anyNumberOf = allowed;

  /**
   * Requires at least one occurrence of a repeated field.  This is equivalent
   * to {@code required} but defined separately to improve readability for
   * repeated fields.
   *
   * @type {!invalidation.util.Constraint}
   */
  var atLeastOneOf = required;

  /**
   * An object whose keys are message type names and whose values are
   * specifications of the constraints on the corresponding messages.  The
   * {@code validate} method looks up the spec for the message it's validating
   * and checks that all the constraints in the spec are satisfied.
   *
   * @type {!Object.<!invalidation.util.MessageSpec>}
   * @private
   */
  this.specifications_ = {
    'Version': {
      'major_version': [required, nonNegative],
      'minor_version': [required, nonNegative]
    },
    'ProtocolVersion': {
      'version': [required]
    },
    'ObjectIdP': {
      'name': [required],
      'source': [required, nonNegative]
    },
    'InvalidationP': {
      'object_id': [required],
      'is_known_version': [required],
      'version': [required, nonNegative],
      'payload': [allowed],
      'is_trickle_restart': [allowed],
      // Bridge arrival time not actually used or exposed in client.
      'bridge_arrival_time_ms_deprecated': [allowed]
    },
    'RegistrationP': {
      'object_id': [required],
      'op_type': [required]
    },
    'RegistrationSummary': {
      'num_registrations': [required, nonNegative],
      'registration_digest': [required, nonEmpty]
    },
    'InvalidationMessage': {
      'invalidation': [atLeastOneOf]
    },
    'ClientHeader': {
      'protocol_version': [required],
      'client_token': [allowed, nonEmpty],
      'registration_summary': [allowed],
      'client_time_ms': [required],
      'max_known_server_time_ms': [required],
      'client_type': [allowed],
      'message_id': [allowed]
    },
    'ApplicationClientIdP': {
      'client_type': [required],
      'client_name': [required, nonEmpty]
    },
    'InitializeMessage': {
      'client_type': [required],
      'nonce': [required, nonEmpty],
      'digest_serialization_type': [required],
      'application_client_id': [required]
    },
    'RegistrationMessage': {
      'registration': [atLeastOneOf]
    },
    'ClientVersion': {
      'version': [required],
      'platform': [required],
      'language': [required],
      'application_info': [required]
    },
    'PropertyRecord': {
      'name': [required],
      'value': [required]
    },
    'InfoMessage': {
      'client_version': [required],
      'config_parameter': [anyNumberOf],
      'performance_counter': [anyNumberOf],
      'client_config': [allowed],
      'server_registration_summary_requested': [allowed]
    },
    'ClientConfigP': {
      'version': [required],
      'network_timeout_delay_ms': [allowed],
      'write_retry_delay_ms': [allowed],
      'heartbeat_interval_ms': [allowed],
      'perf_counter_delay_ms': [allowed],
      'max_exponential_backoff_factor': [allowed],
      'smear_percent': [allowed],
      'is_transient': [allowed],
      'initial_persistent_heartbeat_delay_ms': [allowed],
      'channel_supports_offline_delivery': [allowed],
      'protocol_handler_config': [required],
      'offline_heartbeat_threshold_ms': [allowed],
      'allow_suppression': [allowed]
    },
    'ProtocolHandlerConfigP': {
      'batching_delay_ms': [allowed],
      'rate_limit': [anyNumberOf]
    },
    'RateLimitP': {
      'window_ms': [required, greaterOrEqualTo(1000)],
      'count': [required]
    },
    'RegistrationSubtree': {
      'registered_object': [anyNumberOf]
    },
    'RegistrationSyncMessage': {
      'subtree': [atLeastOneOf]
    },
    'ClientToServerMessage': {
      'header': [required],
      'info_message': [allowed],
      'initialize_message': [allowed],
      'invalidation_ack_message': [allowed],
      'registration_message': [allowed],
      'registration_sync_message': [allowed]
    },
    'ServerHeader': {
      'protocol_version': [required],
      'client_token': [required, nonEmpty],
      'registration_summary': [allowed],
      'server_time_ms': [required, nonNegative],
      'message_id': [allowed, nonEmpty]
    },
    'StatusP': {
      'code': [required],
      'description': [allowed]
    },
    'TokenControlMessage': {
      'new_token': [allowed]
    },
    'ErrorMessage': {
      'code': [required],
      'description': [required]
    },
    'RegistrationStatus': {
      'registration': [required],
      'status': [required]
    },
    'RegistrationStatusMessage': {
      'registration_status': [atLeastOneOf]
    },
    'RegistrationSyncRequestMessage': {
      // No fields.
    },
    'InfoRequestMessage': {
      'info_type': [atLeastOneOf]
    },
    'ConfigChangeMessage': {
      'next_message_delay_ms': [allowed, greaterOrEqualTo(1)]
    },
    'ServerToClientMessage': {
      'header': [required],
      'token_control_message': [allowed],
      'invalidation_message': [allowed],
      'registration_status_message': [allowed],
      'registration_sync_request_message': [allowed],
      'config_change_message': [allowed],
      'info_request_message': [allowed],
      'error_message': [allowed]
    }
  };
};
goog.inherits(
    invalidation.TiclMessageValidator, invalidation.util.MessageValidator);

/** @override */
invalidation.TiclMessageValidator.prototype.getSpecifications = function() {
  return this.specifications_;
};

/**
 * Returns true iff the client {@code message} is valid.
 *
 * @param {!invalidation.proto.ClientToServerMessage} message The message
 *     to be validated.
 * @return {boolean} Where the client message is valid or not.
 */
invalidation.TiclMessageValidator.prototype.isClientMessageValid = function(
    message) {
  var result = this.validate(message);
  if (!result) {
    return false;
  }

  // Aside from the local constraints on the fields of the C2S message, there's
  // a global constraint that it either contains a client token or an
  // initialization message.
  var hasClientToken = message.getHeader().hasClientToken();
  if (message.hasInitializeMessage()) {
    return !hasClientToken;
  } else {
    return hasClientToken;
  }
};

/**
 * Returns true iff the server {@code message} is valid.
 *
 * @param {!invalidation.proto.ServerToClientMessage} message The message
 *     to be validated.
 * @return {boolean} Where the server message is valid or not.
 */
invalidation.TiclMessageValidator.prototype.isServerMessageValid = function(
    message) {
  return this.validate(message);
};

/**
 * Returns true iff the {@code invalidation} is valid.
 *
 * @param {!invalidation.proto.InvalidationP} invalidation The invalidation
 *     to be validated.
 * @return {boolean} Where the client message is valid or not.
 */
invalidation.TiclMessageValidator.prototype.isInvalidationValid = function(
    invalidation) {
  return this.validate(invalidation);
};

//ipc/invalidation/javascript/internal/client/protocolhandler.js
// Copyright 2011 Google Inc. All rights reserved.v

/**
 * @fileoverview A layer for interacting with low-level protocol messages.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.ProtocolHandler');
goog.provide('invalidation.ProtocolListener');
goog.provide('invalidation.ServerMessageHeader');

goog.require('goog.proto2.Message');
goog.require('goog.proto2.TextFormatSerializer');
goog.require('goog.string.format');
goog.require('goog.structs.Map');
goog.require('invalidation.CommonProtos');
goog.require('invalidation.DigestStore');
goog.require('invalidation.NamedFunction');
goog.require('invalidation.RecurringTask');
goog.require('invalidation.RunState');
goog.require('invalidation.Statistics');
goog.require('invalidation.TiclMessageValidator');
goog.require('invalidation.Utils');
goog.require('invalidation.proto.ClientConfigP');
goog.require('invalidation.proto.ClientHeader');
goog.require('invalidation.proto.ClientToServerMessage');
goog.require('invalidation.proto.InfoMessage');
goog.require('invalidation.proto.InvalidationP');
goog.require('invalidation.proto.ObjectIdP');
goog.require('invalidation.proto.ProtocolHandlerConfigP');
goog.require('invalidation.proto.RegistrationP');
goog.require('invalidation.proto.RegistrationSubtree');
goog.require('invalidation.proto.RegistrationSyncMessage');
goog.require('invalidation.proto.ServerToClientMessage');
goog.require('invalidation.proto.StatusP');

/**
 * Parses messages from the server and calls appropriate functions on the
 * ProtocolListener to handle various types of message content.  Also buffers
 * message data from the client and constructs and sends messages to the server.
 *
 * @param {!invalidation.proto.ProtocolHandlerConfigP} config Configuration for
 *     the protocol handler.
 * @param {!invalidation.SystemResources} resources Resources to use.
 * @param {!invalidation.Smearer} smearer a smearer to randomize delays.
 * @param {!invalidation.Statistics} statistics Track information about messages
 *     sent/received, etc.
 * @param {number} clientType Client typecode.
 * @param {string} applicationName Name of the application using the library
 *     (for debugging/monitoring).
 * @param {!invalidation.ProtocolListener} listener Callback for protocol
 *     events.
 * @param {!invalidation.TiclMessageValidator} msgValidator The validator for
 *     checking incoming and outgoing messages.
 *
 * @constructor
 */
invalidation.ProtocolHandler = function(config, resources, smearer, statistics,
    clientType, applicationName, listener, msgValidator) {

  // Rhino returns the getPlatform() as an object and not as a string.
  // Hence, resources.getPlatform() is converted to a string below.

  /**
   * Information about the client, e.g., application name, OS, etc.
   * @type {!invalidation.proto.ClientVersion}
   * @private
   */
  this.clientVersion_ = invalidation.CommonProtos.newClientVersion(
      resources.getPlatform() + '', 'JS', applicationName);

  /**
   * A logger.
   * @type {!invalidation.SystemResources.Logger}
   */
  this.logger = resources.getLogger();

  /**
   * Scheduler for the client's internal processing.
   * @type {!invalidation.SystemResources.Scheduler}
   */
  this.internalScheduler = resources.getInternalScheduler();

  /**
   * Network channel for sending and receiving messages to and from the server.
   * @type {!invalidation.SystemResources.NetworkChannel}
   * @private
   */
  this.network_ = resources.getNetwork();

  /**
   * The protocol listener.
   * @type {!invalidation.ProtocolListener}
   * @private
   */
  this.listener_ = listener;

  /**
   * A validator for checking incoming and outgoing Ticl messages.
   * @type {!invalidation.TiclMessageValidator}
   * @private
   */
  this.msgValidator_ = msgValidator;

  /**
   * A debug message id that is added to every message to the server.
   * @type {number}
   * @private
   */
  this.messageId_ = 1;

  // State specific to a client. If we want to support multiple clients, this
  // could be in a map or could be eliminated (e.g., no batching).

  /**
   * The last known time from the server.
   * @type {number}
   * @private
   */
  this.lastKnownServerTimeMs_ = 0;

  /**
   * The next time before which a message cannot be sent to the server. If
   * this is less than current time, a message can be sent at any time.
   * @type {number}
   * @private
   */
  this.nextMessageSendTimeMs_ = 0;

  /**
   * Statistics objects to track number of sent messages, etc.
   * @type {!invalidation.Statistics}
   * @private
   */
  this.statistics_ = statistics;

  /**
   * The object that batches pending messages to be sent to the server.
   * @type {!invalidation.ProtocolHandler.Batcher}
   * @private
   */
  this.batcher_ =
      new invalidation.ProtocolHandler.Batcher(resources, statistics);

  /**
   * Client typecode.
   * @type {number}
   * @private
   */
  this.clientType_ = clientType;
};

/**
 * Class that batches messages to the server.
 *
 * @param {!invalidation.SystemResources} resources The system resources.
 * @param {!invalidation.Statistics} statistics The statistics.
 * @constructor
 */
invalidation.ProtocolHandler.Batcher = function(resources, statistics) {
  /**
   * Statistics to be updated when messages are created.
   * @type {!invalidation.Statistics}
   * @private
   **/
  this.statistics_ = statistics;

  /**
   * Resources used for logging and thread assertions.
   * @type {!invalidation.SystemResources}
   * @private
   **/
  this.resources_ = resources;

  /**
   * Set of pending registrations stored as a map for overriding later
   * operations. (ObjectIdP string -> RegistrationP)
   * @type {!goog.structs.Map.<string, invalidation.proto.RegistrationP>}
   * @private
   */
  this.pendingRegistrations_ = new goog.structs.Map();

  /**
   * Set of pending invalidation acks (set of InvalidationP objects).
   * (InvalidationIdP string -> InvalidationP)
   * @type {!goog.structs.Map.<string, invalidation.proto.InvalidationP>}
   * @private
   */
  this.pendingAckedInvalidations_ = new goog.structs.Map();

  /**
   * Set of pending registration sub trees for registration sync.
   * (set of RegistrationSubtree objects)
   * @type {!goog.structs.Map.<string, !invalidation.proto.RegistrationSubtree>}
   * @private
   */
  this.pendingRegSubtrees_ = new goog.structs.Map();

  /**
   * Pending initialization message to send to the server, if any.
   * @type {?invalidation.proto.InitializeMessage}
   * @private
   */
  this.pendingInitializeMessage_ = null;

  /**
   * Pending info message to send to the server, if any.
   * @type {?invalidation.proto.InfoMessage}
   * @private
   */
  this.pendingInfoMessage_ = null;
};

/**
 * Sets the initialize message to be sent to the server.
 * @param {!invalidation.proto.InitializeMessage} msg The initialize message.
 */
invalidation.ProtocolHandler.Batcher.prototype.setInitializeMessage =
    function(msg) {
  this.pendingInitializeMessage_ = msg;
};

/**
 * Sets the initialize message to be sent to the server.
 * @param {!invalidation.proto.InfoMessage} msg The info message.
 */
invalidation.ProtocolHandler.Batcher.prototype.setInfoMessage =
    function(msg) {
  this.pendingInfoMessage_ = msg;
};

/**
 * Adds a registration request to be sent to the server.
 * @param {!invalidation.proto.ObjectIdP} objectId The object to operate on.
 * @param {!boolean} isReg Whether to register or unregister.
 */
invalidation.ProtocolHandler.Batcher.prototype.addRegistration =
    function(objectId, isReg) {
  var regOp = invalidation.CommonProtos.newRegistrationP(objectId, isReg);
  this.pendingRegistrations_.set(
      invalidation.Utils.getMessageKey(objectId),
      regOp);
};

/**
 * Adds an acknowledgement to be sent to the server.
 * @param {!invalidation.proto.InvalidationP} ack The invalidation to ack.
 */
invalidation.ProtocolHandler.Batcher.prototype.addAck = function(ack) {
  this.pendingAckedInvalidations_.set(
      invalidation.Utils.getMessageKey(ack),
      ack);
};

/**
 * Adds a registration subtree to be sent to the server.
 * @param {!invalidation.proto.RegistrationSubtree} regSubtree The subtree.
 */
invalidation.ProtocolHandler.Batcher.prototype.addRegSubtree =
    function(regSubtree) {
  this.pendingRegSubtrees_.set(
      invalidation.Utils.getMessageKey(regSubtree),
      regSubtree);
};

/**
 * Returns a {@code ClientToServerMessage} to be sent to the server. Crucially,
 * the message does <b>NOT</b> include the header.
 *
 * @param {!boolean} hasClientToken Whether the client currently holds a token.
 * @return {?invalidation.proto.ClientToServerMessage} The message to send.
 */
invalidation.ProtocolHandler.Batcher.prototype.toMessage =
    function(hasClientToken) {
  var message = new invalidation.proto.ClientToServerMessage();
  var logger = this.resources_.getLogger();

  // Check if an initialize message needs to be sent.
  if (this.pendingInitializeMessage_ != null) {
    this.statistics_.recordSentMessage(
        invalidation.Statistics.SentMessageType.INITIALIZE);
    message.setInitializeMessage(this.pendingInitializeMessage_);
    this.pendingInitializeMessage_ = null;
  }

  // Note: Even if an initialize message is being sent, we can send additional
  // messages such as registration messages, etc to the server. But if there is
  // no token and an initialize message is not being sent, we cannot send any
  // other message.

  if (!hasClientToken && !message.hasInitializeMessage()) {
    // Cannot send any message.
    logger.warning('Cannot send message since no token and no ' +
        'initialize msg: %s', message.toString());
    this.statistics_.recordError(
        invalidation.Statistics.ClientErrorType.TOKEN_MISSING_FAILURE);
    return null;
  }

  // Check for pending batched operations and add to message builder if needed.

  // Add reg, acks, reg subtrees - clear them after adding.
  if (!this.pendingAckedInvalidations_.isEmpty()) {
    message.setInvalidationAckMessage(this.createInvalidationAckMessage());
    this.statistics_.recordSentMessage(
        invalidation.Statistics.SentMessageType.INVALIDATION_ACK);
  }

  // Check regs.
  if (!this.pendingRegistrations_.isEmpty()) {
    message.setRegistrationMessage(this.createRegistrationMessage());
    this.statistics_.recordSentMessage(
        invalidation.Statistics.SentMessageType.REGISTRATION);
  }

  // Check reg substrees.
  if (!this.pendingRegSubtrees_.isEmpty()) {
    var syncMessage = new invalidation.proto.RegistrationSyncMessage();
    var pendingTrees = this.pendingRegSubtrees_.getValues();
    for (var i = 0; i < pendingTrees.length; i++) {
      syncMessage.addSubtree(pendingTrees[i]);
    }
    message.setRegistrationSyncMessage(syncMessage);
    this.pendingRegSubtrees_.clear();
    this.statistics_.recordSentMessage(
        invalidation.Statistics.SentMessageType.REGISTRATION_SYNC);
  }

  // Check if an info message has to be sent.
  if (this.pendingInfoMessage_ != null) {
    this.statistics_.recordSentMessage(
        invalidation.Statistics.SentMessageType.INFO);
    message.setInfoMessage(this.pendingInfoMessage_);
    this.pendingInfoMessage_ = null;
  }

  logger.fine('Created message to server: %s', message.toString());
  return message;
};

/**
 * Creates a registration message based on registrations from
 * {@code pendingRegistrations} and returns it.
 * <p>
 * REQUIRES: pendingRegistrations.size() > 0
 * <p>
 * @return {!invalidation.proto.RegistrationMessage} Registration message that
 *     contains the pending registrations.
 */
invalidation.ProtocolHandler.Batcher.prototype.createRegistrationMessage =
    function() {
  goog.asserts.assert(!this.pendingRegistrations_.isEmpty());
  var regOps = this.pendingRegistrations_.getValues();
  this.pendingRegistrations_.clear();
  return invalidation.CommonProtos.newRegistrationMessage(regOps);
};

/**
 * Creates an invalidation ack message based on acks from
 * {@code pendingAckedInvalidations} and returns it.
 * <p>
 * REQUIRES: pendingAckedInvalidations.size() > 0
 * <p>
 * @return {!invalidation.proto.InvalidationMessage} Invalidation message that
 *     contains the pending acks.
 */
invalidation.ProtocolHandler.Batcher.prototype.createInvalidationAckMessage =
    function() {
  goog.asserts.assert(!this.pendingAckedInvalidations_.isEmpty());
  var acks = this.pendingAckedInvalidations_.getValues();
  this.pendingAckedInvalidations_.clear();
  return invalidation.CommonProtos.newInvalidationMessage(acks);
};


//
// ServerMessageHeader
//

/**
 * Representation of a message header for use in a server message.
 *
 * @param {?string} token Server-sent token.
 * @param {?invalidation.proto.RegistrationSummary} registrationSummary
 *     Summary over server registration state.
 * @constructor
 */
invalidation.ServerMessageHeader = function(token, registrationSummary) {
  /**
   * Server-sent token.
   * @type {?string}
   */
  this.token = token;

  /**
   * Summary over server registration state.
   * @type {?invalidation.proto.RegistrationSummary}
   */
  this.registrationSummary = registrationSummary;
};

/**
 * @override
 */
invalidation.ServerMessageHeader.prototype.toString = function() {
  return goog.string.format('Token: %s, Summary: %s', this.token == null ?
      'null' : this.token, this.registrationSummary.toString());
};

/**
 * Representation of a message receiver for the server. Such a message is
 * guaranteed to be valid (i.e. checked by ticlmessagevalidator), but the
 * session token is <b>not</b> checked.
 *
 * @param {!invalidation.proto.ServerToClientMessage} rawMessage
 *     Message from the server.
 * @constructor
 */
invalidation.ProtocolHandler.ParsedMessage = function(rawMessage) {
  // For each field, assign it to the corresponding protobuf field if present,
  // else null.
  var messageHeader = rawMessage.getHeader();

  /**
   * Header of the server message.
   * @type {!invalidation.ServerMessageHeader}
   */
  this.header = new invalidation.ServerMessageHeader(
      messageHeader.getClientToken(),
      messageHeader.hasRegistrationSummary() ?
          messageHeader.getRegistrationSummary() : null);

  /**
   * Token control message.
   * @type {?invalidation.proto.TokenControlMessage}
   */
  this.tokenControlMessage = rawMessage.hasTokenControlMessage() ?
      rawMessage.getTokenControlMessage() : null;

  /**
   * Invalidations.
   * @type {?invalidation.proto.InvalidationMessage}
   */
  this.invalidationMessage = rawMessage.hasInvalidationMessage() ?
      rawMessage.getInvalidationMessage() : null;

  /**
   * Registration statuses.
   * @type {?invalidation.proto.RegistrationStatusMessage}
   */
  this.registrationStatusMessage = rawMessage.hasRegistrationStatusMessage() ?
      rawMessage.getRegistrationStatusMessage() : null;

  /**
   * Registration sync request.
   * @type {?invalidation.proto.RegistrationSyncRequestMessage}
   */
  this.registrationSyncRequestMessage =
      rawMessage.hasRegistrationSyncRequestMessage() ?
          rawMessage.getRegistrationSyncRequestMessage() : null;

  /**
   * Config change message.
   * @type {?invalidation.proto.ConfigChangeMessage}
   */
  this.configChangeMessage = rawMessage.hasConfigChangeMessage() ?
      rawMessage.getConfigChangeMessage() : null;

  /**
   * Info request message.
   * @type {?invalidation.proto.InfoRequestMessage}
   */
  this.infoRequestMessage = rawMessage.hasInfoRequestMessage() ?
      rawMessage.getInfoRequestMessage() : null;

  /**
   * Error message.
   * @type {?invalidation.proto.ErrorMessage}
   */
  this.errorMessage = rawMessage.hasErrorMessage() ?
      rawMessage.getErrorMessage() : null;
};

//
// ProtocolListener
//

/**
 * Interface against which the protocol handler makes upcalls to retrieve data
 * required when processing messages and when messages are sent.  It guarantees
 * that the call will be made on the internal thread that the SystemResources
 * provides.
 *
 * @interface
 */
// TODO(dsmyers): [bug 7458228] rename.
invalidation.ProtocolListener = function() {};

/**
 * @return {!invalidation.proto.RegistrationSummary} A summary of the current
 *     desired registrations.
 */
invalidation.ProtocolListener.prototype.getRegistrationSummary =
    goog.abstractMethod;

/**
 * @return {?string} The current server-assigned client token, if any. Else
 *     returns null.
 */
invalidation.ProtocolListener.prototype.getClientToken = goog.abstractMethod;

/** Records that a message was sent to the server at the current time. */
invalidation.ProtocolListener.prototype.handleMessageSent = goog.abstractMethod;

//
// Config creation methods.
//

/**
 * @return {!invalidation.proto.ProtocolHandlerConfigP} Returns a default config
 *     for the protocol handler.
 */
invalidation.ProtocolHandler.createConfig = function() {
  var config = new invalidation.proto.ProtocolHandlerConfigP();

  // Allow at most 3 messages every 5 seconds.
  var windowMs = 5 * 1000;
  var numMsgsPerWindow = 3;
  config.addRateLimit(
      invalidation.CommonProtos.newRateLimitP(windowMs, numMsgsPerWindow));
  return config;
};

/**
 * @return {!invalidation.proto.ProtocolHandlerConfigP} Returns a config
 *     for the protocol handler with parameters set for test.
 */
invalidation.ProtocolHandler.createConfigForTest = function() {
  // No rate limits
  var config = new invalidation.proto.ProtocolHandlerConfigP();
  var smallBatchDelayForTest = 200;
  config.setBatchingDelayMs(smallBatchDelayForTest);
  return config;
};

//
// ProtocolHandler methods.
//

/**
 * Returns the next time a message is allowed to be sent to the server.
 * Typically, this will be in the past, meaning that the client is free to send
 * a message at any time.
 *
 * @return {number} The next time for a message.
 */
invalidation.ProtocolHandler.prototype.getNextMessageSendTimeMsForTest =
    function() {
  return this.nextMessageSendTimeMs_;
};

/**
 * Handles a message from the server. If the message can be processed (i.e., is
 * valid, is of the right version, and is not a silence message), returns a
 * {@code ParsedMessage} representing it. Otherwise, returns {@code null}.
 * <p>
 * This class intercepts and processes silence messages. In this case, it will
 * discard any other data in the message.
 * <p>
 * Note that this method does <b>not</b> check the session token of any message.
 *
 * @param {!string} incomingMessage The actual message received from the server.
 * @return {?invalidation.ProtocolHandler.ParsedMessage} A parsed message.
 */
invalidation.ProtocolHandler.prototype.handleIncomingMessage =
    function(incomingMessage) {
  var message = this.deserializeMessage(incomingMessage);
  if (message == null) {
    return null;
  }
  // Validate the message. If this passes, we can blindly assume valid messages
  // from here on.
  this.logger.fine('Incoming message: %s', message.toString());
  if (!this.msgValidator_.isServerMessageValid(message)) {
    this.statistics_.recordError(
        invalidation.Statistics.ClientErrorType.INCOMING_MESSAGE_FAILURE);
    this.logger.severe('Received invalid message: %s', message.toString());
    return null;
  }

  // Construct a representation of the message header.
  var messageHeader = message.getHeader();
  var header = new invalidation.ServerMessageHeader(
      messageHeader.getClientToken(), messageHeader.hasRegistrationSummary() ?
          messageHeader.getRegistrationSummary() : null);

  // Check the version of the message
  if (messageHeader.getProtocolVersion().getVersion().getMajorVersion() !=
      invalidation.Constants.PROTOCOL_MAJOR_VERSION) {
    this.statistics_.recordError(
        invalidation.Statistics.ClientErrorType.PROTOCOL_VERSION_FAILURE);
    this.logger.severe('Dropping message with incompatible version: %s',
        message.toString());
    return null;
  }

  // Check if it is a ConfigChangeMessage which indicates that messages should
  // no longer be sent for a certain duration. Perform this check before the
  // token is even checked.
  if (message.hasConfigChangeMessage()) {
    var configChangeMsg = message.getConfigChangeMessage();
    this.statistics_.recordReceivedMessage(
        invalidation.Statistics.ReceivedMessageType.CONFIG_CHANGE);

    // Validator will ensure that the delay is positive.
    // TODO(adya): [bug 5274899] Implement the real validator.
    if (configChangeMsg.hasNextMessageDelayMs()) {
      this.nextMessageSendTimeMs_ = this.internalScheduler.getCurrentTimeMs() +
          configChangeMsg.getNextMessageDelayMsOrDefault();
    }
    return null;  // Ignore all other messages in the envelope.
  }

  this.lastKnownServerTimeMs_ = Math.max(this.lastKnownServerTimeMs_,
      messageHeader.getServerTimeMs());
  return new invalidation.ProtocolHandler.ParsedMessage(message);
};

/**
 * Sends a message to the server to request a client token.
 *
 * @param {!invalidation.proto.ApplicationClientIdP} applicationClientId
 *     Application-specific client id.
 * @param {string} nonce Nonce for the request.
 * @param {!invalidation.ClientCore.BatchingTask} batchingTask
 *     The recurring task that triggers batched messages to be sent.
 * @param {string} debugString Information to identify the caller.
 */
invalidation.ProtocolHandler.prototype.sendInitializeMessage =
    function(applicationClientId, nonce, batchingTask, debugString) {
  if (applicationClientId.getClientType() != this.clientType_) {
    // This condition is not fatal, but it probably represents a bug somewhere
    // if it occurs.
    this.logger.warning(
      'Client type in application id does not match constructor-provided ' +
      'type: %s vs %s', applicationClientId, this.clientType_);
  }
  // Simply store the message in pendingInitializeMessage and send it when the
  // batching task runs.
  var serializationType =
      invalidation.proto.InitializeMessage.DigestSerializationType.NUMBER_BASED;
  var initializeMessage =
      invalidation.CommonProtos.newInitializeMessage(this.clientType_,
      applicationClientId, nonce, serializationType);
  this.batcher_.setInitializeMessage(initializeMessage);
  this.logger.info('Batching initialize message for client: %s, %s',
      debugString, initializeMessage);
  batchingTask.ensureScheduled(debugString);
};

/**
 * Sends an info message to the server with the performance counters supplied
 * in {@code performanceCounters} and the config in {@code config}.
 *
 * @param {!goog.structs.Map.<string, number>} performanceCounters The
 *     performance counters that need to be sent to the server, if any.
 * @param {invalidation.proto.ClientConfigP} clientConfig The client's config
 *     parameters that need to be sent to the server, if any.
 * @param {boolean} requestServerRegistrationSummary Indicates whether to
 *     request the server's registration summary.
 * @param {!invalidation.ClientCore.BatchingTask} batchingTask
 *     The recurring task that triggers batched messages to be sent.
 */
invalidation.ProtocolHandler.prototype.sendInfoMessage = function(
    performanceCounters,
    clientConfig,
    requestServerRegistrationSummary,
    batchingTask) {
  var pendingInfoMessage = new invalidation.proto.InfoMessage();
  pendingInfoMessage.setClientVersion(this.clientVersion_);

  // Add configuration parameters.
  if (clientConfig != null) {
    pendingInfoMessage.setClientConfig(clientConfig);
  }

  // Add performance counters.
  var keys = performanceCounters.getKeys();
  for (var i = 0; i < keys.length; i++) {
    var counter = invalidation.CommonProtos.newPropertyRecord(keys[i],
        /** @type {number} */ (performanceCounters.get(keys[i])));
    pendingInfoMessage.addPerformanceCounter(counter);
  }

  // Indicate whether we want the server's registration summary sent back.
  pendingInfoMessage.setServerRegistrationSummaryRequested(
      requestServerRegistrationSummary);

  // Send it when the batching task runs.
  this.batcher_.setInfoMessage(pendingInfoMessage);
  batchingTask.ensureScheduled('Send-info');
};

/**
 * Sends a registration request to the server.
 *
 * @param {!Array.<!invalidation.proto.ObjectIdP>} objectIds Object ids on which
 *     to (un)register.
 * @param {!invalidation.proto.RegistrationP.OpType} regOpType Whether to
 *     register or unregister.
 * @param {!invalidation.ClientCore.BatchingTask} batchingTask
 *     The recurring task that triggers batched messages to be sent.
 */
invalidation.ProtocolHandler.prototype.sendRegistrations = function(
    objectIds,
    regOpType,
    batchingTask) {
  var isReg = (regOpType == invalidation.proto.RegistrationP.OpType.REGISTER);
  for (var i = 0; i < objectIds.length; i++) {
    this.batcher_.addRegistration(objectIds[i], isReg);
  }

  // Send it when the batching task runs.
  batchingTask.ensureScheduled('Send-registrations');
};

/**
 * Sends an acknowledgement for {@code invalidation} to the server.
 *
 * @param {!invalidation.proto.InvalidationP} ack The ack sent to the server.
 * @param {!invalidation.ClientCore.BatchingTask} batchingTask
 *     The recurring task that triggers batched messages to be sent.
 */
invalidation.ProtocolHandler.prototype.sendInvalidationAck =
    function(ack, batchingTask) {
  // We could do squelching - we don't since it is unlikely to be too beneficial
  // here.
  this.logger.fine('Sending ack for invalidation %s', ack.toString());
  this.batcher_.addAck(ack);
  batchingTask.ensureScheduled('Send-ack');
};

/**
 * Sends a single registration subtree to the server.
 *
 * @param {!invalidation.proto.RegistrationSubtree} regSubtree Subtree to send.
 * @param {!invalidation.ClientCore.BatchingTask} batchingTask
 *     The recurring task that triggers batched messages to be sent.
 */
invalidation.ProtocolHandler.prototype.sendRegistrationSyncSubtree =
    function(regSubtree, batchingTask) {
  this.batcher_.addRegSubtree(regSubtree);
  this.logger.info('Adding subtree: %s', regSubtree.toString());
  batchingTask.ensureScheduled('Send-reg-sync');
};

/**
 * Sends pending data to the server (e.g., registrations, acks, registration
 * sync messages).
 * <p>
 * REQUIRES: caller must not do any further work after the call returns.
 */
invalidation.ProtocolHandler.prototype.sendMessageToServer = function() {
  if (this.nextMessageSendTimeMs_ > this.internalScheduler.getCurrentTimeMs()) {
    this.logger.warning('In quiet period: not sending message to server: ' +
        '%s > %s', this.nextMessageSendTimeMs_,
        this.internalScheduler.getCurrentTimeMs());
    return;
  }

  // Create the message.
  var hasToken = (this.listener_.getClientToken() != null);
  var message = this.batcher_.toMessage(hasToken);
  if (message == null) {
    // Happens when we don't have a token and are not sending an initialize
    // message.
    return;
  }
  message.setHeader(this.createClientHeader());

  // Validate the message and send it.
  this.messageId_++;
  if (!this.msgValidator_.isClientMessageValid(message)) {
    this.logger.severe('Tried to send invalid msg: %s', message.toString());
    this.statistics_.recordError(
        invalidation.Statistics.ClientErrorType.OUTGOING_MESSAGE_FAILURE);
    return;
  }

  this.logger.fine('Sending message to server: %s', message.toString());
  this.statistics_.recordSentMessage(
      invalidation.Statistics.SentMessageType.TOTAL);
  var serializedMessage = invalidation.Utils.serializeMessage(message);
  this.network_.sendMessage(serializedMessage);

  // Inform the listener that a message was sent. We're invoking the listener
  // directly, rather than scheduling a new work unit to do it. It would be
  // safer to do a schedule, but we want to mirror what the Java Ticl does,
  // and it has to do it this way to in order to support Android.
  this.listener_.handleMessageSent();
};

/**
 * Returns the header to include on a message to the server.
 *
 * @return {!invalidation.proto.ClientHeader} The header to send to the server.
 */
invalidation.ProtocolHandler.prototype.createClientHeader = function() {
  var header = new invalidation.proto.ClientHeader();
  header.setProtocolVersion(invalidation.Constants.PROTOCOL_VERSION);
  header.setClientTimeMs(this.internalScheduler.getCurrentTimeMs());
  header.setMessageId(this.messageId_.toString());
  header.setMaxKnownServerTimeMs(this.lastKnownServerTimeMs_);
  header.setRegistrationSummary(this.listener_.getRegistrationSummary());
  header.setClientType(this.clientType_);
  var clientToken = this.listener_.getClientToken();
  if (clientToken != null) {
    this.logger.fine('Sending token on client->server message: %s',
        clientToken);
    header.setClientToken(clientToken);
  }
  return header;
};

/**
 * Deserializes a message received from the server and returns it. If the
 * message does not parse correctly, returns null.
 *
 * @param {string} jsonMessage Incoming message in Json format.
 * @return {invalidation.proto.ServerToClientMessage} message Deserialized
 *     server message, if the serialized {@code jsonMessage} was valid.
 */
invalidation.ProtocolHandler.prototype.deserializeMessage =
    function(jsonMessage) {
  var descriptor = invalidation.proto.ServerToClientMessage.getDescriptor();
  var message = invalidation.Utils.deserializeMessage(descriptor, jsonMessage,
      this.logger);
  return /** @type {invalidation.proto.ServerToClientMessage} */ (message);
};

//ipc/invalidation/javascript/internal/client/protoconverter.js
// Copyright 2011 Google Inc. All Rights Reserved.

/**
 * @fileoverview Utilities to convert between protobufs and externally-exposed
 * types in the Ticl.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.ProtoConverter');

goog.require('invalidation.CommonProtos');
goog.require('invalidation.Types.Invalidation');
goog.require('invalidation.Types.ObjectId');
goog.require('invalidation.proto.InvalidationP');
goog.require('invalidation.proto.ObjectIdP');

/**
 * Converts an object id protocol buffer {@code objectId} to the
 * corresponding external type and returns it.
 *
 * @param {!invalidation.proto.ObjectIdP} objectIdProto The object id proto that
 *     needs to be converted.
 * @return {!invalidation.Types.ObjectId} The corresponding object Id.
 */
invalidation.ProtoConverter.convertFromObjectIdProto = function(objectIdProto) {
  return new invalidation.Types.ObjectId(
      /** @type {number} */ (objectIdProto.getSource()),
      /** @type {string} */ (objectIdProto.getName()));
};

/**
 * Converts an object id {@code objectId} to the corresponding protocol buffer
 * and returns it.
 *
 * @param {!invalidation.Types.ObjectId} objectId The object id that needs to
 *     be converted.
 * @return {!invalidation.proto.ObjectIdP} The corresponding object Id proto.
 */
invalidation.ProtoConverter.convertToObjectIdProto = function(objectId) {
  return invalidation.CommonProtos.newObjectIdP(objectId.getSource(),
      objectId.getName());
};

/**
 * Converts an invalidation protocol buffer {@code invalidation} to the
 * corresponding external object and returns it
 *
 * @param {!invalidation.proto.InvalidationP} inv The invalidation
 *     proto that needs to be converted.
 * @return {!invalidation.Types.Invalidation} The corresponding invalidation.
 */
invalidation.ProtoConverter.convertFromInvalidationProto = function(inv) {
  var objectId = invalidation.ProtoConverter.convertFromObjectIdProto(
      /** @type {!invalidation.proto.ObjectIdP} */ (inv.getObjectId()));
  var version = /** @type {number} */ (inv.getVersion());
  var payload = inv.hasPayload() ?
      /** @type {string} */ (inv.getPayload()) : undefined;
  var isTrickleRestart = inv.hasIsTrickleRestart() ?
      /** @type boolean */ (inv.getIsTrickleRestart()) : true;
  return new invalidation.Types.Invalidation(objectId, version,
      payload, isTrickleRestart);
};

/**
 * Converts an invalidation {@code invalidation} to the corresponding protocol
 * buffer and returns it.
 *
 * @param {!invalidation.Types.Invalidation} inv The invalidation
 *     that needs to be converted.
 * @return {!invalidation.proto.InvalidationP} Corresponding invalidation proto.
 */
invalidation.ProtoConverter.convertToInvalidationProto = function(inv) {
  var objectId = invalidation.ProtoConverter.convertToObjectIdProto(
      inv.getObjectId());
  var payload = inv.getPayload() != null ?
    /** @type {string} */ (inv.getPayload()) : undefined;
  return invalidation.CommonProtos.newInvalidationP(objectId, inv.getVersion(),
      payload, inv.getIsTrickleRestartForInternalUse());
};

//ipc/invalidation/proto/v2/client_test_internal.pb.js
// Protocol Buffer 2 Copyright 2008 Google Inc.
// All other code copyright its respective owners.

/**
 * @fileoverview Generated Protocol Buffer code for file
 * ipc/invalidation/proto/v2/client_test_internal.proto.
 */

goog.provide('invalidation.proto.RegistrationManagerStateP');
goog.provide('invalidation.proto.TestServerToClientMessageWithExtraFields');

goog.require('goog.proto2.Message');
goog.require('invalidation.proto.ConfigChangeMessage');
goog.require('invalidation.proto.ErrorMessage');
goog.require('invalidation.proto.InfoRequestMessage');
goog.require('invalidation.proto.InvalidationMessage');
goog.require('invalidation.proto.ObjectIdP');
goog.require('invalidation.proto.RegistrationStatusMessage');
goog.require('invalidation.proto.RegistrationSummary');
goog.require('invalidation.proto.RegistrationSyncRequestMessage');
goog.require('invalidation.proto.ServerHeader');
goog.require('invalidation.proto.TokenControlMessage');



/**
 * Message RegistrationManagerStateP.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.RegistrationManagerStateP = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.RegistrationManagerStateP, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.RegistrationManagerStateP} The cloned message.
 * @override
 */
invalidation.proto.RegistrationManagerStateP.prototype.clone;


/**
 * Gets the value of the client_summary field.
 * @return {invalidation.proto.RegistrationSummary} The value.
 */
invalidation.proto.RegistrationManagerStateP.prototype.getClientSummary = function() {
  return /** @type {invalidation.proto.RegistrationSummary} */ (this.get$Value(1));
};


/**
 * Gets the value of the client_summary field or the default value if not set.
 * @return {!invalidation.proto.RegistrationSummary} The value.
 */
invalidation.proto.RegistrationManagerStateP.prototype.getClientSummaryOrDefault = function() {
  return /** @type {!invalidation.proto.RegistrationSummary} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the client_summary field.
 * @param {!invalidation.proto.RegistrationSummary} value The value.
 */
invalidation.proto.RegistrationManagerStateP.prototype.setClientSummary = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the client_summary field has a value.
 */
invalidation.proto.RegistrationManagerStateP.prototype.hasClientSummary = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the client_summary field.
 */
invalidation.proto.RegistrationManagerStateP.prototype.clientSummaryCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the client_summary field.
 */
invalidation.proto.RegistrationManagerStateP.prototype.clearClientSummary = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the server_summary field.
 * @return {invalidation.proto.RegistrationSummary} The value.
 */
invalidation.proto.RegistrationManagerStateP.prototype.getServerSummary = function() {
  return /** @type {invalidation.proto.RegistrationSummary} */ (this.get$Value(2));
};


/**
 * Gets the value of the server_summary field or the default value if not set.
 * @return {!invalidation.proto.RegistrationSummary} The value.
 */
invalidation.proto.RegistrationManagerStateP.prototype.getServerSummaryOrDefault = function() {
  return /** @type {!invalidation.proto.RegistrationSummary} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the server_summary field.
 * @param {!invalidation.proto.RegistrationSummary} value The value.
 */
invalidation.proto.RegistrationManagerStateP.prototype.setServerSummary = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the server_summary field has a value.
 */
invalidation.proto.RegistrationManagerStateP.prototype.hasServerSummary = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the server_summary field.
 */
invalidation.proto.RegistrationManagerStateP.prototype.serverSummaryCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the server_summary field.
 */
invalidation.proto.RegistrationManagerStateP.prototype.clearServerSummary = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the registered_objects field at the index given.
 * @param {number} index The index to lookup.
 * @return {invalidation.proto.ObjectIdP} The value.
 */
invalidation.proto.RegistrationManagerStateP.prototype.getRegisteredObjects = function(index) {
  return /** @type {invalidation.proto.ObjectIdP} */ (this.get$Value(3, index));
};


/**
 * Gets the value of the registered_objects field at the index given or the default value if not set.
 * @param {number} index The index to lookup.
 * @return {!invalidation.proto.ObjectIdP} The value.
 */
invalidation.proto.RegistrationManagerStateP.prototype.getRegisteredObjectsOrDefault = function(index) {
  return /** @type {!invalidation.proto.ObjectIdP} */ (this.get$ValueOrDefault(3, index));
};


/**
 * Adds a value to the registered_objects field.
 * @param {!invalidation.proto.ObjectIdP} value The value to add.
 */
invalidation.proto.RegistrationManagerStateP.prototype.addRegisteredObjects = function(value) {
  this.add$Value(3, value);
};


/**
 * Returns the array of values in the registered_objects field.
 * @return {!Array.<!invalidation.proto.ObjectIdP>} The values in the field.
 */
invalidation.proto.RegistrationManagerStateP.prototype.registeredObjectsArray = function() {
  return /** @type {!Array.<!invalidation.proto.ObjectIdP>} */ (this.array$Values(3));
};


/**
 * @return {boolean} Whether the registered_objects field has a value.
 */
invalidation.proto.RegistrationManagerStateP.prototype.hasRegisteredObjects = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the registered_objects field.
 */
invalidation.proto.RegistrationManagerStateP.prototype.registeredObjectsCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the registered_objects field.
 */
invalidation.proto.RegistrationManagerStateP.prototype.clearRegisteredObjects = function() {
  this.clear$Field(3);
};



/**
 * Message TestServerToClientMessageWithExtraFields.
 * @constructor
 * @extends {goog.proto2.Message}
 */
invalidation.proto.TestServerToClientMessageWithExtraFields = function() {
  goog.proto2.Message.apply(this);
};
goog.inherits(invalidation.proto.TestServerToClientMessageWithExtraFields, goog.proto2.Message);


/**
 * Overrides {@link goog.proto2.Message#clone} to specify its exact return type.
 * @return {!invalidation.proto.TestServerToClientMessageWithExtraFields} The cloned message.
 * @override
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.clone;


/**
 * Gets the value of the header field.
 * @return {invalidation.proto.ServerHeader} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getHeader = function() {
  return /** @type {invalidation.proto.ServerHeader} */ (this.get$Value(1));
};


/**
 * Gets the value of the header field or the default value if not set.
 * @return {!invalidation.proto.ServerHeader} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getHeaderOrDefault = function() {
  return /** @type {!invalidation.proto.ServerHeader} */ (this.get$ValueOrDefault(1));
};


/**
 * Sets the value of the header field.
 * @param {!invalidation.proto.ServerHeader} value The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.setHeader = function(value) {
  this.set$Value(1, value);
};


/**
 * @return {boolean} Whether the header field has a value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.hasHeader = function() {
  return this.has$Value(1);
};


/**
 * @return {number} The number of values in the header field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.headerCount = function() {
  return this.count$Values(1);
};


/**
 * Clears the values in the header field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.clearHeader = function() {
  this.clear$Field(1);
};


/**
 * Gets the value of the token_control_message field.
 * @return {invalidation.proto.TokenControlMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getTokenControlMessage = function() {
  return /** @type {invalidation.proto.TokenControlMessage} */ (this.get$Value(2));
};


/**
 * Gets the value of the token_control_message field or the default value if not set.
 * @return {!invalidation.proto.TokenControlMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getTokenControlMessageOrDefault = function() {
  return /** @type {!invalidation.proto.TokenControlMessage} */ (this.get$ValueOrDefault(2));
};


/**
 * Sets the value of the token_control_message field.
 * @param {!invalidation.proto.TokenControlMessage} value The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.setTokenControlMessage = function(value) {
  this.set$Value(2, value);
};


/**
 * @return {boolean} Whether the token_control_message field has a value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.hasTokenControlMessage = function() {
  return this.has$Value(2);
};


/**
 * @return {number} The number of values in the token_control_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.tokenControlMessageCount = function() {
  return this.count$Values(2);
};


/**
 * Clears the values in the token_control_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.clearTokenControlMessage = function() {
  this.clear$Field(2);
};


/**
 * Gets the value of the invalidation_message field.
 * @return {invalidation.proto.InvalidationMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getInvalidationMessage = function() {
  return /** @type {invalidation.proto.InvalidationMessage} */ (this.get$Value(3));
};


/**
 * Gets the value of the invalidation_message field or the default value if not set.
 * @return {!invalidation.proto.InvalidationMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getInvalidationMessageOrDefault = function() {
  return /** @type {!invalidation.proto.InvalidationMessage} */ (this.get$ValueOrDefault(3));
};


/**
 * Sets the value of the invalidation_message field.
 * @param {!invalidation.proto.InvalidationMessage} value The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.setInvalidationMessage = function(value) {
  this.set$Value(3, value);
};


/**
 * @return {boolean} Whether the invalidation_message field has a value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.hasInvalidationMessage = function() {
  return this.has$Value(3);
};


/**
 * @return {number} The number of values in the invalidation_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.invalidationMessageCount = function() {
  return this.count$Values(3);
};


/**
 * Clears the values in the invalidation_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.clearInvalidationMessage = function() {
  this.clear$Field(3);
};


/**
 * Gets the value of the registration_status_message field.
 * @return {invalidation.proto.RegistrationStatusMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getRegistrationStatusMessage = function() {
  return /** @type {invalidation.proto.RegistrationStatusMessage} */ (this.get$Value(4));
};


/**
 * Gets the value of the registration_status_message field or the default value if not set.
 * @return {!invalidation.proto.RegistrationStatusMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getRegistrationStatusMessageOrDefault = function() {
  return /** @type {!invalidation.proto.RegistrationStatusMessage} */ (this.get$ValueOrDefault(4));
};


/**
 * Sets the value of the registration_status_message field.
 * @param {!invalidation.proto.RegistrationStatusMessage} value The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.setRegistrationStatusMessage = function(value) {
  this.set$Value(4, value);
};


/**
 * @return {boolean} Whether the registration_status_message field has a value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.hasRegistrationStatusMessage = function() {
  return this.has$Value(4);
};


/**
 * @return {number} The number of values in the registration_status_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.registrationStatusMessageCount = function() {
  return this.count$Values(4);
};


/**
 * Clears the values in the registration_status_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.clearRegistrationStatusMessage = function() {
  this.clear$Field(4);
};


/**
 * Gets the value of the registration_sync_request_message field.
 * @return {invalidation.proto.RegistrationSyncRequestMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getRegistrationSyncRequestMessage = function() {
  return /** @type {invalidation.proto.RegistrationSyncRequestMessage} */ (this.get$Value(5));
};


/**
 * Gets the value of the registration_sync_request_message field or the default value if not set.
 * @return {!invalidation.proto.RegistrationSyncRequestMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getRegistrationSyncRequestMessageOrDefault = function() {
  return /** @type {!invalidation.proto.RegistrationSyncRequestMessage} */ (this.get$ValueOrDefault(5));
};


/**
 * Sets the value of the registration_sync_request_message field.
 * @param {!invalidation.proto.RegistrationSyncRequestMessage} value The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.setRegistrationSyncRequestMessage = function(value) {
  this.set$Value(5, value);
};


/**
 * @return {boolean} Whether the registration_sync_request_message field has a value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.hasRegistrationSyncRequestMessage = function() {
  return this.has$Value(5);
};


/**
 * @return {number} The number of values in the registration_sync_request_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.registrationSyncRequestMessageCount = function() {
  return this.count$Values(5);
};


/**
 * Clears the values in the registration_sync_request_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.clearRegistrationSyncRequestMessage = function() {
  this.clear$Field(5);
};


/**
 * Gets the value of the config_change_message field.
 * @return {invalidation.proto.ConfigChangeMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getConfigChangeMessage = function() {
  return /** @type {invalidation.proto.ConfigChangeMessage} */ (this.get$Value(6));
};


/**
 * Gets the value of the config_change_message field or the default value if not set.
 * @return {!invalidation.proto.ConfigChangeMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getConfigChangeMessageOrDefault = function() {
  return /** @type {!invalidation.proto.ConfigChangeMessage} */ (this.get$ValueOrDefault(6));
};


/**
 * Sets the value of the config_change_message field.
 * @param {!invalidation.proto.ConfigChangeMessage} value The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.setConfigChangeMessage = function(value) {
  this.set$Value(6, value);
};


/**
 * @return {boolean} Whether the config_change_message field has a value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.hasConfigChangeMessage = function() {
  return this.has$Value(6);
};


/**
 * @return {number} The number of values in the config_change_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.configChangeMessageCount = function() {
  return this.count$Values(6);
};


/**
 * Clears the values in the config_change_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.clearConfigChangeMessage = function() {
  this.clear$Field(6);
};


/**
 * Gets the value of the info_request_message field.
 * @return {invalidation.proto.InfoRequestMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getInfoRequestMessage = function() {
  return /** @type {invalidation.proto.InfoRequestMessage} */ (this.get$Value(7));
};


/**
 * Gets the value of the info_request_message field or the default value if not set.
 * @return {!invalidation.proto.InfoRequestMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getInfoRequestMessageOrDefault = function() {
  return /** @type {!invalidation.proto.InfoRequestMessage} */ (this.get$ValueOrDefault(7));
};


/**
 * Sets the value of the info_request_message field.
 * @param {!invalidation.proto.InfoRequestMessage} value The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.setInfoRequestMessage = function(value) {
  this.set$Value(7, value);
};


/**
 * @return {boolean} Whether the info_request_message field has a value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.hasInfoRequestMessage = function() {
  return this.has$Value(7);
};


/**
 * @return {number} The number of values in the info_request_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.infoRequestMessageCount = function() {
  return this.count$Values(7);
};


/**
 * Clears the values in the info_request_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.clearInfoRequestMessage = function() {
  this.clear$Field(7);
};


/**
 * Gets the value of the error_message field.
 * @return {invalidation.proto.ErrorMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getErrorMessage = function() {
  return /** @type {invalidation.proto.ErrorMessage} */ (this.get$Value(8));
};


/**
 * Gets the value of the error_message field or the default value if not set.
 * @return {!invalidation.proto.ErrorMessage} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getErrorMessageOrDefault = function() {
  return /** @type {!invalidation.proto.ErrorMessage} */ (this.get$ValueOrDefault(8));
};


/**
 * Sets the value of the error_message field.
 * @param {!invalidation.proto.ErrorMessage} value The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.setErrorMessage = function(value) {
  this.set$Value(8, value);
};


/**
 * @return {boolean} Whether the error_message field has a value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.hasErrorMessage = function() {
  return this.has$Value(8);
};


/**
 * @return {number} The number of values in the error_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.errorMessageCount = function() {
  return this.count$Values(8);
};


/**
 * Clears the values in the error_message field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.clearErrorMessage = function() {
  this.clear$Field(8);
};


/**
 * Gets the value of the extra_string_field field.
 * @return {?string} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getExtraStringField = function() {
  return /** @type {?string} */ (this.get$Value(9));
};


/**
 * Gets the value of the extra_string_field field or the default value if not set.
 * @return {string} The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.getExtraStringFieldOrDefault = function() {
  return /** @type {string} */ (this.get$ValueOrDefault(9));
};


/**
 * Sets the value of the extra_string_field field.
 * @param {string} value The value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.setExtraStringField = function(value) {
  this.set$Value(9, value);
};


/**
 * @return {boolean} Whether the extra_string_field field has a value.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.hasExtraStringField = function() {
  return this.has$Value(9);
};


/**
 * @return {number} The number of values in the extra_string_field field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.extraStringFieldCount = function() {
  return this.count$Values(9);
};


/**
 * Clears the values in the extra_string_field field.
 */
invalidation.proto.TestServerToClientMessageWithExtraFields.prototype.clearExtraStringField = function() {
  this.clear$Field(9);
};


goog.proto2.Message.set$Metadata(invalidation.proto.RegistrationManagerStateP, {
  0: {
    name: 'RegistrationManagerStateP',
    fullName: 'ipc.invalidation.RegistrationManagerStateP'
  },
  1: {
    name: 'client_summary',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationSummary
  },
  2: {
    name: 'server_summary',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationSummary
  },
  3: {
    name: 'registered_objects',
    repeated: true,
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ObjectIdP
  }
});


goog.proto2.Message.set$Metadata(invalidation.proto.TestServerToClientMessageWithExtraFields, {
  0: {
    name: 'TestServerToClientMessageWithExtraFields',
    fullName: 'ipc.invalidation.TestServerToClientMessageWithExtraFields'
  },
  1: {
    name: 'header',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ServerHeader
  },
  2: {
    name: 'token_control_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.TokenControlMessage
  },
  3: {
    name: 'invalidation_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.InvalidationMessage
  },
  4: {
    name: 'registration_status_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationStatusMessage
  },
  5: {
    name: 'registration_sync_request_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.RegistrationSyncRequestMessage
  },
  6: {
    name: 'config_change_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ConfigChangeMessage
  },
  7: {
    name: 'info_request_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.InfoRequestMessage
  },
  8: {
    name: 'error_message',
    fieldType: goog.proto2.Message.FieldType.MESSAGE,
    type: invalidation.proto.ErrorMessage
  },
  9: {
    name: 'extra_string_field',
    fieldType: goog.proto2.Message.FieldType.STRING,
    type: String
  }
});

//javascript/closure/structs/avltree.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Datastructure: AvlTree.
 *
 * @author tgordon@google.com (Taylor Gordon)
 *
 * This file provides the implementation of an AVL-Tree datastructure. The tree
 * maintains a set of unique values in a sorted order. The values can be
 * accessed efficiently in their sorted order since the tree enforces an O(logn)
 * maximum height. See http://en.wikipedia.org/wiki/Avl_tree for more detail.
 *
 * The big-O notation for all operations are below:
 * <pre>
 *   Method                 big-O
 * ----------------------------------------------------------------------------
 * - add                    O(logn)
 * - remove                 O(logn)
 * - clear                  O(1)
 * - contains               O(logn)
 * - getCount               O(1)
 * - getMinimum             O(1), or O(logn) when optional root is specified
 * - getMaximum             O(1), or O(logn) when optional root is specified
 * - getHeight              O(1)
 * - getValues              O(n)
 * - inOrderTraverse        O(logn + k), where k is number of traversed nodes
 * - reverseOrderTraverse   O(logn + k), where k is number of traversed nodes
 * </pre>
 */


goog.provide('goog.structs.AvlTree');
goog.provide('goog.structs.AvlTree.Node');

goog.require('goog.structs.Collection');



/**
 * Constructs an AVL-Tree, which uses the specified comparator to order its
 * values. The values can be accessed efficiently in their sorted order since
 * the tree enforces a O(logn) maximum height.
 *
 * @param {Function=} opt_comparator Function used to order the tree's nodes.
 * @constructor
 * @implements {goog.structs.Collection.<T>}
 * @final
 * @template T
 */
goog.structs.AvlTree = function(opt_comparator) {
  this.comparator_ = opt_comparator ||
                     goog.structs.AvlTree.DEFAULT_COMPARATOR_;
};


/**
 * String comparison function used to compare values in the tree. This function
 * is used by default if no comparator is specified in the tree's constructor.
 *
 * @param {T} a The first value.
 * @param {T} b The second value.
 * @return {number} -1 if a < b, 1 if a > b, 0 if a = b.
 * @template T
 * @private
 */
goog.structs.AvlTree.DEFAULT_COMPARATOR_ = function(a, b) {
  if (String(a) < String(b)) {
    return -1;
  } else if (String(a) > String(b)) {
    return 1;
  }
  return 0;
};


/**
 * Pointer to the root node of the tree.
 *
 * @private {goog.structs.AvlTree.Node.<T>}
 */
goog.structs.AvlTree.prototype.root_ = null;


/**
 * Comparison function used to compare values in the tree. This function should
 * take two values, a and b, and return x where:
 * <pre>
 *  x < 0 if a < b,
 *  x > 0 if a > b,
 *  x = 0 otherwise
 * </pre>
 *
 * @type {Function}
 * @private
 */
goog.structs.AvlTree.prototype.comparator_ = null;


/**
 * Pointer to the node with the smallest value in the tree.
 *
 * @type {goog.structs.AvlTree.Node.<T>}
 * @private
 */
goog.structs.AvlTree.prototype.minNode_ = null;


/**
 * Pointer to the node with the largest value in the tree.
 *
 * @type {goog.structs.AvlTree.Node.<T>}
 * @private
 */
goog.structs.AvlTree.prototype.maxNode_ = null;


/**
 * Inserts a node into the tree with the specified value if the tree does
 * not already contain a node with the specified value. If the value is
 * inserted, the tree is balanced to enforce the AVL-Tree height property.
 *
 * @param {T} value Value to insert into the tree.
 * @return {boolean} Whether value was inserted into the tree.
 * @override
 */
goog.structs.AvlTree.prototype.add = function(value) {
  // If the tree is empty, create a root node with the specified value
  if (this.root_ == null) {
    this.root_ = new goog.structs.AvlTree.Node(value);
    this.minNode_ = this.root_;
    this.maxNode_ = this.root_;
    return true;
  }

  // This will be set to the new node if a new node is added.
  var newNode = null;

  // Depth traverse the tree and insert the value if we reach a null node
  this.traverse_(function(node) {
    var retNode = null;
    if (this.comparator_(node.value, value) > 0) {
      retNode = node.left;
      if (node.left == null) {
        newNode = new goog.structs.AvlTree.Node(value, node);
        node.left = newNode;
        if (node == this.minNode_) {
          this.minNode_ = newNode;
        }
      }
    } else if (this.comparator_(node.value, value) < 0) {
      retNode = node.right;
      if (node.right == null) {
        newNode = new goog.structs.AvlTree.Node(value, node);
        node.right = newNode;
        if (node == this.maxNode_) {
          this.maxNode_ = newNode;
        }
      }
    }
    return retNode; // If null, we'll stop traversing the tree
  });

  // If a node was added, increment counts and balance tree.
  if (newNode) {
    this.traverse_(
        function(node) {
          node.count++;
          return node.parent;
        },
        newNode.parent);
    this.balance_(newNode.parent); // Maintain the AVL-tree balance
  }

  // Return true if a node was added, false otherwise
  return !!newNode;
};


/**
 * Removes a node from the tree with the specified value if the tree contains a
 * node with this value. If a node is removed the tree is balanced to enforce
 * the AVL-Tree height property. The value of the removed node is returned.
 *
 * @param {T} value Value to find and remove from the tree.
 * @return {T} The value of the removed node or null if the value was not in
 *     the tree.
 * @override
 */
goog.structs.AvlTree.prototype.remove = function(value) {
  // Assume the value is not removed and set the value when it is removed
  var retValue = null;

  // Depth traverse the tree and remove the value if we find it
  this.traverse_(function(node) {
    var retNode = null;
    if (this.comparator_(node.value, value) > 0) {
      retNode = node.left;
    } else if (this.comparator_(node.value, value) < 0) {
      retNode = node.right;
    } else {
      retValue = node.value;
      this.removeNode_(node);
    }
    return retNode; // If null, we'll stop traversing the tree
  });

  // Return the value that was removed, null if the value was not in the tree
  return retValue;
};


/**
 * Removes all nodes from the tree.
 */
goog.structs.AvlTree.prototype.clear = function() {
  this.root_ = null;
  this.minNode_ = null;
  this.maxNode_ = null;
};


/**
 * Returns true if the tree contains a node with the specified value, false
 * otherwise.
 *
 * @param {T} value Value to find in the tree.
 * @return {boolean} Whether the tree contains a node with the specified value.
 * @override
 */
goog.structs.AvlTree.prototype.contains = function(value) {
  // Assume the value is not in the tree and set this value if it is found
  var isContained = false;

  // Depth traverse the tree and set isContained if we find the node
  this.traverse_(function(node) {
    var retNode = null;
    if (this.comparator_(node.value, value) > 0) {
      retNode = node.left;
    } else if (this.comparator_(node.value, value) < 0) {
      retNode = node.right;
    } else {
      isContained = true;
    }
    return retNode; // If null, we'll stop traversing the tree
  });

  // Return true if the value is contained in the tree, false otherwise
  return isContained;
};


/**
 * Returns the number of values stored in the tree.
 *
 * @return {number} The number of values stored in the tree.
 * @override
 */
goog.structs.AvlTree.prototype.getCount = function() {
  return this.root_ ? this.root_.count : 0;
};


/**
 * Returns a k-th smallest value, based on the comparator, where 0 <= k <
 * this.getCount().
 * @param {number} k The number k.
 * @return {T} The k-th smallest value.
 */
goog.structs.AvlTree.prototype.getKthValue = function(k) {
  if (k < 0 || k >= this.getCount()) {
    return null;
  }
  return this.getKthNode_(k).value;
};


/**
 * Returns the value u, such that u is contained in the tree and u < v, for all
 * values v in the tree where v != u.
 *
 * @return {T} The minimum value contained in the tree.
 */
goog.structs.AvlTree.prototype.getMinimum = function() {
  return this.getMinNode_().value;
};


/**
 * Returns the value u, such that u is contained in the tree and u > v, for all
 * values v in the tree where v != u.
 *
 * @return {T} The maximum value contained in the tree.
 */
goog.structs.AvlTree.prototype.getMaximum = function() {
  return this.getMaxNode_().value;
};


/**
 * Returns the height of the tree (the maximum depth). This height should
 * always be <= 1.4405*(Math.log(n+2)/Math.log(2))-1.3277, where n is the
 * number of nodes in the tree.
 *
 * @return {number} The height of the tree.
 */
goog.structs.AvlTree.prototype.getHeight = function() {
  return this.root_ ? this.root_.height : 0;
};


/**
 * Inserts the values stored in the tree into a new Array and returns the Array.
 *
 * @return {!Array.<T>} An array containing all of the trees values in sorted
 *     order.
 */
goog.structs.AvlTree.prototype.getValues = function() {
  var ret = [];
  this.inOrderTraverse(function(value) {
    ret.push(value);
  });
  return ret;
};


/**
 * Performs an in-order traversal of the tree and calls {@code func} with each
 * traversed node, optionally starting from the smallest node with a value >= to
 * the specified start value. The traversal ends after traversing the tree's
 * maximum node or when {@code func} returns a value that evaluates to true.
 *
 * @param {Function} func Function to call on each traversed node.
 * @param {Object=} opt_startValue If specified, traversal will begin on the
 *    node with the smallest value >= opt_startValue.
 */
goog.structs.AvlTree.prototype.inOrderTraverse =
    function(func, opt_startValue) {
  // If our tree is empty, return immediately
  if (!this.root_) {
    return;
  }

  // Depth traverse the tree to find node to begin in-order traversal from
  var startNode;
  if (opt_startValue) {
    this.traverse_(function(node) {
      var retNode = null;
      if (this.comparator_(node.value, opt_startValue) > 0) {
        retNode = node.left;
        startNode = node;
      } else if (this.comparator_(node.value, opt_startValue) < 0) {
        retNode = node.right;
      } else {
        startNode = node;
      }
      return retNode; // If null, we'll stop traversing the tree
    });
  } else {
    startNode = this.getMinNode_();
  }

  // Traverse the tree and call func on each traversed node's value
  var node = startNode, prev = startNode.left ? startNode.left : startNode;
  while (node != null) {
    if (node.left != null && node.left != prev && node.right != prev) {
      node = node.left;
    } else {
      if (node.right != prev) {
        if (func(node.value)) {
          return;
        }
      }
      var temp = node;
      node = node.right != null && node.right != prev ?
             node.right :
             node.parent;
      prev = temp;
    }
  }
};


/**
 * Performs a reverse-order traversal of the tree and calls {@code func} with
 * each traversed node, optionally starting from the largest node with a value
 * <= to the specified start value. The traversal ends after traversing the
 * tree's minimum node or when func returns a value that evaluates to true.
 *
 * @param {function(T):?} func Function to call on each traversed node.
 * @param {Object=} opt_startValue If specified, traversal will begin on the
 *    node with the largest value <= opt_startValue.
 */
goog.structs.AvlTree.prototype.reverseOrderTraverse =
    function(func, opt_startValue) {
  // If our tree is empty, return immediately
  if (!this.root_) {
    return;
  }

  // Depth traverse the tree to find node to begin reverse-order traversal from
  var startNode;
  if (opt_startValue) {
    this.traverse_(goog.bind(function(node) {
      var retNode = null;
      if (this.comparator_(node.value, opt_startValue) > 0) {
        retNode = node.left;
      } else if (this.comparator_(node.value, opt_startValue) < 0) {
        retNode = node.right;
        startNode = node;
      } else {
        startNode = node;
      }
      return retNode; // If null, we'll stop traversing the tree
    }, this));
  } else {
    startNode = this.getMaxNode_();
  }

  // Traverse the tree and call func on each traversed node's value
  var node = startNode, prev = startNode.right ? startNode.right : startNode;
  while (node != null) {
    if (node.right != null && node.right != prev && node.left != prev) {
      node = node.right;
    } else {
      if (node.left != prev) {
        if (func(node.value)) {
          return;
        }
      }
      var temp = node;
      node = node.left != null && node.left != prev ?
             node.left :
             node.parent;
      prev = temp;
    }
  }
};


/**
 * Performs a traversal defined by the supplied {@code traversalFunc}. The first
 * call to {@code traversalFunc} is passed the root or the optionally specified
 * startNode. After that, calls {@code traversalFunc} with the node returned
 * by the previous call to {@code traversalFunc} until {@code traversalFunc}
 * returns null or the optionally specified endNode. The first call to
 * traversalFunc is passed the root or the optionally specified startNode.
 *
 * @param {Function} traversalFunc Function used to traverse the tree. Takes a
 *     node as a parameter and returns a node.
 * @param {goog.structs.AvlTree.Node.<T>=} opt_startNode The node at which the
 *     traversal begins.
 * @param {goog.structs.AvlTree.Node.<T>=} opt_endNode The node at which the
 *     traversal ends.
 * @private
 */
goog.structs.AvlTree.prototype.traverse_ =
    function(traversalFunc, opt_startNode, opt_endNode) {
  var node = opt_startNode ? opt_startNode : this.root_;
  var endNode = opt_endNode ? opt_endNode : null;
  while (node && node != endNode) {
    node = traversalFunc.call(this, node);
  }
};


/**
 * Ensures that the specified node and all its ancestors are balanced. If they
 * are not, performs left and right tree rotations to achieve a balanced
 * tree. This method assumes that at most 2 rotations are necessary to balance
 * the tree (which is true for AVL-trees that are balanced after each node is
 * added or removed).
 *
 * @param {goog.structs.AvlTree.Node.<T>} node Node to begin balance from.
 * @private
 */
goog.structs.AvlTree.prototype.balance_ = function(node) {

  this.traverse_(function(node) {
    // Calculate the left and right node's heights
    var lh = node.left ? node.left.height : 0;
    var rh = node.right ? node.right.height : 0;

    // Rotate tree rooted at this node if it is not AVL-tree balanced
    if (lh - rh > 1) {
      if (node.left.right && (!node.left.left ||
          node.left.left.height < node.left.right.height)) {
        this.leftRotate_(node.left);
      }
      this.rightRotate_(node);
    } else if (rh - lh > 1) {
      if (node.right.left && (!node.right.right ||
          node.right.right.height < node.right.left.height)) {
        this.rightRotate_(node.right);
      }
      this.leftRotate_(node);
    }

    // Recalculate the left and right node's heights
    lh = node.left ? node.left.height : 0;
    rh = node.right ? node.right.height : 0;

    // Set this node's height
    node.height = Math.max(lh, rh) + 1;

    // Traverse up tree and balance parent
    return node.parent;
  }, node);

};


/**
 * Performs a left tree rotation on the specified node.
 *
 * @param {goog.structs.AvlTree.Node.<T>} node Pivot node to rotate from.
 * @private
 */
goog.structs.AvlTree.prototype.leftRotate_ = function(node) {
  // Re-assign parent-child references for the parent of the node being removed
  if (node.isLeftChild()) {
    node.parent.left = node.right;
    node.right.parent = node.parent;
  } else if (node.isRightChild()) {
    node.parent.right = node.right;
    node.right.parent = node.parent;
  } else {
    this.root_ = node.right;
    this.root_.parent = null;
  }

  // Re-assign parent-child references for the child of the node being removed
  var temp = node.right;
  node.right = node.right.left;
  if (node.right != null) node.right.parent = node;
  temp.left = node;
  node.parent = temp;

  // Update counts.
  temp.count = node.count;
  node.count -= (temp.right ? temp.right.count : 0) + 1;
};


/**
 * Performs a right tree rotation on the specified node.
 *
 * @param {goog.structs.AvlTree.Node.<T>} node Pivot node to rotate from.
 * @private
 */
goog.structs.AvlTree.prototype.rightRotate_ = function(node) {
  // Re-assign parent-child references for the parent of the node being removed
  if (node.isLeftChild()) {
    node.parent.left = node.left;
    node.left.parent = node.parent;
  } else if (node.isRightChild()) {
    node.parent.right = node.left;
    node.left.parent = node.parent;
  } else {
    this.root_ = node.left;
    this.root_.parent = null;
  }

  // Re-assign parent-child references for the child of the node being removed
  var temp = node.left;
  node.left = node.left.right;
  if (node.left != null) node.left.parent = node;
  temp.right = node;
  node.parent = temp;

  // Update counts.
  temp.count = node.count;
  node.count -= (temp.left ? temp.left.count : 0) + 1;
};


/**
 * Removes the specified node from the tree and ensures the tree still
 * maintains the AVL-tree balance.
 *
 * @param {goog.structs.AvlTree.Node.<T>} node The node to be removed.
 * @private
 */
goog.structs.AvlTree.prototype.removeNode_ = function(node) {
  // Perform normal binary tree node removal, but balance the tree, starting
  // from where we removed the node
  if (node.left != null || node.right != null) {
    var b = null; // Node to begin balance from
    var r;        // Node to replace the node being removed
    if (node.left != null) {
      r = this.getMaxNode_(node.left);

      // Update counts.
      this.traverse_(function(node) {
        node.count--;
        return node.parent;
      }, r);

      if (r != node.left) {
        r.parent.right = r.left;
        if (r.left) r.left.parent = r.parent;
        r.left = node.left;
        r.left.parent = r;
        b = r.parent;
      }
      r.parent = node.parent;
      r.right = node.right;
      if (r.right) r.right.parent = r;
      if (node == this.maxNode_) this.maxNode_ = r;
      r.count = node.count;
    } else {
      r = this.getMinNode_(node.right);

      // Update counts.
      this.traverse_(function(node) {
        node.count--;
        return node.parent;
      }, r);

      if (r != node.right) {
        r.parent.left = r.right;
        if (r.right) r.right.parent = r.parent;
        r.right = node.right;
        r.right.parent = r;
        b = r.parent;
      }
      r.parent = node.parent;
      r.left = node.left;
      if (r.left) r.left.parent = r;
      if (node == this.minNode_) this.minNode_ = r;
      r.count = node.count;
    }

    // Update the parent of the node being removed to point to its replace
    if (node.isLeftChild()) {
      node.parent.left = r;
    } else if (node.isRightChild()) {
      node.parent.right = r;
    } else {
      this.root_ = r;
    }

    // Balance the tree
    this.balance_(b ? b : r);
  } else {
    // Update counts.
    this.traverse_(function(node) {
      node.count--;
      return node.parent;
    }, node.parent);

    // If the node is a leaf, remove it and balance starting from its parent
    if (node.isLeftChild()) {
      this.special = 1;
      node.parent.left = null;
      if (node == this.minNode_) this.minNode_ = node.parent;
      this.balance_(node.parent);
    } else if (node.isRightChild()) {
      node.parent.right = null;
      if (node == this.maxNode_) this.maxNode_ = node.parent;
      this.balance_(node.parent);
    } else {
      this.clear();
    }
  }
};


/**
 * Returns the node in the tree that has k nodes before it in an in-order
 * traversal, optionally rooted at {@code opt_rootNode}.
 *
 * @param {number} k The number of nodes before the node to be returned in an
 *     in-order traversal, where 0 <= k < root.count.
 * @param {goog.structs.AvlTree.Node.<T>=} opt_rootNode Optional root node.
 * @return {goog.structs.AvlTree.Node.<T>} The node at the specified index.
 * @private
 */
goog.structs.AvlTree.prototype.getKthNode_ = function(k, opt_rootNode) {
  var root = opt_rootNode || this.root_;
  var numNodesInLeftSubtree = root.left ? root.left.count : 0;

  if (k < numNodesInLeftSubtree) {
    return this.getKthNode_(k, root.left);
  } else if (k == numNodesInLeftSubtree) {
    return root;
  } else {
    return this.getKthNode_(k - numNodesInLeftSubtree - 1, root.right);
  }
};


/**
 * Returns the node with the smallest value in tree, optionally rooted at
 * {@code opt_rootNode}.
 *
 * @param {goog.structs.AvlTree.Node.<T>=} opt_rootNode Optional root node.
 * @return {goog.structs.AvlTree.Node.<T>} The node with the smallest value in
 *     the tree.
 * @private
 */
goog.structs.AvlTree.prototype.getMinNode_ = function(opt_rootNode) {
  if (!opt_rootNode) {
    return this.minNode_;
  }

  var minNode = opt_rootNode;
  this.traverse_(function(node) {
    var retNode = null;
    if (node.left) {
      minNode = node.left;
      retNode = node.left;
    }
    return retNode; // If null, we'll stop traversing the tree
  }, opt_rootNode);

  return minNode;
};


/**
 * Returns the node with the largest value in tree, optionally rooted at
 * opt_rootNode.
 *
 * @param {goog.structs.AvlTree.Node.<T>=} opt_rootNode Optional root node.
 * @return {goog.structs.AvlTree.Node.<T>} The node with the largest value in
 *     the tree.
 * @private
 */
goog.structs.AvlTree.prototype.getMaxNode_ = function(opt_rootNode) {
  if (!opt_rootNode) {
    return this.maxNode_;
  }

  var maxNode = opt_rootNode;
  this.traverse_(function(node) {
    var retNode = null;
    if (node.right) {
      maxNode = node.right;
      retNode = node.right;
    }
    return retNode; // If null, we'll stop traversing the tree
  }, opt_rootNode);

  return maxNode;
};



/**
 * Constructs an AVL-Tree node with the specified value. If no parent is
 * specified, the node's parent is assumed to be null. The node's height
 * defaults to 1 and its children default to null.
 *
 * @param {T} value Value to store in the node.
 * @param {goog.structs.AvlTree.Node.<T>=} opt_parent Optional parent node.
 * @constructor
 * @final
 * @template T
 */
goog.structs.AvlTree.Node = function(value, opt_parent) {
  /**
   * The value stored by the node.
   *
   * @type {T}
   */
  this.value = value;

  /**
   * The node's parent. Null if the node is the root.
   *
   * @type {goog.structs.AvlTree.Node.<T>}
   */
  this.parent = opt_parent ? opt_parent : null;

  /**
   * The number of nodes in the subtree rooted at this node.
   *
   * @type {number}
   */
  this.count = 1;
};


/**
 * The node's left child. Null if the node does not have a left child.
 *
 * @type {?goog.structs.AvlTree.Node.<T>}
 */
goog.structs.AvlTree.Node.prototype.left = null;


/**
 * The node's right child. Null if the node does not have a right child.
 *
 * @type {?goog.structs.AvlTree.Node.<T>}
 */
goog.structs.AvlTree.Node.prototype.right = null;


/**
 * The height of the tree rooted at this node.
 *
 * @type {number}
 */
goog.structs.AvlTree.Node.prototype.height = 1;


/**
 * Returns true iff the specified node has a parent and is the right child of
 * its parent.
 *
 * @return {boolean} Whether the specified node has a parent and is the right
 *    child of its parent.
 */
goog.structs.AvlTree.Node.prototype.isRightChild = function() {
  return !!this.parent && this.parent.right == this;
};


/**
 * Returns true iff the specified node has a parent and is the left child of
 * its parent.
 *
 * @return {boolean} Whether the specified node has a parent and is the left
 *    child of its parent.
 */
goog.structs.AvlTree.Node.prototype.isLeftChild = function() {
  return !!this.parent && this.parent.left == this;
};

//ipc/invalidation/javascript/internal/client/simpleregistrationstore.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview Simple, map-based implementation of {@code DigestStore}.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.DigestObjectIdPair');
goog.provide('invalidation.SimpleRegistrationStore');

goog.require('goog.structs.AvlTree');

/**
 * Implements the Digestore using a map and a sorted array.
 *
 * @param {!invalidation.DigestFunction} digestFunction The function used for
 *     computing the digests.
 * @param {!invalidation.SystemResources.Logger} logger Logger for logging.
 * @constructor
 * @implements {invalidation.DigestStore}
 */
invalidation.SimpleRegistrationStore = function(digestFunction, logger) {

  /**
   * All the registrations in the store mapped from the digest to the Object Id.
   * @type {!goog.structs.AvlTree}
   * @private
   */
  this.registrations_ = new goog.structs.AvlTree(
      invalidation.DigestObjectIdPair.Comparator);

  /**
   * Logger used for logging.
   * @type {invalidation.SystemResources.Logger}
   * @private
   */
  this.logger_ = logger;

  /**
   * The function used to compute digests of objects.
   * @type {!invalidation.DigestFunction}
   * @private
   */
  this.digestFunction_ = digestFunction;

  /**
   * The memoized digest of all objects in registrations.
   * @type {!invalidation.DigestFunction.Digest}
   * @private
   */
  this.digest_;

  this.recomputeDigest_();
};

/**
 * A record for keeping track of an object's id and its digest.
 *
 * @param {!invalidation.DigestFunction.Digest} digest The digest for
 *     {@code objectId}.
 * @param {!invalidation.proto.ObjectIdP} objectId Object id.
 * @constructor
 */
invalidation.DigestObjectIdPair = function(digest, objectId) {
  /**
   * Digest for the given object id.
   * @type {!invalidation.DigestFunction.Digest}
   */
  this.digest = digest;

  /**
   * Object id whose information is being maintained.
   */
  this.objectId = objectId;
};

/**
 * @override
 */
invalidation.DigestObjectIdPair.prototype.toString = function() {
  return goog.string.format('[%s, %s]', this.digest.toString(),
      this.objectId.toString());
};


/**
 * Comparison function used to compare the digest in a
 * {@code DigestObjectIdPair}
 *
 * @param {!invalidation.DigestObjectIdPair} a The first
 *     digest-objectid pair.
 * @param {!invalidation.DigestObjectIdPair} b The
 *     second digest-objectid pair.
 * @return {number} -1 if a < b, 1 if a > b, 0 if a = b.
 */
invalidation.DigestObjectIdPair.Comparator =
    function(a, b) {
  return invalidation.DigestFunction.Digest.Compare(a.digest, b.digest);
};

/**
 * @override
 */
invalidation.SimpleRegistrationStore.prototype.add = function(oids) {
  // For each object that is not present, add it to the tree.
  var addedOids = [];
  for (var i = 0; i < oids.length; i++) {
    var oid = oids[i];
    var digest = invalidation.ObjectIdDigestUtils.getObjectDigest(oid,
        this.digestFunction_);
    var pair = new invalidation.DigestObjectIdPair(digest, oid);
    if (!this.registrations_.contains(pair)) {
      this.registrations_.add(pair);
      addedOids.push(oid);
    }
  }
  if (addedOids.length > 0) {
    // Only recompute the digest if we made changes.
    this.recomputeDigest_();
  }
  return addedOids;
};

/**
 * @override
 */
invalidation.SimpleRegistrationStore.prototype.remove = function(oids) {
  // For each object that is present, remove it from the tree.
  var removedOids = [];
  for (var i = 0; i < oids.length; i++) {
    var oid = oids[i];
    var digest = invalidation.ObjectIdDigestUtils.getObjectDigest(oid,
        this.digestFunction_);
    var pair = new invalidation.DigestObjectIdPair(digest, oid);
    if (this.registrations_.contains(pair)) {
      this.registrations_.remove(pair);
      removedOids.push(oid);
    }
  }
  if (removedOids.length > 0) {
    // Only recompute the digest if we made changes.
    this.recomputeDigest_();
  }
  return removedOids;
};

/**
 * @override
 */
invalidation.SimpleRegistrationStore.prototype.removeAll = function() {
  var oids = [];
  var regs = this.registrations_.getValues();
  for (var i = 0; i < regs.length; i++) {
    oids.push(regs[i].objectId);
  }
  this.registrations_.clear();
  this.recomputeDigest_();
  return oids;
};

/**
 * @override
 */
invalidation.SimpleRegistrationStore.prototype.contains = function(oid) {
  var digest = invalidation.ObjectIdDigestUtils.getObjectDigest(oid,
      this.digestFunction_);
  var pair = new invalidation.DigestObjectIdPair(digest, oid);
  return this.registrations_.contains(pair);
};

/**
 * @override
 */
invalidation.SimpleRegistrationStore.prototype.size = function() {
  return this.registrations_.getCount();
};

/**
 * @override
 */
invalidation.SimpleRegistrationStore.prototype.getDigest = function() {
  return this.digest_;
};

/**
 * @override
 */
invalidation.SimpleRegistrationStore.prototype.getElements =
    function(oidDigestPrefix, prefixLen) {
  // We always return all the registrations and let the Ticl sort it out.
  var oids = [];
  var regs = this.registrations_.getValues();
  for (var i = 0; i < regs.length; i++) {
    oids.push(regs[i].objectId);
  }
  return oids;
};

/**
 * Recomputes the digests over all objects and sets {@code this.digest_}.
 * @private
 */
invalidation.SimpleRegistrationStore.prototype.recomputeDigest_ = function() {
  var digests = [];

  // Extract all the object digests in sorted order and compute the digest.
  var regs = this.registrations_.getValues();
  for (var i = 0; i < regs.length; i++) {
    digests.push(regs[i].digest);
  }
  this.digest_ = invalidation.ObjectIdDigestUtils.getDigest(digests,
      this.digestFunction_);
};

/**
 * @override
 */
invalidation.SimpleRegistrationStore.prototype.toString = function() {
  return goog.string.format('Digest: %s, Regs: %s', this.digest_.toString(),
      this.registrations_.getValues().toString());
};

//ipc/invalidation/javascript/internal/client/registrationmanager.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview  Object to track desired client registrations.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.RegistrationManager');

goog.require('goog.structs.Map');
goog.require('invalidation.SimpleRegistrationStore');
goog.require('invalidation.Utils');
goog.require('invalidation.proto.ObjectIdP');
goog.require('invalidation.proto.RegistrationManagerStateP');
goog.require('invalidation.proto.RegistrationSubtree');
goog.require('invalidation.proto.RegistrationSummary');

/**
 * Registration manager to handle all the registered objects for a client.
 *
 * @param {!invalidation.SystemResources.Logger} logger Logger for logging.
 * @param {!invalidation.Statistics} statistics Object used to track
 *     various performance counters.
 * @param {!invalidation.DigestFunction} digestFunction Function used to compute
 *     the digest of the registered objects.
 * @constructor
 */
invalidation.RegistrationManager = function(logger, statistics,
    digestFunction) {

  /**
   * Prefix used to request all registrations.
   * @type {string}
   * @private
   */
  this.emptyPrefix_ = '';

  /**
   * The set of regisrations that the application has requested for.
   * @type {!invalidation.DigestStore}
   * @private
   */
  this.desiredRegistrations_ =
      new invalidation.SimpleRegistrationStore(digestFunction, logger);

  /**
   * Statistics objects to track number of sent messages, etc.
   * @type {!invalidation.Statistics}
   * @private
   */
  this.statistics_ = statistics;

  /**
   * Latest known server registration state summary.
   * <p>
   * Initialize the server summary with a 0 size and the digest corresponding
   * to it.  Using defaultInstance would wrong since the server digest will
   * not match unnecessarily and result in an info message being sent.
   * @type {!invalidation.proto.RegistrationSummary}
   * @private
   */
  this.lastKnownServerSummary_ = this.getRegistrationSummary();

  /**
   * Map of object ids and operation types for which we have not yet issued any
   * registration-status upcall to the listener. We need this so that we can
   * synthesize success upcalls if registration sync, rather than a server
   * message, communicates to us that we have a successful (un)registration.
   * <p>
   * This is a map from object id to type, rather than a set of
   * {@code RegistrationP}, because a set of {@code RegistrationP} would assume
   * that we always get a response for every operation we issue, which isn't
   * necessarily true (i.e., the server might send back an unregistration
   * status in response to a registration request).
   * @type {!goog.structs.Map.<string,!invalidation.proto.RegistrationP.OpType>}
   * @private
   */
  this.pendingOperations_ = new goog.structs.Map();

  /**
   * Logger used for logging.
   * @type {invalidation.SystemResources.Logger}
   * @private
   */
  this.logger_ = logger;
};

/**
 * Returns a copy of the registration manager's state
 *
 * @param {!invalidation.DigestFunction} digestFunction The function used
 *     to compute the digests for objects.
 * @return {!invalidation.proto.RegistrationManagerStateP} Copy of the
 *     registration manager's state.
 */
invalidation.RegistrationManager.prototype.
    getRegistrationManagerStateCopyForTest = function(digestFunction) {
  var state = new invalidation.proto.RegistrationManagerStateP();
  state.setClientSummary(this.getRegistrationSummary());
  state.setServerSummary(this.lastKnownServerSummary_);

  var registeredObjs =
      this.desiredRegistrations_.getElements(this.emptyPrefix_, 0);
  for (var i = 0; i < registeredObjs.length; i++) {
    state.addRegisteredObjects(registeredObjs[i]);
  }
  return state;
};

/**
 * Sets the digest store to be {@code digestStore} for testing purposes.
 * <p>
 * REQUIRES: This method is called before the Ticl has done any operations on
 * this object.
 *
 * @param {!invalidation.DigestStore} digestStore The new digest store for
 *     the registration manager.
 */
invalidation.RegistrationManager.prototype.setDigestStoreForTest =
    function(digestStore) {
  this.desiredRegistrations_ = digestStore;
  this.lastKnownServerSummary_ = this.getRegistrationSummary();
};

/**
 * Returns the set of registered objects (for test only).
 *
 * @return {!Array.<!invalidation.proto.ObjectIdP>} The registered objects.
 */
invalidation.RegistrationManager.prototype.getRegisteredObjectsForTest =
    function() {
  return this.desiredRegistrations_.getElements(this.emptyPrefix_, 0);
};

/**
 * Perform registration/unregistation for all objects in {@code objectIds}.
 *
 *  @param {!Array.<!invalidation.proto.ObjectIdP>} objectIds The objects to be
 *      registered or unregistered.
 *  @param {!invalidation.proto.RegistrationP.OpType} regOpType Whether to
 *      perform a registration or unregistration operation.
 *  @return {!Array.<!invalidation.proto.ObjectIdP>} The objects for which
 *      registration messages need to be sent to the server.
 */
invalidation.RegistrationManager.prototype.performOperations =
    function(objectIds, regOpType) {
  // Record that we have pending operations on the objects.
  for (var i = 0; i < objectIds.length; i++) {
    var objectId = objectIds[i];
    this.pendingOperations_.set(
        invalidation.Utils.getMessageKey(objectId), regOpType);
  }
  // Update the digest appropriately.
  if (regOpType == invalidation.proto.RegistrationP.OpType.REGISTER) {
    return this.desiredRegistrations_.add(objectIds);
  } else {
    return this.desiredRegistrations_.remove(objectIds);
  }
};

/**
 * Returns a registration subtree for registrations where the digest of the
 * object id begins with the prefix {@code digestPrefix} of {@code prefixLen}
 * bits. This method may also return objects whose digest prefix does not match
 * {@code digestPrefix}.
 *
 * @param {string} digestPrefix The digest prefix as explained above.
 * @param {number} prefixLen Number of bits in digestPrefix that are relevant.
 * @return {!invalidation.proto.RegistrationSubtree} The subtree corresponding
 *     to the registered objects.
 */
invalidation.RegistrationManager.prototype.getRegistrations =
    function(digestPrefix, prefixLen) {
  var subtree = new invalidation.proto.RegistrationSubtree();
  var objectIds =
      this.desiredRegistrations_.getElements(digestPrefix, prefixLen);
  for (var i = 0; i < objectIds.length; i++) {
    subtree.addRegisteredObject(objectIds[i]);
  }
  return subtree;
};

/**
 * Handles registration operation statuses from the server. Returns a list of
 * booleans, one per registration status, that indicates whether the
 * registration operation was both successful and agreed with the desired client
 * state (i.e., for each registration status, (status.optype == register) ==
 * desiredRegistrations.contains(status.objectid)).
 * <p>
 * REQUIRES: the caller subsequently make an informRegistrationStatus or
 * informRegistrationFailure upcall on the listener for each registration in
 * {@code registrationStatuses}.
 *
 * @param {!Array.<invalidation.proto.RegistrationStatus>} registrationStatuses
 *     A list of local-processing status codes, one per element of
 *     {@code registrationStatuses}.
 * @return {!Array.<boolean>} Result of handling the registration statuses,
 *     one per registrationStatus.
 */
invalidation.RegistrationManager.prototype.handleRegistrationStatus =
    function(registrationStatuses) {

  // Local-processing result code for each element of registrationStatuses.
  var localStatuses = [];
  for (var i = 0; i < registrationStatuses.length; i++) {
    var registrationStatus = registrationStatuses[i];

    var objectId = /** @type {!invalidation.proto.ObjectIdP} */
        (registrationStatus.getRegistration().getObjectId());

    // The object is no longer pending, since we have received a server status
    // for it, so remove it from the pendingOperations map. (It may or may not
    // have existed in the map, since we can receive spontaneous status messages
    // from the server.)
    this.pendingOperations_.remove(invalidation.Utils.getMessageKey(objectId));

    // We start off with the local-processing set as success, then potentially
    // fail.
    var isSuccess = true;

    // if the server operation succeeded, then local processing fails on
    // "incompatibility" as defined above.
    if (invalidation.CommonProtos.isSuccess(registrationStatus.getStatus())) {
      var appWantsRegistration = this.desiredRegistrations_.contains(objectId);
      var isOpRegistration = registrationStatus.getRegistration().getOpType() ==
          invalidation.proto.RegistrationP.OpType.REGISTER;
      var discrepancyExists = isOpRegistration ^ appWantsRegistration;
      if (discrepancyExists) {
        // Remove the registration and set isSuccess to false, which will cause
        // the caller to issue registration-failure to the application.
        this.desiredRegistrations_.remove([objectId]);
        this.statistics_.recordError(
            invalidation.Statistics.ClientErrorType.REGISTRATION_DISCREPANCY);
        this.logger_.info(
            'Ticl discrepancy detected: registered = %s, requested = %s. ' +
            'Removing %s from requested',
            isOpRegistration, appWantsRegistration, objectId.toString());
        isSuccess = false;
      }
    } else {
      // If the server operation failed, then local processing also fails.
      this.desiredRegistrations_.remove([objectId]);
      this.logger_.fine('Removing %s from committed', objectId.toString());
      isSuccess = false;
    }
    localStatuses.push(isSuccess);
  }
  return localStatuses;
};

/**
 * Removes all desired registrations and pending operations. Returns all object
 * ids that were affected.
 * <p>
 * REQUIRES: the caller issue a permanent failure upcall to the listener for all
 * returned object ids.
 * @return {!Array.<!invalidation.proto.ObjectIdP>} Removed registrations.
 */
invalidation.RegistrationManager.prototype.removeRegisteredObjects =
    function() {
  // Map used to create a set of all object ids to return, in their message-key
  // forms.
  var serializedOids =
      /** @type {!goog.structs.Map.<string, !string>} */
      (new goog.structs.Map());

  // Clear the digest store and add the objects to the serializedOids set.
  var desiredRegistrations = this.desiredRegistrations_.removeAll();
  for (var i = 0; i < desiredRegistrations.length; i++) {
    serializedOids.set(
        invalidation.Utils.getMessageKey(desiredRegistrations[i]), '');
  }
  // Clear the pending operations map and add the objects to the serializedOids
  // set.
  var serializedPendingOids = this.pendingOperations_.getKeys();
  for (var i = 0; i < serializedPendingOids.length; i++) {
    serializedOids.set(serializedPendingOids[i], '');
  }
  this.pendingOperations_.clear();

  // Convert the serialized object ids to deserialized form and return them.
  var oidsToReturn = [];
  var serializedOidKeys = serializedOids.getKeys();
  for (var i = 0; i < serializedOidKeys.length; i++) {
    var objectId = new invalidation.proto.ObjectIdP();
    invalidation.Utils.parseProtoFromKey(serializedOidKeys[i], objectId);
    oidsToReturn.push(objectId);
  }
  return oidsToReturn;
};

//
// Summary-related methods
//

/**
 * Returns a summary of the desired registrations.
 *
 * @return {!invalidation.proto.RegistrationSummary} Registration summary.
 */
invalidation.RegistrationManager.prototype.getRegistrationSummary =
    function() {
  var summary = new invalidation.proto.RegistrationSummary();
  summary.setNumRegistrations(this.desiredRegistrations_.size());
  var digest = this.desiredRegistrations_.getDigest();
  summary.setRegistrationDigest(digest.serialize());
  return summary;
};

/**
 * Informs the manager of a new registration state summary from the server.
 * Returns a possibly-empty map of <object-id, reg-op-type>. For each entry in
 * the map, the caller should make an inform-registration-status upcall on the
 * listener.
 * @param {invalidation.proto.RegistrationSummary} regSummary Summary from the
 *     server.
 * @return {!Array.<!invalidation.proto.RegistrationP>} Upcalls to make.
 */
invalidation.RegistrationManager.prototype.informServerRegistrationSummary =
    function(regSummary) {
  if (regSummary != null) {
    this.lastKnownServerSummary_ = regSummary;
  }

  var upcalls = [];
  if (this.isStateInSyncWithServer()) {
    // If we are now in sync with the server, then the caller should make
    // inform-reg-status upcalls for all operations that we had pending, if any;
    // they are also no longer pending.
    var serializedOids = this.pendingOperations_.getKeys();
    for (var i = 0; i < serializedOids.length; i++) {
      var objectId = new invalidation.proto.ObjectIdP();
      invalidation.Utils.parseProtoFromKey(serializedOids[i], objectId);
      var isReg = this.pendingOperations_.get(serializedOids[i]) ==
          invalidation.proto.RegistrationP.OpType.REGISTER;
      var regOp = invalidation.CommonProtos.newRegistrationP(objectId, isReg);
      upcalls.push(regOp);
    }
    this.pendingOperations_.clear();
  }
  return upcalls;
};

/**
 * Returns whether the local registration state and server state agree, based
 * on the last received server summary (from
 * {@code informServerRegistrationSummary}).
 *
 * @return {boolean} Whether the client and server agree.
 */
invalidation.RegistrationManager.prototype.isStateInSyncWithServer =
    function() {
  return this.lastKnownServerSummary_.equals(this.getRegistrationSummary());
};

/**
 * @override
 */
invalidation.RegistrationManager.prototype.toString = function() {
  return goog.string.format('Last known digest: %s, Requested regs: %s',
    this.lastKnownServerSummary_.toString(),
    this.desiredRegistrations_.toString());
};

//ipc/invalidation/javascript/internal/client/smearer.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview  An abstraction to "smear" values by a given percent. Useful
 * for randomizing delays a little bit so that (say) processes do not get
 * synchronized on time inadvertently, e.g., a heartbeat task that sends a
 * message every few minutes is smeared so that all clients do not end up
 * sending a message at the same time. In particular, given a {@code delay},
 * returns a value that is randomly distributed between
 * [delay - smearPercent * delay, delay + smearPercent * delay].
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.Smearer');

/**
 * Creates a smearer with the given smear percent.
 * <p>
 * If defined, REQUIRES: 0 < smearPercent <= 100
 *
 * @param {!function(): number} random Random number generator that returns a
 *     number between 0 and 1.
 * @param {number} smearPercent The percentage of the delay that is used to
 *     randomize delays.
 * @constructor
 */
invalidation.Smearer = function(random, smearPercent) {

  /**
   * Random number generator that returns a number between 0 and 1.
   * @type {!function(): number}
   * @private
   */
  this.random_ = random;

  goog.asserts.assert((smearPercent >= 0) && (smearPercent <= 100));
  /**
   * The fraction by which a given delay is randomized.
   * @type {number}
   * @private
   */
  this.smearFraction_ = smearPercent / 100.0;
};

/**
 * Given a {@code delay}, returns a value that is randomly distributed between
 * [delay - smearPercent * delay, delay + smearPercent * delay]
 *
 * @param {number} delay The delay that needs to be smeared.
 * @return {number} The smeared delay.
 */
invalidation.Smearer.prototype.getSmearedDelay = function(delay) {
  // Get a random number between -1 and 1 and then multiply that by the smear
  // fraction.
  var smearFactor = (2 * this.random_() - 1.0) * this.smearFraction_;
  return Math.ceil(delay + (delay * smearFactor));
};

//ipc/invalidation/javascript/internal/client/invalidationclientcore.js
// Copyright 2011 Google Inc. All rights reservved.

/**
 * @fileoverview Implementation of the Tango Invalidation Client Library (Ticl).
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.ClientCore');
goog.provide('invalidation.ClientCore.AcquireTokenTask');
goog.provide('invalidation.ClientCore.BatchingTask');
goog.provide('invalidation.ClientCore.HeartbeatTask');
goog.provide('invalidation.ClientCore.PersistentWriteTask');
goog.provide('invalidation.ClientCore.RegSyncHeartbeatTask');
goog.require('goog.asserts');
goog.require('goog.crypt.base64');
goog.require('goog.string');
goog.require('goog.structs.Map');
goog.require('invalidation.Client');
goog.require('invalidation.CommonProtos');
goog.require('invalidation.DigestFunction');
goog.require('invalidation.ExponentialBackoffDelayGenerator');
goog.require('invalidation.Listener');
goog.require('invalidation.PersistenceUtils');
goog.require('invalidation.ProtoConverter');
goog.require('invalidation.ProtocolListener');
goog.require('invalidation.RecurringTask');
goog.require('invalidation.RegistrationManager');
goog.require('invalidation.Sha1DigestFunction');
goog.require('invalidation.Smearer');
goog.require('invalidation.Statistics');
goog.require('invalidation.Types.ErrorInfo');
goog.require('invalidation.Utils');
goog.require('invalidation.proto.ClientConfigP');
goog.require('invalidation.proto.InfoRequestMessage');
goog.require('invalidation.proto.RegistrationP');

/**
 * Implements the invalidation Client.
 *
 * @param {!invalidation.SystemResources} resources Resources used for
 *     scheduling, logging, sending network messages, etc.
 * @param {function(): number} random Random number generator that returns a
 *     number between 0 and 1. If {@code null}, uses {@code Math.random}
 *     internally.
 * @param {number} clientType Client type code assigned by the backend.
 * @param {string} clientName Application identifier for the client.
 * @param {!invalidation.proto.ClientConfigP} config Configuration for the
 *     client.
 * @param {string} applicationName Name of the application using the library
 *     (for debugging/monitoring).
 * @param {!invalidation.Listener} listener Application callback.
 *
 * @constructor
 * @implements {invalidation.Client}
 * @implements {invalidation.ProtocolListener}
 */
invalidation.ClientCore = function(resources, random, clientType, clientName,
    config, applicationName, listener) {

  /**
   * A random number generator.
   * @type {!function() : number}
   * @private
   */
  this.random_ = (random == null) ? Math.random : random;

  /**
   * The single key used to write all the Ticl state.
   * @type {string}
   * @private
   */
  this.clientTokenKey_ = invalidation.ClientCore.CLIENT_TOKEN_KEY;

  /**
   * Resources for the Ticl.
   * @type {!invalidation.SystemResources}
   * @private
   */
  this.resources_ = resources;

  /**
   * Reference into the resources object for cleaner code. All Ticl code must
   * be scheduled on this scheduler.
   * @type {!invalidation.SystemResources.Scheduler}
   * @private
   */
  this.internalScheduler_ = resources.getInternalScheduler();

  /**
   * Logger reference into the resources object for cleaner code.
   * @type {!invalidation.SystemResources.Logger}
   * @private
   */
  this.logger_ = resources.getLogger();

  /**
   * Application callback listener object.
   * @type {!invalidation.Listener}
   * @private
   */
  this.listener_ = listener;

  /**
   * Configuration for this instance.
   * @type {!invalidation.proto.ClientConfigP}
   * @private
   */
  this.config_ = config;

  /**
   * Application identifier for this client.
   * @type {!invalidation.proto.ApplicationClientIdP}
   * @private
   */
  this.applicationClientId_ =
      invalidation.CommonProtos.newApplicationClientIdP(clientType,
          clientName);

  /**
   * Statistics objects to track number of sent messages, etc.
   * @type {!invalidation.Statistics}
   * @private
   */
  this.statistics_ = new invalidation.Statistics();

  /**
   * The function for computing the registration and persistence state digests.
   * @type {!invalidation.DigestFunction}
   * @private
   */
  this.digestFn_ = new invalidation.Sha1DigestFunction();

  /**
   * Object maintaining the registration state for this client.
   * @type {!invalidation.RegistrationManager}
   * @private
   */
  this.registrationManager_ = new invalidation.RegistrationManager(
      this.logger_, this.statistics_, this.digestFn_);

  /**
   * Used to validate messages.
   * @type {invalidation.TiclMessageValidator}
   * @private
   */
  this.msgValidator_ = new invalidation.TiclMessageValidator(this.logger_);

  /**
   * A smearer to make sure that delays are randomized a little bit.
   * @type {!invalidation.Smearer}
   * @private
   */
  this.smearer_ = new invalidation.Smearer(this.random_,
      config.getSmearPercentOrDefault());

  var protocolConfig = config.getProtocolHandlerConfigOrDefault();
  /**
   * Object handling low-level wire format interactions.
   * @type {!invalidation.ProtocolHandler}
   * @private
   */
  this.protocolHandler_ = new invalidation.ProtocolHandler(
      protocolConfig, resources, this.smearer_, this.statistics_,
      clientType, applicationName, this, this.msgValidator_);

  /**
   * The state of the Ticl whether it has started or not.
   * @type {!invalidation.RunState}
   * @private
   */
  this.ticlState_ = new invalidation.RunState();

  /**
   * Current client token known from the server.
   * @type {?string}
   * @private
   */
  this.clientToken_ = null;

  // After the client starts, exactly one of nonce and clientToken is non-null.

  /**
   * If not {@code null}, nonce for pending identifier request.
   * @type {?string}
   * @private
   */
  this.nonce_ = null;

  /**
   * Whether we should send registrations to the server or not.
   * @type {boolean}
   * @private
   */
  this.shouldSendRegistrations_ = false;

  /**
   * Whether the network is online.  Assume so when we start.
   * @type {boolean}
   * @private
   */
  this.isOnline_ = true;

  /**
   * Last time a message was sent to the server.
   * @type {number}
   * @private
   */
  this.lastMessageSendTimeMs_ = 0;

  /**
   * A task for acquiring the token (if the client has no token).
   * @type {!invalidation.ClientCore.AcquireTokenTask}
   * @private
   */
  this.acquireTokenTask_;

  /**
   * Task for checking if reg summary is out of sync and then sending a
   * heartbeat to the server.
   * @type {!invalidation.ClientCore.RegSyncHeartbeatTask}
   * @private
   */
  this.regSyncHeartbeatTask_;

  /**
   * Task for writing the state blob to persistent storage.
   * @type {!invalidation.ClientCore.PersistentWriteTask}
   * @private
   */
  this.persistentWriteTask_;

  /**
   * A task for periodic heartbeats.
   * @type {!invalidation.ClientCore.HeartbeatTask}
   * @private
   */
  this.heartbeatTask_;

  /**
   * The task that is scheduled to send batched messages to the server (when
   * needed).
   * @type {!invalidation.ClientCore.BatchingTask}
   * @private
   */
  this.batchingTask_;

  // Create all the tasks.
  this.createSchedulingTasks();

  // Bind to the network.
  this.registerWithNetwork_();

  this.logger_.info('Created client: %s', this);
};

/**
 * The single key used to write all the Ticl state.
 * @type {string}
 * @const
 */
invalidation.ClientCore.CLIENT_TOKEN_KEY = 'ClientToken';

//
// Various recurring tasks used by the Ticl.
//

/**
 * A task for acquiring tokens from the server.
 *
 * @param {!invalidation.ClientCore} client The client using this task.
 *
 * @constructor
 * @extends {invalidation.RecurringTask}
 */
invalidation.ClientCore.AcquireTokenTask = function(client) {
  var config = client.config_;
  var delayGenerator = client.createExpBackOffGenerator(
      config.getNetworkTimeoutDelayMsOrDefault());

  // Cannot use goog.base since this code will not work with Rhino.
  invalidation.RecurringTask.call(this, 'AcquireToken',
      client.internalScheduler_, client.logger_, client.smearer_,
      delayGenerator, 0, config.getNetworkTimeoutDelayMsOrDefault());

  /**
   * @type {!invalidation.ClientCore}
   * @private
   */
  this.client_ = client;
};
goog.inherits(invalidation.ClientCore.AcquireTokenTask,
    invalidation.RecurringTask);

/**
 * @override
 */
invalidation.ClientCore.AcquireTokenTask.prototype.runTask = function() {
  // If token is still not assigned (as expected), sends a request. Otherwise,
  // ignore.
  var client = this.client_;
  if (client.clientToken_ == null) {
    // Allocate a nonce and send a message requesting a new token.
    client.setNonce_(invalidation.ClientCore.generateNonce(
        this.client_.random_));
    client.protocolHandler_.sendInitializeMessage(client.applicationClientId_,
        /** @type {string} */ (client.nonce_), this.client_.batchingTask_,
        'AcquireToken');
    // Reschedule to check state, retry if necessary after timeout.
    return true;
  } else {
    return false;  // Don't reschedule.
  }
};

/**
 * A task that schedules heartbeats when the registration summary at the client
 * is not in sync with the registration summary from the server.
 *
 * @param {!invalidation.ClientCore} client The client using this task.
 *
 * @constructor
 * @extends {invalidation.RecurringTask}
 */
invalidation.ClientCore.RegSyncHeartbeatTask = function(client) {
  var config = client.config_;
  var networkDelayMs = config.getNetworkTimeoutDelayMsOrDefault();
  var delayGenerator = client.createExpBackOffGenerator(networkDelayMs);

  // Cannot use goog.base since this code will not work with Rhino.
  invalidation.RecurringTask.call(this, 'RegSyncHeartbeat',
      client.internalScheduler_, client.logger_, client.smearer_,
      delayGenerator, networkDelayMs, networkDelayMs);

  /**
   * @type {!invalidation.ClientCore}
   * @private
   */
  this.client_ = client;
};
goog.inherits(invalidation.ClientCore.RegSyncHeartbeatTask,
    invalidation.RecurringTask);

/**
 * @override
 */
invalidation.ClientCore.RegSyncHeartbeatTask.prototype.runTask = function() {
  var client = this.client_;
  if (!client.registrationManager_.isStateInSyncWithServer()) {
    // Simply send an info message to ensure syncing happens.
    client.logger_.info('Registration state not in sync with server: %s',
        client.registrationManager_);
    client.sendInfoMessageToServer_(false, true /* request summary */);
    return true;
  } else {
    client.logger_.info('Not sending message since state is now in sync');
    return false;
  }
};

/**
 * A task that writes the token to persistent storage.
 *
 * @param {!invalidation.ClientCore} client The client using this task.
 *
 * @constructor
 * @extends {invalidation.RecurringTask}
 */
invalidation.ClientCore.PersistentWriteTask = function(client) {
  var config = client.config_;
  var delayGenerator = client.createExpBackOffGenerator(
      config.getWriteRetryDelayMsOrDefault());

  // Cannot use goog.base since this code will not work with Rhino.
  invalidation.RecurringTask.call(this, 'PersistentWrite',
      client.internalScheduler_, client.logger_, client.smearer_,
      delayGenerator, 0, config.getWriteRetryDelayMsOrDefault());

  /**
   * @type {!invalidation.ClientCore}
   * @private
   */
  this.client_ = client;

  /**
   * The last client token that was written to to persistent state
   * successfully.
   * @type {?string}
   * @private
   */
  this.lastWrittenToken_ = null;
};
goog.inherits(invalidation.ClientCore.PersistentWriteTask,
    invalidation.RecurringTask);

/**
 * @override
 */
invalidation.ClientCore.PersistentWriteTask.prototype.runTask = function() {
  var client = this.client_;
  var clientToken = /** @type {string} */ (client.clientToken_);
  var state =
      invalidation.CommonProtos.newPersistentTiclState(clientToken);
  var serializedState = invalidation.PersistenceUtils.serializeState(state,
      client.digestFn_);
  if ((clientToken == null) || (clientToken == this.lastWrittenToken_)) {
    // No work to be done. Do not reschedule.
    return false;
  }

  // Callback to handle the status from writeKey.
  var statusCallback = function(status) {
    client.logger_.info('Write state completed: %s', status);
    if (status.isSuccess()) {
      this.lastWrittenToken_ = state.getClientToken();
    } else {
      // Retry with exponential backoff.
      client.statistics_.recordError(
          invalidation.Statistics.ClientErrorType.PERSISTENT_WRITE_FAILURE);
    }
  };
  // Perform the write.
  client.resources_.getStorage().writeKey(
      invalidation.ClientCore.CLIENT_TOKEN_KEY,
      serializedState, goog.bind(statusCallback, this));
  return true;  // Reschedule after timeout to make sure that write does happen.
};

/**
 * A task for sending heartbeats to the server.
 *
 * @param {!invalidation.ClientCore} client The client using this task.
 *
 * @constructor
 * @extends {invalidation.RecurringTask}
 */
invalidation.ClientCore.HeartbeatTask = function(client) {
  // Cannot use goog.base since this code will not work with Rhino.
  invalidation.RecurringTask.call(this, 'Heartbeat',
      client.internalScheduler_, client.logger_, client.smearer_,
      null, client.config_.getHeartbeatIntervalMsOrDefault(), 0);

  /**
   * @type {!invalidation.ClientCore}
   * @private
   */
  this.client_ = client;

  /**
   * Next time that the performance counters are sent to the server.
   * @type {number}
   * @private
   */
  this.nextPerformanceSendTimeMs_ = 0;

};
goog.inherits(invalidation.ClientCore.HeartbeatTask,
    invalidation.RecurringTask);

/**
 * @override
 */
invalidation.ClientCore.HeartbeatTask.prototype.runTask = function() {
  // Send info message. If needed, send performance counters and reset the next
  // performance counter send time.
  var client = this.client_;
  client.logger_.info('Sending heartbeat to server: %s', client.toString());
  var mustSendPerfCounters = this.nextPerformanceSendTimeMs_ >
      client.internalScheduler_.getCurrentTimeMs();
  if (mustSendPerfCounters) {
    var perfCounterDelayMs =
        client.config_.getPerfCounterDelayMsOrDefault();
    client.nextPerformanceSendTimeMs =
        client.internalScheduler_.getCurrentTimeMs() +
        this.smearer.getSmearedDelay(perfCounterDelayMs);
  }
  client.sendInfoMessageToServer_(mustSendPerfCounters,
      !client.registrationManager_.isStateInSyncWithServer());
  return true;  // Reschedule.
};

/**
 * The task that is scheduled to send batched messages to the server (when
 * needed).
 * <p>
 * This class is instantiated from multiple objects, rather than just taking
 * a reference to the client, so that it can be instantiated in the protocol
 * handler test.
 *
 * @param {!invalidation.SystemResources.Scheduler} scheduler
 *     Internal scheduler of the client.
 * @param {!invalidation.SystemResources.Logger} logger Logger of the client.
 * @param {!invalidation.Smearer} smearer Smearer for delays.
 * @param {!number} batchDelayMs The batch delay in milliseconds.
 * @param {!invalidation.ProtocolHandler} protocolHandler
 *     The protocol handler.
 * @constructor
 * @extends {invalidation.RecurringTask}
 */
invalidation.ClientCore.BatchingTask = function(scheduler, logger, smearer,
      batchDelayMs, protocolHandler) {
  // Call super constructor explicitly because goog.base doesn't work in Rhino.
  invalidation.RecurringTask.call(this, 'Batching',
      scheduler, logger, smearer, null, batchDelayMs, 0);

  /**
   * @type {!invalidation.ProtocolHandler}
   * @private
   */
  this.protocolHandler_ = protocolHandler;
};
goog.inherits(invalidation.ClientCore.BatchingTask, invalidation.RecurringTask);

/**
 * @override
 */
invalidation.ClientCore.BatchingTask.prototype.runTask = function() {
  // Send message to server - the batching information is picked up in
  // sendMessageToServer.
  this.protocolHandler_.sendMessageToServer();
  return false;  // Don't reschedule.
};

//
// End of recurring tasks
//

/**
 * Registers with the network contained in resources to receive status change
 * events and messages from the data center.
 * @private
 */
invalidation.ClientCore.prototype.registerWithNetwork_ = function() {
  this.resources_.getNetwork().setMessageReceiver(goog.bind(
      this.handleIncomingMessage_, this));

  this.resources_.getNetwork().addNetworkStatusReceiver(goog.bind(
      this.handleNetworkStatusChange_, this));
};

//
// Create config methods
//

/**
 * @return {!invalidation.proto.ClientConfigP} A default config for the client.
 */
invalidation.ClientCore.createConfig = function() {
  var config = new invalidation.proto.ClientConfigP();
  config.setVersion(invalidation.Constants.CONFIG_VERSION_VALUE);
  config.setProtocolHandlerConfig(invalidation.ProtocolHandler.createConfig());
  return config;
};

/**
 * @return {!invalidation.proto.ClientConfigP} A configuration object with
 * parameters set for unit tests.
 */
invalidation.ClientCore.createConfigForTest = function() {
  var config = new invalidation.proto.ClientConfigP();
  config.setVersion(invalidation.Constants.CONFIG_VERSION_VALUE);
  config.setProtocolHandlerConfig(
      invalidation.ProtocolHandler.createConfigForTest());
  config.setNetworkTimeoutDelayMs(2 * 1000);
  config.setHeartbeatIntervalMs(5 * 1000);
  config.setWriteRetryDelayMs(500);
  config.setProtocolHandlerConfig(
      invalidation.ProtocolHandler.createConfigForTest());
  return config;
};

/**
 * Creates the tasks used by the Ticl for token acquisition, heartbeats,
 * persistent writes and registration sync.
 */
invalidation.ClientCore.prototype.createSchedulingTasks = function() {
  this.acquireTokenTask_ = new invalidation.ClientCore.AcquireTokenTask(this);
  this.regSyncHeartbeatTask_ =
      new invalidation.ClientCore.RegSyncHeartbeatTask(this);
  this.persistentWriteTask_ =
      new invalidation.ClientCore.PersistentWriteTask(this);
  this.heartbeatTask_ = new invalidation.ClientCore.HeartbeatTask(this);

  var protocolConfig = this.config_.getProtocolHandlerConfigOrDefault();
  this.batchingTask_ = new invalidation.ClientCore.BatchingTask(
    this.internalScheduler_, this.logger_, this.smearer_,
    protocolConfig.getBatchingDelayMsOrDefault(), this.protocolHandler_);
};

//
// InvalidationClient methods.
//

/**
 * @override
 */
invalidation.ClientCore.prototype.start = function() {
  goog.asserts.assert(!this.ticlState_.isStarted(), 'Already started');
  goog.asserts.assert(this.resources_.isStarted(), 'Resources must be ' +
      'started before starting the Ticl');
  if (this.ticlState_.isStarted()) {
    this.logger_.severe(
        'Ignoring start call since already started: client = %s',
        this.toString());
    return;
  }

  // Initialize the nonce so that we can maintain the invariant that exactly one
  // of 'nonce' and 'clientToken' is non-null.
  this.setNonce_(invalidation.ClientCore.generateNonce(this.random_));

  this.logger_.info('Starting with JS config: %s', this.config_.toString());

  // Read the state blob and schedule startInternal once the value is there.
  this.scheduleStartAfterReadingStateBlob_();
};

/**
 * Implementation of {@code #start} with the persistent {@code serializedState},
 * if any. Starts the TICL protocol and makes the TICL ready to receive
 * registrations, invalidations, etc
 *
 * @param {?string} serializedState Serialized persistent Ticl state.
 * @private
 */
invalidation.ClientCore.prototype.startInternal_ = function(serializedState) {
  // Initialize the session manager using the persisted client token.
  var persistentState = (serializedState == null) ? null :
      invalidation.PersistenceUtils.deserializeState(this.logger_,
      serializedState, this.digestFn_);

  if ((serializedState != null) && (persistentState == null)) {
    // In this case, we'll proceed as if we had no persistent state -- i.e.,
    // obtain a new client id from the server.
    this.statistics_.recordError(invalidation.Statistics.ClientErrorType.
                                 PERSISTENT_DESERIALIZATION_FAILURE);
    this.logger_.severe('Failed deserializing persistent state: %s',
        serializedState);
  }
  if (persistentState != null) {
    // If we have persistent state, use the previously-stored token and send a
    // heartbeat to let the server know that we've restarted, since we may have
    // been marked offline.

    // In the common case, the server will already have all of our
    // registrations, but we won't know for sure until we've gotten its summary.
    // We'll ask the application for all of its registrations, but to avoid
    // making the registrar redo the work of performing registrations that
    // probably already exist, we'll suppress sending them to the registrar.
    var clientToken = /** @type {string} */ (persistentState.getClientToken());
    this.logger_.info('Restarting from persistent state: %s', clientToken);
    this.setNonce_(null);
    this.setClientToken_(clientToken);
    this.shouldSendRegistrations_ = false;

    // Schedule an info message for the near future. We delay a little bit to
    // allow the application to reissue its registrations locally and avoid
    // triggering registration sync with the data center due to a hash mismatch.
    var sendInfoFunc = new invalidation.NamedFunction('SendFirstPersistentInfo',
        goog.bind(this.sendInfoMessageToServer_, this, false, true));
    var delayMs = this.config_.getInitialPersistentHeartbeatDelayMsOrDefault();
    this.internalScheduler_.schedule(delayMs, sendInfoFunc);

    // We need to ensure that heartbeats are sent, regardless of whether we
    // start fresh or from persistent state.  The line below ensures that they
    // are scheduled in the persistent startup case.  For the other case, the
    // task is scheduled when we acquire a token.
    this.heartbeatTask_.ensureScheduled('Startup-after-persistence');
  } else {
    // If we had no persistent state or couldn't deserialize the state that we
    // had, start fresh. Request a new client identifier.

    // The server can't possibly have our registrations, so whatever we get
    // from the application we should send to the registrar.
    this.logger_.info('Starting with no previous state');
    this.shouldSendRegistrations_ = true;
    this.acquireToken_('Startup');
  }

  // listener.ready() is called when ticl has acquired a new token.
};

/**
 * @override
 */
invalidation.ClientCore.prototype.stop = function() {
  this.logger_.warning('Ticl being stopped: %s', this);
  if (this.ticlState_.isStarted()) {
    this.ticlState_.stop();
  }
};

/**
 * @override
 */
invalidation.ClientCore.prototype.register = function(objectIds) {
  var oidArray = Array.prototype.slice.call(arguments);
  this.performRegisterOperations_(
      oidArray, invalidation.proto.RegistrationP.OpType.REGISTER);
};

/**
 * @override
 */
invalidation.ClientCore.prototype.unregister = function(objectIds) {
  var oidArray = Array.prototype.slice.call(arguments);
  this.performRegisterOperations_(
      oidArray, invalidation.proto.RegistrationP. OpType.UNREGISTER);
};

/**
 * Implementation of (un)registration.
 *
 * @param {!Array.<!invalidation.Types.ObjectId>} objectIds Object ids on which
 *     to operate.
 * @param {!invalidation.proto.RegistrationP.OpType} regOpType Whether to
 *      register or unregister.
 * @private
 */
invalidation.ClientCore.prototype.performRegisterOperations_ =
    function(objectIds, regOpType) {
  goog.asserts.assert(objectIds.length > 0, 'Must specify some object id');
  if (this.ticlState_.isStopped()) {
    // The Ticl has been stopped. This might be some old registration op
    // coming in. Just ignore instead of crashing.
    this.logger_.severe('Ticl stopped: register (%s) of %s ignored',
        regOpType, objectIds);
    return;
  }
  if (!this.ticlState_.isStarted()) {
    // We must be in the NOT_STARTED state, since we can't be in STOPPED or
    // STARTED (since the previous if-check didn't succeeded, and isStarted
    // uses a != STARTED test).
    this.logger_.severe(
        'Ticl is not yet started; failing registration call; client = %s, ' +
        'objects = %s, op = %s',
        this.toString(), objectIds, regOpType);
    for (var i = 0; i < objectIds.length; i++) {
      var objectId = objectIds[i];
      this.listener_.informRegistrationFailure(this, objectId, true,
          'Client not yet ready');
    }
    return;
  }

  var objectIdProtos = [];
  for (var i = 0; i < objectIds.length; i++) {
    var objectId = objectIds[i];
    var objectIdProto =
      invalidation.ProtoConverter.convertToObjectIdProto(objectId);
    var opType =
      (regOpType == invalidation.proto.RegistrationP.OpType.REGISTER) ?
      invalidation.Statistics.IncomingOperationType.REGISTRATION :
      invalidation.Statistics.IncomingOperationType.UNREGISTRATION;
    this.statistics_.recordIncomingOperation(opType);
    this.logger_.info('Register %s, %s', objectIdProto.toString(), regOpType);
    objectIdProtos.push(objectIdProto);
  }

  // Update the registration manager state, then have the protocol client
  // send a message.
  var objectProtosToSend = this.registrationManager_.performOperations(
    objectIdProtos, regOpType);

  // Check whether we should suppress sending registrations because we don't
  // yet know the server's summary.
  if (this.shouldSendRegistrations_ && (objectProtosToSend.length > 0)) {
    this.protocolHandler_.sendRegistrations(objectProtosToSend, regOpType,
        this.batchingTask_);
  }
  this.regSyncHeartbeatTask_.ensureScheduled('performRegister');
};

/**
 * @override
 */
invalidation.ClientCore.prototype.acknowledge = function(acknowledgeHandle) {
  // Validate the ack handle.

  // 1. Parse the ack handle first.
  var ackHandle = invalidation.Utils.deserializeMessage(
      invalidation.proto.AckHandleP.getDescriptor(),
      acknowledgeHandle.getHandleData(), this.logger_);
  if (ackHandle == null) {
    this.logger_.warning('Bad ack handle : %s',
        acknowledgeHandle.getHandleData());
    this.statistics_.recordError(
        invalidation.Statistics.ClientErrorType.ACKNOWLEDGE_HANDLE_FAILURE);
    return;
  }

  // 2. Validate ack handle - it should have a valid invalidation.
  if (!ackHandle.hasInvalidation() ||
      !this.msgValidator_.isInvalidationValid(ackHandle.getInvalidation())) {
    this.logger_.warning('Incorrect ack handle: %s', ackHandle);
    this.statistics_.recordError(
        invalidation.Statistics.ClientErrorType.ACKNOWLEDGE_HANDLE_FAILURE);
    return;
  }

  // Currently, only invalidations have non-trivial ack handle.
  var inv = ackHandle.getInvalidation();
  inv.clearPayload();  // Don't send the payload back.
  this.statistics_.recordIncomingOperation(
      invalidation.Statistics.IncomingOperationType.ACKNOWLEDGE);
  this.protocolHandler_.sendInvalidationAck(inv, this.batchingTask_);
};

/**
 * @override
 */
invalidation.ClientCore.prototype.getConfigForTest = function() {
  return this.config_;
};

/**
 * @override
 */
invalidation.ClientCore.prototype.getAppClientIdForTest = function() {
  return this.applicationClientId_;
};

//
// Protocol listener methods.
//

/**
 * @override
 */
invalidation.ClientCore.prototype.handleMessageSent = function() {
  this.lastMessageSendTimeMs_ = this.internalScheduler_.getCurrentTimeMs();
};

/**
 * @override
 */
invalidation.ClientCore.prototype.getRegistrationSummary = function() {
  return this.registrationManager_.getRegistrationSummary();
};

/**
 * @return {?string} The current client token, if any.
 * @override
 */
invalidation.ClientCore.prototype.getClientToken = function() {
  goog.asserts.assert((this.clientToken_ == null) || (this.nonce_ == null));
  return this.clientToken_;
};

/**
 * Handles the network becoming available or unavailable.
 * @param {boolean} isOnline Whether the network is connected.
 * @private
 */
invalidation.ClientCore.prototype.handleNetworkStatusChange_ =
    function(isOnline) {
  // If we're back online and haven't sent a message to the server in a while,
  // send a heartbeat to make sure the server knows we're online.
  var wasOnline = this.isOnline_;
  this.isOnline_ = isOnline;
  if (isOnline && !wasOnline && (
          this.internalScheduler_.getCurrentTimeMs() >
          this.lastMessageSendTimeMs_ +
          this.config_.getOfflineHeartbeatThresholdMsOrDefault())) {
    this.logger_.info(
        'Sending heartbeat after reconnection: previous send was %s ms ago',
        this.internalScheduler_.getCurrentTimeMs() -
        this.lastMessageSendTimeMs_);
    this.sendInfoMessageToServer_(
        false, !this.registrationManager_.isStateInSyncWithServer());
  }
};

/**
 * Handles an {@code incomingMessage} from the data center. If it is valid and
 * addressed to this client, dispatches to methods to handle sub-parts of the
 * message; if not, drops the message.
 *
 * @param {!string} incomingMessage The message from the data center.
 * @private
 */
invalidation.ClientCore.prototype.handleIncomingMessage_ =
    function(incomingMessage) {
  this.statistics_.recordReceivedMessage(
    invalidation.Statistics.ReceivedMessageType.TOTAL);

  var parsedMessage = this.protocolHandler_.handleIncomingMessage(
      incomingMessage);
  if (parsedMessage == null) {
    // Invalid message.
    this.logger_.warning('Ignoring invalid message: %s', incomingMessage);
    return;
  }

  // Ensure we have either a matching token or a matching nonce.
  if (!this.validateToken_(parsedMessage)) {
    return;
  }

  // Handle a token-control message, if present.
  if (parsedMessage.tokenControlMessage != null) {
    this.statistics_.recordReceivedMessage(
      invalidation.Statistics.ReceivedMessageType.TOKEN_CONTROL);
    this.handleTokenChanged_(
        /** @type {!string} */ (parsedMessage.header.token),
        parsedMessage.tokenControlMessage.hasNewToken() ?
            parsedMessage.tokenControlMessage.getNewToken() : null);
  }

  // We might have lost our token or failed to acquire one. Ensure that we do
  // not proceed in either case.
  if (this.clientToken_ == null) {
    return;
  }

  // First, handle the message header.
  this.handleIncomingHeader_(parsedMessage.header);

  // Then, handle any work remaining in the message.
  if (parsedMessage.invalidationMessage != null) {
    this.statistics_.recordReceivedMessage(
        invalidation.Statistics.ReceivedMessageType.INVALIDATION);
    this.handleInvalidations_(
        parsedMessage.invalidationMessage.invalidationArray());
  }
  if (parsedMessage.registrationStatusMessage != null) {
    this.statistics_.recordReceivedMessage(
        invalidation.Statistics.ReceivedMessageType.REGISTRATION_STATUS);
    this.handleRegistrationStatus_(
        parsedMessage.registrationStatusMessage.registrationStatusArray());
  }
  if (parsedMessage.registrationSyncRequestMessage != null) {
    this.statistics_.recordReceivedMessage(
        invalidation.Statistics.ReceivedMessageType.REGISTRATION_SYNC_REQUEST);
    this.handleRegistrationSyncRequest_();
  }
  if (parsedMessage.infoRequestMessage != null) {
    this.statistics_.recordReceivedMessage(
        invalidation.Statistics.ReceivedMessageType.INFO_REQUEST);
    this.handleInfoMessage_(parsedMessage.infoRequestMessage.infoTypeArray());
  }
  if (parsedMessage.errorMessage != null) {
    this.statistics_.recordReceivedMessage(
        invalidation.Statistics.ReceivedMessageType.ERROR);
    var code = /** @type {invalidation.proto.ErrorMessage.Code} */
        (parsedMessage.errorMessage.getCode());
    this.handleErrorMessage_(code, parsedMessage.errorMessage.getDescription());
  }
};

//
// Private methods and toString
//

/**
 * Handles a token change event from the server.
 *
 * @param {!string} headerToken The token in the server message header.
 * @param {?string} newToken A new token for the client. If {@code null}, it
 *     means destroy the token.
 * @private
 */
invalidation.ClientCore.prototype.handleTokenChanged_ =
    function(headerToken, newToken) {

  // The server is either supplying a new token in response to an
  // InitializeMessage, spontaneously destroying a token we hold, or
  // spontaneously upgrading a token we hold.

  if (newToken != null) {
    // Note: headerToken cannot be null, so a null nonce or clientToken will
    // always be non-equal.
    var headerTokenMatchesNonce = headerToken == this.nonce_;
    var headerTokenMatchesExistingToken = headerToken == this.clientToken_;
    var shouldAcceptToken =
        headerTokenMatchesNonce || headerTokenMatchesExistingToken;
    if (!shouldAcceptToken) {
      this.logger_.info('Ignoring new token; %s does not match nonce = %s ' +
          'or existing token = %s', newToken, this.nonce_, this.clientToken_);
      return;
    }
    this.logger_.info('New token being assigned at client: %s, Old = %s',
        newToken, this.clientToken_);

    // Start the regular heartbeats now.
    this.heartbeatTask_.ensureScheduled('Heartbeat-after-new-token');
    this.setNonce_(null);
    this.setClientToken_(newToken);
    this.persistentWriteTask_.ensureScheduled('Write-after-new-token');
  } else {
    this.logger_.info('Destroying existing token: %s', this.clientToken_);
    this.acquireToken_('Destroy');
  }
};

/**
 * Handles an incoming message from the server. This method may be called in
 * addition to the handle* methods below - so the listener code should be
 * prepared for it.
 *
 * @param {!invalidation.ServerMessageHeader} header The server message header.
 * @private
 */
invalidation.ClientCore.prototype.handleIncomingHeader_ = function(header) {
  goog.asserts.assert(this.nonce_ == null, 'Cannot process server header ' +
      'with non-null nonce (have %s): %s', this.nonce_, header);
  if (header.registrationSummary != null) {
    // We've received a summary from the server, so if we were suppressing
    // registrations, we should now allow them to go to the registrar.
    this.shouldSendRegistrations_ = true;

    // Pass the registration summary to the registration manager. If we are now
    // in agreement with the server and we had any pending operations, we can
    // tell the listener that those operations have succeeded.
    var upcalls = this.registrationManager_.informServerRegistrationSummary(
        header.registrationSummary);
    this.logger_.fine(
        'Receivced new server registration summary (%s); will make %s upcalls',
        header.registrationSummary, upcalls.length);
    for (var i = 0; i < upcalls.length; i++) {
      var registration = upcalls[i];
      var objectId = invalidation.ProtoConverter.convertFromObjectIdProto(
          /** @type {!invalidation.proto.ObjectIdP} */
          (registration.getObjectId()));
      var regState = this.convertOpTypeToRegState_(
          /** @type {!invalidation.proto.RegistrationP.OpType} */
          (registration.getOpType()));
      this.listener_.informRegistrationStatus(this, objectId, regState);
    }
  }
};

/**
 * Handles {@code invalidations} from the server.
 *
 * @param {!Array.<!invalidation.proto.InvalidationP>} invalidations The
 *     invalidations received from the server.
 * @private
 */
invalidation.ClientCore.prototype.handleInvalidations_ =
    function(invalidations) {
  for (var i = 0; i < invalidations.length; i++) {
    var inv = invalidations[i];
    var ackHandleP = invalidation.CommonProtos.newAckHandleP(inv);
    var ackHandleSerialized = invalidation.Utils.serializeMessage(ackHandleP);
    var ackHandle = new invalidation.Types.AckHandle(ackHandleSerialized);
    if (inv.getObjectId().equals(invalidation.Constants.ALL_OBJECT_ID)) {
      this.logger_.info('Issuing invalidate all');
      this.listener_.invalidateAll(this, ackHandle);
    } else {
      // Regular object. Could be unknown version or not.
      var invForClient =
          invalidation.ProtoConverter.convertFromInvalidationProto(inv);
      var isSuppressed = inv.getIsTrickleRestartOrDefault();
      var allowSuppression = this.config_.getAllowSuppressionOrDefault();
      this.logger_.info('Issuing invalidate (known-version = %s, ' +
          'is-trickle-restart=%s): %s',
          inv.getIsKnownVersion(), isSuppressed, invForClient);

      // Issue invalidate if the invalidation had a known version AND either
      // no suppression has occurred or the client allows suppression.
      if (inv.getIsKnownVersion() && (!isSuppressed || allowSuppression)) {
        this.listener_.invalidate(this, invForClient, ackHandle);
      } else {
        // Otherwise issue invalidateUnknownVersion.
        this.listener_.invalidateUnknownVersion(this,
            invForClient.getObjectId(), ackHandle);
      }
    }
  }
};

/**
 * Handles registration updates from the server.
 *
 * @param {!Array.<!invalidation.proto.RegistrationStatus>} regStatusList
 *     Registration updates received from the server.
 * @private
 */
invalidation.ClientCore.prototype.handleRegistrationStatus_ =
    function(regStatusList) {
  var localProcessingStatuses =
      this.registrationManager_.handleRegistrationStatus(regStatusList);
  goog.asserts.assert(localProcessingStatuses.length == regStatusList.length,
      'Not all registration statuses were processed');

  // Inform app about the success or failure of each registration based
  // on what the registration manager has indicated.
  for (var i = 0; i < regStatusList.length; ++i) {
    var regStatus = regStatusList[i];
    var wasSuccess = localProcessingStatuses[i];
    this.logger_.fine('Process reg status: %s', regStatus);

    var objectIdProto = /** @type {!invalidation.proto.ObjectIdP} */
        (regStatus.getRegistration().getObjectId());
    var objectId =
        invalidation.ProtoConverter.convertFromObjectIdProto(objectIdProto);
    if (wasSuccess) {
        // Server operation was both successful and agreed with what the client
        // wanted.
        var regState = this.convertOpTypeToRegState_(
            /** @type {!invalidation.proto.RegistrationP.OpType} */
            (regStatus.getRegistration().getOpType()));
        this.listener_.informRegistrationStatus(this, objectId, regState);
    } else {
      var status = /** @type {!invalidation.proto.StatusP} */
          (regStatus.getStatus());
      var description = /** @type {string} */
          (invalidation.CommonProtos.isSuccess(status) ?
          'Registration discrepancy detected' :
          regStatus.getStatus().getDescription());
      var isPermanent = invalidation.CommonProtos.isPermanentFailure(status);
      this.listener_.informRegistrationFailure(this, objectId, !isPermanent,
          description);
    }
  }
};

/**
 * Handles a registration sync request.
 * @private
 */
invalidation.ClientCore.prototype.handleRegistrationSyncRequest_ = function() {
  // Generate a single subtree for all the registrations.
  var subtree = this.registrationManager_.getRegistrations('', 0);
  this.protocolHandler_.sendRegistrationSyncSubtree(subtree,
      this.batchingTask_);
};

/**
 * Handles an info message.
 * @param {!Array.<!invalidation.proto.InfoRequestMessage.InfoType>}
 *     infoTypes Types of info requested by the server.
 * @private
 */
invalidation.ClientCore.prototype.handleInfoMessage_ = function(infoTypes) {
  var mustSendPerfCounters = false;
  for (var i = 0; i < infoTypes.length; i++) {
    var infoType = infoTypes[i];
    mustSendPerfCounters = (infoType == invalidation.proto.InfoRequestMessage.
                            InfoType.GET_PERFORMANCE_COUNTERS);
    if (mustSendPerfCounters) {
      break;
    }
  }
  this.sendInfoMessageToServer_(mustSendPerfCounters,
      !this.registrationManager_.isStateInSyncWithServer());
};

/**
 * Handles an error message from the server
 *
 * @param {!invalidation.proto.ErrorMessage.Code} code Error reason.
 * @param {?string} description Human-readable description of the error.
 * @private
 */
invalidation.ClientCore.prototype.handleErrorMessage_ =
    function(code, description) {
  // If it is an auth failure, we shut down the ticl.
  this.logger_.severe('Received error message: %s, %s',
      code, invalidation.Utils.toText(description));

  // Translate the code to error reason.
  var reason;
  switch (code) {
    case invalidation.proto.ErrorMessage.Code.AUTH_FAILURE:
      reason = invalidation.Types.ErrorInfo.ErrorReason.AUTH_FAILURE;
      break;
    case invalidation.proto.ErrorMessage.Code.UNKNOWN_FAILURE:
      reason = invalidation.Types.ErrorInfo.ErrorReason.UNKNOWN_FAILURE;
      break;
    default:
      reason = invalidation.Types.ErrorInfo.ErrorReason.UNKNOWN_FAILURE;
      break;
  }

  // Issue an informError to the application.
  var errorInfo =
      new invalidation.Types.ErrorInfo(reason, false, description, null);
  this.listener_.informError(this, errorInfo);

  // If this is an auth failure, remove registrations and stop the Ticl.
  // Otherwise do nothing.
  if (code != invalidation.proto.ErrorMessage.Code.AUTH_FAILURE) {
    return;
  }

  // If there are any registrations, remove them and issue registration failure.
  var desiredRegs = this.registrationManager_.removeRegisteredObjects();
  this.logger_.warning('Issuing failure for %d objects', desiredRegs.length);
  for (var i = 0; i < desiredRegs.length; i++) {
    var objectId = desiredRegs[i];
    var objectIdProto =
        invalidation.ProtoConverter.convertFromObjectIdProto(objectId);
    this.listener_.informRegistrationFailure(this,
      objectIdProto, false, 'Auth error: ' + description);
  }
};

/**
 * Returns whether the token in the header of {@code parsedMessage} matches
 * either the client token or nonce of this Ticl (depending on which is
 * non-{@code null}).
 *
 * @param {!invalidation.ProtocolHandler.ParsedMessage} parsedMessage
 *    Parsed message provided by the protocol handler.
 * @return {boolean} Whether the token was valid.
 * @private
 */
invalidation.ClientCore.prototype.validateToken_ = function(parsedMessage) {
  if (this.clientToken_ != null) {
    // Client token case.
    if (this.clientToken_ != parsedMessage.header.token) {
      this.logger_.info(
          'Incoming message has bad token: server = %s, client = %s',
          parsedMessage.header.token, this.clientToken_);
      this.statistics_.recordError(
          invalidation.Statistics.ClientErrorType.TOKEN_MISMATCH);
      return false;
    }
    return true;
  } else if (this.nonce_ != null) {
    // Nonce case.
    if (this.nonce_ != parsedMessage.header.token) {
      this.statistics_.recordError(
          invalidation.Statistics.ClientErrorType.NONCE_MISMATCH);
      this.logger_.info(
          'Rejecting server message with mismatched nonce: ' +
          'Client = %s, Server = %s', this.nonce_, parsedMessage.header.token);
      return false;
    } else {
      this.logger_.info('Accepting server message with matching nonce: %s',
          this.nonce_);
      return true;
    }
  }
  // Neither token nor nonce; ignore message.
  this.logger_.warning(
      'Neither token nor nonce was set in validateToken: %s, %s',
      this.clientToken_, this.nonce_);
  return false;
};

/**
 * Requests a new client identifier from the server.
 * <p>
 * REQUIRES: no token currently be held.
 *
 * @param {string} debugString Information to identify the caller.
 * @private
 */
invalidation.ClientCore.prototype.acquireToken_ = function(debugString) {
  this.setClientToken_(null);
  this.acquireTokenTask_.ensureScheduled(debugString);
};

/**
 * Sends an info message to the server. If {@code mustSendPerformanceCounters}
 * is true, the performance counters are sent regardless of when they were sent
 * earlier.
 *
 * @param {boolean} mustSendPerfCounters If the performance counters
 *     must be sent regardless of the previous time they were sent.
 * @param {boolean} requestServerSummary Whether the client wants the server
 *     to send its summary or not.
 * @private
 */
invalidation.ClientCore.prototype.sendInfoMessageToServer_ = function(
    mustSendPerfCounters, requestServerSummary) {
  this.logger_.info(
      'Sending info message to server; request server summary = %s',
      requestServerSummary);
  var perfCounters = new goog.structs.Map();
  var configToSend = null;
  if (mustSendPerfCounters) {
    this.statistics_.getNonZeroStatistics(perfCounters);
    configToSend = this.config_;
  }
  this.protocolHandler_.sendInfoMessage(perfCounters, configToSend,
      requestServerSummary, this.batchingTask_);
};

/**
 * Reads the Ticl state from persistent storage (if any) and calls
 * {@code startInternal_}.
 * @private
 */
invalidation.ClientCore.prototype.scheduleStartAfterReadingStateBlob_ =
    function() {
  this.resources_.getStorage().readKey(this.clientTokenKey_, goog.bind(
      function(status, state) {
        var serializedState = status.isSuccess() ? state : null;
        if (!status.isSuccess()) {
          this.statistics_.recordError(
              invalidation.Statistics.ClientErrorType.PERSISTENT_READ_FAILURE);
          this.logger_.warning('Could not read state blob: %s',
              status.getMessage());
        }
        // Start the Ticl.
        this.startInternal_(serializedState);
      }, this));
};

/**
 * Converts an operation type {@code regOpType} to a
 * {@code InvalidationListener.RegistrationState}.
 *
 * @param {!invalidation.proto.RegistrationP.OpType} regOpType Registration
 *     operation type being converted.
 * @return {!invalidation.Listener.RegistrationState} The converted status.
 * @private
 */
invalidation.ClientCore.prototype.convertOpTypeToRegState_ =
    function(regOpType) {
  var regState =
    regOpType == invalidation.proto.RegistrationP.OpType.REGISTER ?
        invalidation.Listener.RegistrationState.REGISTERED :
        invalidation.Listener.RegistrationState.UNREGISTERED;
  return regState;
};

/**
 * Sets the nonce to {@code newNonce}.
 * <p>
 * REQUIRES: {@code newNonce} be null or {@link #clientToken} be null.
 * The goal is to ensure that a nonce is never set unless there is no
 * client token, unless the nonce is being cleared.
 *
 * @param {?string} newNonce The new nonce (if any) for the client.
 * @private
 */
invalidation.ClientCore.prototype.setNonce_ = function(newNonce) {
  goog.asserts.assert((newNonce == null) || (this.clientToken_ == null),
    'Tried to set nonce with existing token %s', this.clientToken_);
  // Base64 encode it since it comes back as client_token.
  this.nonce_ = (newNonce == null) ? null :
      newNonce = goog.crypt.base64.encodeString(newNonce);
};

/**
 * Generates a random nonce a large number of bits of randomness.
 * @param {!function() : number} random A random number generator.
 * @return {string} A random nonce.
 */
invalidation.ClientCore.generateNonce = function(random) {
  return random().toString();
};

/**
 * Sets the clientToken to {@code newClientToken}.
 * <p>
 * REQUIRES: {@code newClientToken} be null or {@link #nonce} be null.
 * The goal is to ensure that a token is never set unless there is no
 * nonce, unless the token is being cleared.
 *
 * @param {?string} newClientToken The client token being set (if any).
 * @private
 */
invalidation.ClientCore.prototype.setClientToken_ = function(newClientToken) {
  goog.asserts.assert((newClientToken == null) || (this.nonce_ == null),
      'Tried to set token with existing nonce %s', this.nonce_);

  // If the ticl is in the process of being started and we are getting a new
  // token (either from persistence or from the server, start the ticl and
  // inform the application.
  var finishStartingTicl = !this.ticlState_.isStarted() &&
      (this.clientToken_ == null) && (newClientToken != null);
  this.clientToken_ = newClientToken;

  if (finishStartingTicl) {
    this.finishStartingTiclAndInformListener_();
  }
};

/**
 * Start the ticl and inform the listener that it is ready.
 * @private
 */
invalidation.ClientCore.prototype.finishStartingTiclAndInformListener_ =
    function() {
  goog.asserts.assert(!this.ticlState_.isStarted());
  this.ticlState_.start();
  this.listener_.ready(this);

  // We are not currently persisting our registration digest, so regardless of
  // whether or not we are restarting from persistent state, we need to query
  // the application for all of its registrations.
  this.listener_.reissueRegistrations(this, '', 0);
  this.logger_.info('Ticl started: %s', this);
};

/**
 * Returns an exponential backoff generator with a max exponential factor given
 * by {@code config.getMaxExponentialBackoffFactor()} and initial delay
 * {@code initialDelayMs}.
 *
 * @param {number} initialDelayMs The initial delay for the generator.
 * @return {!invalidation.ExponentialBackoffDelayGenerator} The delay generator.
 */
invalidation.ClientCore.prototype.createExpBackOffGenerator =
    function(initialDelayMs) {
  return new invalidation.ExponentialBackoffDelayGenerator(this.random_,
      initialDelayMs, this.config_.getMaxExponentialBackoffFactorOrDefault());
};

/**
 * @override
 */
invalidation.ClientCore.prototype.toString = function() {
  return goog.string.format('Client: clientName = %s, token = %s, state = %s',
      this.applicationClientId_.toString(),
      invalidation.Utils.toText(this.clientToken_),
      this.ticlState_.toString());
};

//ipc/invalidation/javascript/internal/client/invalidationclientimpl.js
/**
 * @fileoverview Tango Invalidation Client Library (Ticl).
 */

goog.provide('invalidation.ClientImpl');
goog.require('invalidation.ClientCore');

/**
 * Implements the invalidation Client. This class just extends
 * invalidation.ClientCore so as to mirror the structure of the Java Ticl.
 *
 * @param {!invalidation.SystemResources} resources Resources used for
 *     scheduling, logging, sending network messages, etc.
 * @param {function(): number} random Random number generator that returns a
 *     number between 0 and 1. If {@code null}, uses {@code Math.random}
 *     internally.
 * @param {number} clientType Client type code assigned by the backend.
 * @param {string} clientName Application identifier for the client.
 * @param {!invalidation.proto.ClientConfigP} config Configuration for the
 *     client.
 * @param {string} applicationName Name of the application using the library
 *     (for debugging/monitoring).
 * @param {!invalidation.Listener} listener Application callback.
 *
 * @constructor
 * @extends {invalidation.ClientCore}
 */
invalidation.ClientImpl = function(resources, random, clientType, clientName,
    config, applicationName, listener) {
  // We cannot use goog.base because it would not work under Rhino.
  invalidation.ClientCore.call(this, resources, random, clientType, clientName,
      config, applicationName, listener);
};
goog.inherits(invalidation.ClientImpl, invalidation.ClientCore);

//ipc/invalidation/public/javascript/v2/contrib/simplelistener.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview A simple InvalidationListener for managing some of the upcalls
 * from the Tango Invalidation Client. It handles all calls w.r.t. registrations
 * from the Tango client library, e.g., re-issuing registrations, retrying them
 * with exponential backoff. The application writer only needs to focus on the
 * invalidation calls. It also removes the onus on the application w.r.t.
 * waiting for the {@code ready} call from the Ticl. The application writer can
 * start the Ticl and immediately issue register/unregister calls through this
 * library.
 * <p>
 * This class is intended to be used by subclassing and implementing 4 methods -
 * {@code invalidate}, {@code invalidateAll}, {@code invalidateUnknownVersion},
 * and {@code informError}. In particular, the subclass does not have to handle
 * the following methods: {@code informRegistrationStatus},
 * {@code informRegistrationFailure}, {@code ready},
 * {@code reissueRegistrations}.
 * <p>
 * This class automatically retries registration/unregistration as needed (using
 * exponential backoff).
 * <p>
 * IMPORTANT: ALL register/unregister calls to Tango MUST be made through this
 * library and not directly to the Ticl. Also, if the application is using
 * persistence, i.e., storage across reboots with Tango, it must not use this
 * class (most Javascript applications do not use persistence).
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.SimpleListener');

goog.require('goog.asserts');
goog.require('goog.structs.Map');
goog.require('invalidation.Client');
goog.require('invalidation.ClientImpl');
goog.require('invalidation.ExponentialBackoffDelayGenerator');
goog.require('invalidation.Listener');
goog.require('invalidation.NamedFunction');
goog.require('invalidation.ProtoConverter');
goog.require('invalidation.SystemResources');
goog.require('invalidation.SystemResources.Logger');
goog.require('invalidation.SystemResources.Scheduler');
goog.require('invalidation.Types.ErrorInfo');
goog.require('invalidation.Types.ObjectId');
goog.require('invalidation.Utils');
goog.require('invalidation.proto.ClientConfigP');
goog.require('invalidation.proto.ObjectIdP');

/**
 * Creates a simple listener with the given {@code resources}
 *
 * @param {!invalidation.SystemResources} resources The resources for
 *     scheduling, logging, etc.
 * @implements {invalidation.Listener}
 * @constructor
 */
invalidation.SimpleListener = function(resources) {

  /**
   * The logger.
   * @type {!invalidation.SystemResources.Logger}
   * @protected
   */
  this.logger = resources.getLogger();

  /**
   * The listener's scheduler for scheduling events (note: not the internal
   * scheduler).
   * @type {!invalidation.SystemResources.Scheduler}
   * @protected
   */
  this.scheduler = resources.getListenerScheduler();

  /**
   * Map from the object id proto's key to objectid to keep track of the
   * application's desired registrations.
   * @type {!goog.structs.Map.<string, !invalidation.Types.ObjectId>}
   * @private
   */
  this.registrations_ = new goog.structs.Map();

  /**
   * Whether a ready call has been received from the Ticl.
   * @type {boolean}
   * @private
   */
  this.isReady_ = false;

  var config = invalidation.ClientCore.createConfig();
  var networkDelayMs = config.getNetworkTimeoutDelayMsOrDefault();

  /**
   * Exponential backoff generator for register/unregister after
   * informRegistrationFailure or informRegistrationStatus has been received.
   * @type {!invalidation.ExponentialBackoffDelayGenerator}
   * @private
   */
  this.exponentialBackoff_ =
      new invalidation.ExponentialBackoffDelayGenerator(Math.random,
          config.getMaxExponentialBackoffFactorOrDefault() * networkDelayMs,
              networkDelayMs);
};

//
// Abstract methods that the subclass must implement
//

/** @inheritDoc */
invalidation.SimpleListener.prototype.invalidate = goog.abstractMethod;

/** @inheritDoc */
invalidation.SimpleListener.prototype.invalidateUnknownVersion =
    goog.abstractMethod;

/** @inheritDoc */
invalidation.SimpleListener.prototype.invalidateAll = goog.abstractMethod;

/** @inheritDoc */
invalidation.SimpleListener.prototype.informError = goog.abstractMethod;


//
// Register/Unregister methods that the application must call for
// (un)registration if it wants to use this class.
//

/**
 * Same specs as {@code invalidation.Client.register}.
 *
 * @param {!invalidation.Client} client The Ticl library object.
 * @param {...!invalidation.Types.ObjectId} objectIds The object ids being
 *     registered.
 */
invalidation.SimpleListener.prototype.register = function(client, objectIds) {
  var oidArray = Array.prototype.slice.call(arguments);
  oidArray.shift();
  this.logger.info('Will register objects: %s', oidArray);

  // Add the objects to the registrations map and ask the ticl to register if it
  // is ready.
  for (var i = 0; i < oidArray.length; i++) {
    var oid = oidArray[i];
    var key = invalidation.SimpleListener.getObjectIdKey_(oid);
    this.registrations_.set(key, oid);
  }
  this.performRegOps_(client, true, oidArray);
};

/**
 * Same specs as {@code invalidation.Client.unregister}.
 *
 * @param {!invalidation.Client} client The Ticl library object.
 * @param {...!invalidation.Types.ObjectId} objectIds The object ids being
 *     unregistered.
 */
invalidation.SimpleListener.prototype.unregister = function(client, objectIds) {
  var oidArray = Array.prototype.slice.call(arguments);
  oidArray.shift();
  this.logger.info('Will unregister objects: %s', oidArray);

  // Remove the objects from the registrations map and ask the ticl to
  // unregister if it is ready.
  for (var i = 0; i < oidArray.length; i++) {
    var oid = oidArray[i];
    var key = invalidation.SimpleListener.getObjectIdKey_(oidArray[i]);
    this.registrations_.remove(key);
  }
  this.performRegOps_(client, false, oidArray);
};

//
// Listener methods that this class/object handles.
//

/** @inheritDoc */
invalidation.SimpleListener.prototype.ready = function(client) {
  // Register any objects in the registrations map.
  this.logger.info('Listener received ready call');
  goog.asserts.assert(!this.isReady_);
  this.isReady_ = true;
  this.registerAll_(client);
  this.logger.info('Cleared all waiting registrations');
};

/** @inheritDoc */
invalidation.SimpleListener.prototype.reissueRegistrations = function(client,
    prefix, prefixLength) {
  this.logger.info('Listener received reissueRegistrations call');
  if (!this.isReady_) {
    this.logger.severe('Ticl issued reissueRegistrations but not ready!');
  } else {
    this.registerAll_(client);
  }
};

/** @inheritDoc */
invalidation.SimpleListener.prototype.informRegistrationStatus =
    function(client, objectId, regState) {
  this.logger.info('informRegistrationStatus: %s, %s', objectId, regState);
  this.handleRegistrationStatus_(client, objectId, regState);

  // Assume that a registration status (not failure) from the server means that
  // things are ok and we can reset our backoff timer.
  this.exponentialBackoff_.reset();
};

/** @inheritDoc */
invalidation.SimpleListener.prototype.informRegistrationFailure =
    function(client, objectId, isTransient, errorMessage) {
  this.logger.info('informRegistrationFailure: %s, %s, %s', objectId,
      isTransient, errorMessage);

  // For transient failure, retry with backoff. For permanent, issue an
  // informError to the application.
  if (isTransient) {
    this.handleRegistrationStatus_(client, objectId, null);
  } else {
    // Remove from map and issue an informError.
    var key = invalidation.SimpleListener.getObjectIdKey_(objectId);
    this.registrations_.remove(key);
    var reason = invalidation.Types.ErrorInfo.ErrorReason.UNKNOWN_FAILURE;
    var errorInfo = new invalidation.Types.ErrorInfo(reason, false,
        'RegFailure: ' + objectId + ' - ' + errorMessage, null);
    this.informError(client, errorInfo);
  }
};

//
// Private methods.
//

/**
 * Indicates that the registration state of an object has changed.
 *
 * @param {!invalidation.Client} client The client invoking the listener.
 * @param {!invalidation.Types.ObjectId} objectId The object whose registration
 *     status is being informed.
 * @param {?invalidation.Listener.RegistrationState} regState The registration
 *     status of the object or null if a transient error has occurred.
 * @private
 */
invalidation.SimpleListener.prototype.handleRegistrationStatus_ =
    function(client, objectId, regState) {
  // Determine what the client wants.
  var key = invalidation.SimpleListener.getObjectIdKey_(objectId);
  var desiredReg = this.registrations_.containsKey(key);

  // Is the new state register or unregistered. Note that for regState == null,
  // we will perform the desired operation below.
  var newReg = regState == invalidation.Listener.RegistrationState.REGISTERED;
  if ((regState != null) && (newReg == desiredReg)) {
    // State is as expected.
    return;
  }
  this.logger.fine('handleRegistrationStatus_: Obj: %s, Reg: %s, Desired: %s',
      objectId, regState, desiredReg);
  // Fix the registration/unregistration at the Ticl with backoff.
  var delayMs = this.exponentialBackoff_.getNextDelay();
  this.scheduler.schedule(delayMs, new invalidation.NamedFunction(
      'Reissue regop', goog.bind(function() {
        if (desiredReg) {
          this.register(client, objectId);
        } else {
          this.unregister(client, objectId);
        }
      },
  this)));
};

/**
 * Returns a key for an object id that can be used in maps.
 *
 * @param {!invalidation.Types.ObjectId} objectId The object id whose key is
 * needed.
 * @return {string} The key for the object id.
 * @private
 */
invalidation.SimpleListener.getObjectIdKey_ = function(objectId) {
  // Convert to the ObjectIdP proto and get its message key.
  return invalidation.Utils.getMessageKey(
      invalidation.ProtoConverter.convertToObjectIdProto(objectId));
};

/**
 * Perform (un)registrations on the given objects if the ticl is ready.
 *
 * @param {!invalidation.Client} client The Ticl library object.
 * @param {boolean} isReg If a registration or unregistration operation needs to
 *     be performed.
 * @param {!Array.<!invalidation.Types.ObjectId>} objectIds The object ids to be
 *     registered or unregistered.
 * @private
 */
invalidation.SimpleListener.prototype.performRegOps_ = function(client, isReg,
    objectIds) {
  if (!this.isReady_) {
    this.logger.info('Cannot perform reg ops since ready not received');
    return;
  }

  // The ticl is ready - make the appropriate call.
  if (isReg) {
    client.register.apply(client, objectIds);
  } else {
    client.unregister.apply(client, objectIds);
  }
};

/**
 * Register for all objects in the registrations map.
 * <p>
 * REQUIRES: The ticl is ready.
 *
 * @param {!invalidation.Client} client The Ticl library object.
 * @private
 */
invalidation.SimpleListener.prototype.registerAll_ = function(client) {
  goog.asserts.assert(this.isReady_);
  if (!this.registrations_.isEmpty()) {
    var objectIds = this.registrations_.getValues();
    client.register.apply(client, objectIds);
  }
};

//ipc/invalidation/javascript/internal/client/concurrentstore.js
// Copyright 2010 Google Inc. All Rights Reserved.

/**
 * @fileoverview
 * A store that persists collections of strings using the HTML5
 * local storage API. See http://www.w3.org/TR/webstorage/ for more
 * information.
 *
 * Each store instance has a name. Allinstances with the same name
 * share the same persistent state. The two public operations are add() and
 * removeRandom(), which removes and returns a randomly selected element in
 * the store, unless a race occurs, in which case the item is removed but
 * null is returned.
 *
 * The store provides the guarantee that each value in a named store is returned
 * AT MOST once, even when accessed concurrently on browsers (e.g. Chrome) that
 * do not implement a storage mutex to ensure that  scripts do not observe
 * interleaved access to the store.
 *
 * However, the store is "leaky"-- some items in the store may be lost in the
 * presence of certain race conditions. (This leakiness is OK for our intended
 * use case.)
 *
 * - If two tabs attempts to remove the same item at the same time, the item in
 *   the store may be replaced by null and returned to neither script.
 *
 * - If more than a maximum number of items are added, additional items will be
 *   silently dropped.
 *
 * The internal keys for the values in the underlying local storage are unique
 * ids, so two adds to the store will never overwrite one another.
 *
 * The store can be used by browser TICLs to reuse client tokens across page
 * instances. State blobs are added to the store on page unload and removed for
 * reuse on page load. For this use case, the "leakiness" of the store is
*  acceptable because clients can always request a new client token
 * from the server and create a new state blob.
 *
 * Store users that wish to detect corruptions of items in the store should
 * include a digest in the store value; the store does not have its own digest
 * to avoid implementing integrity checks at two different layers.
 *
 * Implementation notes: the store for provides for safe (but leaky) concurrent
 * accesses by maintaining two hash tables, keyed by slot index, one for storing
 * the values and one for storing a unique identifier for the last store
 * instance that has attempted to remove a value at the given slot index.
 *
 * The lastRemover value allows the store to detect race conditions on removal
 * of items from the store and correctly return null rather than allowing two
 * tabs to observe the same removed value. Additional details and a correctness
 * proof are in the implementation comments.
 *
 * @author pbogle@google.com (Phil Bogle)
 */
goog.provide('invalidation.ConcurrentStore');
goog.provide('invalidation.ConcurrentStoreImpl');

goog.require('goog.iter');
goog.require('goog.storage.mechanism.mechanismfactory');
goog.require('goog.string');

/**
 * Interface for a concurrent store.
 *
 * @interface
 * @export
 */
invalidation.ConcurrentStore = function() {};

/**
 * Adds a value to the cache, unless the cache is full, a race occurs, or
 * storage is not supported. See the implementation for the full spec.
 *
 * @param {string} value The value to add to the store.
 */
invalidation.ConcurrentStore.prototype.add = goog.abstractMethod;

/**
 * Removes a value from the store and (hopefully) returns it, unless a
 * race occurs or the store is empty, in which case null is returned.
 *
 * @return {?string} The extracted string, or null if there are no strings in
 *    the store or storage is not supported.
 */
invalidation.ConcurrentStore.prototype.removeRandom = goog.abstractMethod;

/**
 * Creates a concurrent store.
 *
 * @constructor
 * @param {string} storeName A name for the store. All stores with the
 *    same name share the same state.
 * @param {!invalidation.util.Logger} logger For error messages.
 * @implements {invalidation.ConcurrentStore}
 */
invalidation.ConcurrentStoreImpl = function(storeName, logger) {
  /**
   * @type {!invalidation.util.Logger}
   * @private
   */
  this.logger_ = logger;

  this.logger_.info('Creating concurrent store %s', storeName);

  /**
   * @type {string}
   * @private
   */
  this.storeName_ = storeName;

  /**
   * A unique id that identifies this store instance. (Note that because
   * Javascript in the browser is single-threaded, we do not need to worry about
   * concurrent access from a single store instance.)
   *
   * @type {string}
   * @private
   */
  this.uniqueId_ = this.createUniqueId_();

  /**
   * An HTML5 local storage mechanism for stored values.
   * Note the creation call can return null if storage is not available.
   *
   * @type {goog.storage.mechanism.IterableMechanism}
   * @private
   */
  this.storage_ = goog.storage.mechanism.mechanismfactory.
      createHTML5LocalStorage('google_notification_values_' + this.storeName_);

  /**
   * An HTML5 local storage mechanism for stored values, only set if storage_
   * is non-null (i.e. localStorage is available).
   *
   * @type {goog.storage.mechanism.IterableMechanism}
   * @private
   */
  this.lastRemoverStorage_ = !this.storage_ ? null :
      goog.storage.mechanism.mechanismfactory.
          createHTML5LocalStorage('google_notification_remover_' +
              this.storeName_);
};

/**
 * The maximum number of items retained in the store..
 * @type {number}
 * @const
 */
invalidation.ConcurrentStoreImpl.MAX_SLOTS = 10;

/**
 * The maximum number of times we retry after a race condition before failing
 * an operation.
 *
 * @type {number}
 * @const
 */
invalidation.ConcurrentStoreImpl.MAX_RETRIES = 5;

/**
 * Adds a value to the store. The value might be lost if the store is full, if a
 * race occurs with another operation on the same slot, or if storage is not
 * supported.
 *
 * @param {string} value The value to add to the cache.
 */
invalidation.ConcurrentStoreImpl.prototype.add = function(value) {
  if (this.storage_ == null) {
    this.logger_.warning('Storage unsupported, dropping value');
    return;
  }

  // Log a warning and return if the store is full.
  if (this.storage_.getCount() >= invalidation.ConcurrentStoreImpl.MAX_SLOTS) {
    this.logger_.warning('Store is full, dropping value');
    return;
  }

  this.setSlotValue_(this.createUniqueId_(), value);
};

/**
 * Attempts to remove and returns a value from the cache. The caller is
 * guaranteed that the result will either be null or a value that has been
 * returned to no other caller of this method; that is, each item added to the
 * cache can be returned by removeRandom() at most once.
 *
 * @return {?string} The extracted string, or null if there are no strings in
 *    the store or storage is not supported.
 */
invalidation.ConcurrentStoreImpl.prototype.removeRandom = function() {
  // Try several times to remove a value; retries can occur in the event of a
  // race with another remover.
  var value = null;
  var retriesLeft = invalidation.ConcurrentStoreImpl.MAX_RETRIES;
  while (value == null && retriesLeft-- > 0) {
    // Give up if the store is empty.
    var slotNames = this.getSlotNames_();
    if (slotNames.length == 0) {
      break;
    }

    // Pick a random slot and try to remove it.
    var slot = this.getRandomItem_(slotNames);
    value = this.removeEntry_(slot);
    this.logger_.info('Got value %s for %s', value, slot);
  }

  // Return the successfully removed value or null.
  return value;
};

/**
* Removes the store entry with the given slot name and returns either that value
* or null, in the event a race occurs with another concurrent call to this
* method that removes the same key.
*
* A given value is guaranteed to be removed at most once. Proof: Let C1 and C2
* be two calls to removeSlotValue() for the same slot, and let C1 be the
* call which calls setLastRemover() first.
*
* In either of the two possible cases, at most one of the calls can return
* a non-null value.
*
* Case 1:
* C1 reaches the getLastRemover() check BEFORE C2 calls setLastRemover().
* In that event, C2 will return null because C1 sets the slot value to null
* before C2 reaches the getSlotValue() call.
*
* Case 2:
* C1 reaches the getLastRemover() check AFTER C2 calls setLastRemover().
* In that event, C1 will return null because is not the last remover when
* it gets to the last remover check.
*
* @param {string} slot The name of the slot whose value field should be
*     returned.
* @return {?string} the value or null.
* @private
*/
invalidation.ConcurrentStoreImpl.prototype.removeEntry_ = function(slot) {
  // Contend to be the last remover.
  this.setLastRemover_(slot, this.uniqueId_);

  // Read the value in the slot and set it to null so that if our lastRemover
  // check succeeds then no call after that point can return that value.
  var value = this.getSlotValue_(slot);
  this.setSlotValue_(slot, null);

  // If no one else has started a remove after us, we win and can return the
  // value we read! [Trumpet flourish] However, in the event of a race, it's
  // possible that the value we read was null. [Sad trombone]
  if (this.getLastRemover_(slot) == this.uniqueId_) {
    this.logger_.info('Last remover, returning %s for %s', value, slot);
  } else {
    this.logger_.info('Not last remover, returning null for %s', slot);
    value = null;
  }

  // Clean up the lastRemover state, which is no longer needed.
  this.setLastRemover_(slot, null);

  return value;
};

/**
 * Returns a snapshot of all the slot names for items in the store.
 * @return {Array.<string>} An array of strings.
 * @private
 */
invalidation.ConcurrentStoreImpl.prototype.getSlotNames_ = function() {
  if (!this.storage_) {
    return [];
  } else {
    var iterateKeys = true;
    return goog.iter.toArray(this.storage_.__iterator__(iterateKeys));
  }
};

/**
 * Picks a random item in a non-empty array.
 * @param {Array.<string>} items An array of strings.
 * @return {string} A random string, or null if the array is empty.
 * @private
 */
invalidation.ConcurrentStoreImpl.prototype.getRandomItem_ = function(items) {
  var index = Math.floor(Math.random() * items.length);
  var result = items[index];
  this.logger_.info('Returning random item %d of %d: %s', index, items.length,
      result);
  return result;
};

/**
 * Returns the value of the slot with the given name.
 *
 * @param {string} slot The name of the slot to return the value of.
 * @return {?string} The current value of the given slot, possibly null.
 * @private
 */
invalidation.ConcurrentStoreImpl.prototype.getSlotValue_ = function(slot) {
  var result = this.storage_.get(slot);
  this.logger_.info('Got value of %s for %s', result, slot);
  return result;
};

/**
 * Sets the value of the slot with the given name.
 *
 * @param {string} slot The name of the slot whose value should be set.
 * @param {?string} value The value to set.
 * @private
 */
invalidation.ConcurrentStoreImpl.prototype.setSlotValue_ =
    function(slot, value) {
  if (value != null) {
    this.logger_.info('Setting value of slot %s to %s', slot, value);
    this.storage_.set(slot, value);
  } else {
    this.logger_.info('Removing slot %s', slot);
    this.storage_.remove(slot);
  }
};

/**
 * Gets the unique id of the last remover for the given slot.
 * @param {string} slot The name of the slot for whcih to return the
 *    lastRemover.
 * @return {?string} value The value to set.
 * @private
 */
invalidation.ConcurrentStoreImpl.prototype.getLastRemover_ = function(slot) {
  var lastRemover = this.lastRemoverStorage_.get(slot);
  this.logger_.info('Got lastRemover of %s for %s', lastRemover, slot);
  return lastRemover;
};

/**
 * Sets the unique id of the last remover for the given slot name.
 *
 * @param {string} slot The name of the slot whose lastRemover field should be
 *    set.
 * @param {?string} uniqueId The unique id of the remover, or null to the remove
 *    the field.
 * @private
 */
invalidation.ConcurrentStoreImpl.prototype.setLastRemover_ =
    function(slot, uniqueId) {
  if (uniqueId) {
    this.logger_.info('Setting lastRemover of slot %s to %s', slot, uniqueId);
    this.lastRemoverStorage_.set(slot, uniqueId);
  } else {
    this.logger_.info('Clearing lastRemover of slot %s', slot);
    this.lastRemoverStorage_.remove(slot);
  }
};

/**
 * Sets the local storage mechanism, for testing only.
 *
 * @param {goog.storage.mechanism.IterableMechanism} valueStorage
 *    The local storage mechanism for value fields, or null if local storage is
 *    unsupported.
 * @param {goog.storage.mechanism.IterableMechanism} lastRemoverStorage
 *    The local storage mechanism for lastRemover fields, or null if local
 *    storage is unsupported.
 */
invalidation.ConcurrentStoreImpl.prototype.setLocalStorageForTest =
    function(valueStorage, lastRemoverStorage) {
  this.storage_ = valueStorage;
  this.lastRemoverStorage_ = lastRemoverStorage;
};

/**
 * Returns a randomly generated id that is almost certainly unique.
 *
 * Implementation note: getRandomString() is guaranteed to provide at least
 * 64 bits of randomness.
 *
 * @return {string} A unique id.
 * @private
 */
invalidation.ConcurrentStoreImpl.prototype.createUniqueId_ = function() {
  return goog.string.getRandomString();
};

/**
 * Overrides the function used to generate unique ids, for testing only.
 * This must be called immediately after the constructor.
 *
 * @param {function(): string} uniqueIdFn A function that returns an id string.
 */
invalidation.ConcurrentStoreImpl.prototype.setUniqueIdFunctionForTest =
    function(uniqueIdFn) {

  this.createUniqueId_ = uniqueIdFn;

  // Reassign the store's unique id using the new function.
  this.uniqueId_ = this.createUniqueId_();
};

//ipc/invalidation/public/javascript/v2/factory/recycledstateclient.js
/**
 * @fileoverview A wrapped invalidation client that ensures correct
 * behavior when reusing a client token from a previous client instance.
 *
 * In particular, when reusing a client token, the wrapped client synthesizes a
 * call to InvalidateUnknownVersion for each object registered by the
 * application. This is necessary because the new application instance is
 * unaware of any invalidations received and acked by the previous instance.
 *
 * The wrapped client retries with exponential backoff if the application fails
 * to acknowledge the synthesize invalidation.
 *
 * @author pbogle@google.com (Phil Bogle)
 */

goog.provide('invalidation.RecycledStateClient');

goog.require('goog.string');
goog.require('invalidation.Client');
goog.require('invalidation.ExponentialBackoffDelayGenerator');
goog.require('invalidation.Listener');
goog.require('invalidation.NamedFunction');
goog.require('invalidation.SystemResources');
goog.require('invalidation.SystemResources.Logger');



/**
 * Initializes a recycled state client.
 *
 * @constructor
 * @param {!invalidation.Client} client The client to delegate calls to.
 * @param {!invalidation.Listener} listener The listener used to initialize
 *    client.
 * @param {!invalidation.SystemResources.Logger} logger A logger.
 * @param {!invalidation.SystemResources.Scheduler} listenerScheduler listener
 *    scheduler for scheduling invalidation retries.
 * @param {boolean} isRecycledClientToken Whether the storage has been populated
 *    with a reused client token.
 * @implements {invalidation.Client}
 */
invalidation.RecycledStateClient = function(client, listener, logger,
    listenerScheduler, isRecycledClientToken) {
  /**
   * @type {!invalidation.Client}
   * @private
   */
  this.client_ = client;

  /**
   * @type {!invalidation.Listener}
   * @private
   */
  this.listener_ = listener;

  /**
   * @type {!invalidation.SystemResources.Logger}
   * @private
   */
  this.logger_ = logger;

  /**
   * @type {!invalidation.SystemResources.Scheduler}
   * @private
   */
  this.listenerScheduler_ = listenerScheduler;

  /**
   * Array of unacknowledged synthesized ack handles. Any ack handle not in this
   * list is assumed to belong to the server or has been acknowledged already.
   * @type {Array.<invalidation.Types.AckHandle>}
   * @private
   */
  this.pendingClientAckHandles_ = [];

  /**
   * @type {boolean} Whether the client is reusing an existing token.
   * @private
   */
  this.isRecycledClientToken_ = isRecycledClientToken;
};


/**
 * Returns the array of pending ack handles for client generated invalidations.
 * @return {Array.<invalidation.Types.AckHandle>}
 */
invalidation.RecycledStateClient.prototype.getPendingClientAckHandlesForTest =
    function() {
  return this.pendingClientAckHandles_;
};


/**
 * Starts the client, delegating to the actual client.
 * @override
 */
invalidation.RecycledStateClient.prototype.start = function() {
  this.client_.start();
};


/**
 * Stops the client, delegating to the actual client.
 * @override
 */
invalidation.RecycledStateClient.prototype.stop = function() {
  this.client_.stop();
};


/**
 * Requests that the Ticl register to receive notifications for the objects with
 * ids {@code objectIds}, delegating to the actual client and sending
 * InvalidateUnknownVersion to the listener.
 *
 * @param {...!invalidation.Types.ObjectId} objectIds The object ids being
 *     registered.
 * @override
 */
invalidation.RecycledStateClient.prototype.register = function(objectIds) {
  // Delegrate register to the client.
  this.client_.register.apply(this.client_, arguments);

  for (var i = 0; i < arguments.length; i++) {
    var objectId = arguments[i];

    // If this a recycled client token, call invalidateUnknownVersion with
    // exponential backoff until the client acknowledges it.
    if (this.isRecycledClientToken_) {
      this.logger_.info('Generating invalidation for registration for %s with' +
          ' a recycled client token', objectId);

      // Create an exponential backoff generator for retries, ignoring the
      // initial delay of 0.
      var exponentialBackoff =
          new invalidation.ExponentialBackoffDelayGenerator(Math.random,
          1000 /* initialDelayMs */, 1000 /* maxFactor */);
      var ignoredZeroDelay = exponentialBackoff.getNextDelay();

      // Create and remember a synthesized ack handle.
      var handleData = 'client-ack-handle-' + goog.string.getRandomString();
      var ackHandle = new invalidation.Types.AckHandle(handleData);
      this.pendingClientAckHandles_.push(ackHandle);

      this.retryInvalidateUntilAcked_(objectId, ackHandle, exponentialBackoff);
    }
  }
};


/**
 * Unregisters to receive notifications for the objects with ids
 * {@code objectIds}, delegating the call to the actual client.
 *
 * @param {...!invalidation.Types.ObjectId} objectIds The object ids being
 *     unregistered.
 * @override
 */
invalidation.RecycledStateClient.prototype.unregister = function(objectIds) {
  this.client_.unregister.apply(this.client_, arguments);
};


/**
 * Acknowledges the {@link Listener} event that was delivered with the provided
 * acknowledgement handle.
 * @param {!invalidation.Types.AckHandle} ackHandle The acknowledgement handle
 *     for the event being acknowledged.
 * @override
 */
invalidation.RecycledStateClient.prototype.acknowledge = function(ackHandle) {
  var index = this.findClientAckHandleIndex_(ackHandle);
  if (index != null) {
    // This is an ack handle we generated, so remove it from our array of
    // pending ack handles so we won't retry.
    this.logger_.info('Client-generated invalidation acked.');
    var ackHandles = this.pendingClientAckHandles_;
    this.pendingClientAckHandles_ =
        ackHandles.slice(0, index).concat(ackHandles.slice(index + 1));
  } else {
    // This isn't an ack handle we generated, so delegate to the actual client.
    this.client_.acknowledge(ackHandle);
  }
};


/**
 * Issues an invalidateUnknownVersion upcall for the given object id to the
 * listener, retrying with exponential backoff until the application
 * acks the invalidation.
 *
 * @param {!invalidation.Types.ObjectId} objectId
 *    The object id to invalidate.
 * @param {!invalidation.Types.AckHandle} ackHandle The client-generated ack
 *    handle for objectid.
 * @param {!invalidation.ExponentialBackoffDelayGenerator} delayGenerator
 *    An exponential backoff generator for retries.
 * @private
 */
invalidation.RecycledStateClient.prototype.retryInvalidateUntilAcked_ =
    function(objectId, ackHandle, delayGenerator) {
  // Issue the invalidateUnknown version upcall.
  this.listener_.invalidateUnknownVersion(this, objectId, ackHandle);

  // Retry after a delay with exponential backoff if the ackHandle has not been
  // acknowledged yet.
  var nextDelay = delayGenerator.getNextDelay();
  this.listenerScheduler_.schedule(nextDelay,
      new invalidation.NamedFunction('retry invalidation',
          goog.bind(function() {
        var isAcknowledged =
            (this.findClientAckHandleIndex_(ackHandle) == null);
        if (!isAcknowledged) {
          this.logger_.info('Client-generated invalidation for %s not acked, ' +
                      'retrying after %d ms', objectId, nextDelay);
          this.retryInvalidateUntilAcked_(objectId, ackHandle,
              delayGenerator);
        }
      }, this)));
};


/**
 * Return the index of the ack handle in the array of pending client ack handles
 * or returns null if the ack handle is not pending on the client.
 *
 * @param {!invalidation.Types.AckHandle} ackHandle The ack handle to find.
 * @return {?number} The index of the ack handle, or null if it is not known
 *     as a client ack handle.
 * @private
 */
invalidation.RecycledStateClient.prototype.findClientAckHandleIndex_ =
    function(ackHandle) {
  for (var i = 0; this.pendingClientAckHandles_.length; i++) {
    if (this.pendingClientAckHandles_[i].equals(ackHandle)) {
      return i;
    }
  }
  return null;
};


/** @override */
invalidation.RecycledStateClient.prototype.getConfigForTest = function() {
  return this.client_.getConfigForTest();
};


/** @override */
invalidation.RecycledStateClient.prototype.getAppClientIdForTest = function() {
  return this.client_.getAppClientIdForTest();
};

//ipc/invalidation/public/javascript/v2/factory/recycledstatestorage.js
/**
 * @fileoverview A wrapper for the Javascript storage that allows for
 * client token reuse by backing the ephemeral
 * {@link invalidation.SystemResources.Storage} with a persistent
 * {@link invalidation.ConcurrentStore}.
 *
 * When the the wrapped store is instantiated, it attempts to remove an
 * client token blob from the persistent store and write it to the the ephemeral
 * storage using the client token key.
 *
 * When the onUnload method is called (e.g. during page unload), the wrapped
 * store copies to the persistent store the last blob (if any) written to
 * the client token key. The value written could be either a recycled token or a
 * new token obtained by the TICL from the server.
 *
 * @author pbogle@google.com (Phil Bogle)
 */

goog.provide('invalidation.RecycledStateStorage');

goog.require('invalidation.Client');
goog.require('invalidation.ConcurrentStore');
goog.require('invalidation.ExponentialBackoffDelayGenerator');
goog.require('invalidation.SystemResources');
goog.require('invalidation.SystemResources.Logger');



/**
 * Initializes the RecycledStateStorage and attempts to recycle an old client
 * token blob.
 *
 * @constructor
 * @param {!invalidation.SystemResources.Storage} storage The ephemeral storage
 *    to be wrapped.
 * @param {string} clientTokenKey The key where the client token blob is
 *    written.
 * @param {!invalidation.ConcurrentStore} tokenStore The persistent store where
 *    recyclable client tokens are kept for the client type of this storage.
 * @param {!invalidation.SystemResources.Logger} logger A logger.
 * @implements {invalidation.SystemResources.Storage}
 */
invalidation.RecycledStateStorage = function(storage, clientTokenKey,
    tokenStore, logger) {
  /**
   * @type {!invalidation.SystemResources.Storage}
   * @private
   */
  this.ephemeralStorage_ = storage;

  /**
   * @type {string}
   * @private
   */
  this.clientTokenKey_ = clientTokenKey;

  /**
   * @type {!invalidation.ConcurrentStore}
   * @private
   */
  this.tokenStore_ = tokenStore;

  /**
   * @type {!invalidation.SystemResources.Logger}
   * @private
   */
  this.logger_ = logger;

  /**
   * The last blob written to the client token key. This will returned to the
   *  store when the onUnload event is called.
   * @type {?string}
   * @private
   */
  this.clientTokenBlob_ = null;

  /**
   * @type {boolean} true if the store (probably) recycled a token.
   * @private
   */
  this.isRecyledClientToken_ = this.attemptToRecycleClientToken_();
};


/**
 * Attempts to return the client token to the concurrent store when the
 * application no needs it. Must be called by the application before it shuts
 * down, e.g. on page unload, after which point that application instance must
 * no longer user the client token.
 */
invalidation.RecycledStateStorage.prototype.onUnload =
    function() {
  if (this.clientTokenBlob_ != null) {
    this.tokenStore_.add(this.clientTokenBlob_);
  }
};


/** @return {boolean} true if the store recycled a token. */
invalidation.RecycledStateStorage.prototype.getIsRecycledClientToken =
    function() {
  return this.isRecyledClientToken_;
};


/** @override */
invalidation.RecycledStateStorage.prototype.writeKey = function(key, value,
    doneCallback) {
  this.ephemeralStorage_.writeKey(key, value, doneCallback);

  // If the application is writing a new client token blob, remember it so that
  // we can save it in the persistent store on unload.
  if (key == this.clientTokenKey_) {
    this.clientTokenBlob_ = value;
  }
};


/** @override */
invalidation.RecycledStateStorage.prototype.readKey =
    function(key, doneCallback) {
  return this.ephemeralStorage_.readKey(key, doneCallback);
};


/** @override */
invalidation.RecycledStateStorage.prototype.deleteKey =
    function(key, doneCallback) {
  this.ephemeralStorage_.deleteKey(key, doneCallback);
};


/** @override */
invalidation.RecycledStateStorage.prototype.readAllKeys =
    function(keyCallback) {
  this.ephemeralStorage_.readAllKeys(keyCallback);
};


/** @override */
invalidation.RecycledStateStorage.prototype.setSystemResources =
    function(resources) {
  this.ephemeralStorage_.setSystemResources(resources);
};


/**
 * Attempts to recycle an abandoned client token from the concurrent store.
 * @return {boolean} true if the store was able to recycle a token.
 * @private
 */
invalidation.RecycledStateStorage.prototype.attemptToRecycleClientToken_ =
    function() {
  // Attempt to remove an old client token blob from the persistent store for
  // recycling.
  this.clientTokenBlob_ = this.tokenStore_.removeRandom();
  // If we successfully found one, write it to ephemeral storage so the
  // application will see it.
  if (this.clientTokenBlob_ != null) {
    var logger = this.logger_;
    logger.info('Reusing existing state blob: %s', this.clientTokenBlob_);
    this.writeKey(this.clientTokenKey_,
        this.clientTokenBlob_, function(status) {
          // It's OK if this fails, the client will acquire a new token if it
          // does. In practice failure is unlikely, since the ephemeral storage
          //  is an in-memory map.
          logger.info('Write state blob completed: %s', status);
        });
    return true;
  } else {
    return false;
  }
};

//ipc/invalidation/public/javascript/v2/factory/invalidationclientfactory.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview Factory for InvalidationClient instances.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.ClientFactory');

goog.require('goog.asserts');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('invalidation.Client');
goog.require('invalidation.ClientCore');
goog.require('invalidation.ClientImpl');
goog.require('invalidation.ConcurrentStore');
goog.require('invalidation.ExponentialBackoffDelayGenerator');
goog.require('invalidation.Listener');
goog.require('invalidation.RecycledStateClient');
goog.require('invalidation.RecycledStateStorage');
goog.require('invalidation.SystemResources');

/**
 * Creates an invalidation client config for the given arguments.
 *
 * @constructor
 *
 * @param {number} clientType The type code as assigned by the notification
 *     system's backend.
 * @param {string} clientName id/name of the client in the application's own
 *     naming scheme.
 * @param {string} applicationName Name of the application using the library
 *     (for debugging/monitoring).
 *
 * @export
 */
invalidation.ClientFactory.Config =
    function(clientType, clientName, applicationName) {
  this.clientType_ = clientType;
  this.clientName_ = clientName;
  this.applicationName_ = applicationName;
  this.allowSuppression_ = true;
  this.reuseClientTokens_ = true;

  goog.asserts.assert(Number(this.clientType_) >= 0,
      'client type must parse as non-negative number; given: %s (%s as number)',
      this.clientType_, Number(this.clientType_));

  /**
   * The client configuration, initialized to a default configuration but
   * overridable by calling setClientConfig.
   * @type {!invalidation.proto.ClientConfigP}
   * @private
   */
  this.clientConfig_ = invalidation.ClientCore.createConfig();
};

/**
 * @return {number} The client type code.
 * @export
 */
invalidation.ClientFactory.Config.prototype.getClientType =
    function() {
  return this.clientType_;
};

/**
 * @return {string} The client name.
 * @export
 */
invalidation.ClientFactory.Config.prototype.getClientName =
    function() {
  return this.clientName_;
};

/**
 * @return {string} The application name.
 * @export
 */
invalidation.ClientFactory.Config.prototype.getApplicationName =
    function() {
  return this.applicationName_;
};

/**
 * @return {boolean} whether suppression is allowed without
 *    requiring a call to InvalidationUnknownVersion.
 * @export
 */
invalidation.ClientFactory.Config.prototype.getAllowSuppression =
    function() {
  return this.clientConfig_.getAllowSuppressionOrDefault();
};

/**
 * Sets whether the suppression is allowed. (The default is true.)
 * @param {boolean} allowSuppression  If false, invalidateUnknownVersion()
 *     is called whenever suppression occurs.
 * @return {!invalidation.ClientFactory.Config} this config, to allow chaining.
 * @export
 */
invalidation.ClientFactory.Config.prototype.setAllowSuppression =
    function(allowSuppression) {
  this.clientConfig_.setAllowSuppression(allowSuppression);
  return this;
};

/**
 * @return {boolean} Whether the client should attempt to reuse a client token
 *     from an earlier, no longer running application instance of the same
 *     client type.
 * @export
 */
invalidation.ClientFactory.Config.prototype.getReuseClientTokens =
    function() {
  return this.reuseClientTokens_;
};

/**
 * Sets whether client tokens can be reused. (The default is true.)
 * @param {boolean} reuseClientTokens  Whether to allow client tokens from
 *     terminated application instances to be reused by new instances of the
 *     same type.
 * @return {!invalidation.ClientFactory.Config} this config, to allow chaining.
 * @export
 */
invalidation.ClientFactory.Config.prototype.setReuseClientTokens =
    function(reuseClientTokens) {
  this.reuseClientTokens_ = reuseClientTokens;
  return this;
};

/** @return {!invalidation.proto.ClientConfigP} */
invalidation.ClientFactory.Config.prototype.getClientConfig =
    function() {
  return this.clientConfig_;
};

/**
 * Sets the client config proto.
 * @param {!invalidation.proto.ClientConfigP} clientConfig The client config.
 */
invalidation.ClientFactory.Config.prototype.setClientConfig =
    function(clientConfig) {
  this.clientConfig_ = clientConfig;
};

/**
 * Creates a Ticl using the given resources, config, and listener.
 *
 * @param {!invalidation.SystemResources} resources The resources for logging,
 *     scheduling, network connectivity, and persistence.
 * @param {!invalidation.ClientFactory.Config} config The client config.
 * @param {!invalidation.Listener} listener Callback object for invalidation
 *     events.
 * @return {!invalidation.Client} A new client library for notifications.
 * @export
 */
invalidation.ClientFactory.createClient = function(resources, config,
    listener) {
  var logger = resources.getLogger();
  var clientConfig = config.getClientConfig();
  var listenerScheduler = resources.getListenerScheduler();

  if (!config.getReuseClientTokens()) {
    return new invalidation.ClientImpl(resources, Math.random,
        config.getClientType(), config.getClientName(), clientConfig,
        config.getApplicationName(), listener);
  } else {
    // Wrap the storage to allow for client token reuse. Include the client type
    // in the store name so that tokens are not reused across client types.
    var storeName = 'tokens-' + config.getClientType();
    var tokenStore = new invalidation.ConcurrentStoreImpl(storeName, logger);
    var wrappedStorage = new invalidation.RecycledStateStorage(
        resources.getStorage(), invalidation.ClientCore.CLIENT_TOKEN_KEY,
        tokenStore, logger);

    // Call onUnload when the page unloads to allow for token reuse.
    goog.events.listenOnce(window, goog.events.EventType.UNLOAD, function() {
      wrappedStorage.onUnload();
    });

    // Include the wrapped storage in the resources.
    var wrappedResources = new invalidation.BasicSystemResources(logger,
        resources.getInternalScheduler(), listenerScheduler,
        resources.getNetwork(), wrappedStorage);
    wrappedResources.start();

    // Return a wrapped client to ensure correct semantics with recycled tokens.
    var client = new invalidation.ClientImpl(wrappedResources, Math.random,
        config.getClientType(), config.getClientName(), clientConfig,
        config.getApplicationName(), listener);

    return new invalidation.RecycledStateClient(client, listener, logger,
        listenerScheduler, wrappedStorage.getIsRecycledClientToken());
  }
};

/**
 * Creates a Ticl using the given resources, client type, application id,
 * application name, and listener.
 *
 * Deprecated, please use createClient instead.
 *
 * @param {!invalidation.SystemResources} resources The resources for logging,
 *     scheduling, network connectivity, and persistence.
 * @param {number} clientType The type code as assigned by the notification
 *     system's backend.
 * @param {string} clientName id/name of the client in the application's own
 *     naming scheme.
 * @param {string} applicationName Name of the application using the library
 *     (for debugging/monitoring).
 * @param {!invalidation.Listener} listener Callback object for invalidation
 *     events.
 * @return {!invalidation.Client} A new client library for notifications.
 * @export
 */
invalidation.ClientFactory.create = function(resources, clientType, clientName,
    applicationName, listener) {
  var config = new invalidation.ClientFactory.Config(clientType, clientName,
          applicationName);
  config.setAllowSuppression(true);
  config.setReuseClientTokens(false);
  return invalidation.ClientFactory.createClient(resources, config, listener);
};

//ipc/invalidation/javascript/internal/client/basicsystemresources.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview  A simple implementation of {@code SystemResources} using
 * the Google Closure library.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.BasicSystemResources');

goog.require('goog.Timer');
goog.require('goog.debug.Logger');
goog.require('goog.string.format');
goog.require('goog.structs.Map');
goog.require('goog.userAgent.platform');
goog.require('invalidation.RunState');
goog.require('invalidation.SystemResources');
goog.require('invalidation.SystemResources.Logger');
goog.require('invalidation.SystemResources.NetworkChannel');
goog.require('invalidation.SystemResources.ResourceComponent');
goog.require('invalidation.SystemResources.Scheduler');
goog.require('invalidation.SystemResources.Storage');

/**
 * A simple implementation of {@code SystemResources} that just takes the
 * resource components and constructs a SystemResources object
 *
 * @param {!invalidation.SystemResources.Logger} logger Implementation of the
 *     logger.
 * @param {!invalidation.SystemResources.Scheduler} internalScheduler Scheduler
 *     for scheduling the library's internal events.
 * @param {!invalidation.SystemResources.Scheduler} listenerScheduler Scheduler
 *     for scheduling the listener's events.
 * @param {!invalidation.SystemResources.NetworkChannel} network Implementation
 *     of the network.
 * @param {!invalidation.SystemResources.Storage} storage Implementation of
 *     storage.
 * @constructor
 * @implements {invalidation.SystemResources}
 */
invalidation.BasicSystemResources = function(logger, internalScheduler,
    listenerScheduler, network, storage) {
  /**
   * See method parameter for specs.
   * @type {!invalidation.SystemResources.Scheduler}
   * @private
   */
  this.internalScheduler_ = internalScheduler;

  /**
   * See method parameter for specs.
   * @type {!invalidation.SystemResources.Scheduler}
   * @private
   */
  this.listenerScheduler_ = listenerScheduler;

  /**
   * See method parameter for specs.
   * @type {!invalidation.SystemResources.Logger}
   * @private
   */
  this.logger_ = logger;

  /**
   * See method parameter for specs.
   * @type {!invalidation.SystemResources.NetworkChannel}
   * @private
   */
  this.network_ = network;

  /**
   * See method parameter for specs.
   * @type {!invalidation.SystemResources.Storage}
   * @private
   */
  this.storage_ = storage;

  /**
   * Current state of the resources (stopped in the beginning)
   * @type {!invalidation.RunState}
   * @private
   */
  this.runState_ = new invalidation.RunState();

  // Pass a reference to this object to all of the components, so that they can
  // access resources. E.g., so that the network can do logging.

  this.internalScheduler_.setSystemResources(this);
  this.listenerScheduler_.setSystemResources(this);
  this.logger_.setSystemResources(this);
  this.network_.setSystemResources(this);
  this.storage_.setSystemResources(this);
};

/**
 * @override
 */
invalidation.BasicSystemResources.prototype.start = function() {
  this.runState_.start();
};

/**
 * @override
 */
invalidation.BasicSystemResources.prototype.stop = function() {
    this.runState_.stop();
};

/**
 * @override
 */
invalidation.BasicSystemResources.prototype.isStarted = function() {
  return this.runState_.isStarted();
};

/**
 * @override
 */
invalidation.BasicSystemResources.prototype.getPlatform = function() {
  return goog.userAgent.platform.VERSION;
};

/**
 * @override
 */
invalidation.BasicSystemResources.prototype.getLogger = function() {
  return this.logger_;
};

/**
 * @override
 */
invalidation.BasicSystemResources.prototype.getStorage = function() {
  return this.storage_;
};

/**
 * @override
 */
invalidation.BasicSystemResources.prototype.getNetwork = function() {
  return this.network_;
};

/**
 * @override
 */
invalidation.BasicSystemResources.prototype.getInternalScheduler = function() {
  return this.internalScheduler_;
};
/**
 * @override
 */
invalidation.BasicSystemResources.prototype.getListenerScheduler = function() {
  return this.listenerScheduler_;
};

//ipc/invalidation/javascript/internal/client/defaultresourcesimpl.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview  A default implementation of different system resources -
 * logger, storage and scheduler.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.DefaultLogger');
goog.provide('invalidation.DefaultScheduler');
goog.provide('invalidation.DefaultStorage');

goog.require('goog.string.format');
goog.require('goog.structs.Map');
goog.require('invalidation.NamedFunction');
goog.require('invalidation.util.LoggerImpl');

//
// Default Scheduler
//

/**
 * Implements the scheduler using goog.Timer.
 *
 * @constructor
 * @implements {invalidation.SystemResources.Scheduler}
 */
invalidation.DefaultScheduler = function() {

  /**
   * The resources for scheduling, logging, etc.
   * @type {?invalidation.SystemResources}
   * @private
   */
  this.resources_ = null;

  /**
   * Logger materialized from resources for ease of use.
   * @type {?invalidation.SystemResources.Logger}
   * @private
   */
  this.logger_ = null;
};

/**
 * @override
 */
invalidation.DefaultScheduler.prototype.getCurrentTimeMs = function() {
  return goog.now();
};

/**
 * @override
 */
invalidation.DefaultScheduler.prototype.schedule = function(delayMs, func) {
  // For simplicity, schedule on the workqueue. Check when the event runs later
  // if the resources have been shutdown.
  var scheduleFunction = goog.bind(function() {
    if (this.resources_.isStarted()) {
      func.run();
    } else {
      this.logger_.warning('Not running on internal thread since ' +
        'resources are not started %s, %s', delayMs, func);
    }
  }, this);
  goog.Timer.callOnce(scheduleFunction, delayMs);
};

/**
 * @override
 */
invalidation.DefaultScheduler.prototype.setSystemResources =
    function(resources) {
  this.resources_ = resources;
  this.logger_ = this.resources_.getLogger();
};

//
// Logger
//

/**
 * Logger based on {@code goog.debug.Logger}. Creates a logger that prefixes
 * every logging stmt with {@code logPrefix}.
 *
 * @param {string} logPrefix The prefix used for logging.
 * @extends {invalidation.util.LoggerImpl}
 * @implements {invalidation.SystemResources.Logger}
 * @constructor
 */
invalidation.DefaultLogger = function(logPrefix) {
  invalidation.util.LoggerImpl.call(this, 'invalidation-' + logPrefix);
};
goog.inherits(invalidation.DefaultLogger, invalidation.util.LoggerImpl);

/**
 * @param {!invalidation.SystemResources} resources The resources being
 *     used for logging, etc.
 */
invalidation.DefaultLogger.prototype.setSystemResources =
    function(resources) {
  // Ignore.
};

//
// Storage
//

/**
 * An in-memory implementation of the storage API using goog.structs.Map. All
 * operations are scheduled using the scheduler so that any changes due to a
 * writeKey/deleteKey performed by the caller are not immediately reflected
 * after the caller's call returns.
 *
 * @constructor
 * @implements {invalidation.SystemResources.Storage}
 */
invalidation.DefaultStorage = function() {
  /**
   * Scheduler saved from resources for ease of use.
   *
   * @type {?invalidation.SystemResources.Scheduler}
   * @private
   */
  this.internalScheduler_ = null;

  /**
   * Logger saved from resources for ease of use.
   * @type {?invalidation.SystemResources.Logger}
   * @private
   */
  this.logger_ = null;

  /**
   * Map for storing the "persistent" state.
   *
   * @type {!goog.structs.Map}
   * @private
   */
  this.persistentState_ = new goog.structs.Map();
};


/**
 * @param {!invalidation.SystemResources} resources The resources being
 *     used for logging, etc.
 */
invalidation.DefaultStorage.prototype.setSystemResources =
    function(resources) {
  this.internalScheduler_ = resources.getInternalScheduler();
  this.logger_ = resources.getLogger();
};

/**
 * @override
 */
invalidation.DefaultStorage.prototype.writeKey = function(key, value,
    doneCallback) {
  // Schedule the change to the map.
  var writeFunction = goog.bind(function() {
    this.persistentState_.set(key, value);
    doneCallback(invalidation.Types.newSuccessStatus());
  }, this);
  this.internalScheduler_.schedule(0, new invalidation.NamedFunction('writeKey',
      writeFunction));
};

/**
 * @override
 */
invalidation.DefaultStorage.prototype.readKey = function(key, doneCallback) {
  // Schedule the read from the map.
  var getFunction = goog.bind(function() {
    var value = this.persistentState_.get(key);
    if (value) {
      doneCallback(invalidation.Types.newSuccessStatus(),
                   /** @type {string} */ (value));
    } else {
      doneCallback(invalidation.Types.newPermanentFailureStatus('No value ' +
          'present in map for ' + key), '');
    }
  }, this);
  this.internalScheduler_.schedule(0, new invalidation.NamedFunction('readKey',
      getFunction));
};

/**
 * @override
 */
invalidation.DefaultStorage.prototype.deleteKey = function(key, doneCallback) {
  // Schedule the delete from the map.
  var deleteFunction = goog.bind(function() {
    this.persistentState_.remove(key);
    doneCallback(true);
  }, this);
  this.internalScheduler_.schedule(0, new invalidation.NamedFunction(
      'deleteKey', deleteFunction));
};

/**
 * @override
 */
invalidation.DefaultStorage.prototype.readAllKeys = function(keyCallback) {
  // Schedule the reading and keep calling the callback.
  var readFunction = goog.bind(function() {
    var keys = this.persistentState_.getKeys();
    for (var i = 0; i < keys.length; i++) {
      keyCallback(invalidation.Types.newSuccessStatus(), keys[i]);
    }
  }, this);
  this.internalScheduler_.schedule(0, new invalidation.NamedFunction(
      'readAllKeys', readFunction));
};

//ipc/invalidation/public/javascript/v2/interface/systemresourcesbuilderinterface.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview  A builder to override some or all resource components in
 * {@code SystemResources}. See discussion in {@code ResourceComponent} as well.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.SystemResourcesBuilderInterface');

goog.require('invalidation.SystemResources.Logger');
goog.require('invalidation.SystemResources.NetworkChannel');
goog.require('invalidation.SystemResources.Scheduler');
goog.require('invalidation.SystemResources.Storage');

//
// SystemResourcesBuilderInterface
//

/**
 * A builder for override some or all resource components in
 * {@code SystemResources}. The SystemResourcesBuilder allows applications to
 * create a single {@code SystemResources} implementation by composing
 * individual building blocks, each of which implements one of the four required
 * interfaces ({@code Logger}, {@code Storage}, {@code NetworkChannel},
 * {@code Scheduler}).
 * <p>
 * However, each interface implementation may require functionality from
 * another. For example, the network implementation may need to do logging. Any
 * component (Logger, Storage, NetworkChannel, Scheduler) that wants to use
 * another component must implement the setSystemResources method.
 * <p>
 * Note: for the obvious reasons of infinite recursion, implementations should
 * not attempt to access themselves through the provided
 * {@code SystemResources}.
 *
 * @interface
 */
invalidation.SystemResourcesBuilderInterface = function() {
};

/**
 * @return {!invalidation.SystemResources.Scheduler} The internal scheduler.
 */
invalidation.SystemResourcesBuilderInterface.prototype.getInternalScheduler =
    goog.abstractMethod;

/**
 * @return {!invalidation.SystemResources.Scheduler} The listener scheduler.
 */
invalidation.SystemResourcesBuilderInterface.prototype.getListenerScheduler =
    goog.abstractMethod;

/**
 * @return {!invalidation.SystemResources.Storage} The storage.
 */
invalidation.SystemResourcesBuilderInterface.prototype.getStorage =
    goog.abstractMethod;

/**
 * @return {!invalidation.SystemResources.NetworkChannel} The network channel.
 */
invalidation.SystemResourcesBuilderInterface.prototype.getNetwork =
    goog.abstractMethod;

/**
 * @return {!invalidation.SystemResources.Logger} The logger.
 */
invalidation.SystemResourcesBuilderInterface.prototype.getLogger =
    goog.abstractMethod;

/**
 * Sets the logger to be {@code logger}.
 * <p>
 * REQUIRES: {@code SystemResourcesBuilderInterface.build} has not been called.
 *
 * @param {!invalidation.SystemResources.Logger} logger The new logger for
 *     logging statements.
 * @export
 */
invalidation.SystemResourcesBuilderInterface.prototype.setLogger =
    goog.abstractMethod;

/**
 * Sets the persistence layer to be {@code storage}.
 * <p>
 * REQUIRES: {@code SystemResourcesBuilderInterface.build} has not been called.
 *
 * @param {!invalidation.SystemResources.Storage} storage The new storage layer
 *     for reading/writing data.
 * @export
 */
invalidation.SystemResourcesBuilderInterface.prototype.setStorage =
    goog.abstractMethod;

/**
 * Sets the scheduler for scheduling internal events to be
 *     {@code internalScheduler}.
 * <p>
 * REQUIRES: {@code SystemResourcesBuilderInterface.build} has not been called.
 *
 * @param {!invalidation.SystemResources.Scheduler} internalScheduler The new
 *     scheduler for internal events.
 * @export
 */
invalidation.SystemResourcesBuilderInterface.prototype.setInternalScheduler =
    goog.abstractMethod;

/**
 * Sets the scheduler for scheduling listener events to be
 * {@code listenerScheduler}.
 * <p>
 * REQUIRES: {@code SystemResourcesBuilderInterface.build} has not been called.
 *
 * @param {!invalidation.SystemResources.Scheduler} listenerScheduler The new
 *     scheduler for listener events.
 * @export
 */
invalidation.SystemResourcesBuilderInterface.prototype.setListenerScheduler =
    goog.abstractMethod;

/**
 * Sets the network channel for communicating with the server to be
 * {@code network}.
 * <p>
 * REQUIRES: {@code SystemResourcesBuilderInterface.build} has not been called.
 *
 * @param {!invalidation.SystemResources.NetworkChannel} network The new network
 *     sending/receiving messages.
 * @export
 */
invalidation.SystemResourcesBuilderInterface.prototype.setNetwork =
    goog.abstractMethod;

/**
 * @return {!invalidation.SystemResources} Builds the {@code SystemResources}
 *    object with the given resource components and returns it.
 * <p>
 * Caller must not call any method (on this SystemResourcesBuilderInterface)
 * after {@code build} has been called.
 * @export
 */
invalidation.SystemResourcesBuilderInterface.prototype.build =
    goog.abstractMethod;

/**
 * Seals the builder so that no mutation method can be called on this
 */
invalidation.SystemResourcesBuilderInterface.prototype.seal =
    goog.abstractMethod;

//ipc/invalidation/javascript/internal/client/systemresourcesbuilderimpl.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview  A builder to override some or all resource components in
 * {@code SystemResources}. See discussion in {@code ResourceComponent} as well.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.SystemResourcesBuilderImpl');

goog.require('goog.debug.Logger.Level');
goog.require('invalidation.BasicSystemResources');
goog.require('invalidation.DefaultLogger');
goog.require('invalidation.DefaultScheduler');
goog.require('invalidation.DefaultStorage');
goog.require('invalidation.SystemResources.Logger');
goog.require('invalidation.SystemResources.NetworkChannel');
goog.require('invalidation.SystemResources.Scheduler');
goog.require('invalidation.SystemResources.Storage');
goog.require('invalidation.SystemResourcesBuilderInterface');
goog.require('invalidation.Types.Status');

//
// SystemResourcesBuilderImpl
//

/**
 * A builder for override some or all resource components in
 * {@code SystemResources}. The SystemResourcesBuilderImpl allows applications
 * to create a single {@code SystemResources} implementation by composing
 * individual building blocks, each of which implements one of the four required
 * interfaces ({@code Logger}, {@code Storage}, {@code NetworkChannel},
 * {@code Scheduler}).
 * <p>
 * However, each interface implementation may require functionality from
 * another. For example, the network implementation may need to do logging. Any
 * component (Logger, Storage, NetworkChannel, Scheduler) that wants to use
 * another component must implement the setSystemResources method.
 * <p>
 * Note: for the obvious reasons of infinite recursion, implementations should
 * not attempt to access themselves through the provided
 * {@code SystemResources}.
 *
 *
 * @param {!invalidation.SystemResources.Logger} logger Implementation of the
 *     logger.
 * @param {!invalidation.SystemResources.Scheduler} internalScheduler Scheduler
 *     for scheduling the library's internal events.
 * @param {!invalidation.SystemResources.Scheduler} listenerScheduler Scheduler
 *     for scheduling the listener's events.
 * @param {!invalidation.SystemResources.NetworkChannel} network Implementation
 *     of the network.
 * @param {!invalidation.SystemResources.Storage} storage Implementation of
 *     storage.
 *
 * @constructor
 * @implements {invalidation.SystemResourcesBuilderInterface}
 */
invalidation.SystemResourcesBuilderImpl = function(logger, internalScheduler,
    listenerScheduler, network, storage) {
  /**
   * See method parameter for specs.
   * @type {!invalidation.SystemResources.Scheduler}
   * @private
   */
  this.internalScheduler_ = internalScheduler;

  /**
   * See method parameter for specs.
   * @type {!invalidation.SystemResources.Scheduler}
   * @private
   */
  this.listenerScheduler_ = listenerScheduler;

  /**
   * See method parameter for specs.
   * @type {!invalidation.SystemResources.Logger}
   * @private
   */
  this.logger_ = logger;

  /**
   * See method parameter for specs.
   * @type {!invalidation.SystemResources.NetworkChannel}
   * @private
   */
  this.network_ = network;

  /**
   * See method parameter for specs.
   * @type {!invalidation.SystemResources.Storage}
   * @private
   */
  this.storage_ = storage;


  /**
   * Whether the build method has been called on this builder.
   *  @type {boolean}
   *  @private
   */
  this.sealed_ = false;
};

/**
 * Constructs a {@code SystemResourcesBuilderImpl} instance using default
 * scheduling, logging (with a prefix {@code logPrefix} for log messages if the
 * default logger is not overriden), and storage, and using {@code network} to
 * send and receive messages.
 *
 * @param {string} logPrefix Prefix used for logging messages.
 * @param {!invalidation.SystemResources.NetworkChannel} network The new network
 *     sending/receiving messages.
 * @return {!invalidation.SystemResourcesBuilderImpl} The builder with the
 *     default resources bound internally.
 * @export
 */
invalidation.SystemResourcesBuilderImpl.newDefaultBuilder = function(logPrefix,
    network) {
  return new invalidation.SystemResourcesBuilderImpl(
      new invalidation.DefaultLogger(logPrefix),
      new invalidation.DefaultScheduler(), new invalidation.DefaultScheduler(),
      network, new invalidation.DefaultStorage());
};

/**
 * @return {!invalidation.SystemResources.Scheduler} The internal scheduler.
 */
invalidation.SystemResourcesBuilderImpl.prototype.getInternalScheduler =
    function() {
  return this.internalScheduler_;
};

/**
 * @return {!invalidation.SystemResources.Scheduler} The listener scheduler.
 */
invalidation.SystemResourcesBuilderImpl.prototype.getListenerScheduler =
    function() {
  return this.listenerScheduler_;
};

/**
 * @return {!invalidation.SystemResources.Storage} The storage.
 */
invalidation.SystemResourcesBuilderImpl.prototype.getStorage =
    function() {
  return this.storage_;
};

/**
 * @return {!invalidation.SystemResources.NetworkChannel} The network channel.
 */
invalidation.SystemResourcesBuilderImpl.prototype.getNetwork = function() {
  return this.network_;
};

/**
 * @return {!invalidation.SystemResources.Logger} The logger.
 */
invalidation.SystemResourcesBuilderImpl.prototype.getLogger = function() {
  return this.logger_;
};

/**
 * Sets the logger to be {@code logger}.
 * <p>
 * REQUIRES: {@code SystemResourcesBuilderImpl.build} has not been called.
 *
 * @param {!invalidation.SystemResources.Logger} logger The new logger for
 *     logging statements.
 * @export
 */
invalidation.SystemResourcesBuilderImpl.prototype.setLogger = function(logger) {
  goog.asserts.assert(!this.sealed_, 'build method has already been called');
  this.logger_ = logger;
};

/**
 * Sets the persistence layer to be {@code storage}.
 * <p>
 * REQUIRES: {@code SystemResourcesBuilderImpl.build} has not been called.
 *
 * @param {!invalidation.SystemResources.Storage} storage The new storage layer
 *     for reading/writing data.
 * @export
 */
invalidation.SystemResourcesBuilderImpl.prototype.setStorage =
    function(storage) {
  goog.asserts.assert(!this.sealed_, 'build method has already been called');
  this.storage_ = storage;
};

/**
 * Sets the scheduler for scheduling internal events to be
 *     {@code internalScheduler}.
 * <p>
 * REQUIRES: {@code SystemResourcesBuilderImpl.build} has not been called.
 *
 * @param {!invalidation.SystemResources.Scheduler} internalScheduler The new
 *     scheduler for internal events.
 * @export
 */
invalidation.SystemResourcesBuilderImpl.prototype.setInternalScheduler =
    function(internalScheduler) {
  goog.asserts.assert(!this.sealed_, 'build method has already been called');
  this.internalScheduler_ = internalScheduler;
};

/**
 * Sets the scheduler for scheduling listener events to be
 * {@code listenerScheduler}.
 * <p>
 * REQUIRES: {@code SystemResourcesBuilderImpl.build} has not been called.
 *
 * @param {!invalidation.SystemResources.Scheduler} listenerScheduler The new
 *     scheduler for listener events.
 * @export
 */
invalidation.SystemResourcesBuilderImpl.prototype.setListenerScheduler =
    function(listenerScheduler) {
  goog.asserts.assert(!this.sealed_, 'build method has already been called');
  this.listenerScheduler_ = listenerScheduler;
};

/**
 * Sets the network channel for communicating with the server to be
 * {@code network}.
 * <p>
 * REQUIRES: {@code SystemResourcesBuilderImpl.build} has not been called.
 *
 * @param {!invalidation.SystemResources.NetworkChannel} network The new network
 *     sending/receiving messages.
 * @export
 */
invalidation.SystemResourcesBuilderImpl.prototype.setNetwork =
    function(network) {
  goog.asserts.assert(!this.sealed_, 'build method has already been called');
  this.network_ = network;
};

/**
 * @return {!invalidation.SystemResources} Builds the {@code SystemResources}
 *    object with the given resource components and returns it.
 * <p>
 * Caller must not call any method (on this SystemResourcesBuilderImpl) after
 * {@code build} has been called.
 * @export
 */
invalidation.SystemResourcesBuilderImpl.prototype.build = function() {
  goog.asserts.assert(!this.sealed_, 'build method has already been called');
  this.seal();
  return new invalidation.BasicSystemResources(this.logger_,
      this.internalScheduler_, this.listenerScheduler_, this.network_,
      this.storage_);
};

/**
 * Seals the builder so that no mutation method can be called on this
 */
invalidation.SystemResourcesBuilderImpl.prototype.seal = function() {
  goog.asserts.assert(!this.sealed_, 'build method has already been called');
  this.sealed_ = true;
};

//ipc/invalidation/public/javascript/v2/factory/systemresourcesbuilder.js
// Copyright 2011 Google Inc. All rights reserved.

/**
 * @fileoverview  A builder to override some or all resource components in
 * {@code SystemResources}. See discussion in {@code ResourceComponent} as well.
 *
 * @author adya@google.com (Atul Adya)
 */

goog.provide('invalidation.SystemResourcesBuilder');

goog.require('goog.debug.Logger.Level');
goog.require('invalidation.BasicSystemResources');
goog.require('invalidation.DefaultLogger');
goog.require('invalidation.DefaultScheduler');
goog.require('invalidation.DefaultStorage');
goog.require('invalidation.SystemResources.Logger');
goog.require('invalidation.SystemResources.NetworkChannel');
goog.require('invalidation.SystemResources.Scheduler');
goog.require('invalidation.SystemResources.Storage');
goog.require('invalidation.SystemResourcesBuilderImpl');
goog.require('invalidation.SystemResourcesBuilderInterface');
goog.require('invalidation.Types.Status');

//
// SystemResourcesBuilder
//

// TODO(ghc): [bug 6501480] Consider replacing the inheritance here with
// delegation.

/**
 * A builder for override some or all resource components in
 * {@code SystemResources}. The SystemResourcesBuilder allows applications to
 * create a single {@code SystemResources} implementation by composing
 * individual building blocks, each of which implements one of the four required
 * interfaces ({@code Logger}, {@code Storage}, {@code NetworkChannel},
 * {@code Scheduler}).
 * <p>
 * However, each interface implementation may require functionality from
 * another. For example, the network implementation may need to do logging. Any
 * component (Logger, Storage, NetworkChannel, Scheduler) that wants to use
 * another component must implement the setSystemResources method.
 * <p>
 * Note: for the obvious reasons of infinite recursion, implementations should
 * not attempt to access themselves through the provided
 * {@code SystemResources}.
 *
 *
 * @param {!invalidation.SystemResources.Logger} logger Implementation of the
 *     logger.
 * @param {!invalidation.SystemResources.Scheduler} internalScheduler Scheduler
 *     for scheduling the library's internal events.
 * @param {!invalidation.SystemResources.Scheduler} listenerScheduler Scheduler
 *     for scheduling the listener's events.
 * @param {!invalidation.SystemResources.NetworkChannel} network Implementation
 *     of the network.
 * @param {!invalidation.SystemResources.Storage} storage Implementation of
 *     storage.
 *
 * @constructor
 * @extends {invalidation.SystemResourcesBuilderImpl}
 * @implements {invalidation.SystemResourcesBuilderInterface}
 */
invalidation.SystemResourcesBuilder = function(logger, internalScheduler,
    listenerScheduler, network, storage) {
  invalidation.SystemResourcesBuilderImpl.call(
      this, logger, internalScheduler, listenerScheduler, network, storage);
};
goog.inherits(invalidation.SystemResourcesBuilder,
              invalidation.SystemResourcesBuilderImpl);

/**
 * Constructs a {@code SystemResourcesBuilder} instance using default
 * scheduling, logging (with a prefix {@code logPrefix} for log messages if the
 * default logger is not overriden), and storage, and using {@code network} to
 * send and receive messages.
 *
 * @param {string} logPrefix Prefix used for logging messages.
 * @param {!invalidation.SystemResources.NetworkChannel} network The new network
 *     sending/receiving messages.
 * @return {!invalidation.SystemResourcesBuilder} The builder with the default
 *     resources bound internally.
 * @export
 */
invalidation.SystemResourcesBuilder.newDefaultBuilder = function(logPrefix,
    network) {
  return new invalidation.SystemResourcesBuilder(
      new invalidation.DefaultLogger(logPrefix),
      new invalidation.DefaultScheduler(), new invalidation.DefaultScheduler(),
      network, new invalidation.DefaultStorage());
};

//javascript/apps/drive/dataservice/sync/change/tangoerrorevent.js
goog.provide('drive.ds.sync.change.TangoErrorEvent');

goog.require('goog.events');
goog.require('goog.events.Event');



/**
 * An event for tango errors.
 *
 * @param {string} message The error message.
 * @param {Object=} opt_target Reference to the object that is the target of
 *     this event. It has to implement the {@code EventTarget} interface
 *     declared at {@link http://developer.mozilla.org/en/DOM/EventTarget}.
 * @constructor
 * @extends {goog.events.Event}
 */
drive.ds.sync.change.TangoErrorEvent = function(message, opt_target) {
  goog.base(this, drive.ds.sync.change.TangoErrorEvent.TYPE, opt_target);

  /**
   * The error message.
   * @private {string}
   */
  this.message_ = message;
};
goog.inherits(drive.ds.sync.change.TangoErrorEvent, goog.events.Event);


/**
 * @return {string} The error message.
 */
drive.ds.sync.change.TangoErrorEvent.prototype.getMessage = function() {
  return this.message_;
};


/**
 * The event type for a ErrorEvent.
 * @type {string}
 */
drive.ds.sync.change.TangoErrorEvent.TYPE =
    goog.events.getUniqueId('TangoErrorEvent');

//javascript/apps/drive/dataservice/sync/change/tangolistener.js
goog.provide('drive.ds.sync.change.TangoListener');

goog.require('drive.ds.sync.change.TangoChangelogEvent');
goog.require('drive.ds.sync.change.TangoErrorEvent');
goog.require('invalidation.SimpleListener');



/**
 * An invalidation listener which generates events for changelog updates.
 *
 * @param {!goog.events.EventTarget} eventTarget The event target where
 *     events will be dispatched.
 * @param {!invalidation.SystemResources} resources The system resources for
 *     scheduling, logging, etc.
 * @constructor
 * @extends {invalidation.SimpleListener}
 */
drive.ds.sync.change.TangoListener = function(eventTarget, resources) {
  goog.base(this, resources);

  /**
   * The event target where events will be dispatched from this listener.
   * @private {!goog.events.EventTarget}
   */
  this.eventTarget_ = eventTarget;

  /**
   * The maximum change id seen so far.
   * @private {number}
   */
  this.maxKnownChangeId_ = -1;
};
goog.inherits(
    drive.ds.sync.change.TangoListener,
    invalidation.SimpleListener);


/** @override */
drive.ds.sync.change.TangoListener.prototype.invalidate = function(
    client, inv, ackHandle) {
  var version = inv.getVersion();

  if (version > this.maxKnownChangeId_) {
    this.maxKnownChangeId_ = version;
    this.eventTarget_.dispatchEvent(
        new drive.ds.sync.change.TangoChangelogEvent(version));
  }

  client.acknowledge(ackHandle);
};


/** @override */
drive.ds.sync.change.TangoListener.prototype.invalidateUnknownVersion =
    function(client, objectId, ackHandle) {
  this.eventTarget_.dispatchEvent(
      new drive.ds.sync.change.TangoChangelogEvent());
  client.acknowledge(ackHandle);
};


/** @override */
drive.ds.sync.change.TangoListener.prototype.invalidateAll =
    function(client, ackHandle) {
  this.eventTarget_.dispatchEvent(
      new drive.ds.sync.change.TangoChangelogEvent());
  client.acknowledge(ackHandle);
};


/** @override */
drive.ds.sync.change.TangoListener.prototype.informError =
    function(client, errorInfo) {
  this.eventTarget_.dispatchEvent(
      new drive.ds.sync.change.TangoErrorEvent(errorInfo));
};

//javascript/apps/drive/dataservice/sync/change/tangoclient.js
goog.provide('drive.ds.sync.change.TangoClient');

goog.require('drive.ds.sync.change.TangoListener');
goog.require('goog.events.EventTarget');
goog.require('invalidation.Client');
goog.require('invalidation.ClientFactory');
goog.require('invalidation.LcsPushChannel');
goog.require('invalidation.SimpleListener');
goog.require('invalidation.SystemResourcesBuilder');
goog.require('invalidation.proto.ClientType.Type');
goog.require('invalidation.proto.ObjectSource.Type');



/**
 * A client that receives push notifications from Tango and generates
 * events when changelog updates occur.
 *
 * For this code to work properly, the following code must be in the dom:
 *    <div id="lcsclient" style="display:none"></div>
 *    <div id="lcssenderclient" style="display:none"></div>
 * These are populated with iframes and are used for communication.
 *
 * @param {number=} opt_authUserIndex The index of the authorized user. If
 *     defined, this can be used to support multi-login.
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.change.TangoClient = function(opt_authUserIndex) {
  goog.base(this);

  /**
   * The system resource object used to define logging, storage, and other
   * aspects of Tango.
   * @private {!invalidation.SystemResources}
   */
  this.resources_ = drive.ds.sync.change.TangoClient.createResources_(
      opt_authUserIndex);

  /**
   * A listener for receiving Tango events.
   * @private {!invalidation.SimpleListener}
   */
  this.listener_ = new drive.ds.sync.change.TangoListener(
      this, this.resources_);

  /**
   * The invalidation client.
   * @private {!invalidation.Client}
   */
  this.client_ = drive.ds.sync.change.TangoClient.createClient_(
      this.resources_, this.listener_);

  this.resources_.start();
  this.client_.start();

  this.listener_.register(
      this.client_,
      drive.ds.sync.change.TangoClient.createObject_());
};
goog.inherits(drive.ds.sync.change.TangoClient, goog.events.EventTarget);


/**
 * The URI for the Client Channel (LCS) front ends.
 * @private {string}
 */
drive.ds.sync.change.TangoClient.TANGO_CHANNEL_URI_ =
    'https://client-channel.google.com/client-channel/client';


/**
 * The URI for the Tango Gateway front ends.
 * @private {string}
 */
drive.ds.sync.change.TangoClient.TANGO_SENDER_URI_ =
    'https://clients4.google.com/invalidation/lcs/client';


/**
 * The name of our service. Used when constructing the communications channel.
 * @private {string}
 */
drive.ds.sync.change.TangoClient.CLIENT_NAME_ = 'cello';


/**
 * The changelog object name. This is defined in:
 * j/c/g/ipc/invalidation/bridge/common/CosmoChangelogObjectIdFactory.java
 * @private {string}
 */
drive.ds.sync.change.TangoClient.CHANGELOG_NAME_ = 'CHANGELOG';


/**
 * Factory method used to create a client configuration.
 * @return {!invalidation.ClientFactory.Config}
 * @private
 */
drive.ds.sync.change.TangoClient.createConfig_ = function() {
  return new invalidation.ClientFactory.Config(
      invalidation.proto.ClientType.Type.DRIVE_SYNC,
      drive.ds.sync.change.TangoClient.CLIENT_NAME_,
      drive.ds.sync.change.TangoClient.CLIENT_NAME_);
};


/**
 * Factory method used to create the changelog object.
 * @return {!invalidation.Types.ObjectId}
 * @private
 */
drive.ds.sync.change.TangoClient.createObject_ = function() {
  return new invalidation.Types.ObjectId(
      invalidation.proto.ObjectSource.Type.COSMO_CHANGELOG,
      drive.ds.sync.change.TangoClient.CHANGELOG_NAME_);
};


/**
 * Factory method used to create the channel for communicating with the server.
 * @param {number=} opt_authUserIndex The index of the authorized user. If
 *     defined, this can be used to support multi-login.
 * @return {!invalidation.SystemResources.NetworkChannel}
 * @private
 */
drive.ds.sync.change.TangoClient.createChannel_ = function(opt_authUserIndex) {
  return new invalidation.LcsPushChannel(
      drive.ds.sync.change.TangoClient.TANGO_CHANNEL_URI_,
      drive.ds.sync.change.TangoClient.TANGO_SENDER_URI_,
      drive.ds.sync.change.TangoClient.CLIENT_NAME_,
      opt_authUserIndex);
};


/**
 * Factory method used to create system resources.
 * @param {number=} opt_authUserIndex The index of the authorized user. If
 *     defined, this can be used to support multi-login.
 * @return {!invalidation.SystemResources}
 * @private
 */
drive.ds.sync.change.TangoClient.createResources_ =
    function(opt_authUserIndex) {
  return invalidation.SystemResourcesBuilder.newDefaultBuilder(
      drive.ds.sync.change.TangoClient.CLIENT_NAME_,
      drive.ds.sync.change.TangoClient.createChannel_(opt_authUserIndex))
      .build();
};


/**
 * Factory method used to create tango clients.
 * @param {!invalidation.SystemResources} resources
 * @param {!invalidation.Listener} listener
 * @return {!invalidation.Client}
 * @private
 */
drive.ds.sync.change.TangoClient.createClient_ =
    function(resources, listener) {
  return invalidation.ClientFactory.createClient(
      resources,
      drive.ds.sync.change.TangoClient.createConfig_(),
      listener);
};

//javascript/apps/drive/dataservice/sync/change/pushchangeprocessor.js
goog.provide('drive.ds.sync.change.PushChangeProcessor');

goog.require('drive.ds.sync.change.ChangeProcessor');
goog.require('drive.ds.sync.change.TangoChangelogEvent');
goog.require('drive.ds.sync.change.TangoClient');
goog.require('drive.ds.sync.change.TangoErrorEvent');
goog.require('goog.debug.Logger');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.events.EventHandler');
goog.require('goog.math.Long');



/**
 * Change processor that calls out to Genoa whenever it's triggered with by a
 * Tango push notification.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.change.ChangeProcessor}
 * @constructor
 */
drive.ds.sync.change.PushChangeProcessor = function(context) {
  goog.base(this, context);

  /** @private {!goog.events.EventHandler} */
  this.eventHandler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.eventHandler_);
};
goog.inherits(drive.ds.sync.change.PushChangeProcessor,
    drive.ds.sync.change.ChangeProcessor);


/** @private {!goog.debug.Logger} */
drive.ds.sync.change.PushChangeProcessor.logger_ =
    goog.debug.Logger.getLogger('drive.ds.sync.change.PushChangeProcessor');


/** @override */
drive.ds.sync.change.PushChangeProcessor.prototype.start = function() {
  goog.base(this, 'start');

  this.eventHandler_.listen(this.tangoClient_,
      drive.ds.sync.change.TangoChangelogEvent.TYPE,
      goog.bind(this.handleChangelogEvent_, this));
  this.eventHandler_.listen(this.tangoClient_,
      drive.ds.sync.change.TangoErrorEvent.TYPE,
      goog.bind(this.handleErrorEvent_, this));
};


/** @override */
drive.ds.sync.change.PushChangeProcessor.prototype.stop = function() {
  goog.base(this, 'stop');

  this.eventHandler_.unlisten(this.tangoClient_,
      drive.ds.sync.change.TangoChangelogEvent.TYPE,
      goog.bind(this.handleChangelogEvent_, this));
  this.eventHandler_.unlisten(this.tangoClient_,
      drive.ds.sync.change.TangoErrorEvent.TYPE,
      goog.bind(this.handleErrorEvent_, this));
};


/** @override */
drive.ds.sync.change.PushChangeProcessor.prototype.initialize = function() {
  // Append dom used by tango client for communications.
  // TODO(towong): Let client pass in target Dom to render this in?
  var client = goog.dom.createDom(goog.dom.TagName.DIV, {
    id: 'lcsclient',
    style: 'display: none'
  });
  var senderclient = goog.dom.createDom(goog.dom.TagName.DIV, {
    id: 'lcssenderclient',
    style: 'display: none'
  });
  goog.dom.getDocument().body.appendChild(client);
  goog.dom.getDocument().body.appendChild(senderclient);

  /**
   * The tango client.
   * @private {!drive.ds.sync.change.TangoClient}
   */
  this.tangoClient_ = new drive.ds.sync.change.TangoClient(
      this.getContext().getConfig().getGaiaSessionId());

  goog.base(this, 'initialize');
};


/**
 * Handles a change event from Tango.
 * @param {!drive.ds.sync.change.TangoChangelogEvent} e The tango change log
 *     event.
 * @private
 */
drive.ds.sync.change.PushChangeProcessor.prototype.handleChangelogEvent_ =
    function(e) {
  var changeId = e.getChangeId();
  if (changeId) {
    // ChangeId that Tango returns is the target change id + 1.
    this.setTargetChangeId(goog.math.Long.fromNumber(changeId - 1));
  }

  this.getChanges();
};


/**
 * Handles an error event from Tango.
 * @param {!drive.ds.sync.change.TangoErrorEvent} e The tango error event.
 * @private
 */
drive.ds.sync.change.PushChangeProcessor.prototype.handleErrorEvent_ =
    function(e) {
  drive.ds.sync.change.PushChangeProcessor.logger_.fine(e.getMessage());

  // Dispatch event to indicate error with push notifications.
  this.dispatchEvent(drive.ds.sync.change.ChangeProcessor.EventType.ERROR);
};

//javascript/apps/drive/dataservice/sync/storage/dumpelloutil.js
/**
 * @fileoverview Dumpello related utils.
 */

goog.provide('drive.ds.sync.storage.DumpelloUtil');

goog.require('drive.ds.Dumpello');


/**
 * Converts the given data into a dumpello json string.
 * @param {!Array.<!drive.ds.Item>} items The items to dump.
 * @param {!Array.<!drive.ds.Permission>} permissions The permissions to dump.
 * @param {!Array.<!drive.ds.DumpelloQuery>} queries The queries to dump.
 * @param {boolean} isPartial Whether this dump includes the full corpus.
 * @param {string} rootId The user's root id.
 * @param {!goog.math.Long} changeId The max change id of the items in the
 *     dumpello.
 * @return {string} Stringified dumpello.
 */
drive.ds.sync.storage.DumpelloUtil.toDumpelloJson =
    function(items, permissions, queries, isPartial, rootId, changeId) {
  var dumpello = new drive.ds.Dumpello();
  dumpello.setItemList(items);
  dumpello.setPermissionList(permissions);
  dumpello.setSupportedQueryList(queries);
  dumpello.setPartial(isPartial);
  dumpello.setRootId(rootId);
  dumpello.setChangeId(changeId.toNumber());

  return dumpello.serialize();
};

//javascript/apps/drive/dataservice/sync/storage/encrypteddumpelloupdater.js
goog.provide('drive.ds.sync.storage.EncryptedDumpelloUpdater');

goog.require('drive.ds.sync.storage.DumpelloUtil');
goog.require('goog.async.Deferred');



/**
 * Object responsible for updating the encrypted dumpello.
 * @param {!drive.ds.sync.Context} context The app context.
 * @constructor
 */
drive.ds.sync.storage.EncryptedDumpelloUpdater = function(context) {
  /** @private {!drive.ds.sync.Context} */
  this.context_ = context;

  /**
   * Count of changes since last encrypted dumpello update.
   * @private {number}
   */
  this.changes_ = 0;
};


/**
 * A threshold for the number of changes at which the encrypted dumpello needs
 * to be updated.
 * @private {number}
 */
drive.ds.sync.storage.EncryptedDumpelloUpdater.CHANGES_THRESHOLD_ = 200;


/**
 * Checks whether the encrypted dumpello updater needs a change based on the
 * number of changes so far.
 * @param {!drive.ds.sync.change.ChangeProcessor.ChangeEvent} changeEvent The
 *     change event.
 */
drive.ds.sync.storage.EncryptedDumpelloUpdater.prototype.checkAndUpdate =
    function(changeEvent) {
  if (this.context_.getEncryptedDumpello()) {
    this.changes_ += changeEvent.changes;
    if (this.changes_ >
        drive.ds.sync.storage.EncryptedDumpelloUpdater.CHANGES_THRESHOLD_) {
      this.update_(changeEvent.processedChangeId);
    }
  }
};


/**
 * Updates the encrypted dumpello with the latest dumpello.
 * @param {!goog.math.Long} processedId The last proccessed change id.
 * @private
 */
drive.ds.sync.storage.EncryptedDumpelloUpdater.prototype.update_ =
    function(processedId) {
  var deferred = this.context_.getCache().bulkExport();
  deferred.addCallback(
      goog.partial(this.handleExportSuccess_, processedId), this);
};


/**
 * Handles successful export from cache by writing the data to the encrypted
 * dumpello.
 * @param {!goog.math.Long} changeId The max change id of the items in the
 *     dumpello.
 * @param {!Array.<!drive.ds.Item>} items Items exported from the local cache.
 * @private
 */
drive.ds.sync.storage.EncryptedDumpelloUpdater.prototype.handleExportSuccess_ =
    function(changeId, items) {

  var permissions = this.context_.getCache().bulkExportPermissions();
  var isPartial = !this.context_.getQueryCache().hasFullCorpus();
  var queries = this.context_.getQueryCache().bulkExport();
  var rootId = this.context_.getMetadataStore().getRootId();

  var json = drive.ds.sync.storage.DumpelloUtil.toDumpelloJson(
      items, permissions, queries, isPartial, rootId, changeId);
  var deferred = this.put(json);
  deferred.addCallback(this.handlePutSuccess_, this);
};


/**
 * Writes given dumpello to the EncryptedDumpello.
 * @param {string} json The dumpello in json form.
 * @return {!goog.async.Deferred} A deferred object for this transaction.
 */
drive.ds.sync.storage.EncryptedDumpelloUpdater.prototype.put =
    function(json) {
  var config = this.context_.getConfig();
  return this.context_.getEncryptedDumpello() ?
      this.context_.getEncryptedDumpello().put(
          config.getGaiaId(), json, config.getIndexedDbKeys()[0]) :
      goog.async.Deferred.succeed();
};


/**
 * Handles successful write to the encrypted dumpello. Resets changes counter.
 * @private
 */
drive.ds.sync.storage.EncryptedDumpelloUpdater.prototype.handlePutSuccess_ =
    function() {
  this.changes_ = 0;
};

//javascript/apps/drive/dataservice/sync/change/remotechangemanager.js
goog.provide('drive.ds.sync.change.RemoteChangeManager');

goog.require('drive.ds.sync.SyncedConfig');
goog.require('drive.ds.sync.change.ChangeManager');
goog.require('drive.ds.sync.change.ChangeProcessor');
goog.require('drive.ds.sync.change.PollingChangeProcessor');
goog.require('drive.ds.sync.change.PushChangeProcessor');
goog.require('drive.ds.sync.storage.EncryptedDumpelloUpdater');
goog.require('goog.debug.Logger');
goog.require('goog.events.EventHandler');
goog.require('goog.structs.Queue');



/**
 * Change manager responsible for processing change logs from a remote source.
 * The change manager detects changes via either:
 * - Tango notifications and querying Genoa for changes, or
 * - Polling Genoa regularly for changes.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.change.ChangeManager}
 * @constructor
 */
drive.ds.sync.change.RemoteChangeManager = function(context) {
  goog.base(this, context);

  /** @private {number} The number of push notification errors. */
  this.errors_ = 0;

  /** @private {!goog.events.EventHandler} */
  this.eventHandler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.eventHandler_);

  /**
   * A queue used to decide which change processor to use for processing the
   * request.
   * @private {!goog.structs.Queue.<!drive.ds.sync.change.ChangeProcessor>}
   */
  this.processorQueue_ = new goog.structs.Queue();

  /** @private {!goog.debug.Logger} */
  this.logger_ =
      goog.debug.Logger.getLogger('drive.ds.sync.change.PushChangeProcessor');

  /** @private {!drive.ds.sync.storage.EncryptedDumpelloUpdater} */
  this.encryptedDumpelloUpdater_ =
      new drive.ds.sync.storage.EncryptedDumpelloUpdater(context);
};
goog.inherits(drive.ds.sync.change.RemoteChangeManager,
    drive.ds.sync.change.ChangeManager);


/**
 * The maximum number of errors before switching to another change processor.
 * @private {number}
 */
drive.ds.sync.change.RemoteChangeManager.MAX_ERRORS_ = 5;


/** @override */
drive.ds.sync.change.RemoteChangeManager.prototype.initialize = function() {
  // Enqueue the push change processor.
  var processor = null;
  if (this.getContext().getConfig().getChangeHandler() ==
      drive.ds.sync.SyncedConfig.ChangeHandler.TANGO) {
    processor = new drive.ds.sync.change.PushChangeProcessor(this.getContext());
    processor.initialize();
    this.processorQueue_.enqueue(processor);
  }

  // Enqueue the polling change processor.
  processor =
      new drive.ds.sync.change.PollingChangeProcessor(this.getContext());
  processor.initialize();
  this.processorQueue_.enqueue(processor);

  return goog.base(this, 'initialize');
};


/** @override */
drive.ds.sync.change.RemoteChangeManager.prototype.start = function() {
  // If IndexedDb or Dumpello is enabled and a last change id is available, we
  // use the MetadataStore change id. Otherwise we default to the Genoa change
  // ID.
  var config = this.getContext().getConfig();
  var lastChangeId = this.getContext().getMetadataStore().getLastChangeId();
  var processedChangeId =
      ((config.getUseDumpello() || config.getUseIndexedDb()) && lastChangeId ?
          lastChangeId : this.getLargestGenoaChangeId());

  // Dispatch event to indicate that this change manager has started processing
  // Genoa change log events.
  this.dispatchEvent(drive.ds.sync.change.ChangeManager.EventType.PROCESSING);

  this.startFrom_(/** @type {!goog.math.Long} */ (processedChangeId));
};


/**
 * Starts processing with the processor on the top of the queue from the given
 * id.
 * @param {!goog.math.Long} startId The id to start processing from.
 * @private
 */
drive.ds.sync.change.RemoteChangeManager.prototype.startFrom_ =
    function(startId) {
  // Activate the top processor on the queue.
  if (this.processorQueue_.getCount()) {
    var processor = /** @type {drive.ds.sync.change.ChangeProcessor} */
        (this.processorQueue_.peek());
    processor.setProcessedChangeId(startId);
    processor.start();

    this.eventHandler_.listen(processor,
        drive.ds.sync.change.ChangeProcessor.EventType.COMPLETE,
        goog.bind(this.handleProcessorSuccess_, this));
    this.eventHandler_.listen(processor,
        drive.ds.sync.change.ChangeProcessor.EventType.ERROR,
        goog.bind(this.handleProcessorError_, this));
  }
};


/**
 * Handles a change log processing complete event by notifying the encrypted
 * dumpello updater.
 * @param {!drive.ds.sync.change.ChangeProcessor.ChangeEvent} changeEvent The
 *     change event.
 * @private
 */
drive.ds.sync.change.RemoteChangeManager.prototype.handleProcessorSuccess_ =
    function(changeEvent) {
  this.encryptedDumpelloUpdater_.checkAndUpdate(changeEvent);
};


/**
 * Handles a change log processing failure. Once we exceed a specified number of
 * errors we switch to the next change processor.
 * @private
 */
drive.ds.sync.change.RemoteChangeManager.prototype.handleProcessorError_ =
    function() {
  this.errors_++;
  if (this.errors_ > drive.ds.sync.change.RemoteChangeManager.MAX_ERRORS_) {
    this.errors_ = 0;
    this.swapProcessors_();
  }
};


/**
 * Removes the top processor off the queue. Attempt to start processing with the
 * next change processor where the previous one left off.
 * TODO(towong): Improve swap algorithm, maybe do something priority based.
 *     Currently it just swaps processors in the order that they were
 *     registered.
 * TODO(towong): Potentially requeue failing processors at a later time for
 *     transient errors.
 * @private
 */
drive.ds.sync.change.RemoteChangeManager.prototype.swapProcessors_ =
    function() {
  this.logger_.fine('Swapping change processor');

  var processor = this.processorQueue_.dequeue();
  processor.stop();

  this.eventHandler_.unlisten(
      /** @type {drive.ds.sync.change.ChangeProcessor} */ (processor),
      drive.ds.sync.change.ChangeProcessor.EventType.ERROR,
      goog.bind(this.handleProcessorError_, this));

  this.startFrom_(processor.getProcessedChangeId());
};

//javascript/apps/drive/dataservice/sync/mutate/mutation.js
goog.provide('drive.ds.sync.mutate.Mutation');



/**
 * An abstract mutation object. This class should not be instantiated directly.
 * Implementors should specify how a mutation should be processed.
 * @param {!T} request The mutation request.
 * @param {?string} itemId The ID of the item to mutate.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!goog.async.Deferred} deferred The deferred object whose
 *     callback or errback function is called with a MutateItemResponse once a
 *     response is available.
 * @constructor
 * @template T
 */
drive.ds.sync.mutate.Mutation = function(request, itemId, context, deferred) {
  /** @private {!T} The mutation request. */
  this.request_ = request;

  /** @private {?string} The item id in the request, if any. */
  this.itemId_ = itemId;

  /** @private {!drive.ds.sync.Context} The app context. */
  this.context_ = context;

  /**
   * The deferred object whose callback or errback function is called with a
   * MutateItemResponse once a response is available.
   * @private {!goog.async.Deferred}
   */
  this.deferred_ = deferred;
};


/**
 * @return {!T} The mutation request.
 * @protected
 */
drive.ds.sync.mutate.Mutation.prototype.getRequest = function() {
  return this.request_;
};


/**
 * @return {?string} The ID of the mutated item, if any.  Does not exist for
 *     create item mutations.
 * @protected
 */
drive.ds.sync.mutate.Mutation.prototype.getItemId = function() {
  return this.itemId_;
};


/**
 * @return {!drive.ds.sync.Context} The app context.
 * @protected
 */
drive.ds.sync.mutate.Mutation.prototype.getContext = function() {
  return this.context_;
};


/**
 * @return {!goog.async.Deferred} The deferred object whose callback or
 *     errback function is called with a MutateItemResponse once a response is
 *     available.
 * @protected
 */
drive.ds.sync.mutate.Mutation.prototype.getDeferred = function() {
  return this.deferred_;
};


/**
 * Applies the mutation to Genoa.
 */
drive.ds.sync.mutate.Mutation.prototype.applyRemotely = goog.abstractMethod;

//javascript/apps/drive/dataservice/sync/mutate/copyitemmutation.js
goog.provide('drive.ds.sync.mutate.CopyItemMutation');

goog.require('drive.ds.Status');
goog.require('drive.ds.sync.api.Mutate');
goog.require('drive.ds.sync.mutate.Mutation');



/**
 * A copy item mutation.
 * @param {!drive.ds.CopyItemRequest} request The mutation request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!goog.async.Deferred} deferred The deferred object whose
 *     callback or errback function is called with a MutateItemResponse once a
 *     response is available.
 * @extends {drive.ds.sync.mutate.Mutation.<!drive.ds.CopyItemRequest>}
 * @constructor
 */
drive.ds.sync.mutate.CopyItemMutation = function(request, context, deferred) {
  goog.base(this, request, request.getId(), context, deferred);
};
goog.inherits(drive.ds.sync.mutate.CopyItemMutation,
    drive.ds.sync.mutate.Mutation);


/** @override */
drive.ds.sync.mutate.CopyItemMutation.prototype.applyRemotely = function() {
  drive.ds.sync.api.Mutate.copy(this.getRequest(),
      goog.bind(this.handleResponse_, this), this.getContext().getFields());
};


/**
 * Handles a response for a copy request.
 * @param {!Object} response The response from the drive api.
 * @private
 */
drive.ds.sync.mutate.CopyItemMutation.prototype.handleResponse_ =
    function(response) {
  var responseProto = this.getContext().getResponseParser().parseMutate(
      response, this.getItemId());
  if (responseProto.getStatus() == drive.ds.Status.SUCCESS) {
    var item = /** @type {!drive.ds.Item} */ (responseProto.getItem());
    this.getContext().getCache().put(item);
    this.getDeferred().callback(responseProto);
  } else {
    this.getDeferred().errback(responseProto);
  }
};

//javascript/apps/drive/dataservice/sync/mutate/createitemmutation.js
goog.provide('drive.ds.sync.mutate.CreateItemMutation');

goog.require('drive.ds.Status');
goog.require('drive.ds.sync.api.Mutate');
goog.require('drive.ds.sync.mutate.Mutation');



/**
 * A create item mutation.
 * @param {!drive.ds.CreateItemRequest} request The mutation request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!goog.async.Deferred} deferred The deferred object whose
 *     callback or errback function is called with a MutateItemResponse once a
 *     response is available.
 * @extends {drive.ds.sync.mutate.Mutation.<!drive.ds.CreateItemRequest>}
 * @constructor
 */
drive.ds.sync.mutate.CreateItemMutation = function(request, context, deferred) {
  goog.base(this, request, null, context, deferred);
};
goog.inherits(drive.ds.sync.mutate.CreateItemMutation,
    drive.ds.sync.mutate.Mutation);


/** @override */
drive.ds.sync.mutate.CreateItemMutation.prototype.applyRemotely = function() {
  drive.ds.sync.api.Mutate.create(this.getRequest(),
      goog.bind(this.handleResponse_, this), this.getContext().getFields());
};


/**
 * Handles a response for a create request.
 * @param {!Object} response The response from the drive api.
 * @private
 */
drive.ds.sync.mutate.CreateItemMutation.prototype.handleResponse_ =
    function(response) {
  var responseProto =
      this.getContext().getResponseParser().parseMutate(response, null);
  if (responseProto.getStatus() == drive.ds.Status.SUCCESS) {
    var item = /** @type {!drive.ds.Item} */ (responseProto.getItem());
    this.getContext().getCache().put(item);
    this.getDeferred().callback(responseProto);
  } else {
    this.getDeferred().errback(responseProto);
  }
};

//javascript/apps/drive/dataservice/sync/mutate/deleteitemmutation.js
goog.provide('drive.ds.sync.mutate.DeleteItemMutation');

goog.require('drive.ds.Status');
goog.require('drive.ds.sync.api.Mutate');
goog.require('drive.ds.sync.mutate.Mutation');



/**
 * A delete item mutation.
 * @param {!drive.ds.DeleteItemRequest} request The mutation request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!goog.async.Deferred} deferred  deferred The deferred object whose
 *     callback or errback function is called with a MutateItemResponse once a
 *     response is available.
 * @extends {drive.ds.sync.mutate.Mutation.<!drive.ds.DeleteItemRequest>}
 * @constructor
 */
drive.ds.sync.mutate.DeleteItemMutation = function(request, context, deferred) {
  goog.base(this, request, request.getId(), context, deferred);
};
goog.inherits(drive.ds.sync.mutate.DeleteItemMutation,
    drive.ds.sync.mutate.Mutation);


/** @override */
drive.ds.sync.mutate.DeleteItemMutation.prototype.applyRemotely = function() {
  drive.ds.sync.api.Mutate.deleteItem(this.getRequest(),
      goog.bind(this.handleResponse_, this));
};


/**
 * Handles a response for a delete request.
 * @param {!Object} response The response from the drive api.
 * @private
 */
drive.ds.sync.mutate.DeleteItemMutation.prototype.handleResponse_ =
    function(response) {
  var responseProto = this.getContext().getResponseParser().
      parseMutateEmptyOnSuccess(response, this.getItemId());
  if (responseProto.getStatus() == drive.ds.Status.SUCCESS) {
    this.getContext().getCache().remove(this.getRequest().getId());
    this.getDeferred().callback(responseProto);
  } else {
    this.getDeferred().errback(responseProto);
  }
};

//javascript/apps/drive/dataservice/sync/mutate/emptytrashmutation.js
goog.provide('drive.ds.sync.mutate.EmptyTrashMutation');

goog.require('drive.ds.ItemQueryRequest');
goog.require('drive.ds.MutateItemResponse');
goog.require('drive.ds.Status');
goog.require('drive.ds.sync.api.Mutate');
goog.require('drive.ds.sync.mutate.Mutation');



/**
 * A empty trash mutation.
 * @param {!drive.ds.EmptyTrashRequest} request The mutation request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!goog.async.Deferred} deferred  deferred The deferred object whose
 *     callback or errback function is called with a MutateItemResponse once a
 *     response is available.
 * @extends {drive.ds.sync.mutate.Mutation.<!drive.ds.EmptyTrashRequest>}
 * @constructor
 */
drive.ds.sync.mutate.EmptyTrashMutation = function(request, context, deferred) {
  goog.base(this, request, null, context, deferred);
};
goog.inherits(drive.ds.sync.mutate.EmptyTrashMutation,
    drive.ds.sync.mutate.Mutation);


/** @override */
drive.ds.sync.mutate.EmptyTrashMutation.prototype.applyRemotely = function() {
  drive.ds.sync.api.Mutate.emptyTrash(this.getRequest(),
      goog.bind(this.handleResponse_, this));
};


/**
 * Handles a response for an empty trash request.
 * @param {!Object} response The response from the drive api.
 * @private
 */
drive.ds.sync.mutate.EmptyTrashMutation.prototype.handleResponse_ =
    function(response) {
  var responseProto = this.getContext().getResponseParser().
      parseMutateEmptyOnSuccess(response, null);
  if (responseProto.getStatus() == drive.ds.Status.SUCCESS) {
    var request = new drive.ds.ItemQueryRequest();
    request.setTrashed(true);

    var deferred = this.getContext().getCache().query(request, -1);
    deferred.addCallbacks(goog.partial(this.doEmptyTrash_, responseProto),
        this.handleError_,
        this);
  } else {
    this.getDeferred().errback(responseProto);
  }
};


/**
 * Handles removing the deleted items from the cache.
 * @param {!drive.ds.MutateItemResponse} responseProto The response proto
 *     from the drive api.
 * @param {!drive.ds.ItemQueryResponse} itemResponse The items to delete.
 * @private
 */
drive.ds.sync.mutate.EmptyTrashMutation.prototype.doEmptyTrash_ =
    function(responseProto, itemResponse) {
  var items = itemResponse.getItemList();
  for (var i = 0; i < items.length; i++) {
    this.getContext().getCache().remove(items[i].getId());
  }
  this.getDeferred().callback(responseProto);
};


/**
 * Fires the deferred errback with the given error message.
 * @param {string} msg The error message to use.
 * @private
 */
drive.ds.sync.mutate.EmptyTrashMutation.prototype.handleError_ =
    function(msg) {
  var response = new drive.ds.MutateItemResponse();
  response.setStatus(drive.ds.Status.GENERIC_ERROR);
  response.setErrorMessage(msg);

  this.getDeferred().errback(response);
};

//javascript/apps/drive/dataservice/sync/mutate/updateitemmutation.js
goog.provide('drive.ds.sync.mutate.UpdateItemMutation');

goog.require('drive.ds.Status');
goog.require('drive.ds.sync.api.Mutate');
goog.require('drive.ds.sync.mutate.Mutation');



/**
 * An update item mutation.
 * @param {!drive.ds.UpdateItemRequest} request The mutation request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!goog.async.Deferred} deferred  deferred The deferred object whose
 *     callback or errback function is called with a MutateItemResponse once a
 *     response is available.
 * @extends {drive.ds.sync.mutate.Mutation.<!drive.ds.UpdateItemRequest>}
 * @constructor
 */
drive.ds.sync.mutate.UpdateItemMutation = function(request, context, deferred) {
  goog.base(this, request, request.getId(), context, deferred);
};
goog.inherits(drive.ds.sync.mutate.UpdateItemMutation,
    drive.ds.sync.mutate.Mutation);


/** @override */
drive.ds.sync.mutate.UpdateItemMutation.prototype.applyRemotely = function() {
  drive.ds.sync.api.Mutate.update(this.getRequest(),
      goog.bind(this.handleResponse_, this), this.getContext().getFields());
};


/**
 * Handles a response for a update request.
 * @param {!Object} response The response from the drive api.
 * @private
 */
drive.ds.sync.mutate.UpdateItemMutation.prototype.handleResponse_ =
    function(response) {
  var responseProto = this.getContext().getResponseParser().parseMutate(
      response, this.getItemId());
  if (responseProto.getStatus() == drive.ds.Status.SUCCESS) {
    var item = /** @type {!drive.ds.Item} */ (responseProto.getItem());
    this.getContext().getCache().put(item);
    this.getDeferred().callback(responseProto);
  } else {
    this.getDeferred().errback(responseProto);
  }
};

//javascript/apps/drive/dataservice/sync/mutate/reparentitemmutation.js
goog.provide('drive.ds.sync.mutate.ReparentItemMutation');

goog.require('drive.ds.MutateItemResponse');
goog.require('drive.ds.UpdateItemRequest');
goog.require('drive.ds.sync.mutate.Mutation');
goog.require('drive.ds.sync.mutate.UpdateItemMutation');



/**
 * A reparent item mutation.
 * @param {!drive.ds.ReparentItemRequest} request The mutation request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!goog.async.Deferred} deferred The deferred object whose
 *     callback or errback function is called with a MutateItemResponse once a
 *     response is available.
 * @extends {drive.ds.sync.mutate.Mutation.<!drive.ds.ReparentItemRequest>}
 * @constructor
 */
drive.ds.sync.mutate.ReparentItemMutation = function(
    request, context, deferred) {
  goog.base(this, request, request.getId(), context, deferred);
};
goog.inherits(drive.ds.sync.mutate.ReparentItemMutation,
    drive.ds.sync.mutate.Mutation);


/** @override */
drive.ds.sync.mutate.ReparentItemMutation.prototype.applyRemotely = function() {
  // Reparent defers to the UpdateItemRequest with add/remove parent parameters.
  var request = new drive.ds.UpdateItemRequest();
  request.setId(this.getRequest().getId());
  request.setParentsToAddList(this.getRequest().getParentsToAddList());
  request.setParentsToRemoveList(this.getRequest().getParentsToRemoveList());
  var mutation = new drive.ds.sync.mutate.UpdateItemMutation(
      request, this.getContext(), this.getDeferred());
  mutation.applyRemotely();
};

//javascript/apps/drive/dataservice/sync/mutate/unsupportedmutation.js
goog.provide('drive.ds.sync.mutate.UnsupportedMutation');

goog.require('drive.ds.MutateItemResponse');
goog.require('drive.ds.Status');
goog.require('drive.ds.sync.mutate.Mutation');



/**
 * An unsupported mutation.
 * @param {!drive.ds.sync.mutate.MutationRequest} request The mutation request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!goog.async.Deferred} deferred  deferred The deferred object whose
 *     callback or errback function is called with a MutateItemResponse once a
 *     response is available.
 * @extends
 *     {drive.ds.sync.mutate.Mutation.<!drive.ds.sync.mutate.MutationRequest>}
 * @constructor
 */
drive.ds.sync.mutate.UnsupportedMutation = function(
    request, context, deferred) {
  goog.base(this, request, null, context, deferred);
};
goog.inherits(drive.ds.sync.mutate.UnsupportedMutation,
    drive.ds.sync.mutate.Mutation);


/** @override */
drive.ds.sync.mutate.UnsupportedMutation.prototype.applyRemotely = function() {
  var responseProto = new drive.ds.MutateItemResponse();
  responseProto.setStatus(drive.ds.Status.UNSUPPORTED);
  this.getDeferred().callback(responseProto);
};

//javascript/apps/drive/dataservice/sync/mutate/updaterevisionmutation.js
goog.provide('drive.ds.sync.mutate.UpdateRevisionMutation');

goog.require('drive.ds.Status');
goog.require('drive.ds.sync.api.Mutate');
goog.require('drive.ds.sync.mutate.Mutation');



/**
 * An update revision mutation.
 * @param {!drive.ds.UpdateRevisionRequest} request The mutation request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!goog.async.Deferred.<!drive.ds.MutateItemResponse>} deferred The
 *     deferred object whose callback or errback function is called with a
 *     MutateItemResponse once a response is available.
 * @extends {drive.ds.sync.mutate.Mutation.<!drive.ds.UpdateRevisionRequest>}
 * @constructor
 */
drive.ds.sync.mutate.UpdateRevisionMutation =
    function(request, context, deferred) {
  goog.base(this, request, request.getItemId(), context, deferred);
};
goog.inherits(drive.ds.sync.mutate.UpdateRevisionMutation,
    drive.ds.sync.mutate.Mutation);


/** @override */
drive.ds.sync.mutate.UpdateRevisionMutation.prototype.applyRemotely =
    function() {
  drive.ds.sync.api.Mutate.updateRevision(this.getRequest(),
      goog.bind(this.handleResponse_, this));
};


/**
 * Handles a response for an update revision request.
 * @param {!Object} response The response from the drive api.
 * @private
 */
drive.ds.sync.mutate.UpdateRevisionMutation.prototype.handleResponse_ =
    function(response) {
  var responseProto = this.getContext().getResponseParser().parseMutate(
      response, this.getItemId());
  if (responseProto.getStatus() == drive.ds.Status.SUCCESS) {
    this.getDeferred().callback(responseProto);
  } else {
    this.getDeferred().errback(responseProto);
  }
};

//javascript/apps/drive/dataservice/sync/mutate/mutationfactory.js
goog.provide('drive.ds.sync.mutate.MutationFactory');

goog.require('drive.ds.CopyItemRequest');
goog.require('drive.ds.CreateItemRequest');
goog.require('drive.ds.DeleteItemRequest');
goog.require('drive.ds.EmptyTrashRequest');
goog.require('drive.ds.ReparentItemRequest');
goog.require('drive.ds.UpdateItemRequest');
goog.require('drive.ds.UpdateRevisionRequest');
goog.require('drive.ds.sync.mutate.CopyItemMutation');
goog.require('drive.ds.sync.mutate.CreateItemMutation');
goog.require('drive.ds.sync.mutate.DeleteItemMutation');
goog.require('drive.ds.sync.mutate.EmptyTrashMutation');
goog.require('drive.ds.sync.mutate.ReparentItemMutation');
goog.require('drive.ds.sync.mutate.UnsupportedMutation');
goog.require('drive.ds.sync.mutate.UpdateItemMutation');
goog.require('drive.ds.sync.mutate.UpdateRevisionMutation');



/**
 * A factory for creating a new mutation object given a particular mutation
 * request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @constructor
 */
drive.ds.sync.mutate.MutationFactory = function(context) {
  /** @private {!drive.ds.sync.Context} The app context. */
  this.context_ = context;
};


/**
 * Creates the corresponding mutation object for the given request.
 * @param {!drive.ds.sync.mutate.MutationRequest} request The mutation request.
 * @param {!goog.async.Deferred} deferred The deferred object whose callback or
 *     errback function is called with a MutateItemResponse once a response is
 *     available.
 * @return {!drive.ds.sync.mutate.Mutation} The mutation object.
 */
drive.ds.sync.mutate.MutationFactory.prototype.create = function(
    request, deferred) {
  if (request instanceof drive.ds.CopyItemRequest) {
    return new drive.ds.sync.mutate.CopyItemMutation(
        request, this.context_, deferred);
  } else if (request instanceof drive.ds.CreateItemRequest) {
    return new drive.ds.sync.mutate.CreateItemMutation(
        request, this.context_, deferred);
  } else if (request instanceof drive.ds.DeleteItemRequest) {
    return new drive.ds.sync.mutate.DeleteItemMutation(
        request, this.context_, deferred);
  } else if (request instanceof drive.ds.EmptyTrashRequest) {
    return new drive.ds.sync.mutate.EmptyTrashMutation(
        request, this.context_, deferred);
  } else if (request instanceof drive.ds.ReparentItemRequest) {
    return new drive.ds.sync.mutate.ReparentItemMutation(
        request, this.context_, deferred);
  } else if (request instanceof drive.ds.UpdateItemRequest) {
    return new drive.ds.sync.mutate.UpdateItemMutation(
        request, this.context_, deferred);
  } else if (request instanceof drive.ds.UpdateRevisionRequest) {
    return new drive.ds.sync.mutate.UpdateRevisionMutation(
        request, this.context_, deferred);
  } else {
    return new drive.ds.sync.mutate.UnsupportedMutation(
        request, this.context_, deferred);
  }
};

//javascript/apps/drive/dataservice/sync/mutate/mutationmanager.js
goog.provide('drive.ds.sync.mutate.MutationManager');

goog.require('drive.ds.sync.CommandManager');
goog.require('drive.ds.sync.mutate.MutationFactory');



/**
 * A mutation manager responsible for maintaining a queue of pending changes
 * that need to be applied.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.CommandManager.<drive.ds.sync.mutate.MutationRequest>}
 * @constructor
 */
drive.ds.sync.mutate.MutationManager = function(context) {
  goog.base(this);

  /** @private {!drive.ds.sync.mutate.MutationFactory} The mutation factory. */
  this.mutationFactory_ = new drive.ds.sync.mutate.MutationFactory(context);
};
goog.inherits(drive.ds.sync.mutate.MutationManager,
    drive.ds.sync.CommandManager);


/** @override */
drive.ds.sync.mutate.MutationManager.prototype.processCommand =
    function(commandWrapper) {
  // Processes the given mutation.
  var mutateRequest = commandWrapper.getCommand();
  var deferred = commandWrapper.getDeferred();
  var mutation = this.mutationFactory_.create(mutateRequest, deferred);
  mutation.applyRemotely();
};

//javascript/apps/drive/dataservice/sync/mutate/mutationrequest.js
goog.provide('drive.ds.sync.mutate.MutationRequest');


/**
 * A type to encapsulate the various types of supported mutations.
 * @typedef {drive.ds.CreateItemRequest|
 *     drive.ds.CopyItemRequest|
 *     drive.ds.DeleteItemRequest|
 *     drive.ds.EmptyTrashRequest|
 *     drive.ds.ReparentItemRequest|
 *     drive.ds.UpdateItemRequest|
 *     drive.ds.UpdateRevisionRequest}
 */
drive.ds.sync.mutate.MutationRequest;

//javascript/apps/drive/dataservice/sync/query/querymanager.js
goog.provide('drive.ds.sync.query.QueryManager');

goog.require('drive.ds.sync.query.QueryRunner');
goog.require('goog.structs.Map');



/**
 * Query manager responsible for mapping a item query requests to a particular
 * query runner.
 * @param {!drive.ds.sync.Context} context The app context.
 * @constructor
 */
drive.ds.sync.query.QueryManager = function(context) {
  /**
   * The app context.
   * @private {!drive.ds.sync.Context}
   */
  this.context_ = context;

  /**
   * The map of query requests to query runners.
   * @private {!goog.structs.Map.<!drive.ds.ItemQueryRequest,
   *     !drive.ds.sync.query.QueryRunner>}
   */
  this.runnerMap_ = new goog.structs.Map();
};


/**
 * If necessary, gets a query runner from the query manager.
 * If one already exists for the given request, that runner is returned.
 * Otherwise, a new one is created.
 * We return null if dumpello is enabled and the query is supported by the
 * cache, since the query is fully satisfiable without needing Genoa.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @return {drive.ds.sync.query.QueryRunner} The query runner.
 */
drive.ds.sync.query.QueryManager.prototype.getQueryRunner = function(request) {
  if (this.context_.getConfig().getUseDumpello() &&
      this.context_.getInitViaDumpello() &&
      this.context_.getCache().isRequestSupported(request) &&
      this.context_.getQueryCache().containsQuery(request) &&
      this.context_.getQueryCache().getQueryLimit(request) == null) {
    return null;
  }

  // TODO(towong): Similar requests should also get collapsed into the same
  // query runner. Example we can ignore sort since Genoa doesn't consider it.
  if (!this.runnerMap_.containsKey(request)) {
    this.runnerMap_.set(request,
        new drive.ds.sync.query.QueryRunner(request, this.context_));
  }
  return /** @type {!drive.ds.sync.query.QueryRunner} */ (
      this.runnerMap_.get(request));
};

//javascript/closure/i18n/datetimesymbols.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Date/time formatting symbols for all locales.
 *
 * This file is autogenerated by script.  See
 * http://go/generate_datetime_constants.py using --for_closure
 * File generated from CLDR ver. 23
 *
 * To reduce the file size (which may cause issues in some JS
 * developing environments), this file will only contain locales
 * that are usually supported by google products. It is a super
 * set of 40 languages. Rest of the data can be found in another file
 * named "datetimesymbolsext.js", which will be generated at the same
 * time as this file.
 * Before checkin, this file could have been manually edited. This is
 * to incorporate changes before we could correct CLDR. All manual
 * modification must be documented in this section, and should be
 * removed after those changes land to CLDR.
 *
 * May 9, 2013 - Manually added dot for italian era ('a.D.' vs. 'd.C')
 * cldr bug #6062
 */

goog.provide('goog.i18n.DateTimeSymbols');
goog.provide('goog.i18n.DateTimeSymbols_af');
goog.provide('goog.i18n.DateTimeSymbols_am');
goog.provide('goog.i18n.DateTimeSymbols_ar');
goog.provide('goog.i18n.DateTimeSymbols_bg');
goog.provide('goog.i18n.DateTimeSymbols_bn');
goog.provide('goog.i18n.DateTimeSymbols_br');
goog.provide('goog.i18n.DateTimeSymbols_ca');
goog.provide('goog.i18n.DateTimeSymbols_chr');
goog.provide('goog.i18n.DateTimeSymbols_cs');
goog.provide('goog.i18n.DateTimeSymbols_cy');
goog.provide('goog.i18n.DateTimeSymbols_da');
goog.provide('goog.i18n.DateTimeSymbols_de');
goog.provide('goog.i18n.DateTimeSymbols_de_AT');
goog.provide('goog.i18n.DateTimeSymbols_de_CH');
goog.provide('goog.i18n.DateTimeSymbols_el');
goog.provide('goog.i18n.DateTimeSymbols_en');
goog.provide('goog.i18n.DateTimeSymbols_en_AU');
goog.provide('goog.i18n.DateTimeSymbols_en_GB');
goog.provide('goog.i18n.DateTimeSymbols_en_IE');
goog.provide('goog.i18n.DateTimeSymbols_en_IN');
goog.provide('goog.i18n.DateTimeSymbols_en_ISO');
goog.provide('goog.i18n.DateTimeSymbols_en_SG');
goog.provide('goog.i18n.DateTimeSymbols_en_US');
goog.provide('goog.i18n.DateTimeSymbols_en_ZA');
goog.provide('goog.i18n.DateTimeSymbols_es');
goog.provide('goog.i18n.DateTimeSymbols_es_419');
goog.provide('goog.i18n.DateTimeSymbols_es_ES');
goog.provide('goog.i18n.DateTimeSymbols_et');
goog.provide('goog.i18n.DateTimeSymbols_eu');
goog.provide('goog.i18n.DateTimeSymbols_fa');
goog.provide('goog.i18n.DateTimeSymbols_fi');
goog.provide('goog.i18n.DateTimeSymbols_fil');
goog.provide('goog.i18n.DateTimeSymbols_fr');
goog.provide('goog.i18n.DateTimeSymbols_fr_CA');
goog.provide('goog.i18n.DateTimeSymbols_gl');
goog.provide('goog.i18n.DateTimeSymbols_gsw');
goog.provide('goog.i18n.DateTimeSymbols_gu');
goog.provide('goog.i18n.DateTimeSymbols_haw');
goog.provide('goog.i18n.DateTimeSymbols_he');
goog.provide('goog.i18n.DateTimeSymbols_hi');
goog.provide('goog.i18n.DateTimeSymbols_hr');
goog.provide('goog.i18n.DateTimeSymbols_hu');
goog.provide('goog.i18n.DateTimeSymbols_id');
goog.provide('goog.i18n.DateTimeSymbols_in');
goog.provide('goog.i18n.DateTimeSymbols_is');
goog.provide('goog.i18n.DateTimeSymbols_it');
goog.provide('goog.i18n.DateTimeSymbols_iw');
goog.provide('goog.i18n.DateTimeSymbols_ja');
goog.provide('goog.i18n.DateTimeSymbols_kn');
goog.provide('goog.i18n.DateTimeSymbols_ko');
goog.provide('goog.i18n.DateTimeSymbols_ln');
goog.provide('goog.i18n.DateTimeSymbols_lt');
goog.provide('goog.i18n.DateTimeSymbols_lv');
goog.provide('goog.i18n.DateTimeSymbols_ml');
goog.provide('goog.i18n.DateTimeSymbols_mr');
goog.provide('goog.i18n.DateTimeSymbols_ms');
goog.provide('goog.i18n.DateTimeSymbols_mt');
goog.provide('goog.i18n.DateTimeSymbols_nb');
goog.provide('goog.i18n.DateTimeSymbols_nl');
goog.provide('goog.i18n.DateTimeSymbols_no');
goog.provide('goog.i18n.DateTimeSymbols_or');
goog.provide('goog.i18n.DateTimeSymbols_pl');
goog.provide('goog.i18n.DateTimeSymbols_pt');
goog.provide('goog.i18n.DateTimeSymbols_pt_BR');
goog.provide('goog.i18n.DateTimeSymbols_pt_PT');
goog.provide('goog.i18n.DateTimeSymbols_ro');
goog.provide('goog.i18n.DateTimeSymbols_ru');
goog.provide('goog.i18n.DateTimeSymbols_sk');
goog.provide('goog.i18n.DateTimeSymbols_sl');
goog.provide('goog.i18n.DateTimeSymbols_sq');
goog.provide('goog.i18n.DateTimeSymbols_sr');
goog.provide('goog.i18n.DateTimeSymbols_sv');
goog.provide('goog.i18n.DateTimeSymbols_sw');
goog.provide('goog.i18n.DateTimeSymbols_ta');
goog.provide('goog.i18n.DateTimeSymbols_te');
goog.provide('goog.i18n.DateTimeSymbols_th');
goog.provide('goog.i18n.DateTimeSymbols_tl');
goog.provide('goog.i18n.DateTimeSymbols_tr');
goog.provide('goog.i18n.DateTimeSymbols_uk');
goog.provide('goog.i18n.DateTimeSymbols_ur');
goog.provide('goog.i18n.DateTimeSymbols_vi');
goog.provide('goog.i18n.DateTimeSymbols_zh');
goog.provide('goog.i18n.DateTimeSymbols_zh_CN');
goog.provide('goog.i18n.DateTimeSymbols_zh_HK');
goog.provide('goog.i18n.DateTimeSymbols_zh_TW');
goog.provide('goog.i18n.DateTimeSymbols_zu');


/**
 * Date/time formatting symbols for locale en_ISO.
 */
goog.i18n.DateTimeSymbols_en_ISO = {
  ERAS: ['BC', 'AD'],
  ERANAMES: ['Before Christ', 'Anno Domini'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
    'August', 'September', 'October', 'November', 'December'],
  STANDALONEMONTHS: ['January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
    'Oct', 'Nov', 'Dec'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  WEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
    'Saturday'],
  STANDALONEWEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
    'Friday', 'Saturday'],
  SHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  STANDALONESHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, y MMMM dd', 'y MMMM d', 'y MMM d', 'yyyy-MM-dd'],
  TIMEFORMATS: ['HH:mm:ss v', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} \'at\' {0}', '{1} \'at\' {0}',
    '{1}, {0}', '{1}, {0}'],
  AVAILABLEFORMATS: {'Md': 'M/d', 'MMMMd': 'MMMM d', 'MMMd': 'MMM d'},
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale af.
 */
goog.i18n.DateTimeSymbols_af = {
  ERAS: ['v.C.', 'n.C.'],
  ERANAMES: ['voor Christus', 'na Christus'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Januarie', 'Februarie', 'Maart', 'April', 'Mei', 'Junie', 'Julie',
    'Augustus', 'September', 'Oktober', 'November', 'Desember'],
  STANDALONEMONTHS: ['Januarie', 'Februarie', 'Maart', 'April', 'Mei', 'Junie',
    'Julie', 'Augustus', 'September', 'Oktober', 'November', 'Desember'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'Mei', 'Jun', 'Jul', 'Aug', 'Sep',
    'Okt', 'Nov', 'Des'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'Mei', 'Jun', 'Jul',
    'Aug', 'Sep', 'Okt', 'Nov', 'Des'],
  WEEKDAYS: ['Sondag', 'Maandag', 'Dinsdag', 'Woensdag', 'Donderdag', 'Vrydag',
    'Saterdag'],
  STANDALONEWEEKDAYS: ['Sondag', 'Maandag', 'Dinsdag', 'Woensdag', 'Donderdag',
    'Vrydag', 'Saterdag'],
  SHORTWEEKDAYS: ['So', 'Ma', 'Di', 'Wo', 'Do', 'Vr', 'Sa'],
  STANDALONESHORTWEEKDAYS: ['So', 'Ma', 'Di', 'Wo', 'Do', 'Vr', 'Sa'],
  NARROWWEEKDAYS: ['S', 'M', 'D', 'W', 'D', 'V', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'D', 'W', 'D', 'V', 'S'],
  SHORTQUARTERS: ['K1', 'K2', 'K3', 'K4'],
  QUARTERS: ['1ste kwartaal', '2de kwartaal', '3de kwartaal', '4de kwartaal'],
  AMPMS: ['vm.', 'nm.'],
  DATEFORMATS: ['EEEE dd MMMM y', 'dd MMMM y', 'dd MMM y', 'y-MM-dd'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale am.
 */
goog.i18n.DateTimeSymbols_am = {
  ERAS: ['���/���', '���/���'],
  ERANAMES: ['��������� ���������', '��������� ������������'],
  NARROWMONTHS: ['���', '���', '���', '���', '���', '���', '���', '���', '���',
    '���', '���', '���'],
  STANDALONENARROWMONTHS: ['���', '���', '���', '���', '���', '���', '���',
    '���', '���', '���', '���', '���'],
  MONTHS: ['���������������', '���������������', '���������', '������������',
    '������', '������', '���������', '������������', '������������������',
    '������������������', '���������������', '���������������'],
  STANDALONEMONTHS: ['���������������', '���������������', '���������',
    '������������', '������', '������', '���������', '������������',
    '������������������', '���������������', '���������������',
    '���������������'],
  SHORTMONTHS: ['���������', '���������', '���������', '���������', '������',
    '������', '���������', '���������', '���������', '���������', '���������',
    '���������'],
  STANDALONESHORTMONTHS: ['���������', '���������', '���������', '���������',
    '������', '������', '���������', '���������', '���������', '���������',
    '���������', '���������'],
  WEEKDAYS: ['���������', '������', '������������', '���������', '���������',
    '���������', '���������'],
  STANDALONEWEEKDAYS: ['���������', '������', '������������', '���������',
    '���������', '���������', '���������'],
  SHORTWEEKDAYS: ['���������', '������', '���������', '���������', '���������',
    '���������', '���������'],
  STANDALONESHORTWEEKDAYS: ['���������', '������', '���������', '���������',
    '���������', '���������', '���������'],
  NARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  STANDALONENARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  SHORTQUARTERS: ['������1', '������2', '������3', '������4'],
  QUARTERS: ['1������ ������', '��������������� ������', '3������ ������',
    '4������ ������'],
  AMPMS: ['���������', '������������'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'd MMM y', 'dd/MM/y'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale ar.
 */
goog.i18n.DateTimeSymbols_ar = {
  ZERODIGIT: 0x0660,
  ERAS: ['��.��', '��'],
  ERANAMES: ['������ ��������������', '������������'],
  NARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��'],
  STANDALONENARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��', '��'],
  MONTHS: ['����������', '������������', '��������', '����������', '��������',
    '����������', '����������', '����������', '������������', '������������',
    '������������', '������������'],
  STANDALONEMONTHS: ['����������', '������������', '��������', '����������',
    '��������', '����������', '����������', '����������', '������������',
    '������������', '������������', '������������'],
  SHORTMONTHS: ['����������', '������������', '��������', '����������',
    '��������', '����������', '����������', '����������', '������������',
    '������������', '������������', '������������'],
  STANDALONESHORTMONTHS: ['����������', '������������', '��������',
    '����������', '��������', '����������', '����������', '����������',
    '������������', '������������', '������������', '������������'],
  WEEKDAYS: ['����������', '��������������', '����������������',
    '����������������', '������������', '������������', '����������'],
  STANDALONEWEEKDAYS: ['����������', '��������������', '����������������',
    '����������������', '������������', '������������', '����������'],
  SHORTWEEKDAYS: ['����������', '��������������', '����������������',
    '����������������', '������������', '������������', '����������'],
  STANDALONESHORTWEEKDAYS: ['����������', '��������������', '����������������',
    '����������������', '������������', '������������', '����������'],
  NARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  STANDALONENARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  SHORTQUARTERS: ['���������� ����������', '���������� ������������',
    '���������� ������������', '���������� ������������'],
  QUARTERS: ['���������� ����������', '���������� ������������',
    '���������� ������������', '���������� ������������'],
  AMPMS: ['��', '��'],
  DATEFORMATS: ['EEEE�� d MMMM�� y', 'd MMMM�� y', 'dd���/MM���/y',
    'd���/M���/y'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 5,
  WEEKENDRANGE: [4, 5],
  FIRSTWEEKCUTOFFDAY: 4
};


/**
 * Date/time formatting symbols for locale bg.
 */
goog.i18n.DateTimeSymbols_bg = {
  ERAS: ['����. ��. ��.', '���� ��. ��.'],
  ERANAMES: ['����.����.', '����.����.'],
  NARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��'],
  STANDALONENARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��', '��'],
  MONTHS: ['������������', '����������������', '��������', '����������',
    '������', '������', '������', '������������', '������������������',
    '����������������', '��������������', '����������������'],
  STANDALONEMONTHS: ['������������', '����������������', '��������',
    '����������', '������', '������', '������', '������������',
    '������������������', '����������������', '��������������',
    '����������������'],
  SHORTMONTHS: ['����.', '��������.', '��������', '������.', '������', '������',
    '������', '������.', '��������.', '������.', '��������.', '������.'],
  STANDALONESHORTMONTHS: ['����.', '��������.', '��������', '������.', '������',
    '������', '������', '������.', '��������.', '������.', '��������.',
    '������.'],
  WEEKDAYS: ['������������', '��������������������', '��������������',
    '����������', '������������������', '����������', '������������'],
  STANDALONEWEEKDAYS: ['������������', '��������������������', '��������������',
    '����������', '������������������', '����������', '������������'],
  SHORTWEEKDAYS: ['����', '����', '����', '����', '����', '����', '����'],
  STANDALONESHORTWEEKDAYS: ['����', '����', '����', '����', '����', '����',
    '����'],
  NARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  STANDALONENARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  SHORTQUARTERS: ['I ��������.', 'II ��������.', 'III ��������.',
    'IV ��������.'],
  QUARTERS: ['1-���� ��������������������', '2-���� ��������������������',
    '3-���� ��������������������', '4-���� ��������������������'],
  AMPMS: ['����. ����.', '����. ����.'],
  DATEFORMATS: ['dd MMMM y, EEEE', 'dd MMMM y', 'dd.MM.y', 'dd.MM.yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1}, {0}', '{1}, {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale bn.
 */
goog.i18n.DateTimeSymbols_bn = {
  ZERODIGIT: 0x09E6,
  ERAS: ['������������������������������', '���������������������������'],
  ERANAMES: ['������������������������������', '���������������������������'],
  NARROWMONTHS: ['������', '������', '������', '���', '������', '���������',
    '������', '���', '������', '���', '���', '������'],
  STANDALONENARROWMONTHS: ['������', '������', '������', '���', '������',
    '���������', '������', '���', '������', '���', '���', '������'],
  MONTHS: ['���������������������������', '���������������������������������',
    '���������������', '������������������', '������', '���������',
    '���������������', '���������������', '������������������������������',
    '���������������������', '���������������������',
    '������������������������'],
  STANDALONEMONTHS: ['���������������������������',
    '���������������������������������', '���������������',
    '������������������', '������', '���������', '���������������',
    '���������������', '������������������������������',
    '���������������������', '���������������������',
    '������������������������'],
  SHORTMONTHS: ['���������������������������',
    '���������������������������������', '���������������',
    '������������������', '������', '���������', '���������������',
    '���������������', '������������������������������',
    '���������������������', '���������������������',
    '������������������������'],
  STANDALONESHORTMONTHS: ['���������������������������',
    '���������������������������������', '���������������',
    '������������������', '������', '���������', '���������������',
    '���������������', '������������������������������',
    '���������������������', '���������������������',
    '������������������������'],
  WEEKDAYS: ['������������������', '������������������',
    '������������������������', '������������������',
    '���������������������������������', '������������������������',
    '������������������'],
  STANDALONEWEEKDAYS: ['������������������', '������������������',
    '������������������������', '������������������',
    '���������������������������������', '������������������������',
    '������������������'],
  SHORTWEEKDAYS: ['���������', '���������', '���������������', '���������',
    '������������������������', '���������������', '���������'],
  STANDALONESHORTWEEKDAYS: ['���������', '���������', '���������������',
    '���������', '������������������������', '���������������', '���������'],
  NARROWWEEKDAYS: ['���', '������', '���', '������', '������', '������', '���'],
  STANDALONENARROWWEEKDAYS: ['���', '������', '���', '������', '������',
    '������', '���'],
  SHORTQUARTERS: ['��������������������������� ���',
    '��������������������������� ���', '��������������������������� ���',
    '��������������������������� ���'],
  QUARTERS: ['��������������� ���������������������������',
    '������������������������ ���������������������������',
    '������������������ ���������������������������',
    '������������������ ���������������������������'],
  AMPMS: ['am', 'pm'],
  DATEFORMATS: ['EEEE, d MMMM, y', 'd MMMM, y', 'd MMM, y', 'd/M/yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 4,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale br.
 */
goog.i18n.DateTimeSymbols_br = {
  ERAS: ['BCE', 'CE'],
  ERANAMES: ['BCE', 'CE'],
  NARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  STANDALONENARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
    '11', '12'],
  MONTHS: ['Genver', 'C��hwevrer', 'Meurzh', 'Ebrel', 'Mae', 'Mezheven',
    'Gouere', 'Eost', 'Gwengolo', 'Here', 'Du', 'Kerzu'],
  STANDALONEMONTHS: ['Genver', 'C��hwevrer', 'Meurzh', 'Ebrel', 'Mae',
    'Mezheven', 'Gouere', 'Eost', 'Gwengolo', 'Here', 'Du', 'Kerzu'],
  SHORTMONTHS: ['Gen', 'C��hwe', 'Meur', 'Ebr', 'Mae', 'Mezh', 'Goue', 'Eost',
    'Gwen', 'Here', 'Du', 'Ker'],
  STANDALONESHORTMONTHS: ['Gen', 'C��hwe', 'Meur', 'Ebr', 'Mae', 'Mezh', 'Goue',
    'Eost', 'Gwen', 'Here', 'Du', 'Ker'],
  WEEKDAYS: ['Sul', 'Lun', 'Meurzh', 'Merc��her', 'Yaou', 'Gwener', 'Sadorn'],
  STANDALONEWEEKDAYS: ['Sul', 'Lun', 'Meurzh', 'Merc��her', 'Yaou', 'Gwener',
    'Sadorn'],
  SHORTWEEKDAYS: ['sul', 'lun', 'meu.', 'mer.', 'yaou', 'gwe.', 'sad.'],
  STANDALONESHORTWEEKDAYS: ['sul', 'lun', 'meu.', 'mer.', 'yaou', 'gwe.',
    'sad.'],
  NARROWWEEKDAYS: ['su', 'lu', 'mz', 'mc', 'ya', 'gw', 'sa'],
  STANDALONENARROWWEEKDAYS: ['su', 'lu', 'mz', 'mc', 'ya', 'gw', 'sa'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['y MMMM d, EEEE', 'y MMMM d', 'y MMM d', 'y-MM-dd'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale ca.
 */
goog.i18n.DateTimeSymbols_ca = {
  ERAS: ['aC', 'dC'],
  ERANAMES: ['abans de Crist', 'despr��s de Crist'],
  NARROWMONTHS: ['G', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['g', 'f', 'm', 'a', 'm', 'j', 'j', 'a', 's', 'o',
    'n', 'd'],
  MONTHS: ['de gener', 'de febrer', 'de mar��', 'd���abril', 'de maig',
    'de juny', 'de juliol', 'd���agost', 'de setembre', 'd���octubre',
    'de novembre', 'de desembre'],
  STANDALONEMONTHS: ['gener', 'febrer', 'mar��', 'abril', 'maig', 'juny',
    'juliol', 'agost', 'setembre', 'octubre', 'novembre', 'desembre'],
  SHORTMONTHS: ['de gen.', 'de febr.', 'de mar��', 'd���abr.', 'de maig',
    'de juny', 'de jul.', 'd���ag.', 'de set.', 'd���oct.', 'de nov.',
    'de des.'],
  STANDALONESHORTMONTHS: ['gen.', 'febr.', 'mar��', 'abr.', 'maig', 'juny',
    'jul.', 'ag.', 'set.', 'oct.', 'nov.', 'des.'],
  WEEKDAYS: ['diumenge', 'dilluns', 'dimarts', 'dimecres', 'dijous',
    'divendres', 'dissabte'],
  STANDALONEWEEKDAYS: ['Diumenge', 'Dilluns', 'Dimarts', 'Dimecres', 'Dijous',
    'Divendres', 'Dissabte'],
  SHORTWEEKDAYS: ['dg.', 'dl.', 'dt.', 'dc.', 'dj.', 'dv.', 'ds.'],
  STANDALONESHORTWEEKDAYS: ['dg', 'dl', 'dt', 'dc', 'dj', 'dv', 'ds'],
  NARROWWEEKDAYS: ['dg', 'dl', 'dt', 'dc', 'dj', 'dv', 'ds'],
  STANDALONENARROWWEEKDAYS: ['dg', 'dl', 'dt', 'dc', 'dj', 'dv', 'ds'],
  SHORTQUARTERS: ['1T', '2T', '3T', '4T'],
  QUARTERS: ['1r trimestre', '2n trimestre', '3r trimestre', '4t trimestre'],
  AMPMS: ['a.m.', 'p.m.'],
  DATEFORMATS: ['EEEE d MMMM \'de\' y', 'd MMMM \'de\' y', 'dd/MM/y',
    'dd/MM/yy'],
  TIMEFORMATS: ['H.mm.ss zzzz', 'H.mm.ss z', 'H.mm.ss', 'H.mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale chr.
 */
goog.i18n.DateTimeSymbols_chr = {
  ERAS: ['������������', '������������'],
  ERANAMES: ['��� ������ ������������������',
    '��������������������������� ������������������ ��������� ���������������������'],
  NARROWMONTHS: ['���', '���', '���', '���', '���', '���', '���', '���', '���',
    '���', '���', '���'],
  STANDALONENARROWMONTHS: ['���', '���', '���', '���', '���', '���', '���',
    '���', '���', '���', '���', '���'],
  MONTHS: ['���������������', '���������', '���������', '���������',
    '���������������', '������������', '������������', '���������',
    '������������', '������������', '������������', '������������'],
  STANDALONEMONTHS: ['���������������', '���������', '���������', '���������',
    '���������������', '������������', '������������', '���������',
    '������������', '������������', '������������', '������������'],
  SHORTMONTHS: ['������', '������', '������', '������', '������', '������',
    '������', '������', '������', '������', '������', '������'],
  STANDALONESHORTMONTHS: ['������', '������', '������', '������', '������',
    '������', '������', '������', '������', '������', '������', '������'],
  WEEKDAYS: ['���������������������', '���������������������',
    '���������������', '���������������', '���������������',
    '������������������', '���������������������'],
  STANDALONEWEEKDAYS: ['���������������������', '���������������������',
    '���������������', '���������������', '���������������',
    '������������������', '���������������������'],
  SHORTWEEKDAYS: ['���������', '���������', '���������', '���������',
    '���������', '���������', '���������'],
  STANDALONESHORTWEEKDAYS: ['���������', '���������', '���������', '���������',
    '���������', '���������', '���������'],
  NARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  STANDALONENARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  AMPMS: ['���������', '������������������'],
  DATEFORMATS: ['EEEE, MMMM d, y', 'MMMM d, y', 'MMM d, y', 'M/d/yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale cs.
 */
goog.i18n.DateTimeSymbols_cs = {
  ERAS: ['p��. n. l.', 'n. l.'],
  ERANAMES: ['p��. n. l.', 'n. l.'],
  NARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  STANDALONENARROWMONTHS: ['l', '��', 'b', 'd', 'k', '��', '��', 's', 'z', '��',
    'l', 'p'],
  MONTHS: ['ledna', '��nora', 'b��ezna', 'dubna', 'kv��tna', '��ervna',
    '��ervence', 'srpna', 'z������', '����jna', 'listopadu', 'prosince'],
  STANDALONEMONTHS: ['leden', '��nor', 'b��ezen', 'duben', 'kv��ten', '��erven',
    '��ervenec', 'srpen', 'z������', '����jen', 'listopad', 'prosinec'],
  SHORTMONTHS: ['led', '��no', 'b��e', 'dub', 'kv��', '��vn', '��vc', 'srp',
    'z����', '����j', 'lis', 'pro'],
  STANDALONESHORTMONTHS: ['led', '��no', 'b��e', 'dub', 'kv��', '��vn', '��vc',
    'srp', 'z����', '����j', 'lis', 'pro'],
  WEEKDAYS: ['ned��le', 'pond��l��', '��ter��', 'st��eda', '��tvrtek', 'p��tek',
    'sobota'],
  STANDALONEWEEKDAYS: ['ned��le', 'pond��l��', '��ter��', 'st��eda', '��tvrtek',
    'p��tek', 'sobota'],
  SHORTWEEKDAYS: ['ne', 'po', '��t', 'st', '��t', 'p��', 'so'],
  STANDALONESHORTWEEKDAYS: ['ne', 'po', '��t', 'st', '��t', 'p��', 'so'],
  NARROWWEEKDAYS: ['N', 'P', '��', 'S', '��', 'P', 'S'],
  STANDALONENARROWWEEKDAYS: ['N', 'P', '��', 'S', '��', 'P', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1. ��tvrtlet��', '2. ��tvrtlet��', '3. ��tvrtlet��',
    '4. ��tvrtlet��'],
  AMPMS: ['dop.', 'odp.'],
  DATEFORMATS: ['EEEE, d. MMMM y', 'd. MMMM y', 'd. M. y', 'dd.MM.yy'],
  TIMEFORMATS: ['H:mm:ss zzzz', 'H:mm:ss z', 'H:mm:ss', 'H:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale cy.
 */
goog.i18n.DateTimeSymbols_cy = {
  ERAS: ['CC', 'OC'],
  ERANAMES: ['Cyn Crist', 'Oed Crist'],
  NARROWMONTHS: ['I', 'Ch', 'M', 'E', 'M', 'M', 'G', 'A', 'M', 'H', 'T', 'Rh'],
  STANDALONENARROWMONTHS: ['I', 'Ch', 'M', 'E', 'M', 'M', 'G', 'A', 'M', 'H',
    'T', 'Rh'],
  MONTHS: ['Ionawr', 'Chwefror', 'Mawrth', 'Ebrill', 'Mai', 'Mehefin',
    'Gorffennaf', 'Awst', 'Medi', 'Hydref', 'Tachwedd', 'Rhagfyr'],
  STANDALONEMONTHS: ['Ionawr', 'Chwefror', 'Mawrth', 'Ebrill', 'Mai', 'Mehefin',
    'Gorffennaf', 'Awst', 'Medi', 'Hydref', 'Tachwedd', 'Rhagfyr'],
  SHORTMONTHS: ['Ion', 'Chwef', 'Mawrth', 'Ebrill', 'Mai', 'Meh', 'Gorff',
    'Awst', 'Medi', 'Hyd', 'Tach', 'Rhag'],
  STANDALONESHORTMONTHS: ['Ion', 'Chw', 'Maw', 'Ebr', 'Mai', 'Meh', 'Gor',
    'Awst', 'Medi', 'Hyd', 'Tach', 'Rhag'],
  WEEKDAYS: ['Dydd Sul', 'Dydd Llun', 'Dydd Mawrth', 'Dydd Mercher', 'Dydd Iau',
    'Dydd Gwener', 'Dydd Sadwrn'],
  STANDALONEWEEKDAYS: ['Dydd Sul', 'Dydd Llun', 'Dydd Mawrth', 'Dydd Mercher',
    'Dydd Iau', 'Dydd Gwener', 'Dydd Sadwrn'],
  SHORTWEEKDAYS: ['Sul', 'Llun', 'Maw', 'Mer', 'Iau', 'Gwen', 'Sad'],
  STANDALONESHORTWEEKDAYS: ['Sul', 'Llun', 'Maw', 'Mer', 'Iau', 'Gwe', 'Sad'],
  NARROWWEEKDAYS: ['S', 'Ll', 'M', 'M', 'I', 'G', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'Ll', 'M', 'M', 'I', 'G', 'S'],
  SHORTQUARTERS: ['Ch1', 'Ch2', 'Ch3', 'Ch4'],
  QUARTERS: ['Chwarter 1af', '2il chwarter', '3ydd chwarter', '4ydd chwarter'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'd MMM y', 'dd/MM/y'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale da.
 */
goog.i18n.DateTimeSymbols_da = {
  ERAS: ['f.Kr.', 'e.Kr.'],
  ERANAMES: ['f.Kr.', 'e.Kr.'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['januar', 'februar', 'marts', 'april', 'maj', 'juni', 'juli',
    'august', 'september', 'oktober', 'november', 'december'],
  STANDALONEMONTHS: ['januar', 'februar', 'marts', 'april', 'maj', 'juni',
    'juli', 'august', 'september', 'oktober', 'november', 'december'],
  SHORTMONTHS: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun.', 'jul.', 'aug.',
    'sep.', 'okt.', 'nov.', 'dec.'],
  STANDALONESHORTMONTHS: ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul',
    'aug', 'sep', 'okt', 'nov', 'dec'],
  WEEKDAYS: ['s��ndag', 'mandag', 'tirsdag', 'onsdag', 'torsdag', 'fredag',
    'l��rdag'],
  STANDALONEWEEKDAYS: ['s��ndag', 'mandag', 'tirsdag', 'onsdag', 'torsdag',
    'fredag', 'l��rdag'],
  SHORTWEEKDAYS: ['s��n.', 'man.', 'tir.', 'ons.', 'tor.', 'fre.', 'l��r.'],
  STANDALONESHORTWEEKDAYS: ['s��n', 'man', 'tir', 'ons', 'tor', 'fre', 'l��r'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  SHORTQUARTERS: ['K1', 'K2', 'K3', 'K4'],
  QUARTERS: ['1. kvartal', '2. kvartal', '3. kvartal', '4. kvartal'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE \'den\' d. MMMM y', 'd. MMM y', 'dd/MM/y', 'dd/MM/yy'],
  TIMEFORMATS: ['HH.mm.ss zzzz', 'HH.mm.ss z', 'HH.mm.ss', 'HH.mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale de.
 */
goog.i18n.DateTimeSymbols_de = {
  ERAS: ['v. Chr.', 'n. Chr.'],
  ERANAMES: ['v. Chr.', 'n. Chr.'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Januar', 'Februar', 'M��rz', 'April', 'Mai', 'Juni', 'Juli',
    'August', 'September', 'Oktober', 'November', 'Dezember'],
  STANDALONEMONTHS: ['Januar', 'Februar', 'M��rz', 'April', 'Mai', 'Juni',
    'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
  SHORTMONTHS: ['Jan.', 'Feb.', 'M��r.', 'Apr.', 'Mai', 'Juni', 'Juli', 'Aug.',
    'Sep.', 'Okt.', 'Nov.', 'Dez.'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'M��r', 'Apr', 'Mai', 'Jun', 'Jul',
    'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
  WEEKDAYS: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag',
    'Freitag', 'Samstag'],
  STANDALONEWEEKDAYS: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch',
    'Donnerstag', 'Freitag', 'Samstag'],
  SHORTWEEKDAYS: ['So.', 'Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.'],
  STANDALONESHORTWEEKDAYS: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
  NARROWWEEKDAYS: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1. Quartal', '2. Quartal', '3. Quartal', '4. Quartal'],
  AMPMS: ['vorm.', 'nachm.'],
  DATEFORMATS: ['EEEE, d. MMMM y', 'd. MMMM y', 'dd.MM.y', 'dd.MM.yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale de_AT.
 */
goog.i18n.DateTimeSymbols_de_AT = {
  ERAS: ['v. Chr.', 'n. Chr.'],
  ERANAMES: ['v. Chr.', 'n. Chr.'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['J��nner', 'Februar', 'M��rz', 'April', 'Mai', 'Juni', 'Juli',
    'August', 'September', 'Oktober', 'November', 'Dezember'],
  STANDALONEMONTHS: ['Januar', 'Februar', 'M��rz', 'April', 'Mai', 'Juni',
    'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
  SHORTMONTHS: ['J��n', 'Feb.', 'M��r.', 'Apr.', 'Mai', 'Juni', 'Juli', 'Aug.',
    'Sep.', 'Okt.', 'Nov.', 'Dez.'],
  STANDALONESHORTMONTHS: ['J��n', 'Feb', 'M��r', 'Apr', 'Mai', 'Jun', 'Jul',
    'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
  WEEKDAYS: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag',
    'Freitag', 'Samstag'],
  STANDALONEWEEKDAYS: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch',
    'Donnerstag', 'Freitag', 'Samstag'],
  SHORTWEEKDAYS: ['So.', 'Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.'],
  STANDALONESHORTWEEKDAYS: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
  NARROWWEEKDAYS: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1. Quartal', '2. Quartal', '3. Quartal', '4. Quartal'],
  AMPMS: ['vorm.', 'nachm.'],
  DATEFORMATS: ['EEEE, dd. MMMM y', 'dd. MMMM y', 'dd.MM.y', 'dd.MM.yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale de_CH.
 */
goog.i18n.DateTimeSymbols_de_CH = goog.i18n.DateTimeSymbols_de;


/**
 * Date/time formatting symbols for locale el.
 */
goog.i18n.DateTimeSymbols_el = {
  ERAS: ['��.��.', '��.��.'],
  ERANAMES: ['��.��.', '��.��.'],
  NARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��'],
  STANDALONENARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��', '��'],
  MONTHS: ['��������������������', '����������������������', '��������������',
    '����������������', '����������', '��������������', '��������������',
    '������������������', '����������������������', '������������������',
    '������������������', '��������������������'],
  STANDALONEMONTHS: ['��������������������', '����������������������',
    '��������������', '����������������', '����������', '��������������',
    '��������������', '������������������', '����������������������',
    '������������������', '������������������', '��������������������'],
  SHORTMONTHS: ['������', '������', '������', '������', '������', '��������',
    '��������', '������', '������', '������', '������', '������'],
  STANDALONESHORTMONTHS: ['������', '������', '������', '������', '������',
    '��������', '��������', '������', '������', '������', '������', '������'],
  WEEKDAYS: ['��������������', '��������������', '����������', '��������������',
    '������������', '������������������', '��������������'],
  STANDALONEWEEKDAYS: ['��������������', '��������������', '����������',
    '��������������', '������������', '������������������', '��������������'],
  SHORTWEEKDAYS: ['������', '������', '������', '������', '������', '������',
    '������'],
  STANDALONESHORTWEEKDAYS: ['������', '������', '������', '������', '������',
    '������', '������'],
  NARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  STANDALONENARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  SHORTQUARTERS: ['��1', '��2', '��3', '��4'],
  QUARTERS: ['1�� ��������������', '2�� ��������������', '3�� ��������������',
    '4�� ��������������'],
  AMPMS: ['��.��.', '��.��.'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'd MMM y', 'd/M/yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} - {0}', '{1} - {0}', '{1} - {0}', '{1} - {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale en.
 */
goog.i18n.DateTimeSymbols_en = {
  ERAS: ['BC', 'AD'],
  ERANAMES: ['Before Christ', 'Anno Domini'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
    'August', 'September', 'October', 'November', 'December'],
  STANDALONEMONTHS: ['January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
    'Oct', 'Nov', 'Dec'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  WEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
    'Saturday'],
  STANDALONEWEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
    'Friday', 'Saturday'],
  SHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  STANDALONESHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, MMMM d, y', 'MMMM d, y', 'MMM d, y', 'M/d/yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} \'at\' {0}', '{1} \'at\' {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale en_AU.
 */
goog.i18n.DateTimeSymbols_en_AU = {
  ERAS: ['BC', 'AD'],
  ERANAMES: ['Before Christ', 'Anno Domini'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
    'August', 'September', 'October', 'November', 'December'],
  STANDALONEMONTHS: ['January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
    'Oct', 'Nov', 'Dec'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  WEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
    'Saturday'],
  STANDALONEWEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
    'Friday', 'Saturday'],
  SHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  STANDALONESHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'dd/MM/y', 'd/MM/yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} \'at\' {0}', '{1} \'at\' {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale en_GB.
 */
goog.i18n.DateTimeSymbols_en_GB = {
  ERAS: ['BC', 'AD'],
  ERANAMES: ['Before Christ', 'Anno Domini'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
    'August', 'September', 'October', 'November', 'December'],
  STANDALONEMONTHS: ['January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
    'Oct', 'Nov', 'Dec'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  WEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
    'Saturday'],
  STANDALONEWEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
    'Friday', 'Saturday'],
  SHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  STANDALONESHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'],
  AMPMS: ['am', 'pm'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'd MMM y', 'dd/MM/y'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale en_IE.
 */
goog.i18n.DateTimeSymbols_en_IE = {
  ERAS: ['BC', 'AD'],
  ERANAMES: ['Before Christ', 'Anno Domini'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
    'August', 'September', 'October', 'November', 'December'],
  STANDALONEMONTHS: ['January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
    'Oct', 'Nov', 'Dec'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  WEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
    'Saturday'],
  STANDALONEWEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
    'Friday', 'Saturday'],
  SHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  STANDALONESHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'],
  AMPMS: ['a.m.', 'p.m.'],
  DATEFORMATS: ['EEEE d MMMM y', 'd MMMM y', 'd MMM y', 'dd/MM/y'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} \'at\' {0}', '{1} \'at\' {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 2
};


/**
 * Date/time formatting symbols for locale en_IN.
 */
goog.i18n.DateTimeSymbols_en_IN = {
  ERAS: ['BC', 'AD'],
  ERANAMES: ['Before Christ', 'Anno Domini'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
    'August', 'September', 'October', 'November', 'December'],
  STANDALONEMONTHS: ['January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
    'Oct', 'Nov', 'Dec'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  WEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
    'Saturday'],
  STANDALONEWEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
    'Friday', 'Saturday'],
  SHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  STANDALONESHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE d MMMM y', 'd MMMM y', 'dd-MMM-y', 'dd/MM/yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} \'at\' {0}', '{1} \'at\' {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [6, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale en_SG.
 */
goog.i18n.DateTimeSymbols_en_SG = {
  ERAS: ['BC', 'AD'],
  ERANAMES: ['Before Christ', 'Anno Domini'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
    'August', 'September', 'October', 'November', 'December'],
  STANDALONEMONTHS: ['January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
    'Oct', 'Nov', 'Dec'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  WEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
    'Saturday'],
  STANDALONEWEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
    'Friday', 'Saturday'],
  SHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  STANDALONESHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d MMMM, y', 'd MMMM, y', 'd MMM, y', 'd/M/yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} \'at\' {0}', '{1} \'at\' {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale en_US.
 */
goog.i18n.DateTimeSymbols_en_US = goog.i18n.DateTimeSymbols_en;


/**
 * Date/time formatting symbols for locale en_ZA.
 */
goog.i18n.DateTimeSymbols_en_ZA = {
  ERAS: ['BC', 'AD'],
  ERANAMES: ['Before Christ', 'Anno Domini'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
    'August', 'September', 'October', 'November', 'December'],
  STANDALONEMONTHS: ['January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
    'Oct', 'Nov', 'Dec'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  WEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
    'Saturday'],
  STANDALONEWEEKDAYS: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
    'Friday', 'Saturday'],
  SHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  STANDALONESHORTWEEKDAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE dd MMMM y', 'dd MMMM y', 'dd MMM y', 'y/MM/dd'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} \'at\' {0}', '{1} \'at\' {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale es.
 */
goog.i18n.DateTimeSymbols_es = {
  ERAS: ['a.C.', 'd.C.'],
  ERANAMES: ['antes de Cristo', 'anno D��mini'],
  NARROWMONTHS: ['E', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['E', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio',
    'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'],
  STANDALONEMONTHS: ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
    'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'],
  SHORTMONTHS: ['ene', 'feb', 'mar', 'abr', 'may', 'jun', 'jul', 'ago', 'sep',
    'oct', 'nov', 'dic'],
  STANDALONESHORTMONTHS: ['ene', 'feb', 'mar', 'abr', 'mayo', 'jun', 'jul',
    'ago', 'sep', 'oct', 'nov', 'dic'],
  WEEKDAYS: ['domingo', 'lunes', 'martes', 'mi��rcoles', 'jueves', 'viernes',
    's��bado'],
  STANDALONEWEEKDAYS: ['domingo', 'lunes', 'martes', 'mi��rcoles', 'jueves',
    'viernes', 's��bado'],
  SHORTWEEKDAYS: ['dom', 'lun', 'mar', 'mi��', 'jue', 'vie', 's��b'],
  STANDALONESHORTWEEKDAYS: ['dom', 'lun', 'mar', 'mi��', 'jue', 'vie', 's��b'],
  NARROWWEEKDAYS: ['D', 'L', 'M', 'X', 'J', 'V', 'S'],
  STANDALONENARROWWEEKDAYS: ['D', 'L', 'M', 'X', 'J', 'V', 'S'],
  SHORTQUARTERS: ['T1', 'T2', 'T3', 'T4'],
  QUARTERS: ['1er trimestre', '2�� trimestre', '3er trimestre',
    '4�� trimestre'],
  AMPMS: ['a.m.', 'p.m.'],
  DATEFORMATS: ['EEEE, d \'de\' MMMM \'de\' y', 'd \'de\' MMMM \'de\' y',
    'dd/MM/y', 'dd/MM/yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale es_419.
 */
goog.i18n.DateTimeSymbols_es_419 = {
  ERAS: ['a.C.', 'd.C.'],
  ERANAMES: ['antes de Cristo', 'anno D��mini'],
  NARROWMONTHS: ['E', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['E', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio',
    'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'],
  STANDALONEMONTHS: ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
    'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'],
  SHORTMONTHS: ['ene', 'feb', 'mar', 'abr', 'may', 'jun', 'jul', 'ago', 'sep',
    'oct', 'nov', 'dic'],
  STANDALONESHORTMONTHS: ['ene', 'feb', 'mar', 'abr', 'mayo', 'jun', 'jul',
    'ago', 'sep', 'oct', 'nov', 'dic'],
  WEEKDAYS: ['domingo', 'lunes', 'martes', 'mi��rcoles', 'jueves', 'viernes',
    's��bado'],
  STANDALONEWEEKDAYS: ['domingo', 'lunes', 'martes', 'mi��rcoles', 'jueves',
    'viernes', 's��bado'],
  SHORTWEEKDAYS: ['dom', 'lun', 'mar', 'mi��', 'jue', 'vie', 's��b'],
  STANDALONESHORTWEEKDAYS: ['dom', 'lun', 'mar', 'mi��', 'jue', 'vie', 's��b'],
  NARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  STANDALONENARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  SHORTQUARTERS: ['T1', 'T2', 'T3', 'T4'],
  QUARTERS: ['1er trimestre', '2�� trimestre', '3er trimestre',
    '4�� trimestre'],
  AMPMS: ['a.m.', 'p.m.'],
  DATEFORMATS: ['EEEE, d \'de\' MMMM \'de\' y', 'd \'de\' MMMM \'de\' y',
    'dd/MM/y', 'dd/MM/yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale es_ES.
 */
goog.i18n.DateTimeSymbols_es_ES = goog.i18n.DateTimeSymbols_es;


/**
 * Date/time formatting symbols for locale et.
 */
goog.i18n.DateTimeSymbols_et = {
  ERAS: ['e.m.a.', 'm.a.j.'],
  ERANAMES: ['enne meie aega', 'meie aja j��rgi'],
  NARROWMONTHS: ['J', 'V', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'V', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['jaanuar', 'veebruar', 'm��rts', 'aprill', 'mai', 'juuni', 'juuli',
    'august', 'september', 'oktoober', 'november', 'detsember'],
  STANDALONEMONTHS: ['jaanuar', 'veebruar', 'm��rts', 'aprill', 'mai', 'juuni',
    'juuli', 'august', 'september', 'oktoober', 'november', 'detsember'],
  SHORTMONTHS: ['jaan', 'veebr', 'm��rts', 'apr', 'mai', 'juuni', 'juuli',
    'aug', 'sept', 'okt', 'nov', 'dets'],
  STANDALONESHORTMONTHS: ['jaan', 'veebr', 'm��rts', 'apr', 'mai', 'juuni',
    'juuli', 'aug', 'sept', 'okt', 'nov', 'dets'],
  WEEKDAYS: ['p��hap��ev', 'esmasp��ev', 'teisip��ev', 'kolmap��ev',
    'neljap��ev', 'reede', 'laup��ev'],
  STANDALONEWEEKDAYS: ['p��hap��ev', 'esmasp��ev', 'teisip��ev', 'kolmap��ev',
    'neljap��ev', 'reede', 'laup��ev'],
  SHORTWEEKDAYS: ['P', 'E', 'T', 'K', 'N', 'R', 'L'],
  STANDALONESHORTWEEKDAYS: ['P', 'E', 'T', 'K', 'N', 'R', 'L'],
  NARROWWEEKDAYS: ['P', 'E', 'T', 'K', 'N', 'R', 'L'],
  STANDALONENARROWWEEKDAYS: ['P', 'E', 'T', 'K', 'N', 'R', 'L'],
  SHORTQUARTERS: ['K1', 'K2', 'K3', 'K4'],
  QUARTERS: ['1. kvartal', '2. kvartal', '3. kvartal', '4. kvartal'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d. MMMM y', 'd. MMMM y', 'dd.MM.y', 'dd.MM.yy'],
  TIMEFORMATS: ['H:mm.ss zzzz', 'H:mm.ss z', 'H:mm.ss', 'H:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale eu.
 */
goog.i18n.DateTimeSymbols_eu = {
  ERAS: ['K.a.', 'K.o.'],
  ERANAMES: ['K.a.', 'K.o.'],
  NARROWMONTHS: ['U', 'O', 'M', 'A', 'M', 'E', 'U', 'A', 'I', 'U', 'A', 'A'],
  STANDALONENARROWMONTHS: ['U', 'O', 'M', 'A', 'M', 'E', 'U', 'A', 'I', 'U',
    'A', 'A'],
  MONTHS: ['urtarrila', 'otsaila', 'martxoa', 'apirila', 'maiatza', 'ekaina',
    'uztaila', 'abuztua', 'iraila', 'urria', 'azaroa', 'abendua'],
  STANDALONEMONTHS: ['urtarrila', 'otsaila', 'martxoa', 'apirila', 'maiatza',
    'ekaina', 'uztaila', 'abuztua', 'iraila', 'urria', 'azaroa', 'abendua'],
  SHORTMONTHS: ['urt', 'ots', 'mar', 'api', 'mai', 'eka', 'uzt', 'abu', 'ira',
    'urr', 'aza', 'abe'],
  STANDALONESHORTMONTHS: ['urt', 'ots', 'mar', 'api', 'mai', 'eka', 'uzt',
    'abu', 'ira', 'urr', 'aza', 'abe'],
  WEEKDAYS: ['igandea', 'astelehena', 'asteartea', 'asteazkena', 'osteguna',
    'ostirala', 'larunbata'],
  STANDALONEWEEKDAYS: ['igandea', 'astelehena', 'asteartea', 'asteazkena',
    'osteguna', 'ostirala', 'larunbata'],
  SHORTWEEKDAYS: ['ig', 'al', 'as', 'az', 'og', 'or', 'lr'],
  STANDALONESHORTWEEKDAYS: ['ig', 'al', 'as', 'az', 'og', 'or', 'lr'],
  NARROWWEEKDAYS: ['I', 'M', 'A', 'A', 'A', 'O', 'I'],
  STANDALONENARROWWEEKDAYS: ['I', 'M', 'A', 'L', 'A', 'O', 'I'],
  SHORTQUARTERS: ['1Hh', '2Hh', '3Hh', '4Hh'],
  QUARTERS: ['1. hiruhilekoa', '2. hiruhilekoa', '3. hiruhilekoa',
    '4. hiruhilekoa'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, y MMMM dd', 'y MMMM d', 'y MMM d', 'y-MM-dd'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale fa.
 */
goog.i18n.DateTimeSymbols_fa = {
  ZERODIGIT: 0x06F0,
  ERAS: ['��.��.', '��.'],
  ERANAMES: ['������ ���� ����������', '������������'],
  NARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��'],
  STANDALONENARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��', '��'],
  MONTHS: ['��������������', '������������', '��������', '����������', '������',
    '��������', '������������', '������', '��������������', '����������',
    '������������', '������������'],
  STANDALONEMONTHS: ['������������', '����������', '��������', '����������',
    '����', '��������', '����������', '������', '��������������', '����������',
    '������������', '������������'],
  SHORTMONTHS: ['��������������', '������������', '��������', '����������',
    '������', '��������', '������������', '������', '��������������',
    '����������', '������������', '������������'],
  STANDALONESHORTMONTHS: ['������������', '����������', '��������',
    '����������', '����', '��������', '����������', '������', '��������������',
    '����������', '������������', '������������'],
  WEEKDAYS: ['������������', '������������', '���������������',
    '����������������', '��������������', '��������', '��������'],
  STANDALONEWEEKDAYS: ['������������', '������������', '���������������',
    '����������������', '��������������', '��������', '��������'],
  SHORTWEEKDAYS: ['������������', '������������', '���������������',
    '����������������', '��������������', '��������', '��������'],
  STANDALONESHORTWEEKDAYS: ['������������', '������������', '���������������',
    '����������������', '��������������', '��������', '��������'],
  NARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  STANDALONENARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  SHORTQUARTERS: ['���������', '���������', '���������', '���������'],
  QUARTERS: ['����������������� ������', '����������������� ������',
    '����������������� ������', '����������������� ����������'],
  AMPMS: ['�������������������', '����������������'],
  DATEFORMATS: ['EEEE d MMMM y', 'd MMMM y', 'd MMM y', 'y/M/d'],
  TIMEFORMATS: ['H:mm:ss (zzzz)', 'H:mm:ss (z)', 'H:mm:ss', 'H:mm'],
  DATETIMEFORMATS: ['{1}�� �������� {0}', '{1}�� �������� {0}', '{1}����� {0}',
    '{1}����� {0}'],
  FIRSTDAYOFWEEK: 5,
  WEEKENDRANGE: [3, 4],
  FIRSTWEEKCUTOFFDAY: 4
};


/**
 * Date/time formatting symbols for locale fi.
 */
goog.i18n.DateTimeSymbols_fi = {
  ERAS: ['eKr.', 'jKr.'],
  ERANAMES: ['ennen Kristuksen syntym����', 'j��lkeen Kristuksen syntym��n'],
  NARROWMONTHS: ['T', 'H', 'M', 'H', 'T', 'K', 'H', 'E', 'S', 'L', 'M', 'J'],
  STANDALONENARROWMONTHS: ['T', 'H', 'M', 'H', 'T', 'K', 'H', 'E', 'S', 'L',
    'M', 'J'],
  MONTHS: ['tammikuuta', 'helmikuuta', 'maaliskuuta', 'huhtikuuta',
    'toukokuuta', 'kes��kuuta', 'hein��kuuta', 'elokuuta', 'syyskuuta',
    'lokakuuta', 'marraskuuta', 'joulukuuta'],
  STANDALONEMONTHS: ['tammikuu', 'helmikuu', 'maaliskuu', 'huhtikuu',
    'toukokuu', 'kes��kuu', 'hein��kuu', 'elokuu', 'syyskuu', 'lokakuu',
    'marraskuu', 'joulukuu'],
  SHORTMONTHS: ['tammikuuta', 'helmikuuta', 'maaliskuuta', 'huhtikuuta',
    'toukokuuta', 'kes��kuuta', 'hein��kuuta', 'elokuuta', 'syyskuuta',
    'lokakuuta', 'marraskuuta', 'joulukuuta'],
  STANDALONESHORTMONTHS: ['tammi', 'helmi', 'maalis', 'huhti', 'touko', 'kes��',
    'hein��', 'elo', 'syys', 'loka', 'marras', 'joulu'],
  WEEKDAYS: ['sunnuntaina', 'maanantaina', 'tiistaina', 'keskiviikkona',
    'torstaina', 'perjantaina', 'lauantaina'],
  STANDALONEWEEKDAYS: ['sunnuntai', 'maanantai', 'tiistai', 'keskiviikko',
    'torstai', 'perjantai', 'lauantai'],
  SHORTWEEKDAYS: ['su', 'ma', 'ti', 'ke', 'to', 'pe', 'la'],
  STANDALONESHORTWEEKDAYS: ['su', 'ma', 'ti', 'ke', 'to', 'pe', 'la'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'K', 'T', 'P', 'L'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'K', 'T', 'P', 'L'],
  SHORTQUARTERS: ['1. nelj.', '2. nelj.', '3. nelj.', '4. nelj.'],
  QUARTERS: ['1. nelj��nnes', '2. nelj��nnes', '3. nelj��nnes',
    '4. nelj��nnes'],
  AMPMS: ['ap.', 'ip.'],
  DATEFORMATS: ['cccc d. MMMM y', 'd. MMMM y', 'd.M.y', 'd.M.y'],
  TIMEFORMATS: ['H.mm.ss zzzz', 'H.mm.ss z', 'H.mm.ss', 'H.mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale fil.
 */
goog.i18n.DateTimeSymbols_fil = {
  ERAS: ['BC', 'AD'],
  ERANAMES: ['BC', 'AD'],
  NARROWMONTHS: ['E', 'P', 'M', 'A', 'M', 'H', 'H', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['E', 'P', 'M', 'A', 'M', 'H', 'H', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Enero', 'Pebrero', 'Marso', 'Abril', 'Mayo', 'Hunyo', 'Hulyo',
    'Agosto', 'Setyembre', 'Oktubre', 'Nobyembre', 'Disyembre'],
  STANDALONEMONTHS: ['Enero', 'Pebrero', 'Marso', 'Abril', 'Mayo', 'Hunyo',
    'Hulyo', 'Agosto', 'Setyembre', 'Oktubre', 'Nobyembre', 'Disyembre'],
  SHORTMONTHS: ['Ene', 'Peb', 'Mar', 'Abr', 'May', 'Hun', 'Hul', 'Ago', 'Set',
    'Okt', 'Nob', 'Dis'],
  STANDALONESHORTMONTHS: ['Ene', 'Peb', 'Mar', 'Abr', 'May', 'Hun', 'Hul',
    'Ago', 'Set', 'Okt', 'Nob', 'Dis'],
  WEEKDAYS: ['Linggo', 'Lunes', 'Martes', 'Miyerkules', 'Huwebes', 'Biyernes',
    'Sabado'],
  STANDALONEWEEKDAYS: ['Linggo', 'Lunes', 'Martes', 'Miyerkules', 'Huwebes',
    'Biyernes', 'Sabado'],
  SHORTWEEKDAYS: ['Lin', 'Lun', 'Mar', 'Mye', 'Huw', 'Bye', 'Sab'],
  STANDALONESHORTWEEKDAYS: ['Lin', 'Lun', 'Mar', 'Miy', 'Huw', 'Biy', 'Sab'],
  NARROWWEEKDAYS: ['L', 'L', 'M', 'M', 'H', 'B', 'S'],
  STANDALONENARROWWEEKDAYS: ['L', 'L', 'M', 'M', 'H', 'B', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['ika-1 sangkapat', 'ika-2 sangkapat', 'ika-3 quarter',
    'ika-4 na quarter'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, MMMM dd y', 'MMMM d, y', 'MMM d, y', 'M/d/yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale fr.
 */
goog.i18n.DateTimeSymbols_fr = {
  ERAS: ['av. J.-C.', 'ap. J.-C.'],
  ERANAMES: ['avant J��sus-Christ', 'apr��s J��sus-Christ'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['janvier', 'f��vrier', 'mars', 'avril', 'mai', 'juin', 'juillet',
    'ao��t', 'septembre', 'octobre', 'novembre', 'd��cembre'],
  STANDALONEMONTHS: ['janvier', 'f��vrier', 'mars', 'avril', 'mai', 'juin',
    'juillet', 'ao��t', 'septembre', 'octobre', 'novembre', 'd��cembre'],
  SHORTMONTHS: ['janv.', 'f��vr.', 'mars', 'avr.', 'mai', 'juin', 'juil.',
    'ao��t', 'sept.', 'oct.', 'nov.', 'd��c.'],
  STANDALONESHORTMONTHS: ['janv.', 'f��vr.', 'mars', 'avr.', 'mai', 'juin',
    'juil.', 'ao��t', 'sept.', 'oct.', 'nov.', 'd��c.'],
  WEEKDAYS: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi',
    'samedi'],
  STANDALONEWEEKDAYS: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi',
    'vendredi', 'samedi'],
  SHORTWEEKDAYS: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
  STANDALONESHORTWEEKDAYS: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.',
    'sam.'],
  NARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  STANDALONENARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  SHORTQUARTERS: ['T1', 'T2', 'T3', 'T4'],
  QUARTERS: ['1er trimestre', '2e trimestre', '3e trimestre', '4e trimestre'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE d MMMM y', 'd MMMM y', 'd MMM y', 'dd/MM/y'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale fr_CA.
 */
goog.i18n.DateTimeSymbols_fr_CA = {
  ERAS: ['av. J.-C.', 'ap. J.-C.'],
  ERANAMES: ['avant J��sus-Christ', 'apr��s J��sus-Christ'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['janvier', 'f��vrier', 'mars', 'avril', 'mai', 'juin', 'juillet',
    'ao��t', 'septembre', 'octobre', 'novembre', 'd��cembre'],
  STANDALONEMONTHS: ['janvier', 'f��vrier', 'mars', 'avril', 'mai', 'juin',
    'juillet', 'ao��t', 'septembre', 'octobre', 'novembre', 'd��cembre'],
  SHORTMONTHS: ['janv.', 'f��vr.', 'mars', 'avr.', 'mai', 'juin', 'juil.',
    'ao��t', 'sept.', 'oct.', 'nov.', 'd��c.'],
  STANDALONESHORTMONTHS: ['janv.', 'f��vr.', 'mars', 'avr.', 'mai', 'juin',
    'juil.', 'ao��t', 'sept.', 'oct.', 'nov.', 'd��c.'],
  WEEKDAYS: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi',
    'samedi'],
  STANDALONEWEEKDAYS: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi',
    'vendredi', 'samedi'],
  SHORTWEEKDAYS: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
  STANDALONESHORTWEEKDAYS: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.',
    'sam.'],
  NARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  STANDALONENARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  SHORTQUARTERS: ['T1', 'T2', 'T3', 'T4'],
  QUARTERS: ['1er trimestre', '2e trimestre', '3e trimestre', '4e trimestre'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE d MMMM y', 'd MMMM y', 'y-MM-dd', 'yy-MM-dd'],
  TIMEFORMATS: ['HH \'h\' mm \'min\' ss \'s\' zzzz', 'HH:mm:ss z', 'HH:mm:ss',
    'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale gl.
 */
goog.i18n.DateTimeSymbols_gl = {
  ERAS: ['a.C.', 'd.C.'],
  ERANAMES: ['antes de Cristo', 'despois de Cristo'],
  NARROWMONTHS: ['X', 'F', 'M', 'A', 'M', 'X', 'X', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['X', 'F', 'M', 'A', 'M', 'X', 'X', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Xaneiro', 'Febreiro', 'Marzo', 'Abril', 'Maio', 'Xu��o', 'Xullo',
    'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Decembro'],
  STANDALONEMONTHS: ['Xaneiro', 'Febreiro', 'Marzo', 'Abril', 'Maio', 'Xu��o',
    'Xullo', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Decembro'],
  SHORTMONTHS: ['Xan', 'Feb', 'Mar', 'Abr', 'Mai', 'Xu��', 'Xul', 'Ago', 'Set',
    'Out', 'Nov', 'Dec'],
  STANDALONESHORTMONTHS: ['Xan', 'Feb', 'Mar', 'Abr', 'Mai', 'Xu��', 'Xul',
    'Ago', 'Set', 'Out', 'Nov', 'Dec'],
  WEEKDAYS: ['Domingo', 'Luns', 'Martes', 'M��rcores', 'Xoves', 'Venres',
    'S��bado'],
  STANDALONEWEEKDAYS: ['Domingo', 'Luns', 'Martes', 'M��rcores', 'Xoves',
    'Venres', 'S��bado'],
  SHORTWEEKDAYS: ['Dom', 'Lun', 'Mar', 'M��r', 'Xov', 'Ven', 'S��b'],
  STANDALONESHORTWEEKDAYS: ['Dom', 'Lun', 'Mar', 'M��r', 'Xov', 'Ven', 'S��b'],
  NARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'X', 'V', 'S'],
  STANDALONENARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'X', 'V', 'S'],
  SHORTQUARTERS: ['T1', 'T2', 'T3', 'T4'],
  QUARTERS: ['1o trimestre', '2o trimestre', '3o trimestre', '4o trimestre'],
  AMPMS: ['a.m.', 'p.m.'],
  DATEFORMATS: ['EEEE dd MMMM y', 'dd MMMM y', 'd MMM, y', 'dd/MM/yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale gsw.
 */
goog.i18n.DateTimeSymbols_gsw = {
  ERAS: ['v. Chr.', 'n. Chr.'],
  ERANAMES: ['v. Chr.', 'n. Chr.'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Januar', 'Februar', 'M��rz', 'April', 'Mai', 'Juni', 'Juli',
    'Auguscht', 'Sept��mber', 'Oktoober', 'Nov��mber', 'Dez��mber'],
  STANDALONEMONTHS: ['Januar', 'Februar', 'M��rz', 'April', 'Mai', 'Juni',
    'Juli', 'Auguscht', 'Sept��mber', 'Oktoober', 'Nov��mber', 'Dez��mber'],
  SHORTMONTHS: ['Jan', 'Feb', 'M��r', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep',
    'Okt', 'Nov', 'Dez'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'M��r', 'Apr', 'Mai', 'Jun', 'Jul',
    'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
  WEEKDAYS: ['Sunntig', 'M����ntig', 'Ziischtig', 'Mittwuch', 'Dunschtig',
    'Friitig', 'Samschtig'],
  STANDALONEWEEKDAYS: ['Sunntig', 'M����ntig', 'Ziischtig', 'Mittwuch',
    'Dunschtig', 'Friitig', 'Samschtig'],
  SHORTWEEKDAYS: ['Su.', 'M��.', 'Zi.', 'Mi.', 'Du.', 'Fr.', 'Sa.'],
  STANDALONESHORTWEEKDAYS: ['Su.', 'M��.', 'Zi.', 'Mi.', 'Du.', 'Fr.', 'Sa.'],
  NARROWWEEKDAYS: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1. Quartal', '2. Quartal', '3. Quartal', '4. Quartal'],
  AMPMS: ['vorm.', 'nam.'],
  DATEFORMATS: ['EEEE, d. MMMM y', 'd. MMMM y', 'dd.MM.y', 'dd.MM.yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale gu.
 */
goog.i18n.DateTimeSymbols_gu = {
  ERAS: ['��������������� ������������ ������������������',
    '������������������'],
  ERANAMES: ['������������������ ������������������', '������������������'],
  NARROWMONTHS: ['������', '������', '������', '���', '������', '������',
    '������', '���', '���', '���', '���', '������'],
  STANDALONENARROWMONTHS: ['������', '������', '������', '���', '������',
    '������', '������', '���', '���', '���', '���', '������'],
  MONTHS: ['���������������������������', '���������������������������',
    '���������������', '������������������', '������', '���������',
    '���������������', '���������������', '���������������������������',
    '���������������������', '���������������������',
    '������������������������'],
  STANDALONEMONTHS: ['���������������������������',
    '���������������������������', '���������������', '������������������',
    '������', '���������', '���������������', '���������������',
    '���������������������������', '���������������������',
    '���������������������', '������������������������'],
  SHORTMONTHS: ['������������������', '������������������', '���������������',
    '������������������', '������', '���������', '���������������',
    '���������������', '���������������', '���������������', '���������',
    '������������'],
  STANDALONESHORTMONTHS: ['������������������', '������������������',
    '���������������', '������������������', '������', '���������',
    '���������������', '������', '���������������', '���������������',
    '���������', '������������'],
  WEEKDAYS: ['������������������', '������������������',
    '���������������������', '������������������', '���������������������',
    '������������������������', '������������������'],
  STANDALONEWEEKDAYS: ['������������������', '������������������',
    '���������������������', '������������������', '���������������������',
    '������������������������', '������������������'],
  SHORTWEEKDAYS: ['���������', '���������', '������������', '���������',
    '������������', '���������������', '���������'],
  STANDALONESHORTWEEKDAYS: ['���������', '���������', '������������',
    '���������', '������������', '���������������', '���������'],
  NARROWWEEKDAYS: ['���', '������', '������', '������', '������', '������',
    '���'],
  STANDALONENARROWWEEKDAYS: ['���', '������', '������', '������', '������',
    '������', '���'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['��������������� ���������', '������������ ���������',
    '������������������ ���������', '������������ ���������'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d MMMM, y', 'd MMMM, y', 'd MMM, y', 'd-MM-yy'],
  TIMEFORMATS: ['hh:mm:ss a zzzz', 'hh:mm:ss a z', 'hh:mm:ss a', 'hh:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [6, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale haw.
 */
goog.i18n.DateTimeSymbols_haw = {
  ERAS: ['BCE', 'CE'],
  ERANAMES: ['BCE', 'CE'],
  NARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  STANDALONENARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
    '11', '12'],
  MONTHS: ['Ianuali', 'Pepeluali', 'Malaki', '��Apelila', 'Mei', 'Iune',
    'Iulai', '��Aukake', 'Kepakemapa', '��Okakopa', 'Nowemapa', 'Kekemapa'],
  STANDALONEMONTHS: ['Ianuali', 'Pepeluali', 'Malaki', '��Apelila', 'Mei',
    'Iune', 'Iulai', '��Aukake', 'Kepakemapa', '��Okakopa', 'Nowemapa',
    'Kekemapa'],
  SHORTMONTHS: ['Ian.', 'Pep.', 'Mal.', '��Ap.', 'Mei', 'Iun.', 'Iul.', '��Au.',
    'Kep.', '��Ok.', 'Now.', 'Kek.'],
  STANDALONESHORTMONTHS: ['Ian.', 'Pep.', 'Mal.', '��Ap.', 'Mei', 'Iun.',
    'Iul.', '��Au.', 'Kep.', '��Ok.', 'Now.', 'Kek.'],
  WEEKDAYS: ['L��pule', 'Po��akahi', 'Po��alua', 'Po��akolu', 'Po��ah��',
    'Po��alima', 'Po��aono'],
  STANDALONEWEEKDAYS: ['L��pule', 'Po��akahi', 'Po��alua', 'Po��akolu',
    'Po��ah��', 'Po��alima', 'Po��aono'],
  SHORTWEEKDAYS: ['LP', 'P1', 'P2', 'P3', 'P4', 'P5', 'P6'],
  STANDALONESHORTWEEKDAYS: ['LP', 'P1', 'P2', 'P3', 'P4', 'P5', 'P6'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'd MMM y', 'd/M/yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale he.
 */
goog.i18n.DateTimeSymbols_he = {
  ERAS: ['������������', '����������'],
  ERANAMES: ['�������� ������������', '������������'],
  NARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  STANDALONENARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
    '11', '12'],
  MONTHS: ['����������', '������������', '������', '����������', '������',
    '��������', '��������', '������������', '������������', '��������������',
    '������������', '����������'],
  STANDALONEMONTHS: ['����������', '������������', '������', '����������',
    '������', '��������', '��������', '������������', '������������',
    '��������������', '������������', '����������'],
  SHORTMONTHS: ['������', '������', '������', '������', '������', '������',
    '������', '������', '������', '������', '������', '������'],
  STANDALONESHORTMONTHS: ['��������', '��������', '������', '��������',
    '������', '��������', '��������', '��������', '��������', '��������',
    '��������', '��������'],
  WEEKDAYS: ['������ ����������', '������ ������', '������ ����������',
    '������ ����������', '������ ����������', '������ ��������',
    '������ ������'],
  STANDALONEWEEKDAYS: ['������ ����������', '������ ������',
    '������ ����������', '������ ����������', '������ ����������',
    '������ ��������', '������ ������'],
  SHORTWEEKDAYS: ['������ ����', '������ ����', '������ ����', '������ ����',
    '������ ����', '������ ����', '������'],
  STANDALONESHORTWEEKDAYS: ['������ ����', '������ ����', '������ ����',
    '������ ����', '������ ����', '������ ����', '������'],
  NARROWWEEKDAYS: ['��\'', '��\'', '��\'', '��\'', '��\'', '����', '����'],
  STANDALONENARROWWEEKDAYS: ['����', '����', '����', '����', '����', '��',
    '��'],
  SHORTQUARTERS: ['���������� 1', '���������� 2', '���������� 3',
    '���������� 4'],
  QUARTERS: ['���������� 1', '���������� 2', '���������� 3', '���������� 4'],
  AMPMS: ['������������', '����������'],
  DATEFORMATS: ['EEEE, d ��MMMM y', 'd ��MMMM y', 'd ��MMM y', 'dd/MM/yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [4, 5],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale hi.
 */
goog.i18n.DateTimeSymbols_hi = {
  ERAS: ['������������������������', '������'],
  ERANAMES: ['������������������������', '������'],
  NARROWMONTHS: ['���', '������', '������', '���', '���', '������', '������',
    '���', '������', '���', '���', '������'],
  STANDALONENARROWMONTHS: ['���', '������', '������', '���', '���', '������',
    '������', '���', '������', '���', '���', '������'],
  MONTHS: ['���������������', '���������������', '���������������',
    '������������������', '������', '���������', '���������������',
    '���������������', '���������������������', '���������������������',
    '������������������', '���������������������'],
  STANDALONEMONTHS: ['���������������', '���������������', '���������������',
    '������������������', '������', '���������', '���������������',
    '���������������', '���������������������', '���������������������',
    '������������������', '���������������������'],
  SHORTMONTHS: ['���������������', '���������������', '���������������',
    '������������������', '������', '���������', '���������������',
    '���������������', '���������������������', '���������������������',
    '������������������', '���������������������'],
  STANDALONESHORTMONTHS: ['���������������', '���������������',
    '���������������', '������������������', '������', '���������',
    '���������������', '���������������', '���������������������',
    '���������������������', '������������������', '���������������������'],
  WEEKDAYS: ['������������������', '������������������',
    '���������������������', '������������������',
    '���������������������������������', '������������������������',
    '������������������'],
  STANDALONEWEEKDAYS: ['������������������', '������������������',
    '���������������������', '������������������',
    '���������������������������������', '������������������������',
    '������������������'],
  SHORTWEEKDAYS: ['���������.', '���������.', '������������.', '���������.',
    '���������.', '���������������.', '���������.'],
  STANDALONESHORTWEEKDAYS: ['���������.', '���������.', '������������.',
    '���������.', '���������.', '���������������.', '���������.'],
  NARROWWEEKDAYS: ['���', '������', '������', '������', '������', '������',
    '���'],
  STANDALONENARROWWEEKDAYS: ['���', '������', '������', '������', '������',
    '������', '���'],
  SHORTQUARTERS: ['������������������', '��������������� ������������������',
    '��������������� ������������������', '������������ ������������������'],
  QUARTERS: ['������������������', '��������������� ������������������',
    '��������������� ������������������', '������������ ������������������'],
  AMPMS: ['am', 'pm'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'dd-MM-y', 'd-M-yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [6, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale hr.
 */
goog.i18n.DateTimeSymbols_hr = {
  ERAS: ['p. n. e.', 'A. D.'],
  ERANAMES: ['Prije Krista', 'Poslije Krista'],
  NARROWMONTHS: ['1.', '2.', '3.', '4.', '5.', '6.', '7.', '8.', '9.', '10.',
    '11.', '12.'],
  STANDALONENARROWMONTHS: ['1.', '2.', '3.', '4.', '5.', '6.', '7.', '8.', '9.',
    '10.', '11.', '12.'],
  MONTHS: ['sije��nja', 'velja��e', 'o��ujka', 'travnja', 'svibnja', 'lipnja',
    'srpnja', 'kolovoza', 'rujna', 'listopada', 'studenoga', 'prosinca'],
  STANDALONEMONTHS: ['sije��anj', 'velja��a', 'o��ujak', 'travanj', 'svibanj',
    'lipanj', 'srpanj', 'kolovoz', 'rujan', 'listopad', 'studeni', 'prosinac'],
  SHORTMONTHS: ['sij', 'velj', 'o��u', 'tra', 'svi', 'lip', 'srp', 'kol', 'ruj',
    'lis', 'stu', 'pro'],
  STANDALONESHORTMONTHS: ['sij', 'velj', 'o��u', 'tra', 'svi', 'lip', 'srp',
    'kol', 'ruj', 'lis', 'stu', 'pro'],
  WEEKDAYS: ['nedjelja', 'ponedjeljak', 'utorak', 'srijeda', '��etvrtak',
    'petak', 'subota'],
  STANDALONEWEEKDAYS: ['nedjelja', 'ponedjeljak', 'utorak', 'srijeda',
    '��etvrtak', 'petak', 'subota'],
  SHORTWEEKDAYS: ['ned', 'pon', 'uto', 'sri', '��et', 'pet', 'sub'],
  STANDALONESHORTWEEKDAYS: ['ned', 'pon', 'uto', 'sri', '��et', 'pet', 'sub'],
  NARROWWEEKDAYS: ['N', 'P', 'U', 'S', '��', 'P', 'S'],
  STANDALONENARROWWEEKDAYS: ['n', 'p', 'u', 's', '��', 'p', 's'],
  SHORTQUARTERS: ['1kv', '2kv', '3kv', '4kv'],
  QUARTERS: ['1. kvartal', '2. kvartal', '3. kvartal', '4. kvartal'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d. MMMM y.', 'd. MMMM y.', 'd. M. y.', 'd.M.y.'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale hu.
 */
goog.i18n.DateTimeSymbols_hu = {
  ERAS: ['i. e.', 'i. sz.'],
  ERANAMES: ['id��sz��m��t��sunk el��tt', 'id��sz��m��t��sunk szerint'],
  NARROWMONTHS: ['J', 'F', 'M', '��', 'M', 'J', 'J', '��', 'Sz', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', '��', 'M', 'J', 'J', 'A', 'Sz', 'O',
    'N', 'D'],
  MONTHS: ['janu��r', 'febru��r', 'm��rcius', '��prilis', 'm��jus', 'j��nius',
    'j��lius', 'augusztus', 'szeptember', 'okt��ber', 'november', 'december'],
  STANDALONEMONTHS: ['janu��r', 'febru��r', 'm��rcius', '��prilis', 'm��jus',
    'j��nius', 'j��lius', 'augusztus', 'szeptember', 'okt��ber', 'november',
    'december'],
  SHORTMONTHS: ['jan.', 'febr.', 'm��rc.', '��pr.', 'm��j.', 'j��n.', 'j��l.',
    'aug.', 'szept.', 'okt.', 'nov.', 'dec.'],
  STANDALONESHORTMONTHS: ['jan.', 'febr.', 'm��rc.', '��pr.', 'm��j.', 'j��n.',
    'j��l.', 'aug.', 'szept.', 'okt.', 'nov.', 'dec.'],
  WEEKDAYS: ['vas��rnap', 'h��tf��', 'kedd', 'szerda', 'cs��t��rt��k',
    'p��ntek', 'szombat'],
  STANDALONEWEEKDAYS: ['vas��rnap', 'h��tf��', 'kedd', 'szerda', 'cs��t��rt��k',
    'p��ntek', 'szombat'],
  SHORTWEEKDAYS: ['V', 'H', 'K', 'Sze', 'Cs', 'P', 'Szo'],
  STANDALONESHORTWEEKDAYS: ['V', 'H', 'K', 'Sze', 'Cs', 'P', 'Szo'],
  NARROWWEEKDAYS: ['V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz'],
  STANDALONENARROWWEEKDAYS: ['V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz'],
  SHORTQUARTERS: ['N1', 'N2', 'N3', 'N4'],
  QUARTERS: ['I. negyed��v', 'II. negyed��v', 'III. negyed��v',
    'IV. negyed��v'],
  AMPMS: ['de.', 'du.'],
  DATEFORMATS: ['y. MMMM d., EEEE', 'y. MMMM d.', 'y.MM.dd.', 'y.MM.dd.'],
  TIMEFORMATS: ['H:mm:ss zzzz', 'H:mm:ss z', 'H:mm:ss', 'H:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale id.
 */
goog.i18n.DateTimeSymbols_id = {
  ERAS: ['SM', 'M'],
  ERANAMES: ['SM', 'M'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli',
    'Agustus', 'September', 'Oktober', 'November', 'Desember'],
  STANDALONEMONTHS: ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni',
    'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'Mei', 'Jun', 'Jul', 'Agt', 'Sep',
    'Okt', 'Nov', 'Des'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'Mei', 'Jun', 'Jul',
    'Agt', 'Sep', 'Okt', 'Nov', 'Des'],
  WEEKDAYS: ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu'],
  STANDALONEWEEKDAYS: ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat',
    'Sabtu'],
  SHORTWEEKDAYS: ['Min', 'Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab'],
  STANDALONESHORTWEEKDAYS: ['Min', 'Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab'],
  NARROWWEEKDAYS: ['M', 'S', 'S', 'R', 'K', 'J', 'S'],
  STANDALONENARROWWEEKDAYS: ['M', 'S', 'S', 'R', 'K', 'J', 'S'],
  SHORTQUARTERS: ['K1', 'K2', 'K3', 'K4'],
  QUARTERS: ['Kuartal ke-1', 'Kuartal ke-2', 'Kuartal ke-3', 'Kuartal ke-4'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, dd MMMM y', 'd MMMM y', 'd MMM y', 'dd/MM/yy'],
  TIMEFORMATS: ['HH.mm.ss zzzz', 'HH.mm.ss z', 'HH.mm.ss', 'HH.mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale in.
 */
goog.i18n.DateTimeSymbols_in = {
  ERAS: ['SM', 'M'],
  ERANAMES: ['SM', 'M'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli',
    'Agustus', 'September', 'Oktober', 'November', 'Desember'],
  STANDALONEMONTHS: ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni',
    'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'Mei', 'Jun', 'Jul', 'Agt', 'Sep',
    'Okt', 'Nov', 'Des'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'Mei', 'Jun', 'Jul',
    'Agt', 'Sep', 'Okt', 'Nov', 'Des'],
  WEEKDAYS: ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu'],
  STANDALONEWEEKDAYS: ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat',
    'Sabtu'],
  SHORTWEEKDAYS: ['Min', 'Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab'],
  STANDALONESHORTWEEKDAYS: ['Min', 'Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab'],
  NARROWWEEKDAYS: ['M', 'S', 'S', 'R', 'K', 'J', 'S'],
  STANDALONENARROWWEEKDAYS: ['M', 'S', 'S', 'R', 'K', 'J', 'S'],
  SHORTQUARTERS: ['K1', 'K2', 'K3', 'K4'],
  QUARTERS: ['Kuartal ke-1', 'Kuartal ke-2', 'Kuartal ke-3', 'Kuartal ke-4'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, dd MMMM y', 'd MMMM y', 'd MMM y', 'dd/MM/yy'],
  TIMEFORMATS: ['HH.mm.ss zzzz', 'HH.mm.ss z', 'HH.mm.ss', 'HH.mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale is.
 */
goog.i18n.DateTimeSymbols_is = {
  ERAS: ['f.Kr.', 'e.Kr.'],
  ERANAMES: ['fyrir Krist', 'eftir Krist'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', '��', 'L', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', '��', 'S', 'O',
    'N', 'D'],
  MONTHS: ['jan��ar', 'febr��ar', 'mars', 'apr��l', 'ma��', 'j��n��', 'j��l��',
    '��g��st', 'september', 'okt��ber', 'n��vember', 'desember'],
  STANDALONEMONTHS: ['jan��ar', 'febr��ar', 'mars', 'apr��l', 'ma��', 'j��n��',
    'j��l��', '��g��st', 'september', 'okt��ber', 'n��vember', 'desember'],
  SHORTMONTHS: ['jan', 'feb', 'mar', 'apr', 'ma��', 'j��n', 'j��l', '��g��',
    'sep', 'okt', 'n��v', 'des'],
  STANDALONESHORTMONTHS: ['jan', 'feb', 'mar', 'apr', 'ma��', 'j��n', 'j��l',
    '��g��', 'sep', 'okt', 'n��v', 'des'],
  WEEKDAYS: ['sunnudagur', 'm��nudagur', '��ri��judagur', 'mi��vikudagur',
    'fimmtudagur', 'f��studagur', 'laugardagur'],
  STANDALONEWEEKDAYS: ['sunnudagur', 'm��nudagur', '��ri��judagur',
    'mi��vikudagur', 'fimmtudagur', 'f��studagur', 'laugardagur'],
  SHORTWEEKDAYS: ['sun', 'm��n', '��ri', 'mi��', 'fim', 'f��s', 'lau'],
  STANDALONESHORTWEEKDAYS: ['sun', 'm��n', '��ri', 'mi��', 'fim', 'f��s',
    'lau'],
  NARROWWEEKDAYS: ['S', 'M', '��', 'M', 'F', 'F', 'L'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', '��', 'M', 'F', 'F', 'L'],
  SHORTQUARTERS: ['F1', 'F2', 'F3', 'F4'],
  QUARTERS: ['1. fj��r��ungur', '2. fj��r��ungur', '3. fj��r��ungur',
    '4. fj��r��ungur'],
  AMPMS: ['f.h.', 'e.h.'],
  DATEFORMATS: ['EEEE, d. MMMM y', 'd. MMMM y', 'd.M.y', 'd.M.y'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale it.
 */
goog.i18n.DateTimeSymbols_it = {
  ERAS: ['aC', 'dC'],
  ERANAMES: ['a.C.', 'd.C.'],  /* manual fix */
  NARROWMONTHS: ['G', 'F', 'M', 'A', 'M', 'G', 'L', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['G', 'F', 'M', 'A', 'M', 'G', 'L', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno',
    'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'],
  STANDALONEMONTHS: ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio',
    'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre',
    'Dicembre'],
  SHORTMONTHS: ['gen', 'feb', 'mar', 'apr', 'mag', 'giu', 'lug', 'ago', 'set',
    'ott', 'nov', 'dic'],
  STANDALONESHORTMONTHS: ['gen', 'feb', 'mar', 'apr', 'mag', 'giu', 'lug',
    'ago', 'set', 'ott', 'nov', 'dic'],
  WEEKDAYS: ['domenica', 'luned��', 'marted��', 'mercoled��', 'gioved��',
    'venerd��', 'sabato'],
  STANDALONEWEEKDAYS: ['Domenica', 'Luned��', 'Marted��', 'Mercoled��',
    'Gioved��', 'Venerd��', 'Sabato'],
  SHORTWEEKDAYS: ['dom', 'lun', 'mar', 'mer', 'gio', 'ven', 'sab'],
  STANDALONESHORTWEEKDAYS: ['dom', 'lun', 'mar', 'mer', 'gio', 'ven', 'sab'],
  NARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'G', 'V', 'S'],
  STANDALONENARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'G', 'V', 'S'],
  SHORTQUARTERS: ['T1', 'T2', 'T3', 'T4'],
  QUARTERS: ['1o trimestre', '2o trimestre', '3o trimestre', '4o trimestre'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE d MMMM y', 'dd MMMM y', 'dd/MMM/y', 'dd/MM/yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale iw.
 */
goog.i18n.DateTimeSymbols_iw = {
  ERAS: ['������������', '����������'],
  ERANAMES: ['�������� ������������', '������������'],
  NARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  STANDALONENARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
    '11', '12'],
  MONTHS: ['����������', '������������', '������', '����������', '������',
    '��������', '��������', '������������', '������������', '��������������',
    '������������', '����������'],
  STANDALONEMONTHS: ['����������', '������������', '������', '����������',
    '������', '��������', '��������', '������������', '������������',
    '��������������', '������������', '����������'],
  SHORTMONTHS: ['������', '������', '������', '������', '������', '������',
    '������', '������', '������', '������', '������', '������'],
  STANDALONESHORTMONTHS: ['��������', '��������', '������', '��������',
    '������', '��������', '��������', '��������', '��������', '��������',
    '��������', '��������'],
  WEEKDAYS: ['������ ����������', '������ ������', '������ ����������',
    '������ ����������', '������ ����������', '������ ��������',
    '������ ������'],
  STANDALONEWEEKDAYS: ['������ ����������', '������ ������',
    '������ ����������', '������ ����������', '������ ����������',
    '������ ��������', '������ ������'],
  SHORTWEEKDAYS: ['������ ����', '������ ����', '������ ����', '������ ����',
    '������ ����', '������ ����', '������'],
  STANDALONESHORTWEEKDAYS: ['������ ����', '������ ����', '������ ����',
    '������ ����', '������ ����', '������ ����', '������'],
  NARROWWEEKDAYS: ['��\'', '��\'', '��\'', '��\'', '��\'', '����', '����'],
  STANDALONENARROWWEEKDAYS: ['����', '����', '����', '����', '����', '��',
    '��'],
  SHORTQUARTERS: ['���������� 1', '���������� 2', '���������� 3',
    '���������� 4'],
  QUARTERS: ['���������� 1', '���������� 2', '���������� 3', '���������� 4'],
  AMPMS: ['������������', '����������'],
  DATEFORMATS: ['EEEE, d ��MMMM y', 'd ��MMMM y', 'd ��MMM y', 'dd/MM/yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [4, 5],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale ja.
 */
goog.i18n.DateTimeSymbols_ja = {
  ERAS: ['���������', '������'],
  ERANAMES: ['���������', '������'],
  NARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  STANDALONENARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
    '11', '12'],
  MONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���', '8���',
    '9���', '10���', '11���', '12���'],
  STANDALONEMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���',
    '8���', '9���', '10���', '11���', '12���'],
  SHORTMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���', '8���',
    '9���', '10���', '11���', '12���'],
  STANDALONESHORTMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���',
    '7���', '8���', '9���', '10���', '11���', '12���'],
  WEEKDAYS: ['���������', '���������', '���������', '���������', '���������',
    '���������', '���������'],
  STANDALONEWEEKDAYS: ['���������', '���������', '���������', '���������',
    '���������', '���������', '���������'],
  SHORTWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  STANDALONESHORTWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  NARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  STANDALONENARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  SHORTQUARTERS: ['1Q', '2Q', '3Q', '4Q'],
  QUARTERS: ['���1���������', '���2���������', '���3���������',
    '���4���������'],
  AMPMS: ['������', '������'],
  DATEFORMATS: ['y���M���d���EEEE', 'y���M���d���', 'y/MM/dd', 'y/MM/dd'],
  TIMEFORMATS: ['H���mm���ss��� zzzz', 'H:mm:ss z', 'H:mm:ss', 'H:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale kn.
 */
goog.i18n.DateTimeSymbols_kn = {
  ERAS: ['������������.������', '������������'],
  ERANAMES: ['������������������.', '��������������������� ������'],
  NARROWMONTHS: ['���', '������', '������', '���', '������', '������', '������',
    '���', '������', '���', '���', '������'],
  STANDALONENARROWMONTHS: ['���', '������', '������', '���', '������', '������',
    '������', '���', '������', '���', '���', '������'],
  MONTHS: ['���������������', '������������������������', '������������������',
    '���������������������', '������', '������������', '������������',
    '������������������', '���������������������������',
    '������������������������', '���������������������',
    '������������������������'],
  STANDALONEMONTHS: ['���������������', '������������������������',
    '������������������', '���������������������', '������', '������������',
    '������������', '������������������', '���������������������������',
    '������������������������', '���������������������',
    '������������������������'],
  SHORTMONTHS: ['���������������', '���������������������������',
    '������������������', '���������������������������', '������',
    '������������', '������������', '������������������',
    '���������������������������������', '������������������������',
    '���������������������', '������������������������'],
  STANDALONESHORTMONTHS: ['���������������', '���������������������������',
    '������������������', '���������������������������', '������',
    '������������', '������������', '������������������',
    '���������������������������������', '������������������������',
    '���������������������', '������������������������'],
  WEEKDAYS: ['������������������', '������������������',
    '���������������������', '������������������', '���������������������',
    '������������������������', '������������������'],
  STANDALONEWEEKDAYS: ['������������������', '������������������',
    '���������������������', '������������������', '���������������������',
    '������������������������', '������������������'],
  SHORTWEEKDAYS: ['���.', '������.', '������.', '������.', '������.', '������.',
    '���������.'],
  STANDALONESHORTWEEKDAYS: ['���.', '������.', '������.', '������.', '������.',
    '������.', '���������.'],
  NARROWWEEKDAYS: ['���', '������', '������', '������', '������', '������',
    '���'],
  STANDALONENARROWWEEKDAYS: ['���', '������', '������', '������', '������',
    '������', '���'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE d MMMM y', 'd MMMM y', 'd MMM y', 'd-M-yy'],
  TIMEFORMATS: ['hh:mm:ss a zzzz', 'hh:mm:ss a z', 'hh:mm:ss a', 'hh:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [6, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale ko.
 */
goog.i18n.DateTimeSymbols_ko = {
  ERAS: ['���������', '������'],
  ERANAMES: ['���������������', '������������'],
  NARROWMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���', '8���',
    '9���', '10���', '11���', '12���'],
  STANDALONENARROWMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���',
    '7���', '8���', '9���', '10���', '11���', '12���'],
  MONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���', '8���',
    '9���', '10���', '11���', '12���'],
  STANDALONEMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���',
    '8���', '9���', '10���', '11���', '12���'],
  SHORTMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���', '8���',
    '9���', '10���', '11���', '12���'],
  STANDALONESHORTMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���',
    '7���', '8���', '9���', '10���', '11���', '12���'],
  WEEKDAYS: ['���������', '���������', '���������', '���������', '���������',
    '���������', '���������'],
  STANDALONEWEEKDAYS: ['���������', '���������', '���������', '���������',
    '���������', '���������', '���������'],
  SHORTWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  STANDALONESHORTWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  NARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  STANDALONENARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  SHORTQUARTERS: ['1������', '2������', '3������', '4������'],
  QUARTERS: ['��� 1/4������', '��� 2/4������', '��� 3/4������',
    '��� 4/4������'],
  AMPMS: ['������', '������'],
  DATEFORMATS: ['y��� M��� d��� EEEE', 'y��� M��� d���', 'y. M. d.',
    'yy. M. d.'],
  TIMEFORMATS: ['a h��� m��� s��� zzzz', 'a h��� m��� s��� z', 'a h:mm:ss',
    'a h:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale ln.
 */
goog.i18n.DateTimeSymbols_ln = {
  ERAS: ['lib��so ya', 'nsima ya Y'],
  ERANAMES: ['Yambo ya Y��zu Kr��s', 'Nsima ya Y��zu Kr��s'],
  NARROWMONTHS: ['y', 'f', 'm', 'a', 'm', 'y', 'y', 'a', 's', '��', 'n', 'd'],
  STANDALONENARROWMONTHS: ['y', 'f', 'm', 'a', 'm', 'y', 'y', 'a', 's', '��',
    'n', 'd'],
  MONTHS: ['s��nz�� ya yambo', 's��nz�� ya m��bal��', 's��nz�� ya m��s��to',
    's��nz�� ya m��nei', 's��nz�� ya m��t��no', 's��nz�� ya mot��b��',
    's��nz�� ya nsambo', 's��nz�� ya mwambe', 's��nz�� ya libwa',
    's��nz�� ya z��mi', 's��nz�� ya z��mi na m����k����',
    's��nz�� ya z��mi na m��bal��'],
  STANDALONEMONTHS: ['s��nz�� ya yambo', 's��nz�� ya m��bal��',
    's��nz�� ya m��s��to', 's��nz�� ya m��nei', 's��nz�� ya m��t��no',
    's��nz�� ya mot��b��', 's��nz�� ya nsambo', 's��nz�� ya mwambe',
    's��nz�� ya libwa', 's��nz�� ya z��mi', 's��nz�� ya z��mi na m����k����',
    's��nz�� ya z��mi na m��bal��'],
  SHORTMONTHS: ['yan', 'fbl', 'msi', 'apl', 'mai', 'yun', 'yul', 'agt', 'stb',
    '��tb', 'nvb', 'dsb'],
  STANDALONESHORTMONTHS: ['yan', 'fbl', 'msi', 'apl', 'mai', 'yun', 'yul',
    'agt', 'stb', '��tb', 'nvb', 'dsb'],
  WEEKDAYS: ['eyenga', 'mok��l�� mwa yambo', 'mok��l�� mwa m��bal��',
    'mok��l�� mwa m��s��to', 'mok��l�� ya m��n��i', 'mok��l�� ya m��t��no',
    'mp����s��'],
  STANDALONEWEEKDAYS: ['eyenga', 'mok��l�� mwa yambo', 'mok��l�� mwa m��bal��',
    'mok��l�� mwa m��s��to', 'mok��l�� ya m��n��i', 'mok��l�� ya m��t��no',
    'mp����s��'],
  SHORTWEEKDAYS: ['eye', 'ybo', 'mbl', 'mst', 'min', 'mtn', 'mps'],
  STANDALONESHORTWEEKDAYS: ['eye', 'ybo', 'mbl', 'mst', 'min', 'mtn', 'mps'],
  NARROWWEEKDAYS: ['e', 'y', 'm', 'm', 'm', 'm', 'p'],
  STANDALONENARROWWEEKDAYS: ['e', 'y', 'm', 'm', 'm', 'm', 'p'],
  SHORTQUARTERS: ['SM1', 'SM2', 'SM3', 'SM4'],
  QUARTERS: ['s��nz�� m��s��to ya yambo', 's��nz�� m��s��to ya m��bal��',
    's��nz�� m��s��to ya m��s��to', 's��nz�� m��s��to ya m��nei'],
  AMPMS: ['nt����ng����', 'mp��kwa'],
  DATEFORMATS: ['EEEE d MMMM y', 'd MMMM y', 'd MMM y', 'd/M/y'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale lt.
 */
goog.i18n.DateTimeSymbols_lt = {
  ERAS: ['pr. Kr.', 'po Kr.'],
  ERANAMES: ['prie�� Krist��', 'po Kristaus'],
  NARROWMONTHS: ['S', 'V', 'K', 'B', 'G', 'B', 'L', 'R', 'R', 'S', 'L', 'G'],
  STANDALONENARROWMONTHS: ['S', 'V', 'K', 'B', 'G', 'B', 'L', 'R', 'R', 'S',
    'L', 'G'],
  MONTHS: ['sausis', 'vasaris', 'kovas', 'balandis', 'gegu����', 'bir��elis',
    'liepa', 'rugpj��tis', 'rugs��jis', 'spalis', 'lapkritis', 'gruodis'],
  STANDALONEMONTHS: ['sausis', 'vasaris', 'kovas', 'balandis', 'gegu����',
    'bir��elis', 'liepa', 'rugpj��tis', 'rugs��jis', 'spalis', 'lapkritis',
    'gruodis'],
  SHORTMONTHS: ['saus.', 'vas.', 'kov.', 'bal.', 'geg.', 'bir��.', 'liep.',
    'rugp.', 'rugs.', 'spal.', 'lapkr.', 'gruod.'],
  STANDALONESHORTMONTHS: ['saus.', 'vas.', 'kov.', 'bal.', 'geg.', 'bir��.',
    'liep.', 'rugp.', 'rugs.', 'spal.', 'lapkr.', 'gruod.'],
  WEEKDAYS: ['sekmadienis', 'pirmadienis', 'antradienis', 'tre��iadienis',
    'ketvirtadienis', 'penktadienis', '��e��tadienis'],
  STANDALONEWEEKDAYS: ['sekmadienis', 'pirmadienis', 'antradienis',
    'tre��iadienis', 'ketvirtadienis', 'penktadienis', '��e��tadienis'],
  SHORTWEEKDAYS: ['sk', 'pr', 'an', 'tr', 'kt', 'pn', '��t'],
  STANDALONESHORTWEEKDAYS: ['sk', 'pr', 'an', 'tr', 'kt', 'pn', '��t'],
  NARROWWEEKDAYS: ['S', 'P', 'A', 'T', 'K', 'P', '��'],
  STANDALONENARROWWEEKDAYS: ['S', 'P', 'A', 'T', 'K', 'P', '��'],
  SHORTQUARTERS: ['I k.', 'II k.', 'III k.', 'IV k.'],
  QUARTERS: ['I ketvirtis', 'II ketvirtis', 'III ketvirtis', 'IV ketvirtis'],
  AMPMS: ['prie��piet', 'popiet'],
  DATEFORMATS: ['y \'m\'. MMMM d \'d\'., EEEE', 'y \'m\'. MMMM d \'d\'.',
    'y MMM d', 'y-MM-dd'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale lv.
 */
goog.i18n.DateTimeSymbols_lv = {
  ERAS: ['p.m.��.', 'm.��.'],
  ERANAMES: ['pirms m��su ��ras', 'm��su ��r��'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['janv��ris', 'febru��ris', 'marts', 'apr��lis', 'maijs', 'j��nijs',
    'j��lijs', 'augusts', 'septembris', 'oktobris', 'novembris', 'decembris'],
  STANDALONEMONTHS: ['Janv��ris', 'Febru��ris', 'Marts', 'Apr��lis', 'Maijs',
    'J��nijs', 'J��lijs', 'Augusts', 'Septembris', 'Oktobris', 'Novembris',
    'Decembris'],
  SHORTMONTHS: ['janv.', 'febr.', 'marts', 'apr.', 'maijs', 'j��n.', 'j��l.',
    'aug.', 'sept.', 'okt.', 'nov.', 'dec.'],
  STANDALONESHORTMONTHS: ['Janv.', 'Febr.', 'Marts', 'Apr.', 'Maijs', 'J��n.',
    'J��l.', 'Aug.', 'Sept.', 'Okt.', 'Nov.', 'Dec.'],
  WEEKDAYS: ['sv��tdiena', 'pirmdiena', 'otrdiena', 'tre��diena', 'ceturtdiena',
    'piektdiena', 'sestdiena'],
  STANDALONEWEEKDAYS: ['Sv��tdiena', 'Pirmdiena', 'Otrdiena', 'Tre��diena',
    'Ceturtdiena', 'Piektdiena', 'Sestdiena'],
  SHORTWEEKDAYS: ['Sv', 'Pr', 'Ot', 'Tr', 'Ce', 'Pk', 'Se'],
  STANDALONESHORTWEEKDAYS: ['Sv', 'Pr', 'Ot', 'Tr', 'Ce', 'Pk', 'Se'],
  NARROWWEEKDAYS: ['S', 'P', 'O', 'T', 'C', 'P', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'P', 'O', 'T', 'C', 'P', 'S'],
  SHORTQUARTERS: ['C1', 'C2', 'C3', 'C4'],
  QUARTERS: ['1. ceturksnis', '2. ceturksnis', '3. ceturksnis',
    '4. ceturksnis'],
  AMPMS: ['priek��pusdien��', 'p��cpusdien��'],
  DATEFORMATS: ['EEEE, y. \'gada\' d. MMMM', 'y. \'gada\' d. MMMM',
    'y. \'gada\' d. MMM', 'dd.MM.yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale ml.
 */
goog.i18n.DateTimeSymbols_ml = {
  ERAS: ['������������.������', '������������.������.'],
  ERANAMES: ['��������������������������������������� ���������������������',
    '������������������������������������ ���������������'],
  NARROWMONTHS: ['���', '������', '������', '���', '������', '������', '������',
    '���', '������', '���', '���', '������'],
  STANDALONENARROWMONTHS: ['���', '������', '������', '���', '������', '������',
    '������', '���', '������', '���', '���', '������'],
  MONTHS: ['������������������', '���������������������������',
    '���������������������', '������������������', '������������', '���������',
    '������������', '������������������������',
    '������������������������������', '���������������������',
    '���������������', '������������������'],
  STANDALONEMONTHS: ['������������������', '���������������������������',
    '���������������������', '������������������', '������������', '���������',
    '������������', '������������������������',
    '������������������������������', '���������������������',
    '���������������', '������������������'],
  SHORTMONTHS: ['���������', '������������������', '���������',
    '���������������', '������������', '���������', '������������', '������',
    '������������������������', '���������������', '���������', '������������'],
  STANDALONESHORTMONTHS: ['���������', '������������������', '���������',
    '���������������', '������������', '���������', '������������', '������',
    '������������������������', '���������������', '���������', '������������'],
  WEEKDAYS: ['������������������������', '������������������������������',
    '���������������������������', '������������������������',
    '���������������������������', '���������������������������������',
    '������������������������'],
  STANDALONEWEEKDAYS: ['������������������������',
    '������������������������������', '���������������������������',
    '������������������������', '���������������������������',
    '���������������������������������', '������������������������'],
  SHORTWEEKDAYS: ['������������', '������������������', '���������������',
    '������������', '������������������', '������������������', '���������'],
  STANDALONESHORTWEEKDAYS: ['������������', '������������������',
    '���������������', '������������', '������������������',
    '������������������', '���������'],
  NARROWWEEKDAYS: ['������', '������', '������', '������', '������������',
    '������', '���'],
  STANDALONENARROWWEEKDAYS: ['������', '������', '������', '������',
    '������������', '������', '���'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['������������������ ������������',
    '������������������ ������������', '��������������������� ������������',
    '��������������� ������������'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['y, MMMM d, EEEE', 'y, MMMM d', 'y, MMM d', 'dd/MM/yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [6, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale mr.
 */
goog.i18n.DateTimeSymbols_mr = {
  ZERODIGIT: 0x0966,
  ERAS: ['������������������������', '������'],
  ERANAMES: ['���������������������������������', '������������������'],
  NARROWMONTHS: ['������', '������', '������', '���', '������', '������',
    '������', '���', '���', '���', '������', '������'],
  STANDALONENARROWMONTHS: ['������', '������', '������', '���', '������',
    '������', '������', '���', '���', '���', '������', '������'],
  MONTHS: ['������������������������', '������������������������������',
    '���������������', '������������������', '������', '���������',
    '������������', '���������������', '������������������������',
    '���������������������', '���������������������������',
    '���������������������'],
  STANDALONEMONTHS: ['������������������������',
    '������������������������������', '���������������', '������������������',
    '������', '���������', '������������', '���������������',
    '������������������������', '���������������������',
    '���������������������������', '���������������������'],
  SHORTMONTHS: ['������������', '������������������', '���������������',
    '���������������', '������', '���������', '������������', '������',
    '���������������������', '������������', '���������������������',
    '���������������'],
  STANDALONESHORTMONTHS: ['������������', '������������������',
    '���������������', '���������������', '������', '���������', '������������',
    '������', '���������������������', '������������', '���������������������',
    '���������������'],
  WEEKDAYS: ['������������������', '������������������',
    '���������������������', '������������������', '���������������������',
    '������������������������', '������������������'],
  STANDALONEWEEKDAYS: ['������������������', '������������������',
    '���������������������', '������������������', '���������������������',
    '������������������������', '������������������'],
  SHORTWEEKDAYS: ['���������', '���������', '������������', '���������',
    '������������', '���������������', '���������'],
  STANDALONESHORTWEEKDAYS: ['���������', '���������', '������������',
    '���������', '������������', '���������������', '���������'],
  NARROWWEEKDAYS: ['���', '������', '������', '������', '������', '������',
    '���'],
  STANDALONENARROWWEEKDAYS: ['���', '������', '������', '������', '������',
    '������', '���'],
  SHORTQUARTERS: ['������ 1', '������ 2', '������ 3', '������ 4'],
  QUARTERS: ['��������������� ������������������',
    '��������������������� ������������������',
    '��������������� ������������������',
    '������������������ ������������������'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE d MMMM y', 'd MMMM y', 'd MMM y', 'd-M-yy'],
  TIMEFORMATS: ['h-mm-ss a zzzz', 'h-mm-ss a z', 'h-mm-ss a', 'h-mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [6, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale ms.
 */
goog.i18n.DateTimeSymbols_ms = {
  ERAS: ['S.M.', 'TM'],
  ERANAMES: ['S.M.', 'TM'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'O', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'O', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Januari', 'Februari', 'Mac', 'April', 'Mei', 'Jun', 'Julai', 'Ogos',
    'September', 'Oktober', 'November', 'Disember'],
  STANDALONEMONTHS: ['Januari', 'Februari', 'Mac', 'April', 'Mei', 'Jun',
    'Julai', 'Ogos', 'September', 'Oktober', 'November', 'Disember'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mac', 'Apr', 'Mei', 'Jun', 'Jul', 'Ogos', 'Sep',
    'Okt', 'Nov', 'Dis'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mac', 'Apr', 'Mei', 'Jun', 'Jul',
    'Ogos', 'Sep', 'Okt', 'Nov', 'Dis'],
  WEEKDAYS: ['Ahad', 'Isnin', 'Selasa', 'Rabu', 'Khamis', 'Jumaat', 'Sabtu'],
  STANDALONEWEEKDAYS: ['Ahad', 'Isnin', 'Selasa', 'Rabu', 'Khamis', 'Jumaat',
    'Sabtu'],
  SHORTWEEKDAYS: ['Ahd', 'Isn', 'Sel', 'Rab', 'Kha', 'Jum', 'Sab'],
  STANDALONESHORTWEEKDAYS: ['Ahd', 'Isn', 'Sel', 'Rab', 'Kha', 'Jum', 'Sab'],
  NARROWWEEKDAYS: ['A', 'I', 'S', 'R', 'K', 'J', 'S'],
  STANDALONENARROWWEEKDAYS: ['A', 'I', 'S', 'R', 'K', 'J', 'S'],
  SHORTQUARTERS: ['Suku 1', 'Suku Ke-2', 'Suku Ke-3', 'Suku Ke-4'],
  QUARTERS: ['Suku pertama', 'Suku Ke-2', 'Suku Ke-3', 'Suku Ke-4'],
  AMPMS: ['PG', 'PTG'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'dd/MM/y', 'd/MM/yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale mt.
 */
goog.i18n.DateTimeSymbols_mt = {
  ERAS: ['QK', 'WK'],
  ERANAMES: ['Qabel Kristu', 'Wara Kristu'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', '��', 'L', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', '��', 'L', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Jannar', 'Frar', 'Marzu', 'April', 'Mejju', '��unju', 'Lulju',
    'Awwissu', 'Settembru', 'Ottubru', 'Novembru', 'Di��embru'],
  STANDALONEMONTHS: ['Jannar', 'Frar', 'Marzu', 'April', 'Mejju', '��unju',
    'Lulju', 'Awwissu', 'Settembru', 'Ottubru', 'Novembru', 'Di��embru'],
  SHORTMONTHS: ['Jan', 'Fra', 'Mar', 'Apr', 'Mej', '��un', 'Lul', 'Aww', 'Set',
    'Ott', 'Nov', 'Di��'],
  STANDALONESHORTMONTHS: ['Jan', 'Fra', 'Mar', 'Apr', 'Mej', '��un', 'Lul',
    'Aww', 'Set', 'Ott', 'Nov', 'Di��'],
  WEEKDAYS: ['Il-��add', 'It-Tnejn', 'It-Tlieta', 'L-Erbg��a', 'Il-��amis',
    'Il-��img��a', 'Is-Sibt'],
  STANDALONEWEEKDAYS: ['Il-��add', 'It-Tnejn', 'It-Tlieta', 'L-Erbg��a',
    'Il-��amis', 'Il-��img��a', 'Is-Sibt'],
  SHORTWEEKDAYS: ['��ad', 'Tne', 'Tli', 'Erb', '��am', '��im', 'Sib'],
  STANDALONESHORTWEEKDAYS: ['��ad', 'Tne', 'Tli', 'Erb', '��am', '��im', 'Sib'],
  NARROWWEEKDAYS: ['��', 'T', 'T', 'E', '��', '��', 'S'],
  STANDALONENARROWWEEKDAYS: ['��', 'T', 'T', 'E', '��', '��', 'S'],
  SHORTQUARTERS: ['K1', 'K2', 'K3', 'K4'],
  QUARTERS: ['K1', 'K2', 'K3', 'K4'],
  AMPMS: ['QN', 'WN'],
  DATEFORMATS: ['EEEE, d \'ta\'��� MMMM y', 'd \'ta\'��� MMMM y', 'dd MMM y',
    'dd/MM/y'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale nb.
 */
goog.i18n.DateTimeSymbols_nb = {
  ERAS: ['f.Kr.', 'e.Kr.'],
  ERANAMES: ['f.Kr.', 'e.Kr.'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['januar', 'februar', 'mars', 'april', 'mai', 'juni', 'juli',
    'august', 'september', 'oktober', 'november', 'desember'],
  STANDALONEMONTHS: ['januar', 'februar', 'mars', 'april', 'mai', 'juni',
    'juli', 'august', 'september', 'oktober', 'november', 'desember'],
  SHORTMONTHS: ['jan.', 'feb.', 'mars', 'apr.', 'mai', 'juni', 'juli', 'aug.',
    'sep.', 'okt.', 'nov.', 'des.'],
  STANDALONESHORTMONTHS: ['jan', 'feb', 'mar', 'apr', 'mai', 'jun', 'jul',
    'aug', 'sep', 'okt', 'nov', 'des'],
  WEEKDAYS: ['s��ndag', 'mandag', 'tirsdag', 'onsdag', 'torsdag', 'fredag',
    'l��rdag'],
  STANDALONEWEEKDAYS: ['s��ndag', 'mandag', 'tirsdag', 'onsdag', 'torsdag',
    'fredag', 'l��rdag'],
  SHORTWEEKDAYS: ['s��n.', 'man.', 'tir.', 'ons.', 'tor.', 'fre.', 'l��r.'],
  STANDALONESHORTWEEKDAYS: ['s��.', 'ma.', 'ti.', 'on.', 'to.', 'fr.', 'l��.'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  SHORTQUARTERS: ['K1', 'K2', 'K3', 'K4'],
  QUARTERS: ['1. kvartal', '2. kvartal', '3. kvartal', '4. kvartal'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE d. MMMM y', 'd. MMMM y', 'd. MMM y', 'dd.MM.yy'],
  TIMEFORMATS: ['\'kl\'. HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} \'kl.\' {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale nl.
 */
goog.i18n.DateTimeSymbols_nl = {
  ERAS: ['v.Chr.', 'n.Chr.'],
  ERANAMES: ['Voor Christus', 'na Christus'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli',
    'augustus', 'september', 'oktober', 'november', 'december'],
  STANDALONEMONTHS: ['januari', 'februari', 'maart', 'april', 'mei', 'juni',
    'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
  SHORTMONTHS: ['jan.', 'feb.', 'mrt.', 'apr.', 'mei', 'jun.', 'jul.', 'aug.',
    'sep.', 'okt.', 'nov.', 'dec.'],
  STANDALONESHORTMONTHS: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul',
    'aug', 'sep', 'okt', 'nov', 'dec'],
  WEEKDAYS: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag',
    'zaterdag'],
  STANDALONEWEEKDAYS: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag',
    'vrijdag', 'zaterdag'],
  SHORTWEEKDAYS: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
  STANDALONESHORTWEEKDAYS: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
  NARROWWEEKDAYS: ['Z', 'M', 'D', 'W', 'D', 'V', 'Z'],
  STANDALONENARROWWEEKDAYS: ['Z', 'M', 'D', 'W', 'D', 'V', 'Z'],
  SHORTQUARTERS: ['K1', 'K2', 'K3', 'K4'],
  QUARTERS: ['1e kwartaal', '2e kwartaal', '3e kwartaal', '4e kwartaal'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE d MMMM y', 'd MMMM y', 'd MMM y', 'dd-MM-yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale no.
 */
goog.i18n.DateTimeSymbols_no = {
  ERAS: ['f.Kr.', 'e.Kr.'],
  ERANAMES: ['f.Kr.', 'e.Kr.'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['januar', 'februar', 'mars', 'april', 'mai', 'juni', 'juli',
    'august', 'september', 'oktober', 'november', 'desember'],
  STANDALONEMONTHS: ['januar', 'februar', 'mars', 'april', 'mai', 'juni',
    'juli', 'august', 'september', 'oktober', 'november', 'desember'],
  SHORTMONTHS: ['jan.', 'feb.', 'mars', 'apr.', 'mai', 'juni', 'juli', 'aug.',
    'sep.', 'okt.', 'nov.', 'des.'],
  STANDALONESHORTMONTHS: ['jan', 'feb', 'mar', 'apr', 'mai', 'jun', 'jul',
    'aug', 'sep', 'okt', 'nov', 'des'],
  WEEKDAYS: ['s��ndag', 'mandag', 'tirsdag', 'onsdag', 'torsdag', 'fredag',
    'l��rdag'],
  STANDALONEWEEKDAYS: ['s��ndag', 'mandag', 'tirsdag', 'onsdag', 'torsdag',
    'fredag', 'l��rdag'],
  SHORTWEEKDAYS: ['s��n.', 'man.', 'tir.', 'ons.', 'tor.', 'fre.', 'l��r.'],
  STANDALONESHORTWEEKDAYS: ['s��.', 'ma.', 'ti.', 'on.', 'to.', 'fr.', 'l��.'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  SHORTQUARTERS: ['K1', 'K2', 'K3', 'K4'],
  QUARTERS: ['1. kvartal', '2. kvartal', '3. kvartal', '4. kvartal'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE d. MMMM y', 'd. MMMM y', 'd. MMM y', 'dd.MM.yy'],
  TIMEFORMATS: ['\'kl\'. HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} \'kl.\' {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale or.
 */
goog.i18n.DateTimeSymbols_or = {
  ERAS: ['BCE', 'CE'],
  ERANAMES: ['BCE', 'CE'],
  NARROWMONTHS: ['������', '������', '������', '���', '������', '������',
    '������', '���', '������', '���', '���', '������'],
  STANDALONENARROWMONTHS: ['������', '������', '������', '���', '������',
    '������', '������', '���', '������', '���', '���', '������'],
  MONTHS: ['���������������������', '������������������������������',
    '���������������������', '������������������', '������', '���������',
    '���������������', '���������������', '������������������������������',
    '���������������������', '���������������������',
    '������������������������'],
  STANDALONEMONTHS: ['���������������������', '������������������������������',
    '���������������������', '������������������', '������', '���������',
    '���������������', '���������������', '������������������������������',
    '���������������������', '���������������������',
    '������������������������'],
  SHORTMONTHS: ['���������������������', '������������������������������',
    '���������������������', '������������������', '������', '���������',
    '���������������', '���������������', '������������������������������',
    '���������������������', '���������������������',
    '������������������������'],
  STANDALONESHORTMONTHS: ['���������������������',
    '������������������������������', '���������������������',
    '������������������', '������', '���������', '���������������',
    '���������������', '������������������������������',
    '���������������������', '���������������������',
    '������������������������'],
  WEEKDAYS: ['������������������', '������������������',
    '������������������������', '������������������', '���������������������',
    '������������������������', '������������������'],
  STANDALONEWEEKDAYS: ['������������������', '������������������',
    '������������������������', '������������������', '���������������������',
    '������������������������', '������������������'],
  SHORTWEEKDAYS: ['���������', '���������', '���������������', '���������',
    '������������', '���������������', '���������'],
  STANDALONESHORTWEEKDAYS: ['���������', '���������', '���������������',
    '���������', '������������', '���������������', '���������'],
  NARROWWEEKDAYS: ['���', '������', '���', '������', '������', '������', '���'],
  STANDALONENARROWWEEKDAYS: ['���', '������', '���', '������', '������',
    '������', '���'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  AMPMS: ['am', 'pm'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'd MMM y', 'd-M-yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [6, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale pl.
 */
goog.i18n.DateTimeSymbols_pl = {
  ERAS: ['p.n.e.', 'n.e.'],
  ERANAMES: ['p.n.e.', 'n.e.'],
  NARROWMONTHS: ['s', 'l', 'm', 'k', 'm', 'c', 'l', 's', 'w', 'p', 'l', 'g'],
  STANDALONENARROWMONTHS: ['s', 'l', 'm', 'k', 'm', 'c', 'l', 's', 'w', 'p',
    'l', 'g'],
  MONTHS: ['stycznia', 'lutego', 'marca', 'kwietnia', 'maja', 'czerwca',
    'lipca', 'sierpnia', 'wrze��nia', 'pa��dziernika', 'listopada', 'grudnia'],
  STANDALONEMONTHS: ['stycze��', 'luty', 'marzec', 'kwiecie��', 'maj',
    'czerwiec', 'lipiec', 'sierpie��', 'wrzesie��', 'pa��dziernik', 'listopad',
    'grudzie��'],
  SHORTMONTHS: ['sty', 'lut', 'mar', 'kwi', 'maj', 'cze', 'lip', 'sie', 'wrz',
    'pa��', 'lis', 'gru'],
  STANDALONESHORTMONTHS: ['sty', 'lut', 'mar', 'kwi', 'maj', 'cze', 'lip',
    'sie', 'wrz', 'pa��', 'lis', 'gru'],
  WEEKDAYS: ['niedziela', 'poniedzia��ek', 'wtorek', '��roda', 'czwartek',
    'pi��tek', 'sobota'],
  STANDALONEWEEKDAYS: ['niedziela', 'poniedzia��ek', 'wtorek', '��roda',
    'czwartek', 'pi��tek', 'sobota'],
  SHORTWEEKDAYS: ['niedz.', 'pon.', 'wt.', '��r.', 'czw.', 'pt.', 'sob.'],
  STANDALONESHORTWEEKDAYS: ['niedz.', 'pon.', 'wt.', '��r.', 'czw.', 'pt.',
    'sob.'],
  NARROWWEEKDAYS: ['N', 'P', 'W', '��', 'C', 'P', 'S'],
  STANDALONENARROWWEEKDAYS: ['N', 'P', 'W', '��', 'C', 'P', 'S'],
  SHORTQUARTERS: ['K1', 'K2', 'K3', 'K4'],
  QUARTERS: ['I kwarta��', 'II kwarta��', 'III kwarta��', 'IV kwarta��'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'd MMM y', 'dd.MM.y'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale pt.
 */
goog.i18n.DateTimeSymbols_pt = {
  ERAS: ['a.C.', 'd.C.'],
  ERANAMES: ['Antes de Cristo', 'Ano do Senhor'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['janeiro', 'fevereiro', 'mar��o', 'abril', 'maio', 'junho', 'julho',
    'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'],
  STANDALONEMONTHS: ['janeiro', 'fevereiro', 'mar��o', 'abril', 'maio', 'junho',
    'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'],
  SHORTMONTHS: ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set',
    'out', 'nov', 'dez'],
  STANDALONESHORTMONTHS: ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul',
    'ago', 'set', 'out', 'nov', 'dez'],
  WEEKDAYS: ['domingo', 'segunda-feira', 'ter��a-feira', 'quarta-feira',
    'quinta-feira', 'sexta-feira', 's��bado'],
  STANDALONEWEEKDAYS: ['domingo', 'segunda-feira', 'ter��a-feira',
    'quarta-feira', 'quinta-feira', 'sexta-feira', 's��bado'],
  SHORTWEEKDAYS: ['dom', 'seg', 'ter', 'qua', 'qui', 'sex', 's��b'],
  STANDALONESHORTWEEKDAYS: ['dom', 'seg', 'ter', 'qua', 'qui', 'sex', 's��b'],
  NARROWWEEKDAYS: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
  STANDALONENARROWWEEKDAYS: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
  SHORTQUARTERS: ['T1', 'T2', 'T3', 'T4'],
  QUARTERS: ['1�� trimestre', '2�� trimestre', '3�� trimestre',
    '4�� trimestre'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d \'de\' MMMM \'de\' y', 'd \'de\' MMMM \'de\' y',
    'dd/MM/y', 'dd/MM/yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale pt_BR.
 */
goog.i18n.DateTimeSymbols_pt_BR = goog.i18n.DateTimeSymbols_pt;


/**
 * Date/time formatting symbols for locale pt_PT.
 */
goog.i18n.DateTimeSymbols_pt_PT = {
  ERAS: ['a.C.', 'd.C.'],
  ERANAMES: ['Antes de Cristo', 'Ano do Senhor'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Janeiro', 'Fevereiro', 'Mar��o', 'Abril', 'Maio', 'Junho', 'Julho',
    'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
  STANDALONEMONTHS: ['Janeiro', 'Fevereiro', 'Mar��o', 'Abril', 'Maio', 'Junho',
    'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
  SHORTMONTHS: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set',
    'Out', 'Nov', 'Dez'],
  STANDALONESHORTMONTHS: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul',
    'Ago', 'Set', 'Out', 'Nov', 'Dez'],
  WEEKDAYS: ['Domingo', 'Segunda-feira', 'Ter��a-feira', 'Quarta-feira',
    'Quinta-feira', 'Sexta-feira', 'S��bado'],
  STANDALONEWEEKDAYS: ['Domingo', 'Segunda-feira', 'Ter��a-feira',
    'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'S��bado'],
  SHORTWEEKDAYS: ['dom', 'seg', 'ter', 'qua', 'qui', 'sex', 's��b'],
  STANDALONESHORTWEEKDAYS: ['dom', 'seg', 'ter', 'qua', 'qui', 'sex', 's��b'],
  NARROWWEEKDAYS: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
  STANDALONENARROWWEEKDAYS: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
  SHORTQUARTERS: ['T1', 'T2', 'T3', 'T4'],
  QUARTERS: ['1.�� trimestre', '2.�� trimestre', '3.�� trimestre',
    '4.�� trimestre'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d \'de\' MMMM \'de\' y', 'd \'de\' MMMM \'de\' y',
    'dd/MM/y', 'dd/MM/yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} \'��s\' {0}', '{1} \'��s\' {0}', '{1}, {0}',
    '{1}, {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale ro.
 */
goog.i18n.DateTimeSymbols_ro = {
  ERAS: ['��.Hr.', 'd.Hr.'],
  ERANAMES: ['��nainte de Hristos', 'dup�� Hristos'],
  NARROWMONTHS: ['I', 'F', 'M', 'A', 'M', 'I', 'I', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['I', 'F', 'M', 'A', 'M', 'I', 'I', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['ianuarie', 'februarie', 'martie', 'aprilie', 'mai', 'iunie',
    'iulie', 'august', 'septembrie', 'octombrie', 'noiembrie', 'decembrie'],
  STANDALONEMONTHS: ['ianuarie', 'februarie', 'martie', 'aprilie', 'mai',
    'iunie', 'iulie', 'august', 'septembrie', 'octombrie', 'noiembrie',
    'decembrie'],
  SHORTMONTHS: ['ian.', 'feb.', 'mar.', 'apr.', 'mai', 'iun.', 'iul.', 'aug.',
    'sept.', 'oct.', 'nov.', 'dec.'],
  STANDALONESHORTMONTHS: ['ian.', 'feb.', 'mar.', 'apr.', 'mai', 'iun.', 'iul.',
    'aug.', 'sept.', 'oct.', 'nov.', 'dec.'],
  WEEKDAYS: ['duminic��', 'luni', 'mar��i', 'miercuri', 'joi', 'vineri',
    's��mb��t��'],
  STANDALONEWEEKDAYS: ['duminic��', 'luni', 'mar��i', 'miercuri', 'joi',
    'vineri', 's��mb��t��'],
  SHORTWEEKDAYS: ['Du', 'Lu', 'Ma', 'Mi', 'Jo', 'Vi', 'S��'],
  STANDALONESHORTWEEKDAYS: ['Du', 'Lu', 'Ma', 'Mi', 'Jo', 'Vi', 'S��'],
  NARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  STANDALONENARROWWEEKDAYS: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  SHORTQUARTERS: ['trim. I', 'trim. II', 'trim. III', 'trim. IV'],
  QUARTERS: ['trimestrul I', 'trimestrul al II-lea', 'trimestrul al III-lea',
    'trimestrul al IV-lea'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'dd.MM.y', 'dd.MM.y'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1}, {0}', '{1}, {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale ru.
 */
goog.i18n.DateTimeSymbols_ru = {
  ERAS: ['���� ��.��.', '��.��.'],
  ERANAMES: ['���� ��.��.', '��.��.'],
  NARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��'],
  STANDALONENARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��', '��'],
  MONTHS: ['������������', '��������������', '����������', '������������',
    '������', '��������', '��������', '��������������', '����������������',
    '��������������', '������������', '��������������'],
  STANDALONEMONTHS: ['������������', '��������������', '��������',
    '������������', '������', '��������', '��������', '������������',
    '����������������', '��������������', '������������', '��������������'],
  SHORTMONTHS: ['������.', '��������.', '����������', '������.', '������',
    '��������', '��������', '������.', '��������.', '������.', '��������.',
    '������.'],
  STANDALONESHORTMONTHS: ['������.', '��������.', '��������', '������.',
    '������', '��������', '��������', '������.', '��������.', '������.',
    '��������.', '������.'],
  WEEKDAYS: ['����������������������', '����������������������',
    '��������������', '����������', '��������������', '��������������',
    '��������������'],
  STANDALONEWEEKDAYS: ['����������������������', '����������������������',
    '��������������', '����������', '��������������', '��������������',
    '��������������'],
  SHORTWEEKDAYS: ['����', '����', '����', '����', '����', '����', '����'],
  STANDALONESHORTWEEKDAYS: ['����', '����', '����', '����', '����', '����',
    '����'],
  NARROWWEEKDAYS: ['����', '����', '����', '����', '����', '����', '����'],
  STANDALONENARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  SHORTQUARTERS: ['1-�� ����.', '2-�� ����.', '3-�� ����.', '4-�� ����.'],
  QUARTERS: ['1-�� ��������������', '2-�� ��������������',
    '3-�� ��������������', '4-�� ��������������'],
  AMPMS: ['���� ��������������', '���������� ��������������'],
  DATEFORMATS: ['EEEE, d MMMM y \'��\'.', 'd MMMM y \'��\'.',
    'dd MMM y \'��\'.', 'dd.MM.yy'],
  TIMEFORMATS: ['H:mm:ss zzzz', 'H:mm:ss z', 'H:mm:ss', 'H:mm'],
  DATETIMEFORMATS: ['{1}, {0}', '{1}, {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale sk.
 */
goog.i18n.DateTimeSymbols_sk = {
  ERAS: ['pred n.l.', 'n.l.'],
  ERANAMES: ['pred n.l.', 'n.l.'],
  NARROWMONTHS: ['j', 'f', 'm', 'a', 'm', 'j', 'j', 'a', 's', 'o', 'n', 'd'],
  STANDALONENARROWMONTHS: ['j', 'f', 'm', 'a', 'm', 'j', 'j', 'a', 's', 'o',
    'n', 'd'],
  MONTHS: ['janu��ra', 'febru��ra', 'marca', 'apr��la', 'm��ja', 'j��na',
    'j��la', 'augusta', 'septembra', 'okt��bra', 'novembra', 'decembra'],
  STANDALONEMONTHS: ['janu��r', 'febru��r', 'marec', 'apr��l', 'm��j', 'j��n',
    'j��l', 'august', 'september', 'okt��ber', 'november', 'december'],
  SHORTMONTHS: ['jan', 'feb', 'mar', 'apr', 'm��j', 'j��n', 'j��l', 'aug',
    'sep', 'okt', 'nov', 'dec'],
  STANDALONESHORTMONTHS: ['jan', 'feb', 'mar', 'apr', 'm��j', 'j��n', 'j��l',
    'aug', 'sep', 'okt', 'nov', 'dec'],
  WEEKDAYS: ['nede��a', 'pondelok', 'utorok', 'streda', '��tvrtok', 'piatok',
    'sobota'],
  STANDALONEWEEKDAYS: ['nede��a', 'pondelok', 'utorok', 'streda', '��tvrtok',
    'piatok', 'sobota'],
  SHORTWEEKDAYS: ['ne', 'po', 'ut', 'st', '��t', 'pi', 'so'],
  STANDALONESHORTWEEKDAYS: ['ne', 'po', 'ut', 'st', '��t', 'pi', 'so'],
  NARROWWEEKDAYS: ['N', 'P', 'U', 'S', '��', 'P', 'S'],
  STANDALONENARROWWEEKDAYS: ['N', 'P', 'U', 'S', '��', 'P', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1. ��tvr��rok', '2. ��tvr��rok', '3. ��tvr��rok',
    '4. ��tvr��rok'],
  AMPMS: ['dopoludnia', 'popoludn��'],
  DATEFORMATS: ['EEEE, d. MMMM y', 'd. MMMM y', 'd.M.y', 'd.M.y'],
  TIMEFORMATS: ['H:mm:ss zzzz', 'H:mm:ss z', 'H:mm:ss', 'H:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale sl.
 */
goog.i18n.DateTimeSymbols_sl = {
  ERAS: ['pr. n. ��t.', 'po Kr.'],
  ERANAMES: ['pred na��im ��tetjem', 'na��e ��tetje'],
  NARROWMONTHS: ['j', 'f', 'm', 'a', 'm', 'j', 'j', 'a', 's', 'o', 'n', 'd'],
  STANDALONENARROWMONTHS: ['j', 'f', 'm', 'a', 'm', 'j', 'j', 'a', 's', 'o',
    'n', 'd'],
  MONTHS: ['januar', 'februar', 'marec', 'april', 'maj', 'junij', 'julij',
    'avgust', 'september', 'oktober', 'november', 'december'],
  STANDALONEMONTHS: ['januar', 'februar', 'marec', 'april', 'maj', 'junij',
    'julij', 'avgust', 'september', 'oktober', 'november', 'december'],
  SHORTMONTHS: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun.', 'jul.', 'avg.',
    'sep.', 'okt.', 'nov.', 'dec.'],
  STANDALONESHORTMONTHS: ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul',
    'avg', 'sep', 'okt', 'nov', 'dec'],
  WEEKDAYS: ['nedelja', 'ponedeljek', 'torek', 'sreda', '��etrtek', 'petek',
    'sobota'],
  STANDALONEWEEKDAYS: ['nedelja', 'ponedeljek', 'torek', 'sreda', '��etrtek',
    'petek', 'sobota'],
  SHORTWEEKDAYS: ['ned.', 'pon.', 'tor.', 'sre.', '��et.', 'pet.', 'sob.'],
  STANDALONESHORTWEEKDAYS: ['ned', 'pon', 'tor', 'sre', '��et', 'pet', 'sob'],
  NARROWWEEKDAYS: ['n', 'p', 't', 's', '��', 'p', 's'],
  STANDALONENARROWWEEKDAYS: ['n', 'p', 't', 's', '��', 'p', 's'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['1. ��etrtletje', '2. ��etrtletje', '3. ��etrtletje',
    '4. ��etrtletje'],
  AMPMS: ['dop.', 'pop.'],
  DATEFORMATS: ['EEEE, dd. MMMM y', 'dd. MMMM y', 'd. MMM y', 'd. MM. yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale sq.
 */
goog.i18n.DateTimeSymbols_sq = {
  ERAS: ['p.e.r.', 'n.e.r.'],
  ERANAMES: ['p.e.r.', 'n.e.r.'],
  NARROWMONTHS: ['J', 'S', 'M', 'P', 'M', 'Q', 'K', 'G', 'S', 'T', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'S', 'M', 'P', 'M', 'Q', 'K', 'G', 'S', 'T',
    'N', 'D'],
  MONTHS: ['janar', 'shkurt', 'mars', 'prill', 'maj', 'qershor', 'korrik',
    'gusht', 'shtator', 'tetor', 'n��ntor', 'dhjetor'],
  STANDALONEMONTHS: ['janar', 'shkurt', 'mars', 'prill', 'maj', 'qershor',
    'korrik', 'gusht', 'shtator', 'tetor', 'n��ntor', 'dhjetor'],
  SHORTMONTHS: ['Jan', 'Shk', 'Mar', 'Pri', 'Maj', 'Qer', 'Kor', 'Gsh', 'Sht',
    'Tet', 'N��n', 'Dhj'],
  STANDALONESHORTMONTHS: ['Jan', 'Shk', 'Mar', 'Pri', 'Maj', 'Qer', 'Kor',
    'Gsh', 'Sht', 'Tet', 'N��n', 'Dhj'],
  WEEKDAYS: ['e diel', 'e h��n��', 'e mart��', 'e m��rkur��', 'e enjte',
    'e premte', 'e shtun��'],
  STANDALONEWEEKDAYS: ['e diel', 'e h��n��', 'e mart��', 'e m��rkur��',
    'e enjte', 'e premte', 'e shtun��'],
  SHORTWEEKDAYS: ['Die', 'H��n', 'Mar', 'M��r', 'Enj', 'Pre', 'Sht'],
  STANDALONESHORTWEEKDAYS: ['Die', 'H��n', 'Mar', 'M��r', 'Enj', 'Pre', 'Sht'],
  NARROWWEEKDAYS: ['D', 'H', 'M', 'M', 'E', 'P', 'S'],
  STANDALONENARROWWEEKDAYS: ['D', 'H', 'M', 'M', 'E', 'P', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  AMPMS: ['PD', 'MD'],
  DATEFORMATS: ['EEEE, dd MMMM y', 'dd MMMM y', 'y-MM-dd', 'yy-MM-dd'],
  TIMEFORMATS: ['h.mm.ss.a zzzz', 'h.mm.ss.a z', 'h.mm.ss.a', 'h.mm.a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale sr.
 */
goog.i18n.DateTimeSymbols_sr = {
  ERAS: ['��. ��. ��.', '��. ��.'],
  ERANAMES: ['������ �������� ������', '�������� ������'],
  NARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��'],
  STANDALONENARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��', '��'],
  MONTHS: ['������������', '��������������', '��������', '����������', '������',
    '������', '������', '������������', '������������������', '��������������',
    '����������������', '����������������'],
  STANDALONEMONTHS: ['������������', '��������������', '��������', '����������',
    '������', '������', '������', '������������', '������������������',
    '��������������', '����������������', '����������������'],
  SHORTMONTHS: ['������', '������', '������', '������', '������', '������',
    '������', '������', '������', '������', '������', '������'],
  STANDALONESHORTMONTHS: ['������', '������', '������', '������', '������',
    '������', '������', '������', '������', '������', '������', '������'],
  WEEKDAYS: ['������������', '������������������', '������������', '����������',
    '����������������', '����������', '������������'],
  STANDALONEWEEKDAYS: ['������������', '������������������', '������������',
    '����������', '����������������', '����������', '������������'],
  SHORTWEEKDAYS: ['������', '������', '������', '������', '������', '������',
    '������'],
  STANDALONESHORTWEEKDAYS: ['������', '������', '������', '������', '������',
    '������', '������'],
  NARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  STANDALONENARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  SHORTQUARTERS: ['��1', '��2', '��3', '��4'],
  QUARTERS: ['�������� ��������������������', '���������� ��������������������',
    '���������� ��������������������', '�������������� ��������������������'],
  AMPMS: ['������ ����������', '��������������'],
  DATEFORMATS: ['EEEE, dd. MMMM y.', 'dd. MMMM y.', 'dd.MM.y.', 'd.M.yy.'],
  TIMEFORMATS: ['HH.mm.ss zzzz', 'HH.mm.ss z', 'HH.mm.ss', 'HH.mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale sv.
 */
goog.i18n.DateTimeSymbols_sv = {
  ERAS: ['f.Kr.', 'e.Kr.'],
  ERANAMES: ['f��re Kristus', 'efter Kristus'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['januari', 'februari', 'mars', 'april', 'maj', 'juni', 'juli',
    'augusti', 'september', 'oktober', 'november', 'december'],
  STANDALONEMONTHS: ['Januari', 'Februari', 'Mars', 'April', 'Maj', 'Juni',
    'Juli', 'Augusti', 'September', 'Oktober', 'November', 'December'],
  SHORTMONTHS: ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul', 'aug', 'sep',
    'okt', 'nov', 'dec'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul',
    'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
  WEEKDAYS: ['s��ndag', 'm��ndag', 'tisdag', 'onsdag', 'torsdag', 'fredag',
    'l��rdag'],
  STANDALONEWEEKDAYS: ['S��ndag', 'M��ndag', 'Tisdag', 'Onsdag', 'Torsdag',
    'Fredag', 'L��rdag'],
  SHORTWEEKDAYS: ['s��n', 'm��n', 'tis', 'ons', 'tors', 'fre', 'l��r'],
  STANDALONESHORTWEEKDAYS: ['S��n', 'M��n', 'Tis', 'Ons', 'Tor', 'Fre', 'L��r'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  SHORTQUARTERS: ['K1', 'K2', 'K3', 'K4'],
  QUARTERS: ['1:a kvartalet', '2:a kvartalet', '3:e kvartalet',
    '4:e kvartalet'],
  AMPMS: ['fm', 'em'],
  DATEFORMATS: ['EEEE\'en\' \'den\' d:\'e\' MMMM y', 'd MMMM y', 'd MMM y',
    'y-MM-dd'],
  TIMEFORMATS: ['\'kl\'. HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 3
};


/**
 * Date/time formatting symbols for locale sw.
 */
goog.i18n.DateTimeSymbols_sw = {
  ERAS: ['KK', 'BK'],
  ERANAMES: ['Kabla ya Kristo', 'Baada ya Kristo'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Januari', 'Februari', 'Machi', 'Aprili', 'Mei', 'Juni', 'Julai',
    'Agosti', 'Septemba', 'Oktoba', 'Novemba', 'Desemba'],
  STANDALONEMONTHS: ['Januari', 'Februari', 'Machi', 'Aprili', 'Mei', 'Juni',
    'Julai', 'Agosti', 'Septemba', 'Oktoba', 'Novemba', 'Desemba'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mac', 'Apr', 'Mei', 'Jun', 'Jul', 'Ago', 'Sep',
    'Okt', 'Nov', 'Des'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mac', 'Apr', 'Mei', 'Jun', 'Jul',
    'Ago', 'Sep', 'Okt', 'Nov', 'Des'],
  WEEKDAYS: ['Jumapili', 'Jumatatu', 'Jumanne', 'Jumatano', 'Alhamisi',
    'Ijumaa', 'Jumamosi'],
  STANDALONEWEEKDAYS: ['Jumapili', 'Jumatatu', 'Jumanne', 'Jumatano',
    'Alhamisi', 'Ijumaa', 'Jumamosi'],
  SHORTWEEKDAYS: ['J2', 'J3', 'J4', 'J5', 'Alh', 'Ij', 'J1'],
  STANDALONESHORTWEEKDAYS: ['J2', 'J3', 'J4', 'J5', 'Alh', 'Ij', 'J1'],
  NARROWWEEKDAYS: ['2', '3', '4', '5', 'A', 'I', '1'],
  STANDALONENARROWWEEKDAYS: ['2', '3', '4', '5', 'A', 'I', '1'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['Robo 1', 'Robo 2', 'Robo 3', 'Robo 4'],
  AMPMS: ['asubuhi', 'alasiri'],
  DATEFORMATS: ['EEEE, d MMMM y', 'd MMMM y', 'd MMM y', 'dd/MM/y'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale ta.
 */
goog.i18n.DateTimeSymbols_ta = {
  ERAS: ['������.������.', '������.������.'],
  ERANAMES: ['������������������������������������������ ������������',
    '��������� ������������������'],
  NARROWMONTHS: ['���', '������', '������', '���', '������', '������', '������',
    '���', '������', '���', '���', '������'],
  STANDALONENARROWMONTHS: ['���', '������', '������', '���', '������', '������',
    '������', '���', '������', '���', '���', '������'],
  MONTHS: ['���������������', '������������������������', '������������������',
    '������������������', '������', '������������', '������������',
    '������������������', '������������������������������',
    '������������������������', '���������������������',
    '������������������������'],
  STANDALONEMONTHS: ['���������������', '������������������������',
    '������������������', '������������������', '������', '������������',
    '������������', '������������������', '������������������������������',
    '������������������������', '���������������������',
    '������������������������'],
  SHORTMONTHS: ['������.', '������������.', '������������.', '���������.',
    '������', '������������', '������������', '������.', '������������.',
    '���������.', '������.', '���������.'],
  STANDALONESHORTMONTHS: ['������.', '������������.', '������������.',
    '���������.', '������', '������������', '������������', '������.',
    '������������.', '���������.', '������.', '���������.'],
  WEEKDAYS: ['������������������', '���������������������',
    '������������������������', '���������������', '���������������������',
    '������������������', '���������'],
  STANDALONEWEEKDAYS: ['������������������', '���������������������',
    '������������������������', '���������������', '���������������������',
    '������������������', '���������'],
  SHORTWEEKDAYS: ['������', '������', '������', '������', '������', '������',
    '���'],
  STANDALONESHORTWEEKDAYS: ['������', '������', '������', '������', '������',
    '������', '���'],
  NARROWWEEKDAYS: ['������', '������', '������', '������', '������', '������',
    '���'],
  STANDALONENARROWWEEKDAYS: ['������', '������', '������', '������', '������',
    '������', '���'],
  SHORTQUARTERS: ['������������������������1', '������������������������2',
    '������������������������3', '������������������������4'],
  QUARTERS: ['��������������� ������������������������',
    '������������������������ ������������������������',
    '������������������������ ������������������������',
    '������������������������ ������������������������'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, d MMMM, y', 'd MMMM, y', 'd MMM, y', 'd-M-yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [6, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale te.
 */
goog.i18n.DateTimeSymbols_te = {
  ERAS: ['������������������', '���������������'],
  ERANAMES: ['������������������������.', '���������.'],
  NARROWMONTHS: ['���', '������', '������', '���', '������', '������', '������',
    '���', '������', '���', '���', '������'],
  STANDALONENARROWMONTHS: ['���', '������', '������', '���', '������', '������',
    '������', '���', '������', '���', '���', '������'],
  MONTHS: ['���������������', '������������������������', '������������������',
    '���������������������', '������', '������������', '������������',
    '������������������', '������������������������������',
    '������������������������', '������������������',
    '������������������������'],
  STANDALONEMONTHS: ['���������������', '������������������������',
    '������������������', '���������������������', '������', '������������',
    '������������', '������������������', '������������������������������',
    '������������������������', '������������������',
    '������������������������'],
  SHORTMONTHS: ['������', '���������������', '������������������',
    '���������������', '������', '������������', '������������',
    '������������������', '������������������������������',
    '������������������������', '������������������',
    '������������������������'],
  STANDALONESHORTMONTHS: ['������', '���������������', '������������������',
    '���������������', '������', '������������', '������������',
    '������������������', '���������������������', '���������������',
    '���������', '���������������'],
  WEEKDAYS: ['���������������������', '���������������������',
    '������������������������', '���������������������',
    '������������������������', '���������������������������',
    '���������������������'],
  STANDALONEWEEKDAYS: ['���������������������', '���������������������',
    '������������������������', '���������������������',
    '������������������������', '���������������������������',
    '���������������������'],
  SHORTWEEKDAYS: ['���������', '���������', '������������', '���������',
    '������������', '���������������', '���������'],
  STANDALONESHORTWEEKDAYS: ['���������', '���������', '������������',
    '���������', '������������', '���������������', '���������'],
  NARROWWEEKDAYS: ['���', '������', '���', '������', '������', '������', '���'],
  STANDALONENARROWWEEKDAYS: ['���', '������', '���', '������', '������',
    '������', '���'],
  SHORTQUARTERS: ['������������1', '������������2', '������������3',
    '������������4'],
  QUARTERS: ['1��� ������������������������', '2��� ������������������������',
    '3��� ������������������������', '4��� ������������������������'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE d MMMM y', 'd MMMM y', 'd MMM y', 'dd-MM-yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [6, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale th.
 */
goog.i18n.DateTimeSymbols_th = {
  ERAS: ['������������������ ���.���.', '���.���.'],
  ERANAMES: ['������������������������������������������������������',
    '������������������������������������'],
  NARROWMONTHS: ['���.���.', '���.���.', '������.���.', '������.���.',
    '���.���.', '������.���', '���.���.', '���.���.', '���.���.', '���.���.',
    '���.���.', '���.���.'],
  STANDALONENARROWMONTHS: ['���.���.', '���.���.', '������.���.', '������.���.',
    '���.���.', '������.���.', '���.���.', '���.���.', '���.���.', '���.���.',
    '���.���.', '���.���.'],
  MONTHS: ['������������������', '������������������������������',
    '������������������', '������������������', '���������������������',
    '������������������������', '���������������������',
    '���������������������', '���������������������', '������������������',
    '���������������������������', '���������������������'],
  STANDALONEMONTHS: ['������������������', '������������������������������',
    '������������������', '������������������', '���������������������',
    '������������������������', '���������������������',
    '���������������������', '���������������������', '������������������',
    '���������������������������', '���������������������'],
  SHORTMONTHS: ['���.���.', '���.���.', '������.���.', '������.���.',
    '���.���.', '������.���.', '���.���.', '���.���.', '���.���.', '���.���.',
    '���.���.', '���.���.'],
  STANDALONESHORTMONTHS: ['���.���.', '���.���.', '������.���.', '������.���.',
    '���.���.', '������.���.', '���.���.', '���.���.', '���.���.', '���.���.',
    '���.���.', '���.���.'],
  WEEKDAYS: ['������������������������������', '���������������������������',
    '���������������������������', '������������������',
    '���������������������������������', '������������������������',
    '������������������������'],
  STANDALONEWEEKDAYS: ['������������������������������',
    '���������������������������', '���������������������������',
    '������������������', '���������������������������������',
    '������������������������', '������������������������'],
  SHORTWEEKDAYS: ['������.', '���.', '���.', '���.', '������.', '���.', '���.'],
  STANDALONESHORTWEEKDAYS: ['������.', '���.', '���.', '���.', '������.',
    '���.', '���.'],
  NARROWWEEKDAYS: ['������.', '���.', '���.', '���.', '������.', '���.',
    '���.'],
  STANDALONENARROWWEEKDAYS: ['������.', '���.', '���.', '���.', '������.',
    '���.', '���.'],
  SHORTQUARTERS: ['������������������ 1', '������������������ 2',
    '������������������ 3', '������������������ 4'],
  QUARTERS: ['������������������ 1', '������������������ 2',
    '������������������ 3', '������������������ 4'],
  AMPMS: ['������������������������������', '������������������������������'],
  DATEFORMATS: ['EEEE��������� d MMMM G y', 'd MMMM y', 'd MMM y', 'd/M/yy'],
  TIMEFORMATS: [
    'H ������������������ mm ������������ ss ������������������ zzzz',
    'H ������������������ mm ������������ ss ������������������ z', 'HH:mm:ss',
    'HH:mm'],
  DATETIMEFORMATS: ['{1}, {0}', '{1}, {0}', '{1}, {0}', '{1}, {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale tl.
 */
goog.i18n.DateTimeSymbols_tl = {
  ERAS: ['BC', 'AD'],
  ERANAMES: ['BC', 'AD'],
  NARROWMONTHS: ['E', 'P', 'M', 'A', 'M', 'H', 'H', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['E', 'P', 'M', 'A', 'M', 'H', 'H', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Enero', 'Pebrero', 'Marso', 'Abril', 'Mayo', 'Hunyo', 'Hulyo',
    'Agosto', 'Setyembre', 'Oktubre', 'Nobyembre', 'Disyembre'],
  STANDALONEMONTHS: ['Enero', 'Pebrero', 'Marso', 'Abril', 'Mayo', 'Hunyo',
    'Hulyo', 'Agosto', 'Setyembre', 'Oktubre', 'Nobyembre', 'Disyembre'],
  SHORTMONTHS: ['Ene', 'Peb', 'Mar', 'Abr', 'May', 'Hun', 'Hul', 'Ago', 'Set',
    'Okt', 'Nob', 'Dis'],
  STANDALONESHORTMONTHS: ['Ene', 'Peb', 'Mar', 'Abr', 'May', 'Hun', 'Hul',
    'Ago', 'Set', 'Okt', 'Nob', 'Dis'],
  WEEKDAYS: ['Linggo', 'Lunes', 'Martes', 'Miyerkules', 'Huwebes', 'Biyernes',
    'Sabado'],
  STANDALONEWEEKDAYS: ['Linggo', 'Lunes', 'Martes', 'Miyerkules', 'Huwebes',
    'Biyernes', 'Sabado'],
  SHORTWEEKDAYS: ['Lin', 'Lun', 'Mar', 'Mye', 'Huw', 'Bye', 'Sab'],
  STANDALONESHORTWEEKDAYS: ['Lin', 'Lun', 'Mar', 'Miy', 'Huw', 'Biy', 'Sab'],
  NARROWWEEKDAYS: ['L', 'L', 'M', 'M', 'H', 'B', 'S'],
  STANDALONENARROWWEEKDAYS: ['L', 'L', 'M', 'M', 'H', 'B', 'S'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['ika-1 sangkapat', 'ika-2 sangkapat', 'ika-3 quarter',
    'ika-4 na quarter'],
  AMPMS: ['AM', 'PM'],
  DATEFORMATS: ['EEEE, MMMM dd y', 'MMMM d, y', 'MMM d, y', 'M/d/yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale tr.
 */
goog.i18n.DateTimeSymbols_tr = {
  ERAS: ['M��', 'MS'],
  ERANAMES: ['Milattan ��nce', 'Milattan Sonra'],
  NARROWMONTHS: ['O', '��', 'M', 'N', 'M', 'H', 'T', 'A', 'E', 'E', 'K', 'A'],
  STANDALONENARROWMONTHS: ['O', '��', 'M', 'N', 'M', 'H', 'T', 'A', 'E', 'E',
    'K', 'A'],
  MONTHS: ['Ocak', '��ubat', 'Mart', 'Nisan', 'May��s', 'Haziran', 'Temmuz',
    'A��ustos', 'Eyl��l', 'Ekim', 'Kas��m', 'Aral��k'],
  STANDALONEMONTHS: ['Ocak', '��ubat', 'Mart', 'Nisan', 'May��s', 'Haziran',
    'Temmuz', 'A��ustos', 'Eyl��l', 'Ekim', 'Kas��m', 'Aral��k'],
  SHORTMONTHS: ['Oca', '��ub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'A��u', 'Eyl',
    'Eki', 'Kas', 'Ara'],
  STANDALONESHORTMONTHS: ['Oca', '��ub', 'Mar', 'Nis', 'May', 'Haz', 'Tem',
    'A��u', 'Eyl', 'Eki', 'Kas', 'Ara'],
  WEEKDAYS: ['Pazar', 'Pazartesi', 'Sal��', '��ar��amba', 'Per��embe', 'Cuma',
    'Cumartesi'],
  STANDALONEWEEKDAYS: ['Pazar', 'Pazartesi', 'Sal��', '��ar��amba', 'Per��embe',
    'Cuma', 'Cumartesi'],
  SHORTWEEKDAYS: ['Paz', 'Pzt', 'Sal', '��ar', 'Per', 'Cum', 'Cmt'],
  STANDALONESHORTWEEKDAYS: ['Paz', 'Pzt', 'Sal', '��ar', 'Per', 'Cum', 'Cmt'],
  NARROWWEEKDAYS: ['P', 'P', 'S', '��', 'P', 'C', 'C'],
  STANDALONENARROWWEEKDAYS: ['P', 'P', 'S', '��', 'P', 'C', 'C'],
  SHORTQUARTERS: ['��1', '��2', '��3', '��4'],
  QUARTERS: ['1. ��eyrek', '2. ��eyrek', '3. ��eyrek', '4. ��eyrek'],
  AMPMS: ['����', '��S'],
  DATEFORMATS: ['d MMMM y EEEE', 'd MMMM y', 'd MMM y', 'd MM y'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale uk.
 */
goog.i18n.DateTimeSymbols_uk = {
  ERAS: ['���� ��.��.', '��.��.'],
  ERANAMES: ['���� ���������� ������', '���������� ������'],
  NARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��'],
  STANDALONENARROWMONTHS: ['��', '��', '��', '��', '��', '��', '��', '��', '��',
    '��', '��', '��'],
  MONTHS: ['����������', '������������', '��������������', '������������',
    '������������', '������������', '����������', '������������',
    '��������������', '������������', '������������������', '������������'],
  STANDALONEMONTHS: ['������������', '����������', '����������������',
    '��������������', '��������������', '��������������', '������������',
    '��������������', '����������������', '��������������', '����������������',
    '��������������'],
  SHORTMONTHS: ['������.', '������.', '������.', '��������.', '��������.',
    '��������.', '������.', '��������.', '������.', '��������.', '��������.',
    '��������.'],
  STANDALONESHORTMONTHS: ['������', '������', '������', '������', '������',
    '������', '������', '������', '������', '������', '������', '������'],
  WEEKDAYS: ['������������', '������������������', '����������������',
    '������������', '������������', '����������������', '������������'],
  STANDALONEWEEKDAYS: ['������������', '������������������', '����������������',
    '������������', '������������', '����������������', '������������'],
  SHORTWEEKDAYS: ['����', '����', '����', '����', '����', '����', '����'],
  STANDALONESHORTWEEKDAYS: ['����', '����', '����', '����', '����', '����',
    '����'],
  NARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  STANDALONENARROWWEEKDAYS: ['��', '��', '��', '��', '��', '��', '��'],
  SHORTQUARTERS: ['I ����.', 'II ����.', 'III ����.', 'IV ����.'],
  QUARTERS: ['I ��������������', 'II ��������������', 'III ��������������',
    'IV ��������������'],
  AMPMS: ['����', '����'],
  DATEFORMATS: ['EEEE, d MMMM y \'��\'.', 'd MMMM y \'��\'.', 'd MMM y',
    'dd.MM.yy'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale ur.
 */
goog.i18n.DateTimeSymbols_ur = {
  ERAS: ['�� ��', '���������� ����'],
  ERANAMES: ['������ ��������', '���������� ����'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['����������', '����������', '��������', '����������', '����',
    '������', '����������', '��������', '����������', '������������',
    '����������', '����������'],
  STANDALONEMONTHS: ['����������', '����������', '��������', '����������',
    '����', '������', '����������', '��������', '����������', '������������',
    '����������', '����������'],
  SHORTMONTHS: ['����������', '����������', '��������', '����������', '����',
    '������', '����������', '��������', '����������', '������������',
    '����������', '����������'],
  STANDALONESHORTMONTHS: ['����������', '����������', '��������', '����������',
    '����', '������', '����������', '��������', '����������', '������������',
    '����������', '����������'],
  WEEKDAYS: ['����������', '������', '��������', '������', '������������',
    '��������', '��������'],
  STANDALONEWEEKDAYS: ['����������', '������', '��������', '������',
    '������������', '��������', '��������'],
  SHORTWEEKDAYS: ['����������', '������', '��������', '������', '������������',
    '��������', '��������'],
  STANDALONESHORTWEEKDAYS: ['����������', '������', '��������', '������',
    '������������', '��������', '��������'],
  NARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  SHORTQUARTERS: ['�������� ���� ��������', '���������� ���� ��������',
    '���������� ���� ��������', '���������� ���� ��������'],
  QUARTERS: ['�������� ���� ��������', '���������� ���� ��������',
    '���������� ���� ��������', '���������� ���� ��������'],
  AMPMS: ['������ ����������', '������ ����������'],
  DATEFORMATS: ['EEEE�� d MMMM�� y', 'd MMMM�� y', 'd MMM�� y', 'd/M/yy'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale vi.
 */
goog.i18n.DateTimeSymbols_vi = {
  ERAS: ['tr. CN', 'sau CN'],
  ERANAMES: ['tr. CN', 'sau CN'],
  NARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  STANDALONENARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
    '11', '12'],
  MONTHS: ['th��ng m���t', 'th��ng hai', 'th��ng ba', 'th��ng t��',
    'th��ng n��m', 'th��ng s��u', 'th��ng b���y', 'th��ng t��m', 'th��ng ch��n',
    'th��ng m�����i', 'th��ng m�����i m���t', 'th��ng m�����i hai'],
  STANDALONEMONTHS: ['th��ng m���t', 'th��ng hai', 'th��ng ba', 'th��ng t��',
    'th��ng n��m', 'th��ng s��u', 'th��ng b���y', 'th��ng t��m', 'th��ng ch��n',
    'th��ng m�����i', 'th��ng m�����i m���t', 'th��ng m�����i hai'],
  SHORTMONTHS: ['thg 1', 'thg 2', 'thg 3', 'thg 4', 'thg 5', 'thg 6', 'thg 7',
    'thg 8', 'thg 9', 'thg 10', 'thg 11', 'thg 12'],
  STANDALONESHORTMONTHS: ['thg 1', 'thg 2', 'thg 3', 'thg 4', 'thg 5', 'thg 6',
    'thg 7', 'thg 8', 'thg 9', 'thg 10', 'thg 11', 'thg 12'],
  WEEKDAYS: ['Ch��� nh���t', 'Th��� hai', 'Th��� ba', 'Th��� t��', 'Th��� n��m',
    'Th��� s��u', 'Th��� b���y'],
  STANDALONEWEEKDAYS: ['Ch��� nh���t', 'Th��� hai', 'Th��� ba', 'Th��� t��',
    'Th��� n��m', 'Th��� s��u', 'Th��� b���y'],
  SHORTWEEKDAYS: ['CN', 'Th 2', 'Th 3', 'Th 4', 'Th 5', 'Th 6', 'Th 7'],
  STANDALONESHORTWEEKDAYS: ['CN', 'Th 2', 'Th 3', 'Th 4', 'Th 5', 'Th 6',
    'Th 7'],
  NARROWWEEKDAYS: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
  STANDALONENARROWWEEKDAYS: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['Qu�� 1', 'Qu�� 2', 'Qu�� 3', 'Qu�� 4'],
  AMPMS: ['SA', 'CH'],
  DATEFORMATS: ['EEEE, \'ng��y\' dd MMMM \'n��m\' y',
    '\'Ng��y\' dd \'th��ng\' M \'n��m\' y', 'dd-MM-y', 'dd/MM/y'],
  TIMEFORMATS: ['HH:mm:ss zzzz', 'HH:mm:ss z', 'HH:mm:ss', 'HH:mm'],
  DATETIMEFORMATS: ['{0} {1}', '{0} {1}', '{0} {1}', '{0} {1}'],
  FIRSTDAYOFWEEK: 0,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 6
};


/**
 * Date/time formatting symbols for locale zh.
 */
goog.i18n.DateTimeSymbols_zh = {
  ERAS: ['���������', '������'],
  ERANAMES: ['���������', '������'],
  NARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  STANDALONENARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
    '11', '12'],
  MONTHS: ['������', '������', '������', '������', '������', '������', '������',
    '������', '������', '������', '���������', '���������'],
  STANDALONEMONTHS: ['������', '������', '������', '������', '������', '������',
    '������', '������', '������', '������', '���������', '���������'],
  SHORTMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���', '8���',
    '9���', '10���', '11���', '12���'],
  STANDALONESHORTMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���',
    '7���', '8���', '9���', '10���', '11���', '12���'],
  WEEKDAYS: ['���������', '���������', '���������', '���������', '���������',
    '���������', '���������'],
  STANDALONEWEEKDAYS: ['���������', '���������', '���������', '���������',
    '���������', '���������', '���������'],
  SHORTWEEKDAYS: ['������', '������', '������', '������', '������', '������',
    '������'],
  STANDALONESHORTWEEKDAYS: ['������', '������', '������', '������', '������',
    '������', '������'],
  NARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  STANDALONENARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  SHORTQUARTERS: ['1������', '2������', '3������', '4������'],
  QUARTERS: ['������������', '������������', '������������', '������������'],
  AMPMS: ['������', '������'],
  DATEFORMATS: ['y���M���d���EEEE', 'y���M���d���', 'y���M���d���', 'yy-M-d'],
  TIMEFORMATS: ['zzzzah:mm:ss', 'zah:mm:ss', 'ah:mm:ss', 'ah:mm'],
  DATETIMEFORMATS: ['{1}{0}', '{1}{0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale zh_CN.
 */
goog.i18n.DateTimeSymbols_zh_CN = goog.i18n.DateTimeSymbols_zh;


/**
 * Date/time formatting symbols for locale zh_HK.
 */
goog.i18n.DateTimeSymbols_zh_HK = {
  ERAS: ['���������', '������'],
  ERANAMES: ['���������', '������'],
  NARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  STANDALONENARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
    '11', '12'],
  MONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���', '8���',
    '9���', '10���', '11���', '12���'],
  STANDALONEMONTHS: ['������', '������', '������', '������', '������', '������',
    '������', '������', '������', '������', '���������', '���������'],
  SHORTMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���', '8���',
    '9���', '10���', '11���', '12���'],
  STANDALONESHORTMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���',
    '7���', '8���', '9���', '10���', '11���', '12���'],
  WEEKDAYS: ['���������', '���������', '���������', '���������', '���������',
    '���������', '���������'],
  STANDALONEWEEKDAYS: ['���������', '���������', '���������', '���������',
    '���������', '���������', '���������'],
  SHORTWEEKDAYS: ['������', '������', '������', '������', '������', '������',
    '������'],
  STANDALONESHORTWEEKDAYS: ['������', '������', '������', '������', '������',
    '������', '������'],
  NARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  STANDALONENARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  SHORTQUARTERS: ['1���', '2���', '3���', '4���'],
  QUARTERS: ['���1���', '���2���', '���3���', '���4���'],
  AMPMS: ['������', '������'],
  DATEFORMATS: ['y���M���d���EEEE', 'y���M���d���', 'y���M���d���', 'd/M/yy'],
  TIMEFORMATS: ['ah:mm:ss [zzzz]', 'ah:mm:ss [z]', 'ahh:mm:ss', 'ah:mm'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1}{0}', '{1}{0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale zh_TW.
 */
goog.i18n.DateTimeSymbols_zh_TW = {
  ERAS: ['���������', '������'],
  ERANAMES: ['���������', '������'],
  NARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  STANDALONENARROWMONTHS: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
    '11', '12'],
  MONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���', '8���',
    '9���', '10���', '11���', '12���'],
  STANDALONEMONTHS: ['������', '������', '������', '������', '������', '������',
    '������', '������', '������', '������', '���������', '���������'],
  SHORTMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���', '7���', '8���',
    '9���', '10���', '11���', '12���'],
  STANDALONESHORTMONTHS: ['1���', '2���', '3���', '4���', '5���', '6���',
    '7���', '8���', '9���', '10���', '11���', '12���'],
  WEEKDAYS: ['���������', '���������', '���������', '���������', '���������',
    '���������', '���������'],
  STANDALONEWEEKDAYS: ['���������', '���������', '���������', '���������',
    '���������', '���������', '���������'],
  SHORTWEEKDAYS: ['������', '������', '������', '������', '������', '������',
    '������'],
  STANDALONESHORTWEEKDAYS: ['������', '������', '������', '������', '������',
    '������', '������'],
  NARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  STANDALONENARROWWEEKDAYS: ['���', '���', '���', '���', '���', '���', '���'],
  SHORTQUARTERS: ['1���', '2���', '3���', '4���'],
  QUARTERS: ['���1���', '���2���', '���3���', '���4���'],
  AMPMS: ['������', '������'],
  DATEFORMATS: ['y���M���d���EEEE', 'y���M���d���', 'y/M/d', 'y/M/d'],
  TIMEFORMATS: ['zzzzah���mm���ss���', 'zah���mm���ss���', 'ah:mm:ss', 'ah:mm'],
  DATETIMEFORMATS: ['{1}{0}', '{1}{0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Date/time formatting symbols for locale zu.
 */
goog.i18n.DateTimeSymbols_zu = {
  ERAS: ['BC', 'AD'],
  ERANAMES: ['BC', 'AD'],
  NARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  STANDALONENARROWMONTHS: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O',
    'N', 'D'],
  MONTHS: ['Januwari', 'Februwari', 'Mashi', 'Apreli', 'Meyi', 'Juni', 'Julayi',
    'Agasti', 'Septhemba', 'Okthoba', 'Novemba', 'Disemba'],
  STANDALONEMONTHS: ['uJanuwari', 'uFebruwari', 'uMashi', 'u-Apreli', 'uMeyi',
    'uJuni', 'uJulayi', 'uAgasti', 'uSepthemba', 'u-Okthoba', 'uNovemba',
    'uDisemba'],
  SHORTMONTHS: ['Jan', 'Feb', 'Mas', 'Apr', 'Mey', 'Jun', 'Jul', 'Aga', 'Sep',
    'Okt', 'Nov', 'Dis'],
  STANDALONESHORTMONTHS: ['Jan', 'Feb', 'Mas', 'Apr', 'Mey', 'Jun', 'Jul',
    'Aga', 'Sep', 'Okt', 'Nov', 'Dis'],
  WEEKDAYS: ['Sonto', 'Msombuluko', 'Lwesibili', 'Lwesithathu', 'uLwesine',
    'Lwesihlanu', 'Mgqibelo'],
  STANDALONEWEEKDAYS: ['Sonto', 'Msombuluko', 'Lwesibili', 'Lwesithathu',
    'uLwesine', 'Lwesihlanu', 'Mgqibelo'],
  SHORTWEEKDAYS: ['Son', 'Mso', 'Bil', 'Tha', 'Sin', 'Hla', 'Mgq'],
  STANDALONESHORTWEEKDAYS: ['Son', 'Mso', 'Bil', 'Tha', 'Sin', 'Hla', 'Mgq'],
  NARROWWEEKDAYS: ['S', 'M', 'B', 'T', 'S', 'H', 'M'],
  STANDALONENARROWWEEKDAYS: ['S', 'M', 'B', 'T', 'S', 'H', 'M'],
  SHORTQUARTERS: ['Q1', 'Q2', 'Q3', 'Q4'],
  QUARTERS: ['ikota yoku-1', 'ikota yesi-2', 'ikota yesi-3', 'ikota yesi-4'],
  AMPMS: ['Ekuseni', 'Ntambama'],
  DATEFORMATS: ['EEEE dd MMMM y', 'd MMMM y', 'd MMM y', 'y-MM-dd'],
  TIMEFORMATS: ['h:mm:ss a zzzz', 'h:mm:ss a z', 'h:mm:ss a', 'h:mm a'],
  DATETIMEFORMATS: ['{1} {0}', '{1} {0}', '{1} {0}', '{1} {0}'],
  FIRSTDAYOFWEEK: 6,
  WEEKENDRANGE: [5, 6],
  FIRSTWEEKCUTOFFDAY: 5
};


/**
 * Selected date/time formatting symbols by locale.
 * "switch" statement won't work here. JsCompiler cannot handle it yet.
 */
if (goog.LOCALE == 'af') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_af;
} else if (goog.LOCALE == 'am') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_am;
} else if (goog.LOCALE == 'ar') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_ar;
} else if (goog.LOCALE == 'bg') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_bg;
} else if (goog.LOCALE == 'bn') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_bn;
} else if (goog.LOCALE == 'br') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_br;
} else if (goog.LOCALE == 'ca') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_ca;
} else if (goog.LOCALE == 'chr') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_chr;
} else if (goog.LOCALE == 'cs') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_cs;
} else if (goog.LOCALE == 'cy') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_cy;
} else if (goog.LOCALE == 'da') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_da;
} else if (goog.LOCALE == 'de') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_de;
} else if (goog.LOCALE == 'de_AT' || goog.LOCALE == 'de-AT') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_de_AT;
} else if (goog.LOCALE == 'de_CH' || goog.LOCALE == 'de-CH') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_de;
} else if (goog.LOCALE == 'el') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_el;
} else if (goog.LOCALE == 'en') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_en;
} else if (goog.LOCALE == 'en_AU' || goog.LOCALE == 'en-AU') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_en_AU;
} else if (goog.LOCALE == 'en_GB' || goog.LOCALE == 'en-GB') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_en_GB;
} else if (goog.LOCALE == 'en_IE' || goog.LOCALE == 'en-IE') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_en_IE;
} else if (goog.LOCALE == 'en_IN' || goog.LOCALE == 'en-IN') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_en_IN;
} else if (goog.LOCALE == 'en_SG' || goog.LOCALE == 'en-SG') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_en_SG;
} else if (goog.LOCALE == 'en_US' || goog.LOCALE == 'en-US') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_en;
} else if (goog.LOCALE == 'en_ZA' || goog.LOCALE == 'en-ZA') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_en_ZA;
} else if (goog.LOCALE == 'es') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_es;
} else if (goog.LOCALE == 'es_419' || goog.LOCALE == 'es-419') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_es_419;
} else if (goog.LOCALE == 'es_ES' || goog.LOCALE == 'es-ES') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_es;
} else if (goog.LOCALE == 'et') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_et;
} else if (goog.LOCALE == 'eu') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_eu;
} else if (goog.LOCALE == 'fa') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_fa;
} else if (goog.LOCALE == 'fi') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_fi;
} else if (goog.LOCALE == 'fil') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_fil;
} else if (goog.LOCALE == 'fr') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_fr;
} else if (goog.LOCALE == 'fr_CA' || goog.LOCALE == 'fr-CA') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_fr_CA;
} else if (goog.LOCALE == 'gl') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_gl;
} else if (goog.LOCALE == 'gsw') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_gsw;
} else if (goog.LOCALE == 'gu') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_gu;
} else if (goog.LOCALE == 'haw') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_haw;
} else if (goog.LOCALE == 'he') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_he;
} else if (goog.LOCALE == 'hi') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_hi;
} else if (goog.LOCALE == 'hr') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_hr;
} else if (goog.LOCALE == 'hu') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_hu;
} else if (goog.LOCALE == 'id') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_id;
} else if (goog.LOCALE == 'in') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_in;
} else if (goog.LOCALE == 'is') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_is;
} else if (goog.LOCALE == 'it') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_it;
} else if (goog.LOCALE == 'iw') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_iw;
} else if (goog.LOCALE == 'ja') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_ja;
} else if (goog.LOCALE == 'kn') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_kn;
} else if (goog.LOCALE == 'ko') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_ko;
} else if (goog.LOCALE == 'ln') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_ln;
} else if (goog.LOCALE == 'lt') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_lt;
} else if (goog.LOCALE == 'lv') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_lv;
} else if (goog.LOCALE == 'ml') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_ml;
} else if (goog.LOCALE == 'mr') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_mr;
} else if (goog.LOCALE == 'ms') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_ms;
} else if (goog.LOCALE == 'mt') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_mt;
} else if (goog.LOCALE == 'nb') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_nb;
} else if (goog.LOCALE == 'nl') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_nl;
} else if (goog.LOCALE == 'no') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_no;
} else if (goog.LOCALE == 'or') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_or;
} else if (goog.LOCALE == 'pl') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_pl;
} else if (goog.LOCALE == 'pt') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_pt;
} else if (goog.LOCALE == 'pt_BR' || goog.LOCALE == 'pt-BR') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_pt;
} else if (goog.LOCALE == 'pt_PT' || goog.LOCALE == 'pt-PT') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_pt_PT;
} else if (goog.LOCALE == 'ro') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_ro;
} else if (goog.LOCALE == 'ru') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_ru;
} else if (goog.LOCALE == 'sk') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_sk;
} else if (goog.LOCALE == 'sl') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_sl;
} else if (goog.LOCALE == 'sq') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_sq;
} else if (goog.LOCALE == 'sr') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_sr;
} else if (goog.LOCALE == 'sv') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_sv;
} else if (goog.LOCALE == 'sw') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_sw;
} else if (goog.LOCALE == 'ta') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_ta;
} else if (goog.LOCALE == 'te') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_te;
} else if (goog.LOCALE == 'th') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_th;
} else if (goog.LOCALE == 'tl') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_tl;
} else if (goog.LOCALE == 'tr') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_tr;
} else if (goog.LOCALE == 'uk') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_uk;
} else if (goog.LOCALE == 'ur') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_ur;
} else if (goog.LOCALE == 'vi') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_vi;
} else if (goog.LOCALE == 'zh') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_zh;
} else if (goog.LOCALE == 'zh_CN' || goog.LOCALE == 'zh-CN') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_zh;
} else if (goog.LOCALE == 'zh_HK' || goog.LOCALE == 'zh-HK') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_zh_HK;
} else if (goog.LOCALE == 'zh_TW' || goog.LOCALE == 'zh-TW') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_zh_TW;
} else if (goog.LOCALE == 'zu') {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_zu;
} else {
  goog.i18n.DateTimeSymbols = goog.i18n.DateTimeSymbols_en;
}

//javascript/closure/date/datelike.js
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Typedefs for working with dates.
 *
 * @author nicksantos@google.com (Nick Santos)
 */

goog.provide('goog.date.DateLike');


/**
 * @typedef {(Date|goog.date.Date)}
 */
goog.date.DateLike;

//javascript/closure/date/date.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Functions and objects for date representation and manipulation.
 *
 * @author eae@google.com (Emil A Eklund)
 * @author pallosp@google.com (Peter Pallos)
 */

goog.provide('goog.date');
goog.provide('goog.date.Date');
goog.provide('goog.date.DateTime');
goog.provide('goog.date.Interval');
goog.provide('goog.date.month');
goog.provide('goog.date.weekDay');

goog.require('goog.asserts');
/** @suppress {extraRequire} */
goog.require('goog.date.DateLike');
goog.require('goog.i18n.DateTimeSymbols');
goog.require('goog.string');


/**
 * Constants for weekdays.
 * @enum {number}
 */
goog.date.weekDay = {
  MON: 0,
  TUE: 1,
  WED: 2,
  THU: 3,
  FRI: 4,
  SAT: 5,
  SUN: 6
};


/**
 * Constants for months.
 * @enum {number}
 */
goog.date.month = {
  JAN: 0,
  FEB: 1,
  MAR: 2,
  APR: 3,
  MAY: 4,
  JUN: 5,
  JUL: 6,
  AUG: 7,
  SEP: 8,
  OCT: 9,
  NOV: 10,
  DEC: 11
};


/**
 * Formats a month/year string.
 * Example: "January 2008"
 *
 * @param {string} monthName The month name to use in the result.
 * @param {number} yearNum The numeric year to use in the result.
 * @return {string} A formatted month/year string.
 */
goog.date.formatMonthAndYear = function(monthName, yearNum) {
  /** @desc Month/year format given the month name and the numeric year. */
  var MSG_MONTH_AND_YEAR = goog.getMsg(
      '{$monthName} {$yearNum}',
      { 'monthName' : monthName, 'yearNum' : yearNum });
  return MSG_MONTH_AND_YEAR;
};


/**
 * Regular expression for splitting date parts from ISO 8601 styled string.
 * Examples: '20060210' or '2005-02-22' or '20050222' or '2005-08'
 * or '2005-W22' or '2005W22' or '2005-W22-4', etc.
 * For explanation and more examples, see:
 * {@link http://en.wikipedia.org/wiki/ISO_8601}
 *
 * @type {RegExp}
 * @private
 */
goog.date.splitDateStringRegex_ = new RegExp(
    '^(\\d{4})(?:(?:-?(\\d{2})(?:-?(\\d{2}))?)|' +
    '(?:-?(\\d{3}))|(?:-?W(\\d{2})(?:-?([1-7]))?))?$');


/**
 * Regular expression for splitting time parts from ISO 8601 styled string.
 * Examples: '18:46:39.994' or '184639.994'
 *
 * @type {RegExp}
 * @private
 */
goog.date.splitTimeStringRegex_ =
    /^(\d{2})(?::?(\d{2})(?::?(\d{2})(\.\d+)?)?)?$/;


/**
 * Regular expression for splitting timezone parts from ISO 8601 styled string.
 * Example: The part after the '+' in '18:46:39+07:00'.  Or '09:30Z' (UTC).
 *
 * @type {RegExp}
 * @private
 */
goog.date.splitTimezoneStringRegex_ = /Z|(?:([-+])(\d{2})(?::?(\d{2}))?)$/;


/**
 * Regular expression for splitting duration parts from ISO 8601 styled string.
 * Example: '-P1Y2M3DT4H5M6.7S'
 *
 * @type {RegExp}
 * @private
 */
goog.date.splitDurationRegex_ = new RegExp(
    '^(-)?P(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?' +
    '(T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?)?$');


/**
 * Returns whether the given year is a leap year.
 *
 * @param {number} year Year part of date.
 * @return {boolean} Whether the given year is a leap year.
 */
goog.date.isLeapYear = function(year) {
  // Leap year logic; the 4-100-400 rule
  return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
};


/**
 * Returns whether the given year is a long ISO year.
 * See {@link http://www.phys.uu.nl/~vgent/calendar/isocalendar_text3.htm}.
 *
 * @param {number} year Full year part of date.
 * @return {boolean} Whether the given year is a long ISO year.
 */
goog.date.isLongIsoYear = function(year) {
  var n = 5 * year + 12 - 4 * (Math.floor(year / 100) - Math.floor(year / 400));
  n += Math.floor((year - 100) / 400) - Math.floor((year - 102) / 400);
  n += Math.floor((year - 200) / 400) - Math.floor((year - 199) / 400);

  return n % 28 < 5;
};


/**
 * Returns the number of days for a given month.
 *
 * @param {number} year Year part of date.
 * @param {number} month Month part of date.
 * @return {number} The number of days for the given month.
 */
goog.date.getNumberOfDaysInMonth = function(year, month) {
  switch (month) {
    case goog.date.month.FEB:
      return goog.date.isLeapYear(year) ? 29 : 28;
    case goog.date.month.JUN:
    case goog.date.month.SEP:
    case goog.date.month.NOV:
    case goog.date.month.APR:
      return 30;
  }
  return 31;
};


/**
 * Returns true if the 2 dates are in the same day.
 * @param {goog.date.DateLike} date The time to check.
 * @param {goog.date.DateLike=} opt_now The current time.
 * @return {boolean} Whether the dates are on the same day.
 */
goog.date.isSameDay = function(date, opt_now) {
  var now = opt_now || new Date(goog.now());
  return date.getDate() == now.getDate() &&
      goog.date.isSameMonth(date, now);
};


/**
 * Returns true if the 2 dates are in the same month.
 * @param {goog.date.DateLike} date The time to check.
 * @param {goog.date.DateLike=} opt_now The current time.
 * @return {boolean} Whether the dates are in the same calendar month.
 */
goog.date.isSameMonth = function(date, opt_now) {
  var now = opt_now || new Date(goog.now());
  return date.getMonth() == now.getMonth() &&
      goog.date.isSameYear(date, now);
};


/**
 * Returns true if the 2 dates are in the same year.
 * @param {goog.date.DateLike} date The time to check.
 * @param {goog.date.DateLike=} opt_now The current time.
 * @return {boolean} Whether the dates are in the same calendar year.
 */
goog.date.isSameYear = function(date, opt_now) {
  var now = opt_now || new Date(goog.now());
  return date.getFullYear() == now.getFullYear();
};


/**
 * Static function for week number calculation. ISO 8601 implementation.
 *
 * @param {number} year Year part of date.
 * @param {number} month Month part of date (0-11).
 * @param {number} date Day part of date (1-31).
 * @param {number=} opt_weekDay Cut off weekday, defaults to Thursday.
 * @param {number=} opt_firstDayOfWeek First day of the week, defaults to
 *     Monday.
 *     Monday=0, Sunday=6.
 * @return {number} The week number (1-53).
 */
goog.date.getWeekNumber = function(year, month, date, opt_weekDay,
    opt_firstDayOfWeek) {
  var d = new Date(year, month, date);

  // Default to Thursday for cut off as per ISO 8601.
  var cutoff = opt_weekDay || goog.date.weekDay.THU;

  // Default to Monday for first day of the week as per ISO 8601.
  var firstday = opt_firstDayOfWeek || goog.date.weekDay.MON;

  // 1 day in milliseconds.
  var ONE_DAY = 24 * 60 * 60 * 1000;

  // The d.getDay() has to be converted first to ISO weekday (Monday=0).
  var isoday = (d.getDay() + 6) % 7;

  // Position of given day in the picker grid w.r.t. first day of week
  var daypos = (isoday - firstday + 7) % 7;

  // Position of cut off day in the picker grid w.r.t. first day of week
  var cutoffpos = (cutoff - firstday + 7) % 7;

  // Unix timestamp of the midnight of the cutoff day in the week of 'd'.
  // There might be +-1 hour shift in the result due to the daylight saving,
  // but it doesn't affect the year.
  var cutoffSameWeek = d.valueOf() + (cutoffpos - daypos) * ONE_DAY;

  // Unix timestamp of January 1 in the year of 'cutoffSameWeek'.
  var jan1 = new Date(new Date(cutoffSameWeek).getFullYear(), 0, 1).valueOf();

  // Number of week. The round() eliminates the effect of daylight saving.
  return Math.floor(Math.round((cutoffSameWeek - jan1) / ONE_DAY) / 7) + 1;
};


/**
 * @param {!T} date1 A datelike object.
 * @param {!S} date2 Another datelike object.
 * @return {!(T|S)} The earlier of them in time.
 * @template T,S
 */
goog.date.min = function(date1, date2) {
  return date1 < date2 ? date1 : date2;
};


/**
 * @param {!T} date1 A datelike object.
 * @param {!S} date2 Another datelike object.
 * @return {!(T|S)} The later of them in time.
 * @template T,S
 */
goog.date.max = function(date1, date2) {
  return date1 > date2 ? date1 : date2;
};


/**
 * Creates a DateTime from a datetime string expressed in ISO 8601 format.
 *
 * @param {string} formatted A date or datetime expressed in ISO 8601 format.
 * @return {goog.date.DateTime} Parsed date or null if parse fails.
 */
goog.date.fromIsoString = function(formatted) {
  var ret = new goog.date.DateTime(2000);
  return goog.date.setIso8601DateTime(ret, formatted) ? ret : null;
};


/**
 * Parses a datetime string expressed in ISO 8601 format. Overwrites the date
 * and optionally the time part of the given object with the parsed values.
 *
 * @param {!goog.date.DateTime} dateTime Object whose fields will be set.
 * @param {string} formatted A date or datetime expressed in ISO 8601 format.
 * @return {boolean} Whether the parsing succeeded.
 */
goog.date.setIso8601DateTime = function(dateTime, formatted) {
  formatted = goog.string.trim(formatted);
  var delim = formatted.indexOf('T') == -1 ? ' ' : 'T';
  var parts = formatted.split(delim);
  return goog.date.setIso8601DateOnly_(dateTime, parts[0]) &&
      (parts.length < 2 || goog.date.setIso8601TimeOnly_(dateTime, parts[1]));
};


/**
 * Sets date fields based on an ISO 8601 format string.
 *
 * @param {!goog.date.DateTime} d Object whose fields will be set.
 * @param {string} formatted A date expressed in ISO 8601 format.
 * @return {boolean} Whether the parsing succeeded.
 * @private
 */
goog.date.setIso8601DateOnly_ = function(d, formatted) {
  // split the formatted ISO date string into its date fields
  var parts = formatted.match(goog.date.splitDateStringRegex_);
  if (!parts) {
    return false;
  }

  var year = Number(parts[1]);
  var month = Number(parts[2]);
  var date = Number(parts[3]);
  var dayOfYear = Number(parts[4]);
  var week = Number(parts[5]);
  // ISO weekdays start with 1, native getDay() values start with 0
  var dayOfWeek = Number(parts[6]) || 1;

  d.setFullYear(year);

  if (dayOfYear) {
    d.setDate(1);
    d.setMonth(0);
    var offset = dayOfYear - 1; // offset, so 1-indexed, i.e., skip day 1
    d.add(new goog.date.Interval(goog.date.Interval.DAYS, offset));
  } else if (week) {
    goog.date.setDateFromIso8601Week_(d, week, dayOfWeek);
  } else {
    if (month) {
      d.setDate(1);
      d.setMonth(month - 1);
    }
    if (date) {
      d.setDate(date);
    }
  }

  return true;
};


/**
 * Sets date fields based on an ISO 8601 week string.
 * See {@link http://en.wikipedia.org/wiki/ISO_week_date}, "Relation with the
 * Gregorian Calendar".  The first week of a new ISO year is the week with the
 * majority of its days in the new Gregorian year.  I.e., ISO Week 1's Thursday
 * is in that year.  ISO weeks always start on Monday. So ISO Week 1 can
 * contain a few days from the previous Gregorian year.  And ISO weeks always
 * end on Sunday, so the last ISO week (Week 52 or 53) can have a few days from
 * the following Gregorian year.
 * Example: '1997-W01' lasts from 1996-12-30 to 1997-01-05.  January 1, 1997 is
 * a Wednesday. So W01's Monday is Dec.30, 1996, and Sunday is January 5, 1997.
 *
 * @param {goog.date.DateTime} d Object whose fields will be set.
 * @param {number} week ISO week number.
 * @param {number} dayOfWeek ISO day of week.
 * @private
 */
goog.date.setDateFromIso8601Week_ = function(d, week, dayOfWeek) {
  // calculate offset for first week
  d.setMonth(0);
  d.setDate(1);
  var jsDay = d.getDay();
  // switch Sunday (0) to index 7; ISO days are 1-indexed
  var jan1WeekDay = jsDay || 7;

  var THURSDAY = 4;
  if (jan1WeekDay <= THURSDAY) {
    // was extended back to Monday
    var startDelta = 1 - jan1WeekDay; // e.g., Thu(4) ==> -3
  } else {
    // was extended forward to Monday
    startDelta = 8 - jan1WeekDay; // e.g., Fri(5) ==> +3
  }

  // find the absolute number of days to offset from the start of year
  // to arrive close to the Gregorian equivalent (pending adjustments above)
  // Note: decrement week multiplier by one because 1st week is
  // represented by dayOfWeek value
  var absoluteDays = Number(dayOfWeek) + (7 * (Number(week) - 1));

  // convert from ISO weekday format to Gregorian calendar date
  // note: subtract 1 because 1-indexed; offset should not include 1st of month
  var delta = startDelta + absoluteDays - 1;
  var interval = new goog.date.Interval(goog.date.Interval.DAYS, delta);
  d.add(interval);
};


/**
 * Sets time fields based on an ISO 8601 format string.
 * Note: only time fields, not date fields.
 *
 * @param {!goog.date.DateTime} d Object whose fields will be set.
 * @param {string} formatted A time expressed in ISO 8601 format.
 * @return {boolean} Whether the parsing succeeded.
 * @private
 */
goog.date.setIso8601TimeOnly_ = function(d, formatted) {
  // first strip timezone info from the end
  var parts = formatted.match(goog.date.splitTimezoneStringRegex_);

  var offset = 0; // local time if no timezone info
  if (parts) {
    if (parts[0] != 'Z') {
      offset = parts[2] * 60 + Number(parts[3]);
      offset *= parts[1] == '-' ? 1 : -1;
    }
    offset -= d.getTimezoneOffset();
    formatted = formatted.substr(0, formatted.length - parts[0].length);
  }

  // then work out the time
  parts = formatted.match(goog.date.splitTimeStringRegex_);
  if (!parts) {
    return false;
  }

  d.setHours(Number(parts[1]));
  d.setMinutes(Number(parts[2]) || 0);
  d.setSeconds(Number(parts[3]) || 0);
  d.setMilliseconds(parts[4] ? parts[4] * 1000 : 0);

  if (offset != 0) {
    // adjust the date and time according to the specified timezone
    d.setTime(d.getTime() + offset * 60000);
  }

  return true;
};



/**
 * Class representing a date/time interval. Used for date calculations.
 * <pre>
 * new goog.date.Interval(0, 1) // One month
 * new goog.date.Interval(0, 0, 3, 1) // Three days and one hour
 * new goog.date.Interval(goog.date.Interval.DAYS, 1) // One day
 * </pre>
 *
 * @param {number|string=} opt_years Years or string representing date part.
 * @param {number=} opt_months Months or number of whatever date part specified
 *     by first parameter.
 * @param {number=} opt_days Days.
 * @param {number=} opt_hours Hours.
 * @param {number=} opt_minutes Minutes.
 * @param {number=} opt_seconds Seconds.
 * @constructor
 * @final
 */
goog.date.Interval = function(opt_years, opt_months, opt_days, opt_hours,
                              opt_minutes, opt_seconds) {
  if (goog.isString(opt_years)) {
    var type = opt_years;
    var interval = /** @type {number} */ (opt_months);
    this.years = type == goog.date.Interval.YEARS ? interval : 0;
    this.months = type == goog.date.Interval.MONTHS ? interval : 0;
    this.days = type == goog.date.Interval.DAYS ? interval : 0;
    this.hours = type == goog.date.Interval.HOURS ? interval : 0;
    this.minutes = type == goog.date.Interval.MINUTES ? interval : 0;
    this.seconds = type == goog.date.Interval.SECONDS ? interval : 0;
  } else {
    this.years = /** @type {number} */ (opt_years) || 0;
    this.months = opt_months || 0;
    this.days = opt_days || 0;
    this.hours = opt_hours || 0;
    this.minutes = opt_minutes || 0;
    this.seconds = opt_seconds || 0;
  }
};


/**
 * Parses an XML Schema duration (ISO 8601 extended).
 * @see http://www.w3.org/TR/xmlschema-2/#duration
 *
 * @param  {string} duration An XML schema duration in textual format.
 *     Recurring durations and weeks are not supported.
 * @return {goog.date.Interval} The duration as a goog.date.Interval or null
 *     if the parse fails.
 */
goog.date.Interval.fromIsoString = function(duration) {
  var parts = duration.match(goog.date.splitDurationRegex_);
  if (!parts) {
    return null;
  }

  var timeEmpty = !(parts[6] || parts[7] || parts[8]);
  var dateTimeEmpty = timeEmpty && !(parts[2] || parts[3] || parts[4]);
  if (dateTimeEmpty || timeEmpty && parts[5]) {
    return null;
  }

  var negative = parts[1];
  var years = parseInt(parts[2], 10) || 0;
  var months = parseInt(parts[3], 10) || 0;
  var days = parseInt(parts[4], 10) || 0;
  var hours = parseInt(parts[6], 10) || 0;
  var minutes = parseInt(parts[7], 10) || 0;
  var seconds = parseFloat(parts[8]) || 0;
  return negative ? new goog.date.Interval(-years, -months, -days,
                                           -hours, -minutes, -seconds) :
                    new goog.date.Interval(years, months, days,
                                           hours, minutes, seconds);
};


/**
 * Serializes goog.date.Interval into XML Schema duration (ISO 8601 extended).
 * @see http://www.w3.org/TR/xmlschema-2/#duration
 *
 * @param {boolean=} opt_verbose Include zero fields in the duration string.
 * @return {?string} An XML schema duration in ISO 8601 extended format,
 *     or null if the interval contains both positive and negative fields.
 */
goog.date.Interval.prototype.toIsoString = function(opt_verbose) {
  var minField = Math.min(this.years, this.months, this.days,
                          this.hours, this.minutes, this.seconds);
  var maxField = Math.max(this.years, this.months, this.days,
                          this.hours, this.minutes, this.seconds);
  if (minField < 0 && maxField > 0) {
    return null;
  }

  // Return 0 seconds if all fields are zero.
  if (!opt_verbose && minField == 0 && maxField == 0) {
    return 'PT0S';
  }

  var res = [];

  // Add sign and 'P' prefix.
  if (minField < 0) {
    res.push('-');
  }
  res.push('P');

  // Add date.
  if (this.years || opt_verbose) {
    res.push(Math.abs(this.years) + 'Y');
  }
  if (this.months || opt_verbose) {
    res.push(Math.abs(this.months) + 'M');
  }
  if (this.days || opt_verbose) {
    res.push(Math.abs(this.days) + 'D');
  }

  // Add time.
  if (this.hours || this.minutes || this.seconds || opt_verbose) {
    res.push('T');
    if (this.hours || opt_verbose) {
      res.push(Math.abs(this.hours) + 'H');
    }
    if (this.minutes || opt_verbose) {
      res.push(Math.abs(this.minutes) + 'M');
    }
    if (this.seconds || opt_verbose) {
      res.push(Math.abs(this.seconds) + 'S');
    }
  }

  return res.join('');
};


/**
 * Tests whether the given interval is equal to this interval.
 * Note, this is a simple field-by-field comparison, it doesn't
 * account for comparisons like "12 months == 1 year".
 *
 * @param {goog.date.Interval} other The interval to test.
 * @return {boolean} Whether the intervals are equal.
 */
goog.date.Interval.prototype.equals = function(other) {
  return other.years == this.years &&
         other.months == this.months &&
         other.days == this.days &&
         other.hours == this.hours &&
         other.minutes == this.minutes &&
         other.seconds == this.seconds;
};


/**
 * @return {!goog.date.Interval} A clone of the interval object.
 */
goog.date.Interval.prototype.clone = function() {
  return new goog.date.Interval(
      this.years, this.months, this.days,
      this.hours, this.minutes, this.seconds);
};


/**
 * Years constant for the date parts.
 * @type {string}
 */
goog.date.Interval.YEARS = 'y';


/**
 * Months constant for the date parts.
 * @type {string}
 */
goog.date.Interval.MONTHS = 'm';


/**
 * Days constant for the date parts.
 * @type {string}
 */
goog.date.Interval.DAYS = 'd';


/**
 * Hours constant for the date parts.
 * @type {string}
 */
goog.date.Interval.HOURS = 'h';


/**
 * Minutes constant for the date parts.
 * @type {string}
 */
goog.date.Interval.MINUTES = 'n';


/**
 * Seconds constant for the date parts.
 * @type {string}
 */
goog.date.Interval.SECONDS = 's';


/**
 * @return {boolean} Whether all fields of the interval are zero.
 */
goog.date.Interval.prototype.isZero = function() {
  return this.years == 0 &&
         this.months == 0 &&
         this.days == 0 &&
         this.hours == 0 &&
         this.minutes == 0 &&
         this.seconds == 0;
};


/**
 * @return {!goog.date.Interval} Negative of this interval.
 */
goog.date.Interval.prototype.getInverse = function() {
  return this.times(-1);
};


/**
 * Calculates n * (this interval) by memberwise multiplication.
 * @param {number} n An integer.
 * @return {!goog.date.Interval} n * this.
 */
goog.date.Interval.prototype.times = function(n) {
  return new goog.date.Interval(this.years * n,
                                this.months * n,
                                this.days * n,
                                this.hours * n,
                                this.minutes * n,
                                this.seconds * n);
};


/**
 * Gets the total number of seconds in the time interval. Assumes that months
 * and years are empty.
 * @return {number} Total number of seconds in the interval.
 */
goog.date.Interval.prototype.getTotalSeconds = function() {
  goog.asserts.assert(this.years == 0 && this.months == 0);
  return ((this.days * 24 + this.hours) * 60 + this.minutes) * 60 +
      this.seconds;
};


/**
 * Adds the Interval in the argument to this Interval field by field.
 *
 * @param {goog.date.Interval} interval The Interval to add.
 */
goog.date.Interval.prototype.add = function(interval) {
  this.years += interval.years;
  this.months += interval.months;
  this.days += interval.days;
  this.hours += interval.hours;
  this.minutes += interval.minutes;
  this.seconds += interval.seconds;
};



/**
 * Class representing a date. Defaults to current date if none is specified.
 *
 * Implements most methods of the native js Date object (except the time related
 * ones, {@see goog.date.DateTime}) and can be used interchangeably with it just
 * as if goog.date.Date was a synonym of Date. To make this more transparent,
 * Closure APIs should accept goog.date.DateLike instead of the real Date
 * object.
 *
 * To allow goog.date.Date objects to be passed as arguments to methods
 * expecting Date objects this class is marked as extending the built in Date
 * object even though that's not strictly true.
 *
 * @param {number|Object=} opt_year Four digit year or a date-like object. If
 *     not set, the created object will contain the date determined by
 *     goog.now().
 * @param {number=} opt_month Month, 0 = Jan, 11 = Dec.
 * @param {number=} opt_date Date of month, 1 - 31.
 * @constructor
 * @see goog.date.DateTime
 */
goog.date.Date = function(opt_year, opt_month, opt_date) {
  /** @protected {!Date} The wrapped date or datetime. */
  this.date;
  // goog.date.DateTime assumes that only this.date is added in this ctor.
  if (goog.isNumber(opt_year)) {
    this.date = this.buildDate_(opt_year, opt_month || 0, opt_date || 1);
    this.maybeFixDst_(opt_date || 1);
  } else if (goog.isObject(opt_year)) {
    this.date = this.buildDate_(opt_year.getFullYear(), opt_year.getMonth(),
        opt_year.getDate());
    this.maybeFixDst_(opt_year.getDate());
  } else {
    this.date = new Date(goog.now());
    this.date.setHours(0);
    this.date.setMinutes(0);
    this.date.setSeconds(0);
    this.date.setMilliseconds(0);
  }
};


/**
 * new Date(y, m, d) treats years in the interval [0, 100) as two digit years,
 * adding 1900 to them. This method ensures that calling the date constructor
 * as a copy constructor returns a value that is equal to the passed in
 * date value by explicitly setting the full year.
 * @private
 * @param {number} fullYear The full year (including century).
 * @param {number} month The month, from 0-11.
 * @param {number} date The day of the month.
 * @return {!Date} The constructed Date object.
 */
goog.date.Date.prototype.buildDate_ = function(fullYear, month, date) {
  var d = new Date(fullYear, month, date);
  if (fullYear >= 0 && fullYear < 100) {
    // Can't just setFullYear as new Date() can flip over for e.g. month = 13.
    d.setFullYear(d.getFullYear() - 1900);
  }
  return d;
};


/**
 * First day of week. 0 = Mon, 6 = Sun.
 * @type {number}
 * @private
 */
goog.date.Date.prototype.firstDayOfWeek_ =
    goog.i18n.DateTimeSymbols.FIRSTDAYOFWEEK;


/**
 * The cut off weekday used for week number calculations. 0 = Mon, 6 = Sun.
 * @type {number}
 * @private
 */
goog.date.Date.prototype.firstWeekCutOffDay_ =
    goog.i18n.DateTimeSymbols.FIRSTWEEKCUTOFFDAY;


/**
 * @return {!goog.date.Date} A clone of the date object.
 */
goog.date.Date.prototype.clone = function() {
  var date = new goog.date.Date(this.date);
  date.firstDayOfWeek_ = this.firstDayOfWeek_;
  date.firstWeekCutOffDay_ = this.firstWeekCutOffDay_;

  return date;
};


/**
 * @return {number} The four digit year of date.
 */
goog.date.Date.prototype.getFullYear = function() {
  return this.date.getFullYear();
};


/**
 * Alias for getFullYear.
 *
 * @return {number} The four digit year of date.
 * @see #getFullyear
 */
goog.date.Date.prototype.getYear = function() {
  return this.getFullYear();
};


/**
 * @return {goog.date.month} The month of date, 0 = Jan, 11 = Dec.
 */
goog.date.Date.prototype.getMonth = function() {
  return /** @type {goog.date.month} */ (this.date.getMonth());
};


/**
 * @return {number} The date of month.
 */
goog.date.Date.prototype.getDate = function() {
  return this.date.getDate();
};


/**
 * Returns the number of milliseconds since 1 January 1970 00:00:00.
 *
 * @return {number} The number of milliseconds since 1 January 1970 00:00:00.
 */
goog.date.Date.prototype.getTime = function() {
  return this.date.getTime();
};


/**
 * @return {goog.date.weekDay} The day of week, US style. 0 = Sun, 6 = Sat.
 */
goog.date.Date.prototype.getDay = function() {
  return /** @type {goog.date.weekDay} */ (this.date.getDay());
};


/**
 * @return {number} The day of week, ISO style. 0 = Mon, 6 = Sun.
 */
goog.date.Date.prototype.getIsoWeekday = function() {
  return (this.getDay() + 6) % 7;
};


/**
 * @return {number} The day of week according to firstDayOfWeek setting.
 */
goog.date.Date.prototype.getWeekday = function() {
  return (this.getIsoWeekday() - this.firstDayOfWeek_ + 7) % 7;
};


/**
 * @return {number} The four digit year of date according to universal time.
 */
goog.date.Date.prototype.getUTCFullYear = function() {
  return this.date.getUTCFullYear();
};


/**
 * @return {goog.date.month} The month of date according to universal time,
 *     0 = Jan, 11 = Dec.
 */
goog.date.Date.prototype.getUTCMonth = function() {
  return /** @type {goog.date.month} */ (this.date.getUTCMonth());
};


/**
 * @return {number} The date of month according to universal time.
 */
goog.date.Date.prototype.getUTCDate = function() {
  return this.date.getUTCDate();
};


/**
 * @return {goog.date.weekDay} The day of week according to universal time,
 *     US style. 0 = Sun, 1 = Mon, 6 = Sat.
 */
goog.date.Date.prototype.getUTCDay = function() {
  return /** @type {goog.date.weekDay} */ (this.date.getDay());
};


/**
 * @return {number} The hours value according to universal time.
 */
goog.date.Date.prototype.getUTCHours = function() {
  return this.date.getUTCHours();
};


/**
 * @return {number} The hours value according to universal time.
 */
goog.date.Date.prototype.getUTCMinutes = function() {
  return this.date.getUTCMinutes();
};


/**
 * @return {number} The day of week according to universal time, ISO style.
 *     0 = Mon, 6 = Sun.
 */
goog.date.Date.prototype.getUTCIsoWeekday = function() {
  return (this.date.getUTCDay() + 6) % 7;
};


/**
 * @return {number} The day of week according to universal time and
 *     firstDayOfWeek setting.
 */
goog.date.Date.prototype.getUTCWeekday = function() {
  return (this.getUTCIsoWeekday() - this.firstDayOfWeek_ + 7) % 7;
};


/**
 * @return {number} The first day of the week. 0 = Mon, 6 = Sun.
 */
goog.date.Date.prototype.getFirstDayOfWeek = function() {
  return this.firstDayOfWeek_;
};


/**
 * @return {number} The cut off weekday used for week number calculations.
 *     0 = Mon, 6 = Sun.
 */
goog.date.Date.prototype.getFirstWeekCutOffDay = function() {
  return this.firstWeekCutOffDay_;
};


/**
 * @return {number} The number of days for the selected month.
 */
goog.date.Date.prototype.getNumberOfDaysInMonth = function() {
  return goog.date.getNumberOfDaysInMonth(this.getFullYear(), this.getMonth());
};


/**
 * @return {number} The week number.
 */
goog.date.Date.prototype.getWeekNumber = function() {
  return goog.date.getWeekNumber(
      this.getFullYear(), this.getMonth(), this.getDate(),
      this.firstWeekCutOffDay_, this.firstDayOfWeek_);
};


/**
 * @return {number} The day of year.
 */
goog.date.Date.prototype.getDayOfYear = function() {
  var dayOfYear = this.getDate();
  var year = this.getFullYear();
  for (var m = this.getMonth() - 1; m >= 0; m--) {
    dayOfYear += goog.date.getNumberOfDaysInMonth(year, m);
  }

  return dayOfYear;
};


/**
 * Returns timezone offset. The timezone offset is the delta in minutes between
 * UTC and your local time. E.g., UTC+10 returns -600. Daylight savings time
 * prevents this value from being constant.
 *
 * @return {number} The timezone offset.
 */
goog.date.Date.prototype.getTimezoneOffset = function() {
  return this.date.getTimezoneOffset();
};


/**
 * Returns timezone offset as a string. Returns offset in [+-]HH:mm format or Z
 * for UTC.
 *
 * @return {string} The timezone offset as a string.
 */
goog.date.Date.prototype.getTimezoneOffsetString = function() {
  var tz;
  var offset = this.getTimezoneOffset();

  if (offset == 0) {
    tz = 'Z';
  } else {
    var n = Math.abs(offset) / 60;
    var h = Math.floor(n);
    var m = (n - h) * 60;
    tz = (offset > 0 ? '-' : '+') +
        goog.string.padNumber(h, 2) + ':' +
        goog.string.padNumber(m, 2);
  }

  return tz;
};


/**
 * Sets the date.
 *
 * @param {goog.date.Date} date Date object to set date from.
 */
goog.date.Date.prototype.set = function(date) {
  this.date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
};


/**
 * Sets the year part of the date.
 *
 * @param {number} year Four digit year.
 */
goog.date.Date.prototype.setFullYear = function(year) {
  this.date.setFullYear(year);
};


/**
 * Alias for setFullYear.
 *
 * @param {number} year Four digit year.
 * @see #setFullYear
 */
goog.date.Date.prototype.setYear = function(year) {
  this.setFullYear(year);
};


/**
 * Sets the month part of the date.
 *
 * TODO(nnaze): Update type to goog.date.month.
 *
 * @param {number} month The month, where 0 = Jan, 11 = Dec.
 */
goog.date.Date.prototype.setMonth = function(month) {
  this.date.setMonth(month);
};


/**
 * Sets the day part of the date.
 *
 * @param {number} date The day part.
 */
goog.date.Date.prototype.setDate = function(date) {
  this.date.setDate(date);
};


/**
 * Sets the value of the date object as expressed in the number of milliseconds
 * since 1 January 1970 00:00:00.
 *
 * @param {number} ms Number of milliseconds since 1 Jan 1970.
 */
goog.date.Date.prototype.setTime = function(ms) {
  this.date.setTime(ms);
};


/**
 * Sets the year part of the date according to universal time.
 *
 * @param {number} year Four digit year.
 */
goog.date.Date.prototype.setUTCFullYear = function(year) {
  this.date.setUTCFullYear(year);
};


/**
 * Sets the month part of the date according to universal time.
 *
 * @param {number} month The month, where 0 = Jan, 11 = Dec.
 */
goog.date.Date.prototype.setUTCMonth = function(month) {
  this.date.setUTCMonth(month);
};


/**
 * Sets the day part of the date according to universal time.
 *
 * @param {number} date The UTC date.
 */
goog.date.Date.prototype.setUTCDate = function(date) {
  this.date.setUTCDate(date);
};


/**
 * Sets the first day of week.
 *
 * @param {number} day 0 = Mon, 6 = Sun.
 */
goog.date.Date.prototype.setFirstDayOfWeek = function(day) {
  this.firstDayOfWeek_ = day;
};


/**
 * Sets cut off weekday used for week number calculations. 0 = Mon, 6 = Sun.
 *
 * @param {number} day The cut off weekday.
 */
goog.date.Date.prototype.setFirstWeekCutOffDay = function(day) {
  this.firstWeekCutOffDay_ = day;
};


/**
 * Performs date calculation by adding the supplied interval to the date.
 *
 * @param {goog.date.Interval} interval Date interval to add.
 */
goog.date.Date.prototype.add = function(interval) {
  if (interval.years || interval.months) {
    // As months have different number of days adding a month to Jan 31 by just
    // setting the month would result in a date in early March rather than Feb
    // 28 or 29. Doing it this way overcomes that problem.

    // adjust year and month, accounting for both directions
    var month = this.getMonth() + interval.months + interval.years * 12;
    var year = this.getYear() + Math.floor(month / 12);
    month %= 12;
    if (month < 0) {
      month += 12;
    }

    var daysInTargetMonth = goog.date.getNumberOfDaysInMonth(year, month);
    var date = Math.min(daysInTargetMonth, this.getDate());

    // avoid inadvertently causing rollovers to adjacent months
    this.setDate(1);

    this.setFullYear(year);
    this.setMonth(month);
    this.setDate(date);
  }

  if (interval.days) {
    // Convert the days to milliseconds and add it to the UNIX timestamp.
    // Taking noon helps to avoid 1 day error due to the daylight saving.
    var noon = new Date(this.getYear(), this.getMonth(), this.getDate(), 12);
    var result = new Date(noon.getTime() + interval.days * 86400000);

    // Set date to 1 to prevent rollover caused by setting the year or month.
    this.setDate(1);
    this.setFullYear(result.getFullYear());
    this.setMonth(result.getMonth());
    this.setDate(result.getDate());

    this.maybeFixDst_(result.getDate());
  }
};


/**
 * Returns ISO 8601 string representation of date.
 *
 * @param {boolean=} opt_verbose Whether the verbose format should be used
 *     instead of the default compact one.
 * @param {boolean=} opt_tz Whether the timezone offset should be included
 *     in the string.
 * @return {string} ISO 8601 string representation of date.
 */
goog.date.Date.prototype.toIsoString = function(opt_verbose, opt_tz) {
  var str = [
    this.getFullYear(),
    goog.string.padNumber(this.getMonth() + 1, 2),
    goog.string.padNumber(this.getDate(), 2)
  ];

  return str.join((opt_verbose) ? '-' : '') +
         (opt_tz ? this.getTimezoneOffsetString() : '');
};


/**
 * Returns ISO 8601 string representation of date according to universal time.
 *
 * @param {boolean=} opt_verbose Whether the verbose format should be used
 *     instead of the default compact one.
 * @param {boolean=} opt_tz Whether the timezone offset should be included in
 *     the string.
 * @return {string} ISO 8601 string representation of date according to
 *     universal time.
 */
goog.date.Date.prototype.toUTCIsoString = function(opt_verbose, opt_tz) {
  var str = [
    this.getUTCFullYear(),
    goog.string.padNumber(this.getUTCMonth() + 1, 2),
    goog.string.padNumber(this.getUTCDate(), 2)
  ];

  return str.join((opt_verbose) ? '-' : '') + (opt_tz ? 'Z' : '');
};


/**
 * Tests whether given date is equal to this Date.
 * Note: This ignores units more precise than days (hours and below)
 * and also ignores timezone considerations.
 *
 * @param {goog.date.Date} other The date to compare.
 * @return {boolean} Whether the given date is equal to this one.
 */
goog.date.Date.prototype.equals = function(other) {
  return !!(other &&
            this.getYear() == other.getYear() &&
            this.getMonth() == other.getMonth() &&
            this.getDate() == other.getDate());
};


/**
 * Overloaded toString method for object.
 * @return {string} ISO 8601 string representation of date.
 * @override
 */
goog.date.Date.prototype.toString = function() {
  return this.toIsoString();
};


/**
 * Fixes date to account for daylight savings time in browsers that fail to do
 * so automatically.
 * @param {number} expected Expected date.
 * @private
 */
goog.date.Date.prototype.maybeFixDst_ = function(expected) {
  if (this.getDate() != expected) {
    var dir = this.getDate() < expected ? 1 : -1;
    this.date.setUTCHours(this.date.getUTCHours() + dir);
  }
};


/**
 * @return {number} Value of wrapped date.
 * @override
 */
goog.date.Date.prototype.valueOf = function() {
  return this.date.valueOf();
};


/**
 * Compares two dates.  May be used as a sorting function.
 * @see goog.array.sort
 * @param {!goog.date.DateLike} date1 Date to compare.
 * @param {!goog.date.DateLike} date2 Date to compare.
 * @return {number} Comparison result. 0 if dates are the same, less than 0 if
 *     date1 is earlier than date2, greater than 0 if date1 is later than date2.
 */
goog.date.Date.compare = function(date1, date2) {
  return date1.getTime() - date2.getTime();
};



/**
 * Class representing a date and time. Defaults to current date and time if none
 * is specified.
 *
 * Implements most methods of the native js Date object and can be used
 * interchangeably with it just as if goog.date.DateTime was a subclass of Date.
 *
 * @param {number|Object=} opt_year Four digit year or a date-like object. If
 *     not set, the created object will contain the date determined by
 *     goog.now().
 * @param {number=} opt_month Month, 0 = Jan, 11 = Dec.
 * @param {number=} opt_date Date of month, 1 - 31.
 * @param {number=} opt_hours Hours, 0 - 24.
 * @param {number=} opt_minutes Minutes, 0 - 59.
 * @param {number=} opt_seconds Seconds, 0 - 61.
 * @param {number=} opt_milliseconds Milliseconds, 0 - 999.
 * @constructor
 * @extends {goog.date.Date}
 */
goog.date.DateTime = function(opt_year, opt_month, opt_date, opt_hours,
                              opt_minutes, opt_seconds, opt_milliseconds) {
  if (goog.isNumber(opt_year)) {
    this.date = new Date(opt_year, opt_month || 0, opt_date || 1,
        opt_hours || 0, opt_minutes || 0, opt_seconds || 0,
        opt_milliseconds || 0);
  } else {
    this.date = new Date(opt_year ? opt_year.getTime() : goog.now());
  }
};
goog.inherits(goog.date.DateTime, goog.date.Date);


/**
 * Creates a DateTime from a datetime string expressed in RFC 822 format.
 *
 * @param {string} formatted A date or datetime expressed in RFC 822 format.
 * @return {goog.date.DateTime} Parsed date or null if parse fails.
 */
goog.date.DateTime.fromRfc822String = function(formatted) {
  var date = new Date(formatted);
  return !isNaN(date.getTime()) ? new goog.date.DateTime(date) : null;
};


/**
 * Returns the hours part of the datetime.
 *
 * @return {number} An integer between 0 and 23, representing the hour.
 */
goog.date.DateTime.prototype.getHours = function() {
  return this.date.getHours();
};


/**
 * Returns the minutes part of the datetime.
 *
 * @return {number} An integer between 0 and 59, representing the minutes.
 */
goog.date.DateTime.prototype.getMinutes = function() {
  return this.date.getMinutes();
};


/**
 * Returns the seconds part of the datetime.
 *
 * @return {number} An integer between 0 and 59, representing the seconds.
 */
goog.date.DateTime.prototype.getSeconds = function() {
  return this.date.getSeconds();
};


/**
 * Returns the milliseconds part of the datetime.
 *
 * @return {number} An integer between 0 and 999, representing the milliseconds.
 */
goog.date.DateTime.prototype.getMilliseconds = function() {
  return this.date.getMilliseconds();
};


/**
 * Returns the day of week according to universal time, US style.
 *
 * @return {goog.date.weekDay} Day of week, 0 = Sun, 1 = Mon, 6 = Sat.
 * @override
 */
goog.date.DateTime.prototype.getUTCDay = function() {
  return /** @type {goog.date.weekDay} */ (this.date.getUTCDay());
};


/**
 * Returns the hours part of the datetime according to universal time.
 *
 * @return {number} An integer between 0 and 23, representing the hour.
 * @override
 */
goog.date.DateTime.prototype.getUTCHours = function() {
  return this.date.getUTCHours();
};


/**
 * Returns the minutes part of the datetime according to universal time.
 *
 * @return {number} An integer between 0 and 59, representing the minutes.
 * @override
 */
goog.date.DateTime.prototype.getUTCMinutes = function() {
  return this.date.getUTCMinutes();
};


/**
 * Returns the seconds part of the datetime according to universal time.
 *
 * @return {number} An integer between 0 and 59, representing the seconds.
 */
goog.date.DateTime.prototype.getUTCSeconds = function() {
  return this.date.getUTCSeconds();
};


/**
 * Returns the milliseconds part of the datetime according to universal time.
 *
 * @return {number} An integer between 0 and 999, representing the milliseconds.
 */
goog.date.DateTime.prototype.getUTCMilliseconds = function() {
  return this.date.getUTCMilliseconds();
};


/**
 * Sets the hours part of the datetime.
 *
 * @param {number} hours An integer between 0 and 23, representing the hour.
 */
goog.date.DateTime.prototype.setHours = function(hours) {
  this.date.setHours(hours);
};


/**
 * Sets the minutes part of the datetime.
 *
 * @param {number} minutes Integer between 0 and 59, representing the minutes.
 */
goog.date.DateTime.prototype.setMinutes = function(minutes) {
  this.date.setMinutes(minutes);
};


/**
 * Sets the seconds part of the datetime.
 *
 * @param {number} seconds Integer between 0 and 59, representing the seconds.
 */
goog.date.DateTime.prototype.setSeconds = function(seconds) {
  this.date.setSeconds(seconds);
};


/**
 * Sets the seconds part of the datetime.
 *
 * @param {number} ms Integer between 0 and 999, representing the milliseconds.
 */
goog.date.DateTime.prototype.setMilliseconds = function(ms) {
  this.date.setMilliseconds(ms);
};


/**
 * Sets the hours part of the datetime according to universal time.
 *
 * @param {number} hours An integer between 0 and 23, representing the hour.
 */
goog.date.DateTime.prototype.setUTCHours = function(hours) {
  this.date.setUTCHours(hours);
};


/**
 * Sets the minutes part of the datetime according to universal time.
 *
 * @param {number} minutes Integer between 0 and 59, representing the minutes.
 */
goog.date.DateTime.prototype.setUTCMinutes = function(minutes) {
  this.date.setUTCMinutes(minutes);
};


/**
 * Sets the seconds part of the datetime according to universal time.
 *
 * @param {number} seconds Integer between 0 and 59, representing the seconds.
 */
goog.date.DateTime.prototype.setUTCSeconds = function(seconds) {
  this.date.setUTCSeconds(seconds);
};


/**
 * Sets the seconds part of the datetime according to universal time.
 *
 * @param {number} ms Integer between 0 and 999, representing the milliseconds.
 */
goog.date.DateTime.prototype.setUTCMilliseconds = function(ms) {
  this.date.setUTCMilliseconds(ms);
};


/**
 * @return {boolean} Whether the datetime is aligned to midnight.
 */
goog.date.DateTime.prototype.isMidnight = function() {
  return this.getHours() == 0 && this.getMinutes() == 0 &&
      this.getSeconds() == 0 && this.getMilliseconds() == 0;
};


/**
 * Performs date calculation by adding the supplied interval to the date.
 *
 * @param {goog.date.Interval} interval Date interval to add.
 * @override
 */
goog.date.DateTime.prototype.add = function(interval) {
  goog.date.Date.prototype.add.call(this, interval);

  if (interval.hours) {
    this.setHours(this.date.getHours() + interval.hours);
  }
  if (interval.minutes) {
    this.setMinutes(this.date.getMinutes() + interval.minutes);
  }
  if (interval.seconds) {
    this.setSeconds(this.date.getSeconds() + interval.seconds);
  }
};


/**
 * Returns ISO 8601 string representation of date/time.
 *
 * @param {boolean=} opt_verbose Whether the verbose format should be used
 *     instead of the default compact one.
 * @param {boolean=} opt_tz Whether the timezone offset should be included
 *     in the string.
 * @return {string} ISO 8601 string representation of date/time.
 * @override
 */
goog.date.DateTime.prototype.toIsoString = function(opt_verbose, opt_tz) {
  var dateString = goog.date.Date.prototype.toIsoString.call(this, opt_verbose);

  if (opt_verbose) {
    return dateString + ' ' +
        goog.string.padNumber(this.getHours(), 2) + ':' +
        goog.string.padNumber(this.getMinutes(), 2) + ':' +
        goog.string.padNumber(this.getSeconds(), 2) +
        (opt_tz ? this.getTimezoneOffsetString() : '');
  }

  return dateString + 'T' +
      goog.string.padNumber(this.getHours(), 2) +
      goog.string.padNumber(this.getMinutes(), 2) +
      goog.string.padNumber(this.getSeconds(), 2) +
      (opt_tz ? this.getTimezoneOffsetString() : '');
};


/**
 * Returns XML Schema 2 string representation of date/time.
 * The return value is also ISO 8601 compliant.
 *
 * @param {boolean=} opt_timezone Should the timezone offset be included in the
 *     string?.
 * @return {string} XML Schema 2 string representation of date/time.
 */
goog.date.DateTime.prototype.toXmlDateTime = function(opt_timezone) {
  return goog.date.Date.prototype.toIsoString.call(this, true) + 'T' +
      goog.string.padNumber(this.getHours(), 2) + ':' +
      goog.string.padNumber(this.getMinutes(), 2) + ':' +
      goog.string.padNumber(this.getSeconds(), 2) +
      (opt_timezone ? this.getTimezoneOffsetString() : '');
};


/**
 * Returns ISO 8601 string representation of date/time according to universal
 * time.
 *
 * @param {boolean=} opt_verbose Whether the opt_verbose format should be
 *     returned instead of the default compact one.
 * @param {boolean=} opt_tz Whether the the timezone offset should be included
 *     in the string.
 * @return {string} ISO 8601 string representation of date/time according to
 *     universal time.
 * @override
 */
goog.date.DateTime.prototype.toUTCIsoString = function(opt_verbose, opt_tz) {
  var dateStr = goog.date.Date.prototype.toUTCIsoString.call(this, opt_verbose);

  if (opt_verbose) {
    return dateStr + ' ' +
        goog.string.padNumber(this.getUTCHours(), 2) + ':' +
        goog.string.padNumber(this.getUTCMinutes(), 2) + ':' +
        goog.string.padNumber(this.getUTCSeconds(), 2) +
        (opt_tz ? 'Z' : '');
  }

  return dateStr + 'T' +
      goog.string.padNumber(this.getUTCHours(), 2) +
      goog.string.padNumber(this.getUTCMinutes(), 2) +
      goog.string.padNumber(this.getUTCSeconds(), 2) +
      (opt_tz ? 'Z' : '');
};


/**
 * Tests whether given datetime is exactly equal to this DateTime.
 *
 * @param {goog.date.Date} other The datetime to compare.
 * @return {boolean} Whether the given datetime is exactly equal to this one.
 * @override
 */
goog.date.DateTime.prototype.equals = function(other) {
  return this.getTime() == other.getTime();
};


/**
 * Overloaded toString method for object.
 * @return {string} ISO 8601 string representation of date/time.
 * @override
 */
goog.date.DateTime.prototype.toString = function() {
  return this.toIsoString();
};


/**
 * Generates time label for the datetime, e.g., '5:30am'.
 * By default this does not pad hours (e.g., to '05:30') and it does add
 * an am/pm suffix.
 * TODO(timman): i18n -- hardcoding time format like this is bad.  E.g., in CJK
 *               locales, need Chinese characters for hour and minute units.
 * @param {boolean=} opt_padHours Whether to pad hours, e.g., '05:30' vs '5:30'.
 * @param {boolean=} opt_showAmPm Whether to show the 'am' and 'pm' suffix.
 * @param {boolean=} opt_omitZeroMinutes E.g., '5:00pm' becomes '5pm',
 *                                      but '5:01pm' remains '5:01pm'.
 * @return {string} The time label.
 */
goog.date.DateTime.prototype.toUsTimeString = function(opt_padHours,
                                                       opt_showAmPm,
                                                       opt_omitZeroMinutes) {
  var hours = this.getHours();

  // show am/pm marker by default
  if (!goog.isDef(opt_showAmPm)) {
    opt_showAmPm = true;
  }

  // 12pm
  var isPM = hours == 12;

  // change from 1-24 to 1-12 basis
  if (hours > 12) {
    hours -= 12;
    isPM = true;
  }

  // midnight is expressed as "12am", but if am/pm marker omitted, keep as '0'
  if (hours == 0 && opt_showAmPm) {
    hours = 12;
  }

  var label = opt_padHours ? goog.string.padNumber(hours, 2) : String(hours);
  var minutes = this.getMinutes();
  if (!opt_omitZeroMinutes || minutes > 0) {
    label += ':' + goog.string.padNumber(minutes, 2);
  }

  // by default, show am/pm suffix
  if (opt_showAmPm) {
    /**
     * @desc Suffix for morning times.
     */
    var MSG_TIME_AM = goog.getMsg('am');

    /**
     * @desc Suffix for afternoon times.
     */
    var MSG_TIME_PM = goog.getMsg('pm');

    label += isPM ? MSG_TIME_PM : MSG_TIME_AM;
  }
  return label;
};


/**
 * Generates time label for the datetime in standard ISO 24-hour time format.
 * E.g., '06:00:00' or '23:30:15'.
 * @param {boolean=} opt_showSeconds Whether to shows seconds. Defaults to TRUE.
 * @return {string} The time label.
 */
goog.date.DateTime.prototype.toIsoTimeString = function(opt_showSeconds) {
  var hours = this.getHours();
  var label = goog.string.padNumber(hours, 2) +
              ':' +
              goog.string.padNumber(this.getMinutes(), 2);
  if (!goog.isDef(opt_showSeconds) || opt_showSeconds) {
    label += ':' + goog.string.padNumber(this.getSeconds(), 2);
  }
  return label;
};


/**
 * @return {!goog.date.DateTime} A clone of the datetime object.
 * @override
 */
goog.date.DateTime.prototype.clone = function() {
  var date = new goog.date.DateTime(this.date);
  date.setFirstDayOfWeek(this.getFirstDayOfWeek());
  date.setFirstWeekCutOffDay(this.getFirstWeekCutOffDay());
  return date;
};

//javascript/closure/date/utcdatetime.js
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Locale independent date/time class.
 *
 * @author pallosp@google.com (Peter Pallos)
 */

goog.provide('goog.date.UtcDateTime');

goog.require('goog.date');
goog.require('goog.date.Date');
goog.require('goog.date.DateTime');
goog.require('goog.date.Interval');



/**
 * Class representing a date/time in GMT+0 time zone, without daylight saving.
 * Defaults to current date and time if none is specified. The get... and the
 * getUTC... methods are equivalent.
 *
 * @param {number|Object=} opt_year Four digit UTC year or a date-like object.
 *     If not set, the created object will contain the date determined by
 *     goog.now().
 * @param {number=} opt_month UTC month, 0 = Jan, 11 = Dec.
 * @param {number=} opt_date UTC date of month, 1 - 31.
 * @param {number=} opt_hours UTC hours, 0 - 23.
 * @param {number=} opt_minutes UTC minutes, 0 - 59.
 * @param {number=} opt_seconds UTC seconds, 0 - 59.
 * @param {number=} opt_milliseconds UTC milliseconds, 0 - 999.
 * @constructor
 * @extends {goog.date.DateTime}
 */
goog.date.UtcDateTime = function(opt_year, opt_month, opt_date, opt_hours,
                                 opt_minutes, opt_seconds, opt_milliseconds) {
  var timestamp;
  if (goog.isNumber(opt_year)) {
    timestamp = Date.UTC(opt_year, opt_month || 0, opt_date || 1,
                         opt_hours || 0, opt_minutes || 0, opt_seconds || 0,
                         opt_milliseconds || 0);
  } else {
    timestamp = opt_year ? opt_year.getTime() : goog.now();
  }
  this.date = new Date(timestamp);
};
goog.inherits(goog.date.UtcDateTime, goog.date.DateTime);


/**
 * Creates a DateTime from a UTC datetime string expressed in ISO 8601 format.
 *
 * @param {string} formatted A date or datetime expressed in ISO 8601 format.
 * @return {goog.date.UtcDateTime} Parsed date or null if parse fails.
 */
goog.date.UtcDateTime.fromIsoString = function(formatted) {
  var ret = new goog.date.UtcDateTime(2000);
  return goog.date.setIso8601DateTime(ret, formatted) ? ret : null;
};


/**
 * Clones the UtcDateTime object.
 *
 * @return {!goog.date.UtcDateTime} A clone of the datetime object.
 * @override
 */
goog.date.UtcDateTime.prototype.clone = function() {
  var date = new goog.date.UtcDateTime(this.date);
  date.setFirstDayOfWeek(this.getFirstDayOfWeek());
  date.setFirstWeekCutOffDay(this.getFirstWeekCutOffDay());
  return date;
};


/** @override */
goog.date.UtcDateTime.prototype.add = function(interval) {
  if (interval.years || interval.months) {
    var yearsMonths = new goog.date.Interval(interval.years, interval.months);
    goog.date.Date.prototype.add.call(this, yearsMonths);
  }
  var daysAndTimeMillis = 1000 * (
      interval.seconds + 60 * (
          interval.minutes + 60 * (
              interval.hours + 24 * interval.days)));
  this.date = new Date(this.date.getTime() + daysAndTimeMillis);
};


/** @override */
goog.date.UtcDateTime.prototype.getTimezoneOffset = function() {
  return 0;
};


/** @override */
goog.date.UtcDateTime.prototype.getFullYear =
    goog.date.DateTime.prototype.getUTCFullYear;


/** @override */
goog.date.UtcDateTime.prototype.getMonth =
    goog.date.DateTime.prototype.getUTCMonth;


/** @override */
goog.date.UtcDateTime.prototype.getDate =
    goog.date.DateTime.prototype.getUTCDate;


/** @override */
goog.date.UtcDateTime.prototype.getHours =
    goog.date.DateTime.prototype.getUTCHours;


/** @override */
goog.date.UtcDateTime.prototype.getMinutes =
    goog.date.DateTime.prototype.getUTCMinutes;


/** @override */
goog.date.UtcDateTime.prototype.getSeconds =
    goog.date.DateTime.prototype.getUTCSeconds;


/** @override */
goog.date.UtcDateTime.prototype.getMilliseconds =
    goog.date.DateTime.prototype.getUTCMilliseconds;


/** @override */
goog.date.UtcDateTime.prototype.getDay =
    goog.date.DateTime.prototype.getUTCDay;


/** @override */
goog.date.UtcDateTime.prototype.setFullYear =
    goog.date.DateTime.prototype.setUTCFullYear;


/** @override */
goog.date.UtcDateTime.prototype.setMonth =
    goog.date.DateTime.prototype.setUTCMonth;


/** @override */
goog.date.UtcDateTime.prototype.setDate =
    goog.date.DateTime.prototype.setUTCDate;


/** @override */
goog.date.UtcDateTime.prototype.setHours =
    goog.date.DateTime.prototype.setUTCHours;


/** @override */
goog.date.UtcDateTime.prototype.setMinutes =
    goog.date.DateTime.prototype.setUTCMinutes;


/** @override */
goog.date.UtcDateTime.prototype.setSeconds =
    goog.date.DateTime.prototype.setUTCSeconds;


/** @override */
goog.date.UtcDateTime.prototype.setMilliseconds =
    goog.date.DateTime.prototype.setUTCMilliseconds;

//javascript/closure/i18n/timezone.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Functions to provide timezone information for use with
 * date/time format.
 * @author shanjian@google.com (Shanjian Li)
 */

goog.provide('goog.i18n.TimeZone');

goog.require('goog.array');
goog.require('goog.date.DateLike');
goog.require('goog.string');



/**
 * TimeZone class implemented a time zone resolution and name information
 * source for client applications. The time zone object is initiated from
 * a time zone information object. Application can initiate a time zone
 * statically, or it may choose to initiate from a data obtained from server.
 * Each time zone information array is small, but the whole set of data
 * is too much for client application to download. If end user is allowed to
 * change time zone setting, dynamic retrieval should be the method to use.
 * In case only time zone offset is known, there is a decent fallback
 * that only use the time zone offset to create a TimeZone object.
 * A whole set of time zone information array was available under
 * http://go/js_locale_data. It is generated based on CLDR and
 * Olson time zone data base (through pytz), and will be updated timely.
 *
 * @constructor
 * @final
 */
goog.i18n.TimeZone = function() {
  /**
   * The standard time zone id.
   * @type {string}
   * @private
   */
  this.timeZoneId_;


  /**
   * The standard, non-daylight time zone offset, in minutes WEST of UTC.
   * @type {number}
   * @private
   */
  this.standardOffset_;


  /**
   * An array of strings that can have 2 or 4 elements.  The first two elements
   * are the long and short names for standard time in this time zone, and the
   * last two elements (if present) are the long and short names for daylight
   * time in this time zone.
   * @type {Array.<string>}
   * @private
   */
  this.tzNames_;


  /**
   * This array specifies the Daylight Saving Time transitions for this time
   * zone.  This is a flat array of numbers which are interpreted in pairs:
   * [time1, adjustment1, time2, adjustment2, ...] where each time is a DST
   * transition point given as a number of hours since 00:00 UTC, January 1,
   * 1970, and each adjustment is the adjustment to apply for times after the
   * DST transition, given as minutes EAST of UTC.
   * @type {Array.<number>}
   * @private
   */
  this.transitions_;
};


/**
 * The number of milliseconds in an hour.
 * @type {number}
 * @private
 */
goog.i18n.TimeZone.MILLISECONDS_PER_HOUR_ = 3600 * 1000;


/**
 * Indices into the array of time zone names.
 * @enum {number}
 */
goog.i18n.TimeZone.NameType = {
  STD_SHORT_NAME: 0,
  STD_LONG_NAME: 1,
  DLT_SHORT_NAME: 2,
  DLT_LONG_NAME: 3
};


/**
 * This factory method creates a time zone instance.  It takes either an object
 * containing complete time zone information, or a single number representing a
 * constant time zone offset.  If the latter form is used, DST functionality is
 * not available.
 *
 * @param {number|Object} timeZoneData If this parameter is a number, it should
 *     indicate minutes WEST of UTC to be used as a constant time zone offset.
 *     Otherwise, it should be an object with these four fields:
 *     <ul>
 *     <li>id: A string ID for the time zone.
 *     <li>std_offset: The standard time zone offset in minutes EAST of UTC.
 *     <li>names: An array of four names (standard short name, standard long
 *           name, daylight short name, daylight long, name)
 *     <li>transitions: An array of numbers which are interpreted in pairs:
 *           [time1, adjustment1, time2, adjustment2, ...] where each time is
 *           a DST transition point given as a number of hours since 00:00 UTC,
 *           January 1, 1970, and each adjustment is the adjustment to apply
 *           for times after the DST transition, given as minutes EAST of UTC.
 *     </ul>
 * @return {!goog.i18n.TimeZone} A goog.i18n.TimeZone object for the given
 *     time zone data.
 */
goog.i18n.TimeZone.createTimeZone = function(timeZoneData) {
  if (typeof timeZoneData == 'number') {
    return goog.i18n.TimeZone.createSimpleTimeZone_(timeZoneData);
  }
  var tz = new goog.i18n.TimeZone();
  tz.timeZoneId_ = timeZoneData['id'];
  tz.standardOffset_ = -timeZoneData['std_offset'];
  tz.tzNames_ = timeZoneData['names'];
  tz.transitions_ = timeZoneData['transitions'];
  return tz;
};


/**
 * This factory method creates a time zone object with a constant offset.
 * @param {number} timeZoneOffsetInMinutes Offset in minutes WEST of UTC.
 * @return {!goog.i18n.TimeZone} A time zone object with the given constant
 *     offset.  Note that the time zone ID of this object will use the POSIX
 *     convention, which has a reversed sign ("Etc/GMT+8" means UTC-8 or PST).
 * @private
 */
goog.i18n.TimeZone.createSimpleTimeZone_ = function(timeZoneOffsetInMinutes) {
  var tz = new goog.i18n.TimeZone();
  tz.standardOffset_ = timeZoneOffsetInMinutes;
  tz.timeZoneId_ =
      goog.i18n.TimeZone.composePosixTimeZoneID_(timeZoneOffsetInMinutes);
  var str = goog.i18n.TimeZone.composeUTCString_(timeZoneOffsetInMinutes);
  tz.tzNames_ = [str, str];
  tz.transitions_ = [];
  return tz;
};


/**
 * Generate a GMT-relative string for a constant time zone offset.
 * @param {number} offset The time zone offset in minutes WEST of UTC.
 * @return {string} The GMT string for this offset, which will indicate
 *     hours EAST of UTC.
 * @private
 */
goog.i18n.TimeZone.composeGMTString_ = function(offset) {
  var parts = ['GMT'];
  parts.push(offset <= 0 ? '+' : '-');
  offset = Math.abs(offset);
  parts.push(goog.string.padNumber(Math.floor(offset / 60) % 100, 2),
             ':', goog.string.padNumber(offset % 60, 2));
  return parts.join('');
};


/**
 * Generate a POSIX time zone ID for a constant time zone offset.
 * @param {number} offset The time zone offset in minutes WEST of UTC.
 * @return {string} The POSIX time zone ID for this offset, which will indicate
 *     hours WEST of UTC.
 * @private
 */
goog.i18n.TimeZone.composePosixTimeZoneID_ = function(offset) {
  if (offset == 0) {
    return 'Etc/GMT';
  }
  var parts = ['Etc/GMT', offset < 0 ? '-' : '+'];
  offset = Math.abs(offset);
  parts.push(Math.floor(offset / 60) % 100);
  offset = offset % 60;
  if (offset != 0) {
    parts.push(':', goog.string.padNumber(offset, 2));
  }
  return parts.join('');
};


/**
 * Generate a UTC-relative string for a constant time zone offset.
 * @param {number} offset The time zone offset in minutes WEST of UTC.
 * @return {string} The UTC string for this offset, which will indicate
 *     hours EAST of UTC.
 * @private
 */
goog.i18n.TimeZone.composeUTCString_ = function(offset) {
  if (offset == 0) {
    return 'UTC';
  }
  var parts = ['UTC', offset < 0 ? '+' : '-'];
  offset = Math.abs(offset);
  parts.push(Math.floor(offset / 60) % 100);
  offset = offset % 60;
  if (offset != 0) {
    parts.push(':', offset);
  }
  return parts.join('');
};


/**
 * Convert the contents of time zone object to a timeZoneData object, suitable
 * for passing to goog.i18n.TimeZone.createTimeZone.
 * @return {!Object} A timeZoneData object (see the documentation for
 *     goog.i18n.TimeZone.createTimeZone).
 */
goog.i18n.TimeZone.prototype.getTimeZoneData = function() {
  return {
    'id': this.timeZoneId_,
    'std_offset': -this.standardOffset_,  // note createTimeZone flips the sign
    'names': goog.array.clone(this.tzNames_),  // avoid aliasing the array
    'transitions': goog.array.clone(this.transitions_)  // avoid aliasing
  };
};


/**
 * Return the DST adjustment to the time zone offset for a given time.
 * While Daylight Saving Time is in effect, this number is positive.
 * Otherwise, it is zero.
 * @param {goog.date.DateLike} date The time to check.
 * @return {number} The DST adjustment in minutes EAST of UTC.
 */
goog.i18n.TimeZone.prototype.getDaylightAdjustment = function(date) {
  var timeInMs = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(),
                          date.getUTCDate(), date.getUTCHours(),
                          date.getUTCMinutes());
  var timeInHours = timeInMs / goog.i18n.TimeZone.MILLISECONDS_PER_HOUR_;
  var index = 0;
  while (index < this.transitions_.length &&
         timeInHours >= this.transitions_[index]) {
    index += 2;
  }
  return (index == 0) ? 0 : this.transitions_[index - 1];
};


/**
 * Return the GMT representation of this time zone object.
 * @param {goog.date.DateLike} date The date for which time to retrieve
 *     GMT string.
 * @return {string} GMT representation string.
 */
goog.i18n.TimeZone.prototype.getGMTString = function(date) {
  return goog.i18n.TimeZone.composeGMTString_(this.getOffset(date));
};


/**
 * Get the long time zone name for a given date/time.
 * @param {goog.date.DateLike} date The time for which to retrieve
 *     the long time zone name.
 * @return {string} The long time zone name.
 */
goog.i18n.TimeZone.prototype.getLongName = function(date) {
  return this.tzNames_[this.isDaylightTime(date) ?
      goog.i18n.TimeZone.NameType.DLT_LONG_NAME :
      goog.i18n.TimeZone.NameType.STD_LONG_NAME];
};


/**
 * Get the time zone offset in minutes WEST of UTC for a given date/time.
 * @param {goog.date.DateLike} date The time for which to retrieve
 *     the time zone offset.
 * @return {number} The time zone offset in minutes WEST of UTC.
 */
goog.i18n.TimeZone.prototype.getOffset = function(date) {
  return this.standardOffset_ - this.getDaylightAdjustment(date);
};


/**
 * Get the RFC representation of the time zone for a given date/time.
 * @param {goog.date.DateLike} date The time for which to retrieve the
 *     RFC time zone string.
 * @return {string} The RFC time zone string.
 */
goog.i18n.TimeZone.prototype.getRFCTimeZoneString = function(date) {
  var offset = -this.getOffset(date);
  var parts = [offset < 0 ? '-' : '+'];
  offset = Math.abs(offset);
  parts.push(goog.string.padNumber(Math.floor(offset / 60) % 100, 2),
             goog.string.padNumber(offset % 60, 2));
  return parts.join('');
};


/**
 * Get the short time zone name for given date/time.
 * @param {goog.date.DateLike} date The time for which to retrieve
 *     the short time zone name.
 * @return {string} The short time zone name.
 */
goog.i18n.TimeZone.prototype.getShortName = function(date) {
  return this.tzNames_[this.isDaylightTime(date) ?
      goog.i18n.TimeZone.NameType.DLT_SHORT_NAME :
      goog.i18n.TimeZone.NameType.STD_SHORT_NAME];
};


/**
 * Return the time zone ID for this time zone.
 * @return {string} The time zone ID.
 */
goog.i18n.TimeZone.prototype.getTimeZoneId = function() {
  return this.timeZoneId_;
};


/**
 * Check if Daylight Saving Time is in effect at a given time in this time zone.
 * @param {goog.date.DateLike} date The time to check.
 * @return {boolean} True if Daylight Saving Time is in effect.
 */
goog.i18n.TimeZone.prototype.isDaylightTime = function(date) {
  return this.getDaylightAdjustment(date) > 0;
};

//javascript/closure/i18n/datetimeformat.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Functions for dealing with date/time formatting.
 * @author shanjian@google.com (Shanjian Li)
 */


/**
 * Namespace for i18n date/time formatting functions
 */
goog.provide('goog.i18n.DateTimeFormat');
goog.provide('goog.i18n.DateTimeFormat.Format');

goog.require('goog.asserts');
goog.require('goog.date');
goog.require('goog.i18n.DateTimeSymbols');
goog.require('goog.i18n.TimeZone');
goog.require('goog.string');


/**
 * Datetime formatting functions following the pattern specification as defined
 * in JDK, ICU and CLDR, with minor modification for typical usage in JS.
 * Pattern specification: (Refer to JDK/ICU/CLDR)
 * <pre>
 * Symbol Meaning Presentation        Example
 * ------   -------                 ------------        -------
 * G        era designator          (Text)              AD
 * y#       year                    (Number)            1996
 * Y*       year (week of year)     (Number)            1997
 * u*       extended year           (Number)            4601
 * M        month in year           (Text & Number)     July & 07
 * d        day in month            (Number)            10
 * h        hour in am/pm (1~12)    (Number)            12
 * H        hour in day (0~23)      (Number)            0
 * m        minute in hour          (Number)            30
 * s        second in minute        (Number)            55
 * S        fractional second       (Number)            978
 * E        day of week             (Text)              Tuesday
 * e*       day of week (local 1~7) (Number)            2
 * D*       day in year             (Number)            189
 * F*       day of week in month    (Number)            2 (2nd Wed in July)
 * w        week in year            (Number)            27
 * W*       week in month           (Number)            2
 * a        am/pm marker            (Text)              PM
 * k        hour in day (1~24)      (Number)            24
 * K        hour in am/pm (0~11)    (Number)            0
 * z        time zone               (Text)              Pacific Standard Time
 * Z        time zone (RFC 822)     (Number)            -0800
 * v        time zone (generic)     (Text)              Pacific Time
 * g*       Julian day              (Number)            2451334
 * A*       milliseconds in day     (Number)            69540000
 * '        escape for text         (Delimiter)         'Date='
 * ''       single quote            (Literal)           'o''clock'
 *
 * Item marked with '*' are not supported yet.
 * Item marked with '#' works different than java
 *
 * The count of pattern letters determine the format.
 * (Text): 4 or more, use full form, <4, use short or abbreviated form if it
 * exists. (e.g., "EEEE" produces "Monday", "EEE" produces "Mon")
 *
 * (Number): the minimum number of digits. Shorter numbers are zero-padded to
 * this amount (e.g. if "m" produces "6", "mm" produces "06"). Year is handled
 * specially; that is, if the count of 'y' is 2, the Year will be truncated to
 * 2 digits. (e.g., if "yyyy" produces "1997", "yy" produces "97".) Unlike other
 * fields, fractional seconds are padded on the right with zero.
 *
 * (Text & Number): 3 or over, use text, otherwise use number. (e.g., "M"
 * produces "1", "MM" produces "01", "MMM" produces "Jan", and "MMMM" produces
 * "January".)
 *
 * Any characters in the pattern that are not in the ranges of ['a'..'z'] and
 * ['A'..'Z'] will be treated as quoted text. For instance, characters like ':',
 * '.', ' ', '#' and '@' will appear in the resulting time text even they are
 * not embraced within single quotes.
 * </pre>
 */



/**
 * Construct a DateTimeFormat object based on current locale.
 * @constructor
 * @param {string|number} pattern pattern specification or pattern type.
 * @param {!Object=} opt_dateTimeSymbols Optional symbols to use use for this
 *     instance rather than the global symbols.
 * @final
 */
goog.i18n.DateTimeFormat = function(pattern, opt_dateTimeSymbols) {
  goog.asserts.assert(goog.isDef(pattern), 'Pattern must be defined');
  goog.asserts.assert(
      goog.isDef(opt_dateTimeSymbols) || goog.isDef(goog.i18n.DateTimeSymbols),
      'goog.i18n.DateTimeSymbols or explicit symbols must be defined');

  this.patternParts_ = [];

  /**
   * Data structure that with all the locale info needed for date formatting.
   * (day/month names, most common patterns, rules for week-end, etc.)
   * @type {!Object}
   * @private
   */
  this.dateTimeSymbols_ = opt_dateTimeSymbols || goog.i18n.DateTimeSymbols;
  if (typeof pattern == 'number') {
    this.applyStandardPattern_(pattern);
  } else {
    this.applyPattern_(pattern);
  }
};


/**
 * Enum to identify predefined Date/Time format pattern.
 * @enum {number}
 */
goog.i18n.DateTimeFormat.Format = {
  FULL_DATE: 0,
  LONG_DATE: 1,
  MEDIUM_DATE: 2,
  SHORT_DATE: 3,
  FULL_TIME: 4,
  LONG_TIME: 5,
  MEDIUM_TIME: 6,
  SHORT_TIME: 7,
  FULL_DATETIME: 8,
  LONG_DATETIME: 9,
  MEDIUM_DATETIME: 10,
  SHORT_DATETIME: 11
};


/**
 * regular expression pattern for parsing pattern string
 * @type {Array.<RegExp>}
 * @private
 */
goog.i18n.DateTimeFormat.TOKENS_ = [
  //quote string
  /^\'(?:[^\']|\'\')*\'/,
  // pattern chars
  /^(?:G+|y+|M+|k+|S+|E+|a+|h+|K+|H+|c+|L+|Q+|d+|m+|s+|v+|w+|z+|Z+)/,
  // and all the other chars
  /^[^\'GyMkSEahKHcLQdmsvwzZ]+/  // and all the other chars
];


/**
 * These are token types, corresponding to above token definitions.
 * @enum {number}
 * @private
 */
goog.i18n.DateTimeFormat.PartTypes_ = {
  QUOTED_STRING: 0,
  FIELD: 1,
  LITERAL: 2
};


/**
 * Apply specified pattern to this formatter object.
 * @param {string} pattern String specifying how the date should be formatted.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.applyPattern_ = function(pattern) {
  // lex the pattern, once for all uses
  while (pattern) {
    for (var i = 0; i < goog.i18n.DateTimeFormat.TOKENS_.length; ++i) {
      var m = pattern.match(goog.i18n.DateTimeFormat.TOKENS_[i]);
      if (m) {
        var part = m[0];
        pattern = pattern.substring(part.length);
        if (i == goog.i18n.DateTimeFormat.PartTypes_.QUOTED_STRING) {
          if (part == "''") {
            part = "'";  // '' -> '
          } else {
            part = part.substring(1, part.length - 1); // strip quotes
            part = part.replace(/\'\'/, "'");
          }
        }
        this.patternParts_.push({ text: part, type: i });
        break;
      }
    }
  }
};


/**
 * Format the given date object according to preset pattern and current lcoale.
 * @param {goog.date.DateLike} date The Date object that is being formatted.
 * @param {goog.i18n.TimeZone=} opt_timeZone optional, if specified, time
 *    related fields will be formatted based on its setting. When this field
 *    is not specified, "undefined" will be pass around and those function
 *    that really need time zone service will create a default one.
 * @return {string} Formatted string for the given date.
 */
goog.i18n.DateTimeFormat.prototype.format = function(date, opt_timeZone) {
  // We don't want to write code to calculate each date field because we
  // want to maximize performance and minimize code size.
  // JavaScript only provide API to render local time.
  // Suppose target date is: 16:00 GMT-0400
  // OS local time is:       12:00 GMT-0800
  // We want to create a Local Date Object : 16:00 GMT-0800, and fix the
  // time zone display ourselves.
  // Thing get a little bit tricky when daylight time transition happens. For
  // example, suppose OS timeZone is America/Los_Angeles, it is impossible to
  // represent "2006/4/2 02:30" even for those timeZone that has no transition
  // at this time. Because 2:00 to 3:00 on that day does not exising in
  // America/Los_Angeles time zone. To avoid calculating date field through
  // our own code, we uses 3 Date object instead, one for "Year, month, day",
  // one for time within that day, and one for timeZone object since it need
  // the real time to figure out actual time zone offset.
  var diff = opt_timeZone ?
      (date.getTimezoneOffset() - opt_timeZone.getOffset(date)) * 60000 : 0;
  var dateForDate = diff ? new Date(date.getTime() + diff) : date;
  var dateForTime = dateForDate;
  // in daylight time switch on/off hour, diff adjustment could alter time
  // because of timeZone offset change, move 1 day forward or backward.
  if (opt_timeZone &&
      dateForDate.getTimezoneOffset() != date.getTimezoneOffset()) {
    diff += diff > 0 ? -24 * 60 * 60000 : 24 * 60 * 60000;
    dateForTime = new Date(date.getTime() + diff);
  }

  var out = [];
  for (var i = 0; i < this.patternParts_.length; ++i) {
    var text = this.patternParts_[i].text;
    if (goog.i18n.DateTimeFormat.PartTypes_.FIELD ==
        this.patternParts_[i].type) {
      out.push(this.formatField_(text, date, dateForDate, dateForTime,
                                 opt_timeZone));
    } else {
      out.push(text);
    }
  }
  return out.join('');
};


/**
 * Apply a predefined pattern as identified by formatType, which is stored in
 * locale specific repository.
 * @param {number} formatType A number that identified the predefined pattern.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.applyStandardPattern_ =
    function(formatType) {
  var pattern;
  if (formatType < 4) {
    pattern = this.dateTimeSymbols_.DATEFORMATS[formatType];
  } else if (formatType < 8) {
    pattern = this.dateTimeSymbols_.TIMEFORMATS[formatType - 4];
  } else if (formatType < 12) {
    pattern = this.dateTimeSymbols_.DATETIMEFORMATS[formatType - 8];
    pattern = pattern.replace('{1}',
        this.dateTimeSymbols_.DATEFORMATS[formatType - 8]);
    pattern = pattern.replace('{0}',
        this.dateTimeSymbols_.TIMEFORMATS[formatType - 8]);
  } else {
    this.applyStandardPattern_(goog.i18n.DateTimeFormat.Format.MEDIUM_DATETIME);
    return;
  }
  this.applyPattern_(pattern);
};


/**
 * Localizes a string potentially containing numbers, replacing ASCII digits
 * with native digits if specified so by the locale. Leaves other characters.
 *
 * Although this is not private anymore, is should not be used.
 * We needed to make it public so that we can use it in goog.date.relative.
 * But when CLDR gets better support for relative dates, this will be
 * refactored and will become private again.
 *
 * @param {string} input the string to be localized, using ASCII digits.
 * @return {string} localized string, potentially using native digits.
 */
goog.i18n.DateTimeFormat.prototype.localizeNumbers = function(input) {
  // TODO(mnita): fix date/duration.js and date/relative.js.
  // They call goog.i18n.DateTimeFormat.prototype.localizeNumbers directly,
  // without calling a constructor.
  if (this.dateTimeSymbols_ === undefined ||
      this.dateTimeSymbols_.ZERODIGIT === undefined) {
    return input;
  }

  var parts = [];
  for (var i = 0; i < input.length; i++) {
    var c = input.charCodeAt(i);
    parts.push((0x30 <= c && c <= 0x39) ? // '0' <= c <= '9'
        String.fromCharCode(this.dateTimeSymbols_.ZERODIGIT + c - 0x30) :
        input.charAt(i));
  }
  return parts.join('');
};


/**
 * Formats Era field according to pattern specified.
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatEra_ = function(count, date) {
  var value = date.getFullYear() > 0 ? 1 : 0;
  return count >= 4 ? this.dateTimeSymbols_.ERANAMES[value] :
                      this.dateTimeSymbols_.ERAS[value];
};


/**
 * Formats Year field according to pattern specified
 *   Javascript Date object seems incapable handling 1BC and
 *   year before. It can show you year 0 which does not exists.
 *   following we just keep consistent with javascript's
 *   toString method. But keep in mind those things should be
 *   unsupported.
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatYear_ = function(count, date) {
  var value = date.getFullYear();
  if (value < 0) {
    value = -value;
  }
  if (count == 2) {
    // See comment about special casing 'yy' at the start of the file, this
    // matches ICU and CLDR behaviour. See also:
    // http://icu-project.org/apiref/icu4j/com/ibm/icu/text/SimpleDateFormat.html
    // http://www.unicode.org/reports/tr35/tr35-dates.html
    value = value % 100;
  }
  return this.localizeNumbers(goog.string.padNumber(value, count));
};


/**
 * Formats Month field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatMonth_ = function(count, date) {
  var value = date.getMonth();
  switch (count) {
    case 5: return this.dateTimeSymbols_.NARROWMONTHS[value];
    case 4: return this.dateTimeSymbols_.MONTHS[value];
    case 3: return this.dateTimeSymbols_.SHORTMONTHS[value];
    default:
      return this.localizeNumbers(goog.string.padNumber(value + 1, count));
  }
};


/**
 * Formats (1..24) Hours field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats. This controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.format24Hours_ =
    function(count, date) {
  return this.localizeNumbers(
      goog.string.padNumber(date.getHours() || 24, count));
};


/**
 * Formats Fractional seconds field according to pattern
 * specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 *
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatFractionalSeconds_ =
    function(count, date) {
  // Fractional seconds left-justify, append 0 for precision beyond 3
  var value = date.getTime() % 1000 / 1000;
  return this.localizeNumbers(
      value.toFixed(Math.min(3, count)).substr(2) +
      (count > 3 ? goog.string.padNumber(0, count - 3) : ''));
};


/**
 * Formats Day of week field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatDayOfWeek_ =
    function(count, date) {
  var value = date.getDay();
  return count >= 4 ? this.dateTimeSymbols_.WEEKDAYS[value] :
                      this.dateTimeSymbols_.SHORTWEEKDAYS[value];
};


/**
 * Formats Am/Pm field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatAmPm_ = function(count, date) {
  var hours = date.getHours();
  return this.dateTimeSymbols_.AMPMS[hours >= 12 && hours < 24 ? 1 : 0];
};


/**
 * Formats (1..12) Hours field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.format1To12Hours_ =
    function(count, date) {
  return this.localizeNumbers(
      goog.string.padNumber(date.getHours() % 12 || 12, count));
};


/**
 * Formats (0..11) Hours field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.format0To11Hours_ =
    function(count, date) {
  return this.localizeNumbers(
      goog.string.padNumber(date.getHours() % 12, count));
};


/**
 * Formats (0..23) Hours field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.format0To23Hours_ =
    function(count, date) {
  return this.localizeNumbers(goog.string.padNumber(date.getHours(), count));
};


/**
 * Formats Standalone weekday field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatStandaloneDay_ =
    function(count, date) {
  var value = date.getDay();
  switch (count) {
    case 5:
      return this.dateTimeSymbols_.STANDALONENARROWWEEKDAYS[value];
    case 4:
      return this.dateTimeSymbols_.STANDALONEWEEKDAYS[value];
    case 3:
      return this.dateTimeSymbols_.STANDALONESHORTWEEKDAYS[value];
    default:
      return this.localizeNumbers(goog.string.padNumber(value, 1));
  }
};


/**
 * Formats Standalone Month field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatStandaloneMonth_ =
    function(count, date) {
  var value = date.getMonth();
  switch (count) {
    case 5:
      return this.dateTimeSymbols_.STANDALONENARROWMONTHS[value];
    case 4:
      return this.dateTimeSymbols_.STANDALONEMONTHS[value];
    case 3:
      return this.dateTimeSymbols_.STANDALONESHORTMONTHS[value];
    default:
      return this.localizeNumbers(goog.string.padNumber(value + 1, count));
  }
};


/**
 * Formats Quarter field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatQuarter_ =
    function(count, date) {
  var value = Math.floor(date.getMonth() / 3);
  return count < 4 ? this.dateTimeSymbols_.SHORTQUARTERS[value] :
                     this.dateTimeSymbols_.QUARTERS[value];
};


/**
 * Formats Date field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatDate_ = function(count, date) {
  return this.localizeNumbers(goog.string.padNumber(date.getDate(), count));
};


/**
 * Formats Minutes field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatMinutes_ =
    function(count, date) {
  return this.localizeNumbers(goog.string.padNumber(date.getMinutes(), count));
};


/**
 * Formats Seconds field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatSeconds_ =
    function(count, date) {
  return this.localizeNumbers(goog.string.padNumber(date.getSeconds(), count));
};


/**
 * Formats the week of year field according to pattern specified
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatWeekOfYear_ = function(count, date) {


  var weekNum = goog.date.getWeekNumber(
      date.getFullYear(), date.getMonth(), date.getDate(),
      this.dateTimeSymbols_.FIRSTWEEKCUTOFFDAY,
      this.dateTimeSymbols_.FIRSTDAYOFWEEK);

  return this.localizeNumbers(goog.string.padNumber(weekNum, count));
};


/**
 * Formats TimeZone field following RFC
 *
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date It holds the date object to be formatted.
 * @param {goog.i18n.TimeZone=} opt_timeZone This holds current time zone info.
 * @return {string} Formatted string that represent this field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatTimeZoneRFC_ =
    function(count, date, opt_timeZone) {
  opt_timeZone = opt_timeZone ||
      goog.i18n.TimeZone.createTimeZone(date.getTimezoneOffset());

  // RFC 822 formats should be kept in ASCII, but localized GMT formats may need
  // to use native digits.
  return count < 4 ? opt_timeZone.getRFCTimeZoneString(date) :
                     this.localizeNumbers(opt_timeZone.getGMTString(date));
};


/**
 * Generate GMT timeZone string for given date
 * @param {number} count Number of time pattern char repeats, it controls
 *     how a field should be formatted.
 * @param {goog.date.DateLike} date Whose value being evaluated.
 * @param {goog.i18n.TimeZone=} opt_timeZone This holds current time zone info.
 * @return {string} GMT timeZone string.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatTimeZone_ =
    function(count, date, opt_timeZone) {
  opt_timeZone = opt_timeZone ||
      goog.i18n.TimeZone.createTimeZone(date.getTimezoneOffset());
  return count < 4 ? opt_timeZone.getShortName(date) :
             opt_timeZone.getLongName(date);
};


/**
 * Generate GMT timeZone string for given date
 * @param {goog.date.DateLike} date Whose value being evaluated.
 * @param {goog.i18n.TimeZone=} opt_timeZone This holds current time zone info.
 * @return {string} GMT timeZone string.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatTimeZoneId_ =
    function(date, opt_timeZone) {
  opt_timeZone = opt_timeZone ||
      goog.i18n.TimeZone.createTimeZone(date.getTimezoneOffset());
  return opt_timeZone.getTimeZoneId();
};


/**
 * Formatting one date field.
 * @param {string} patternStr The pattern string for the field being formatted.
 * @param {goog.date.DateLike} date represents the real date to be formatted.
 * @param {goog.date.DateLike} dateForDate used to resolve date fields
 *     for formatting.
 * @param {goog.date.DateLike} dateForTime used to resolve time fields
 *     for formatting.
 * @param {goog.i18n.TimeZone=} opt_timeZone This holds current time zone info.
 * @return {string} string representation for the given field.
 * @private
 */
goog.i18n.DateTimeFormat.prototype.formatField_ =
    function(patternStr, date, dateForDate, dateForTime, opt_timeZone) {
  var count = patternStr.length;
  switch (patternStr.charAt(0)) {
    case 'G': return this.formatEra_(count, dateForDate);
    case 'y': return this.formatYear_(count, dateForDate);
    case 'M': return this.formatMonth_(count, dateForDate);
    case 'k': return this.format24Hours_(count, dateForTime);
    case 'S': return this.formatFractionalSeconds_(count, dateForTime);
    case 'E': return this.formatDayOfWeek_(count, dateForDate);
    case 'a': return this.formatAmPm_(count, dateForTime);
    case 'h': return this.format1To12Hours_(count, dateForTime);
    case 'K': return this.format0To11Hours_(count, dateForTime);
    case 'H': return this.format0To23Hours_(count, dateForTime);
    case 'c': return this.formatStandaloneDay_(count, dateForDate);
    case 'L': return this.formatStandaloneMonth_(count, dateForDate);
    case 'Q': return this.formatQuarter_(count, dateForDate);
    case 'd': return this.formatDate_(count, dateForDate);
    case 'm': return this.formatMinutes_(count, dateForTime);
    case 's': return this.formatSeconds_(count, dateForTime);
    case 'v': return this.formatTimeZoneId_(date, opt_timeZone);
    case 'w': return this.formatWeekOfYear_(count, dateForTime);
    case 'z': return this.formatTimeZone_(count, date, opt_timeZone);
    case 'Z': return this.formatTimeZoneRFC_(count, date, opt_timeZone);
    default: return '';
  }
};


//javascript/closure/i18n/datetimeparse.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Date/Time parsing library with locale support.
 * @author shanjian@google.com (Shanjian Li)
 */


/**
 * Namespace for locale date/time parsing functions
 */
goog.provide('goog.i18n.DateTimeParse');

goog.require('goog.date');
goog.require('goog.i18n.DateTimeFormat');
goog.require('goog.i18n.DateTimeSymbols');


/**
 * DateTimeParse is for parsing date in a locale-sensitive manner. It allows
 * user to use any customized patterns to parse date-time string under certain
 * locale. Things varies across locales like month name, weekname, field
 * order, etc.
 *
 * This module is the counter-part of DateTimeFormat. They use the same
 * date/time pattern specification, which is borrowed from ICU/JDK.
 *
 * This implementation could parse partial date/time.
 *
 * Time Format Syntax: To specify the time format use a time pattern string.
 * In this pattern, following letters are reserved as pattern letters, which
 * are defined as the following:
 *
 * <pre>
 * Symbol   Meaning                 Presentation        Example
 * ------   -------                 ------------        -------
 * G        era designator          (Text)              AD
 * y#       year                    (Number)            1996
 * M        month in year           (Text & Number)     July & 07
 * d        day in month            (Number)            10
 * h        hour in am/pm (1~12)    (Number)            12
 * H        hour in day (0~23)      (Number)            0
 * m        minute in hour          (Number)            30
 * s        second in minute        (Number)            55
 * S        fractional second       (Number)            978
 * E        day of week             (Text)              Tuesday
 * D        day in year             (Number)            189
 * a        am/pm marker            (Text)              PM
 * k        hour in day (1~24)      (Number)            24
 * K        hour in am/pm (0~11)    (Number)            0
 * z        time zone               (Text)              Pacific Standard Time
 * Z        time zone (RFC 822)     (Number)            -0800
 * v        time zone (generic)     (Text)              Pacific Time
 * '        escape for text         (Delimiter)         'Date='
 * ''       single quote            (Literal)           'o''clock'
 * </pre>
 *
 * The count of pattern letters determine the format. <p>
 * (Text): 4 or more pattern letters--use full form,
 *         less than 4--use short or abbreviated form if one exists.
 *         In parsing, we will always try long format, then short. <p>
 * (Number): the minimum number of digits. <p>
 * (Text & Number): 3 or over, use text, otherwise use number. <p>
 * Any characters that not in the pattern will be treated as quoted text. For
 * instance, characters like ':', '.', ' ', '#' and '@' will appear in the
 * resulting time text even they are not embraced within single quotes. In our
 * current pattern usage, we didn't use up all letters. But those unused
 * letters are strongly discouraged to be used as quoted text without quote.
 * That's because we may use other letter for pattern in future. <p>
 *
 * Examples Using the US Locale:
 *
 * Format Pattern                         Result
 * --------------                         -------
 * "yyyy.MM.dd G 'at' HH:mm:ss vvvv" ->>  1996.07.10 AD at 15:08:56 Pacific Time
 * "EEE, MMM d, ''yy"                ->>  Wed, July 10, '96
 * "h:mm a"                          ->>  12:08 PM
 * "hh 'o''clock' a, zzzz"           ->>  12 o'clock PM, Pacific Daylight Time
 * "K:mm a, vvv"                     ->>  0:00 PM, PT
 * "yyyyy.MMMMM.dd GGG hh:mm aaa"    ->>  01996.July.10 AD 12:08 PM
 *
 * <p> When parsing a date string using the abbreviated year pattern ("yy"),
 * DateTimeParse must interpret the abbreviated year relative to some
 * century. It does this by adjusting dates to be within 80 years before and 20
 * years after the time the parse function is called. For example, using a
 * pattern of "MM/dd/yy" and a DateTimeParse instance created on Jan 1, 1997,
 * the string "01/11/12" would be interpreted as Jan 11, 2012 while the string
 * "05/04/64" would be interpreted as May 4, 1964. During parsing, only
 * strings consisting of exactly two digits, as defined by {@link
 * java.lang.Character#isDigit(char)}, will be parsed into the default
 * century. Any other numeric string, such as a one digit string, a three or
 * more digit string will be interpreted as its face value.
 *
 * <p> If the year pattern does not have exactly two 'y' characters, the year is
 * interpreted literally, regardless of the number of digits. So using the
 * pattern "MM/dd/yyyy", "01/11/12" parses to Jan 11, 12 A.D.
 *
 * <p> When numeric fields abut one another directly, with no intervening
 * delimiter characters, they constitute a run of abutting numeric fields. Such
 * runs are parsed specially. For example, the format "HHmmss" parses the input
 * text "123456" to 12:34:56, parses the input text "12345" to 1:23:45, and
 * fails to parse "1234". In other words, the leftmost field of the run is
 * flexible, while the others keep a fixed width. If the parse fails anywhere in
 * the run, then the leftmost field is shortened by one character, and the
 * entire run is parsed again. This is repeated until either the parse succeeds
 * or the leftmost field is one character in length. If the parse still fails at
 * that point, the parse of the run fails.
 *
 * <p> Now timezone parsing only support GMT:hhmm, GMT:+hhmm, GMT:-hhmm
 */



/**
 * Construct a DateTimeParse based on current locale.
 * @param {string|number} pattern pattern specification or pattern type.
 * @constructor
 * @final
 */
goog.i18n.DateTimeParse = function(pattern) {
  this.patternParts_ = [];
  if (typeof pattern == 'number') {
    this.applyStandardPattern_(pattern);
  } else {
    this.applyPattern_(pattern);
  }
};


/**
 * Number of years prior to now that the century used to
 * disambiguate two digit years will begin
 *
 * @type {number}
 */
goog.i18n.DateTimeParse.ambiguousYearCenturyStart = 80;


/**
 * Apply a pattern to this Parser. The pattern string will be parsed and saved
 * in "compiled" form.
 * Note: this method is somewhat similar to the pattern parsing method in
 *       datetimeformat. If you see something wrong here, you might want
 *       to check the other.
 * @param {string} pattern It describes the format of date string that need to
 *     be parsed.
 * @private
 */
goog.i18n.DateTimeParse.prototype.applyPattern_ = function(pattern) {
  var inQuote = false;
  var buf = '';

  for (var i = 0; i < pattern.length; i++) {
    var ch = pattern.charAt(i);

    // handle space, add literal part (if exist), and add space part
    if (ch == ' ') {
      if (buf.length > 0) {
        this.patternParts_.push({text: buf, count: 0, abutStart: false});
        buf = '';
      }
      this.patternParts_.push({text: ' ', count: 0, abutStart: false});
      while (i < pattern.length - 1 && pattern.charAt(i + 1) == ' ') {
        i++;
      }
    } else if (inQuote) {
      // inside quote, except '', just copy or exit
      if (ch == '\'') {
        if (i + 1 < pattern.length && pattern.charAt(i + 1) == '\'') {
          // quote appeared twice continuously, interpret as one quote.
          buf += '\'';
          i++;
        } else {
          // exit quote
          inQuote = false;
        }
      } else {
        // literal
        buf += ch;
      }
    } else if (goog.i18n.DateTimeParse.PATTERN_CHARS_.indexOf(ch) >= 0) {
      // outside quote, it is a pattern char
      if (buf.length > 0) {
        this.patternParts_.push({text: buf, count: 0, abutStart: false});
        buf = '';
      }
      var count = this.getNextCharCount_(pattern, i);
      this.patternParts_.push({text: ch, count: count, abutStart: false});
      i += count - 1;
    } else if (ch == '\'') {
      // Two consecutive quotes is a quote literal, inside or outside of quotes.
      if (i + 1 < pattern.length && pattern.charAt(i + 1) == '\'') {
        buf += '\'';
        i++;
      } else {
        inQuote = true;
      }
    } else {
      buf += ch;
    }
  }

  if (buf.length > 0) {
    this.patternParts_.push({text: buf, count: 0, abutStart: false});
  }

  this.markAbutStart_();
};


/**
 * Apply a predefined pattern to this Parser.
 * @param {number} formatType A constant used to identified the predefined
 *     pattern string stored in locale repository.
 * @private
 */
goog.i18n.DateTimeParse.prototype.applyStandardPattern_ = function(formatType) {
  var pattern;
  // formatType constants are in consecutive numbers. So it can be used to
  // index array in following way.

  // if type is out of range, default to medium date/time format.
  if (formatType > goog.i18n.DateTimeFormat.Format.SHORT_DATETIME) {
    formatType = goog.i18n.DateTimeFormat.Format.MEDIUM_DATETIME;
  }

  if (formatType < 4) {
    pattern = goog.i18n.DateTimeSymbols.DATEFORMATS[formatType];
  } else if (formatType < 8) {
    pattern = goog.i18n.DateTimeSymbols.TIMEFORMATS[formatType - 4];
  } else {
    pattern = goog.i18n.DateTimeSymbols.DATETIMEFORMATS[formatType - 8];
    pattern = pattern.replace('{1}',
        goog.i18n.DateTimeSymbols.DATEFORMATS[formatType - 8]);
    pattern = pattern.replace('{0}',
        goog.i18n.DateTimeSymbols.TIMEFORMATS[formatType - 8]);
  }
  this.applyPattern_(pattern);
};


/**
 * Parse the given string and fill info into date object. This version does
 * not validate the input.
 * @param {string} text The string being parsed.
 * @param {goog.date.DateLike} date The Date object to hold the parsed date.
 * @param {number=} opt_start The position from where parse should begin.
 * @return {number} How many characters parser advanced.
 */
goog.i18n.DateTimeParse.prototype.parse = function(text, date, opt_start) {
  var start = opt_start || 0;
  return this.internalParse_(text, date, start, false/*validation*/);
};


/**
 * Parse the given string and fill info into date object. This version will
 * validate the input and make sure it is a validate date/time.
 * @param {string} text The string being parsed.
 * @param {goog.date.DateLike} date The Date object to hold the parsed date.
 * @param {number=} opt_start The position from where parse should begin.
 * @return {number} How many characters parser advanced.
 */
goog.i18n.DateTimeParse.prototype.strictParse =
    function(text, date, opt_start) {
  var start = opt_start || 0;
  return this.internalParse_(text, date, start, true/*validation*/);
};


/**
 * Parse the given string and fill info into date object.
 * @param {string} text The string being parsed.
 * @param {goog.date.DateLike} date The Date object to hold the parsed date.
 * @param {number} start The position from where parse should begin.
 * @param {boolean} validation If true, input string need to be a valid
 *     date/time string.
 * @return {number} How many characters parser advanced.
 * @private
 */
goog.i18n.DateTimeParse.prototype.internalParse_ =
    function(text, date, start, validation) {
  var cal = new goog.i18n.DateTimeParse.MyDate_();
  var parsePos = [start];

  // For parsing abutting numeric fields. 'abutPat' is the
  // offset into 'pattern' of the first of 2 or more abutting
  // numeric fields. 'abutStart' is the offset into 'text'
  // where parsing the fields begins. 'abutPass' starts off as 0
  // and increments each time we try to parse the fields.
  var abutPat = -1; // If >=0, we are in a run of abutting numeric fields
  var abutStart = 0;
  var abutPass = 0;

  for (var i = 0; i < this.patternParts_.length; i++) {
    if (this.patternParts_[i].count > 0) {
      if (abutPat < 0 && this.patternParts_[i].abutStart) {
        abutPat = i;
        abutStart = start;
        abutPass = 0;
      }

      // Handle fields within a run of abutting numeric fields. Take
      // the pattern "HHmmss" as an example. We will try to parse
      // 2/2/2 characters of the input text, then if that fails,
      // 1/2/2. We only adjust the width of the leftmost field; the
      // others remain fixed. This allows "123456" => 12:34:56, but
      // "12345" => 1:23:45. Likewise, for the pattern "yyyyMMdd" we
      // try 4/2/2, 3/2/2, 2/2/2, and finally 1/2/2.
      if (abutPat >= 0) {
        // If we are at the start of a run of abutting fields, then
        // shorten this field in each pass. If we can't shorten
        // this field any more, then the parse of this set of
        // abutting numeric fields has failed.
        var count = this.patternParts_[i].count;
        if (i == abutPat) {
          count -= abutPass;
          abutPass++;
          if (count == 0) {
            // tried all possible width, fail now
            return 0;
          }
        }

        if (!this.subParse_(text, parsePos, this.patternParts_[i], count,
                            cal)) {
          // If the parse fails anywhere in the run, back up to the
          // start of the run and retry.
          i = abutPat - 1;
          parsePos[0] = abutStart;
          continue;
        }
      }

      // Handle non-numeric fields and non-abutting numeric fields.
      else {
        abutPat = -1;
        if (!this.subParse_(text, parsePos, this.patternParts_[i], 0, cal)) {
          return 0;
        }
      }
    } else {
      // Handle literal pattern characters. These are any
      // quoted characters and non-alphabetic unquoted
      // characters.
      abutPat = -1;
      // A run of white space in the pattern matches a run
      // of white space in the input text.
      if (this.patternParts_[i].text.charAt(0) == ' ') {
        // Advance over run in input text
        var s = parsePos[0];
        this.skipSpace_(text, parsePos);

        // Must see at least one white space char in input
        if (parsePos[0] > s) {
          continue;
        }
      } else if (text.indexOf(this.patternParts_[i].text, parsePos[0]) ==
                 parsePos[0]) {
        parsePos[0] += this.patternParts_[i].text.length;
        continue;
      }
      // We fall through to this point if the match fails
      return 0;
    }
  }

  // return progress
  return cal.calcDate_(date, validation) ? parsePos[0] - start : 0;
};


/**
 * Calculate character repeat count in pattern.
 *
 * @param {string} pattern It describes the format of date string that need to
 *     be parsed.
 * @param {number} start The position of pattern character.
 *
 * @return {number} Repeat count.
 * @private
 */
goog.i18n.DateTimeParse.prototype.getNextCharCount_ =
    function(pattern, start) {
  var ch = pattern.charAt(start);
  var next = start + 1;
  while (next < pattern.length && pattern.charAt(next) == ch) {
    next++;
  }
  return next - start;
};


/**
 * All acceptable pattern characters.
 * @private
 */
goog.i18n.DateTimeParse.PATTERN_CHARS_ = 'GyMdkHmsSEDahKzZvQL';


/**
 * Pattern characters that specify numerical field.
 * @private
 */
goog.i18n.DateTimeParse.NUMERIC_FORMAT_CHARS_ = 'MydhHmsSDkK';


/**
 * Check if the pattern part is a numeric field.
 *
 * @param {Object} part pattern part to be examined.
 *
 * @return {boolean} true if the pattern part is numeric field.
 * @private
 */
goog.i18n.DateTimeParse.prototype.isNumericField_ = function(part) {
  if (part.count <= 0) {
    return false;
  }
  var i = goog.i18n.DateTimeParse.NUMERIC_FORMAT_CHARS_.indexOf(
      part.text.charAt(0));
  return i > 0 || i == 0 && part.count < 3;
};


/**
 * Identify the start of an abutting numeric fields' run. Taking pattern
 * "HHmmss" as an example. It will try to parse 2/2/2 characters of the input
 * text, then if that fails, 1/2/2. We only adjust the width of the leftmost
 * field; the others remain fixed. This allows "123456" => 12:34:56, but
 * "12345" => 1:23:45. Likewise, for the pattern "yyyyMMdd" we try 4/2/2,
 * 3/2/2, 2/2/2, and finally 1/2/2. The first field of connected numeric
 * fields will be marked as abutStart, its width can be reduced to accommodate
 * others.
 *
 * @private
 */
goog.i18n.DateTimeParse.prototype.markAbutStart_ = function() {
  // abut parts are continuous numeric parts. abutStart is the switch
  // point from non-abut to abut
  var abut = false;

  for (var i = 0; i < this.patternParts_.length; i++) {
    if (this.isNumericField_(this.patternParts_[i])) {
      // if next part is not following abut sequence, and isNumericField_
      if (!abut && i + 1 < this.patternParts_.length &&
          this.isNumericField_(this.patternParts_[i + 1])) {
        abut = true;
        this.patternParts_[i].abutStart = true;
      }
    } else {
      abut = false;
    }
  }
};


/**
 * Skip space in the string.
 *
 * @param {string} text input string.
 * @param {Array.<number>} pos where skip start, and return back where the skip
 *     stops.
 * @private
 */
goog.i18n.DateTimeParse.prototype.skipSpace_ = function(text, pos) {
  var m = text.substring(pos[0]).match(/^\s+/);
  if (m) {
    pos[0] += m[0].length;
  }
};


/**
 * Protected method that converts one field of the input string into a
 * numeric field value.
 *
 * @param {string} text the time text to be parsed.
 * @param {Array.<number>} pos Parse position.
 * @param {Object} part the pattern part for this field.
 * @param {number} digitCount when > 0, numeric parsing must obey the count.
 * @param {goog.i18n.DateTimeParse.MyDate_} cal object that holds parsed value.
 *
 * @return {boolean} True if it parses successfully.
 * @private
 */
goog.i18n.DateTimeParse.prototype.subParse_ =
    function(text, pos, part, digitCount, cal) {
  this.skipSpace_(text, pos);

  var start = pos[0];
  var ch = part.text.charAt(0);

  // parse integer value if it is a numeric field
  var value = -1;
  if (this.isNumericField_(part)) {
    if (digitCount > 0) {
      if ((start + digitCount) > text.length) {
        return false;
      }
      value = this.parseInt_(
          text.substring(0, start + digitCount), pos);
    } else {
      value = this.parseInt_(text, pos);
    }
  }

  switch (ch) {
    case 'G': // ERA
      cal.era = this.matchString_(text, pos, goog.i18n.DateTimeSymbols.ERAS);
      return true;
    case 'M': // MONTH
    case 'L': // STANDALONEMONTH
      return this.subParseMonth_(text, pos, cal, value);
    case 'E':
      return this.subParseDayOfWeek_(text, pos, cal);
    case 'a': // AM_PM
      cal.ampm = this.matchString_(text, pos, goog.i18n.DateTimeSymbols.AMPMS);
      return true;
    case 'y': // YEAR
      return this.subParseYear_(text, pos, start, value, part, cal);
    case 'Q': // QUARTER
      return this.subParseQuarter_(text, pos, cal, value);
    case 'd': // DATE
      cal.day = value;
      return true;
    case 'S': // FRACTIONAL_SECOND
      return this.subParseFractionalSeconds_(value, pos, start, cal);
    case 'h': // HOUR (1..12)
      if (value == 12) {
        value = 0;
      }
    case 'K': // HOUR (0..11)
    case 'H': // HOUR_OF_DAY (0..23)
    case 'k': // HOUR_OF_DAY (1..24)
      cal.hours = value;
      return true;
    case 'm': // MINUTE
      cal.minutes = value;
      return true;
    case 's': // SECOND
      cal.seconds = value;
      return true;

    case 'z': // ZONE_OFFSET
    case 'Z': // TIMEZONE_RFC
    case 'v': // TIMEZONE_GENERIC
      return this.subparseTimeZoneInGMT_(text, pos, cal);
    default:
      return false;
  }
};


/**
 * Parse year field. Year field is special because
 * 1) two digit year need to be resolved.
 * 2) we allow year to take a sign.
 * 3) year field participate in abut processing.
 *
 * @param {string} text the time text to be parsed.
 * @param {Array.<number>} pos Parse position.
 * @param {number} start where this field start.
 * @param {number} value integer value of year.
 * @param {Object} part the pattern part for this field.
 * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.
 *
 * @return {boolean} True if successful.
 * @private
 */
goog.i18n.DateTimeParse.prototype.subParseYear_ =
    function(text, pos, start, value, part, cal) {
  var ch;
  if (value < 0) {
    //possible sign
    ch = text.charAt(pos[0]);
    if (ch != '+' && ch != '-') {
      return false;
    }
    pos[0]++;
    value = this.parseInt_(text, pos);
    if (value < 0) {
      return false;
    }
    if (ch == '-') {
      value = -value;
    }
  }

  // only if 2 digit was actually parsed, and pattern say it has 2 digit.
  if (!ch && pos[0] - start == 2 && part.count == 2) {
    cal.setTwoDigitYear_(value);
  } else {
    cal.year = value;
  }
  return true;
};


/**
 * Parse Month field.
 *
 * @param {string} text the time text to be parsed.
 * @param {Array.<number>} pos Parse position.
 * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.
 * @param {number} value numeric value if this field is expressed using
 *      numeric pattern, or -1 if not.
 *
 * @return {boolean} True if parsing successful.
 * @private
 */
goog.i18n.DateTimeParse.prototype.subParseMonth_ =
    function(text, pos, cal, value) {
  // when month is symbols, i.e., MMM, MMMM, LLL or LLLL, value will be -1
  if (value < 0) {
    // Want to be able to parse both short and long forms.
    // Try count == 4 first
    var months = goog.i18n.DateTimeSymbols.MONTHS.concat(
        goog.i18n.DateTimeSymbols.STANDALONEMONTHS).concat(
        goog.i18n.DateTimeSymbols.SHORTMONTHS).concat(
        goog.i18n.DateTimeSymbols.STANDALONESHORTMONTHS);
    value = this.matchString_(text, pos, months);
    if (value < 0) {
      return false;
    }
    // The months variable is multiple of 12, so we have to get the actual
    // month index by modulo 12.
    cal.month = (value % 12);
    return true;
  } else {
    cal.month = value - 1;
    return true;
  }
};


/**
 * Parse Quarter field.
 *
 * @param {string} text the time text to be parsed.
 * @param {Array.<number>} pos Parse position.
 * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.
 * @param {number} value numeric value if this field is expressed using
 *      numeric pattern, or -1 if not.
 *
 * @return {boolean} True if parsing successful.
 * @private
 */
goog.i18n.DateTimeParse.prototype.subParseQuarter_ =
    function(text, pos, cal, value) {
  // value should be -1, since this is a non-numeric field.
  if (value < 0) {
    // Want to be able to parse both short and long forms.
    // Try count == 4 first:
    value = this.matchString_(text, pos, goog.i18n.DateTimeSymbols.QUARTERS);
    if (value < 0) { // count == 4 failed, now try count == 3
      value = this.matchString_(text, pos,
                                goog.i18n.DateTimeSymbols.SHORTQUARTERS);
    }
    if (value < 0) {
      return false;
    }
    cal.month = value * 3;  // First month of quarter.
    cal.day = 1;
    return true;
  }
  return false;
};


/**
 * Parse Day of week field.
 * @param {string} text the time text to be parsed.
 * @param {Array.<number>} pos Parse position.
 * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.
 *
 * @return {boolean} True if successful.
 * @private
 */
goog.i18n.DateTimeParse.prototype.subParseDayOfWeek_ =
    function(text, pos, cal) {
  // Handle both short and long forms.
  // Try count == 4 (DDDD) first:
  var value = this.matchString_(text, pos, goog.i18n.DateTimeSymbols.WEEKDAYS);
  if (value < 0) {
    value = this.matchString_(text, pos,
                              goog.i18n.DateTimeSymbols.SHORTWEEKDAYS);
  }
  if (value < 0) {
    return false;
  }
  cal.dayOfWeek = value;
  return true;
};


/**
 * Parse fractional seconds field.
 *
 * @param {number} value parsed numeric value.
 * @param {Array.<number>} pos current parse position.
 * @param {number} start where this field start.
 * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.
 *
 * @return {boolean} True if successful.
 * @private
 */
goog.i18n.DateTimeParse.prototype.subParseFractionalSeconds_ =
    function(value, pos, start, cal) {
  // Fractional seconds left-justify
  var len = pos[0] - start;
  cal.milliseconds = len < 3 ? value * Math.pow(10, 3 - len) :
                               Math.round(value / Math.pow(10, len - 3));
  return true;
};


/**
 * Parse GMT type timezone.
 *
 * @param {string} text the time text to be parsed.
 * @param {Array.<number>} pos Parse position.
 * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.
 *
 * @return {boolean} True if successful.
 * @private
 */
goog.i18n.DateTimeParse.prototype.subparseTimeZoneInGMT_ =
    function(text, pos, cal) {
  // First try to parse generic forms such as GMT-07:00. Do this first
  // in case localized DateFormatZoneData contains the string "GMT"
  // for a zone; in that case, we don't want to match the first three
  // characters of GMT+/-HH:MM etc.

  // For time zones that have no known names, look for strings
  // of the form:
  //    GMT[+-]hours:minutes or
  //    GMT[+-]hhmm or
  //    GMT.
  if (text.indexOf('GMT', pos[0]) == pos[0]) {
    pos[0] += 3;  // 3 is the length of GMT
    return this.parseTimeZoneOffset_(text, pos, cal);
  }

  // TODO(shanjian): check for named time zones by looking through the locale
  // data from the DateFormatZoneData strings. Should parse both short and long
  // forms.
  // subParseZoneString(text, start, cal);

  // As a last resort, look for numeric timezones of the form
  // [+-]hhmm as specified by RFC 822.  This code is actually
  // a little more permissive than RFC 822.  It will try to do
  // its best with numbers that aren't strictly 4 digits long.
  return this.parseTimeZoneOffset_(text, pos, cal);
};


/**
 * Parse time zone offset.
 *
 * @param {string} text the time text to be parsed.
 * @param {Array.<number>} pos Parse position.
 * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.
 *
 * @return {boolean} True if successful.
 * @private
 */
goog.i18n.DateTimeParse.prototype.parseTimeZoneOffset_ =
    function(text, pos, cal) {
  if (pos[0] >= text.length) {
    cal.tzOffset = 0;
    return true;
  }

  var sign = 1;
  switch (text.charAt(pos[0])) {
    case '-': sign = -1;  // fall through
    case '+': pos[0]++;
  }

  // Look for hours:minutes or hhmm.
  var st = pos[0];
  var value = this.parseInt_(text, pos);
  if (value == 0 && pos[0] == st) {
    return false;
  }

  var offset;
  if (pos[0] < text.length && text.charAt(pos[0]) == ':') {
    // This is the hours:minutes case
    offset = value * 60;
    pos[0]++;
    st = pos[0];
    value = this.parseInt_(text, pos);
    if (value == 0 && pos[0] == st) {
      return false;
    }
    offset += value;
  } else {
    // This is the hhmm case.
    offset = value;
    // Assume "-23".."+23" refers to hours.
    if (offset < 24 && (pos[0] - st) <= 2) {
      offset *= 60;
    } else {
      // todo: this looks questionable, should have more error checking
      offset = offset % 100 + offset / 100 * 60;
    }
  }

  offset *= sign;
  cal.tzOffset = -offset;
  return true;
};


/**
 * Parse a integer string and return integer value.
 *
 * @param {string} text string being parsed.
 * @param {Array.<number>} pos parse position.
 *
 * @return {number} Converted integer value.
 * @private
 */
goog.i18n.DateTimeParse.prototype.parseInt_ = function(text, pos) {
  // Delocalizes the string containing native digits specified by the locale,
  // replaces the native digits with ASCII digits. Leaves other characters.
  // This is the reverse operation of localizeNumbers_ in datetimeformat.js.
  if (goog.i18n.DateTimeSymbols.ZERODIGIT) {
    var parts = [];
    for (var i = pos[0]; i < text.length; i++) {
      var c = text.charCodeAt(i) - goog.i18n.DateTimeSymbols.ZERODIGIT;
      parts.push((0 <= c && c <= 9) ?
          String.fromCharCode(c + 0x30) :
          text.charAt(i));
    }
    text = parts.join('');
  } else {
    text = text.substring(pos[0]);
  }

  var m = text.match(/^\d+/);
  if (!m) {
    return -1;
  }
  pos[0] += m[0].length;
  return parseInt(m[0], 10);
};


/**
 * Attempt to match the text at a given position against an array of strings.
 * Since multiple strings in the array may match (for example, if the array
 * contains "a", "ab", and "abc", all will match the input string "abcd") the
 * longest match is returned.
 *
 * @param {string} text The string to match to.
 * @param {Array.<number>} pos parsing position.
 * @param {Array.<string>} data The string array of matching patterns.
 *
 * @return {number} the new start position if matching succeeded; a negative
 *     number indicating matching failure.
 * @private
 */
goog.i18n.DateTimeParse.prototype.matchString_ = function(text, pos, data) {
  // There may be multiple strings in the data[] array which begin with
  // the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).
  // We keep track of the longest match, and return that. Note that this
  // unfortunately requires us to test all array elements.
  var bestMatchLength = 0;
  var bestMatch = -1;
  var lower_text = text.substring(pos[0]).toLowerCase();
  for (var i = 0; i < data.length; i++) {
    var len = data[i].length;
    // Always compare if we have no match yet; otherwise only compare
    // against potentially better matches (longer strings).
    if (len > bestMatchLength &&
        lower_text.indexOf(data[i].toLowerCase()) == 0) {
      bestMatch = i;
      bestMatchLength = len;
    }
  }
  if (bestMatch >= 0) {
    pos[0] += bestMatchLength;
  }
  return bestMatch;
};



/**
 * This class hold the intermediate parsing result. After all fields are
 * consumed, final result will be resolved from this class.
 * @constructor
 * @private
 */
goog.i18n.DateTimeParse.MyDate_ = function() {};


/**
 * The date's era.
 * @type {?number}
 */
goog.i18n.DateTimeParse.MyDate_.prototype.era;


/**
 * The date's year.
 * @type {?number}
 */
goog.i18n.DateTimeParse.MyDate_.prototype.year;


/**
 * The date's month.
 * @type {?number}
 */
goog.i18n.DateTimeParse.MyDate_.prototype.month;


/**
 * The date's day of month.
 * @type {?number}
 */
goog.i18n.DateTimeParse.MyDate_.prototype.day;


/**
 * The date's hour.
 * @type {?number}
 */
goog.i18n.DateTimeParse.MyDate_.prototype.hours;


/**
 * The date's before/afternoon denominator.
 * @type {?number}
 */
goog.i18n.DateTimeParse.MyDate_.prototype.ampm;


/**
 * The date's minutes.
 * @type {?number}
 */
goog.i18n.DateTimeParse.MyDate_.prototype.minutes;


/**
 * The date's seconds.
 * @type {?number}
 */
goog.i18n.DateTimeParse.MyDate_.prototype.seconds;


/**
 * The date's milliseconds.
 * @type {?number}
 */
goog.i18n.DateTimeParse.MyDate_.prototype.milliseconds;


/**
 * The date's timezone offset.
 * @type {?number}
 */
goog.i18n.DateTimeParse.MyDate_.prototype.tzOffset;


/**
 * The date's day of week. Sunday is 0, Saturday is 6.
 * @type {?number}
 */
goog.i18n.DateTimeParse.MyDate_.prototype.dayOfWeek;


/**
 * 2 digit year special handling. Assuming for example that the
 * defaultCenturyStart is 6/18/1903. This means that two-digit years will be
 * forced into the range 6/18/1903 to 6/17/2003. As a result, years 00, 01, and
 * 02 correspond to 2000, 2001, and 2002. Years 04, 05, etc. correspond
 * to 1904, 1905, etc. If the year is 03, then it is 2003 if the
 * other fields specify a date before 6/18, or 1903 if they specify a
 * date afterwards. As a result, 03 is an ambiguous year. All other
 * two-digit years are unambiguous.
 *
 * @param {number} year 2 digit year value before adjustment.
 * @return {number} disambiguated year.
 * @private
 */
goog.i18n.DateTimeParse.MyDate_.prototype.setTwoDigitYear_ = function(year) {
  var now = new Date();
  var defaultCenturyStartYear =
      now.getFullYear() - goog.i18n.DateTimeParse.ambiguousYearCenturyStart;
  var ambiguousTwoDigitYear = defaultCenturyStartYear % 100;
  this.ambiguousYear = (year == ambiguousTwoDigitYear);
  year += Math.floor(defaultCenturyStartYear / 100) * 100 +
      (year < ambiguousTwoDigitYear ? 100 : 0);
  return this.year = year;
};


/**
 * Based on the fields set, fill a Date object. For those fields that not
 * set, use the passed in date object's value.
 *
 * @param {goog.date.DateLike} date Date object to be filled.
 * @param {boolean} validation If true, input string will be checked to make
 *     sure it is valid.
 *
 * @return {boolean} false if fields specify a invalid date.
 * @private
 */
goog.i18n.DateTimeParse.MyDate_.prototype.calcDate_ =
    function(date, validation) {
  // year 0 is 1 BC, and so on.
  if (this.era != undefined && this.year != undefined &&
      this.era == 0 && this.year > 0) {
    this.year = -(this.year - 1);
  }

  if (this.year != undefined) {
    date.setFullYear(this.year);
  }

  // The setMonth and setDate logic is a little tricky. We need to make sure
  // day of month is smaller enough so that it won't cause a month switch when
  // setting month. For example, if data in date is Nov 30, when month is set
  // to Feb, because there is no Feb 30, JS adjust it to Mar 2. So Feb 12 will
  // become  Mar 12.
  var orgDate = date.getDate();

  // Every month has a 1st day, this can actually be anything less than 29.
  date.setDate(1);

  if (this.month != undefined) {
    date.setMonth(this.month);
  }

  if (this.day != undefined) {
    date.setDate(this.day);
  } else {
    var maxDate =
        goog.date.getNumberOfDaysInMonth(date.getFullYear(), date.getMonth());
    date.setDate(orgDate > maxDate ? maxDate : orgDate);
  }

  if (goog.isFunction(date.setHours)) {
    if (this.hours == undefined) {
      this.hours = date.getHours();
    }
    // adjust ampm
    if (this.ampm != undefined && this.ampm > 0 && this.hours < 12) {
      this.hours += 12;
    }
    date.setHours(this.hours);
  }

  if (goog.isFunction(date.setMinutes) && this.minutes != undefined) {
    date.setMinutes(this.minutes);
  }

  if (goog.isFunction(date.setSeconds) && this.seconds != undefined) {
    date.setSeconds(this.seconds);
  }

  if (goog.isFunction(date.setMilliseconds) &&
      this.milliseconds != undefined) {
    date.setMilliseconds(this.milliseconds);
  }

  // If validation is needed, verify that the uncalculated date fields
  // match the calculated date fields.  We do this before we set the
  // timezone offset, which will skew all of the dates.
  //
  // Don't need to check the day of week as it is guaranteed to be
  // correct or return false below.
  if (validation &&
      (this.year != undefined && this.year != date.getFullYear() ||
       this.month != undefined && this.month != date.getMonth() ||
       this.day != undefined && this.day != date.getDate() ||
       this.hours >= 24 || this.minutes >= 60 || this.seconds >= 60 ||
       this.milliseconds >= 1000)) {
    return false;
  }

  // adjust time zone
  if (this.tzOffset != undefined) {
    var offset = date.getTimezoneOffset();
    date.setTime(date.getTime() + (this.tzOffset - offset) * 60 * 1000);
  }

  // resolve ambiguous year if needed
  if (this.ambiguousYear) { // the two-digit year == the default start year
    var defaultCenturyStart = new Date();
    defaultCenturyStart.setFullYear(
        defaultCenturyStart.getFullYear() -
        goog.i18n.DateTimeParse.ambiguousYearCenturyStart);
    if (date.getTime() < defaultCenturyStart.getTime()) {
      date.setFullYear(defaultCenturyStart.getFullYear() + 100);
    }
  }

  // dayOfWeek, validation only
  if (this.dayOfWeek != undefined) {
    if (this.day == undefined) {
      // adjust to the nearest day of the week
      var adjustment = (7 + this.dayOfWeek - date.getDay()) % 7;
      if (adjustment > 3) {
        adjustment -= 7;
      }
      var orgMonth = date.getMonth();
      date.setDate(date.getDate() + adjustment);

      // don't let it switch month
      if (date.getMonth() != orgMonth) {
        date.setDate(date.getDate() + (adjustment > 0 ? -7 : 7));
      }
    } else if (this.dayOfWeek != date.getDay()) {
      return false;
    }
  }
  return true;
};

//javascript/apps/drive/dataservice/sync/response/responseparser.js
goog.provide('drive.ds.sync.response.ResponseParser');

goog.require('drive.ds.Account');
goog.require('drive.ds.App');
goog.require('drive.ds.Icon');
goog.require('drive.ds.Image');
goog.require('drive.ds.Item');
goog.require('drive.ds.ItemChange');
goog.require('drive.ds.ItemQueryResponse');
goog.require('drive.ds.ListChangesResponse');
goog.require('drive.ds.ListPermissionsResponse');
goog.require('drive.ds.ListRevisionsResponse');
goog.require('drive.ds.MutateItemResponse');
goog.require('drive.ds.Permission');
goog.require('drive.ds.Revision');
goog.require('drive.ds.Role');
goog.require('drive.ds.Status');
goog.require('drive.ds.UserAccountResponse');
goog.require('drive.ds.UserMetadata');
goog.require('goog.asserts');
goog.require('goog.date.UtcDateTime');
goog.require('goog.i18n.DateTimeParse');
goog.require('goog.json');
goog.require('proto.apps.activity.frontend.ActivityResponse');



/**
 * Handles parsing various Genoa response types and creating the appropriate
 * response.
 * TODO(towong): We should break this file up, maybe have a parser per major
 * type of response from Genoa (files, changes, mutate, etc).
 * @param {!drive.ds.sync.SyncedConfig} config The synced item config.
 * @constructor
 */
drive.ds.sync.response.ResponseParser = function(config) {
  /** @private {!drive.ds.sync.SyncedConfig} */
  this.config_ = config;
};


/**
 * Kinds of response objects from the Genoa API.
 * @enum {string}
 * @private
 */
drive.ds.sync.response.ResponseParser.Kind_ = {
  ABOUT: 'drive#about',
  APP: 'drive#app',
  APP_LIST: 'drive#appList',
  CHANGE: 'drive#change',
  CHANGE_LIST: 'drive#changeList',
  FILE: 'drive#file',
  FILE_LIST: 'drive#fileList',
  PERMISSION: 'drive#permission',
  PERMISSION_LIST: 'drive#permissionList',
  REVISION: 'drive#revision',
  REVISION_LIST: 'drive#revisionList',
  USER: 'drive#user'
};


/**
 * Maps a Genoa role string to a Proto role.
 * @private {!Object.<string, !drive.ds.Role>}
 */
drive.ds.sync.response.ResponseParser.Role_ = {
  'owner': drive.ds.Role.OWNER,
  'reader': drive.ds.Role.READER,
  'writer': drive.ds.Role.WRITER
};


/**
 * Maps a Genoa permission type to a Permission proto type.
 * @private {!Object.<string, !drive.ds.Permission.Type>}
 */
drive.ds.sync.response.ResponseParser.PermissionType_ = {
  'user': drive.ds.Permission.Type.USER,
  'group': drive.ds.Permission.Type.GROUP,
  'domain': drive.ds.Permission.Type.DASHER_DOMAIN,
  'anyone': drive.ds.Permission.Type.ANYONE
};


/**
 * Maps a Genoa category string to a Proto category.
 * @private {!Object.<string, !drive.ds.Icon.Category>}
 */
drive.ds.sync.response.ResponseParser.IconCategory_ = {
  'application': drive.ds.Icon.Category.APPLICATION,
  'document': drive.ds.Icon.Category.DOCUMENT,
  'documentShared': drive.ds.Icon.Category.DOCUMENT_SHARED
};


/**
 * An exif date parser.
 * @private {!goog.i18n.DateTimeParse}
 */
drive.ds.sync.response.ResponseParser.EXIF_PARSER_ =
    new goog.i18n.DateTimeParse('yyyy:MM:dd HH:mm:ss');


/**
 * Builds an ItemQueryResponse object from the drive response. This can handle a
 * response of kind drive#file and drive#fileList.
 * TODO(towong): Add unit tests for this class.
 * @param {!Object} response The response from the Genoa API.
 * @return {!drive.ds.ItemQueryResponse} The item query response.
 */
drive.ds.sync.response.ResponseParser.prototype.parseItems =
    function(response) {
  var responseProto = new drive.ds.ItemQueryResponse();

  // Check for errors from the Genoa API.
  var error = response['error'];
  if (error) {
    responseProto.setStatus(drive.ds.Status.GENERIC_ERROR);
    responseProto.setErrorMessage(
        response['error']['code'] + ' ' + response['error']['message']);
  } else {
    responseProto.setStatus(drive.ds.Status.SUCCESS);
    responseProto.setItemList(this.parseItems_(response));
  }
  return responseProto;
};


/**
 * Gets the next token string from the response.
 * @param {!Object} response The response from the Genoa API.
 * @return {string} The next token, or empty string if there isn't one.
 */
drive.ds.sync.response.ResponseParser.prototype.parseNextPageToken =
    function(response) {
  return (response['nextPageToken'] ? response['nextPageToken'] : '');
};


/**
 * Builds a ListChangesResponse object from the drive response. This can handle
 * response of kind drive#about and drive#changeList.
 * @param {!Object} response The response from the Genoa API.
 * @return {!drive.ds.ListChangesResponse} The item query response.
 */
drive.ds.sync.response.ResponseParser.prototype.parseChanges =
    function(response) {
  var responseProto = new drive.ds.ListChangesResponse();

  // Check for errors from the Genoa API.
  var error = response['error'];
  if (error) {
    responseProto.setStatus(drive.ds.Status.GENERIC_ERROR);
  } else {
    responseProto.setStatus(drive.ds.Status.SUCCESS);

    var nextChangeId = response['nextPageToken'];
    if (nextChangeId) {
      responseProto.setNextChangeId(nextChangeId);
    }

    var largestChangeId = response['largestChangeId'];
    if (largestChangeId) {
      responseProto.setLargestChangeId(largestChangeId);
    }

    if (response['kind'] ==
        drive.ds.sync.response.ResponseParser.Kind_.CHANGE_LIST) {
      responseProto.setItemChangeList(this.parseChanges_(response));
    }
  }
  return responseProto;
};


/**
 * Builds a MutateResponse object from the drive response for a create or update
 * request. This can handle response of kind drive#file.
 * @param {!Object} response The response from the Genoa API.
 * @param {?string} itemId The id of the item being mutated.
 * @return {!drive.ds.MutateItemResponse} The mutate item response.
 */
drive.ds.sync.response.ResponseParser.prototype.parseMutate =
    function(response, itemId) {
  var responseProto = new drive.ds.MutateItemResponse();
  responseProto.setItemId(itemId);

  // Check for errors from the Genoa API.
  var error = response['error'];
  if (error) {
    responseProto.setStatus(drive.ds.Status.GENERIC_ERROR);
    responseProto.setErrorMessage(
        response['error']['code'] + ' ' + response['error']['message']);
  } else {
    responseProto.setStatus(drive.ds.Status.SUCCESS);
    if (response['kind'] == drive.ds.sync.response.ResponseParser.Kind_.FILE) {
      var item = this.parseItem_(response);
      responseProto.setItem(item);
      if (!itemId) {
        responseProto.setItemId(item.getId());
      }
    } else if (response['kind'] ==
        drive.ds.sync.response.ResponseParser.Kind_.REVISION) {
      var revision = this.parseRevision_(response);
      responseProto.setRevision(revision);
    } else {
      goog.asserts.fail('Attempted to parse an invalid mutation response.');
    }
  }
  return responseProto;
};


/**
 * Builds a MutateResponse object from a drive mutate response that returns
 * empty on success, or contain an error on failure.
 * @param {!Object} response The response from the Genoa API.
 * @param {?string} itemId The id of the item being mutated.
 * @return {!drive.ds.MutateItemResponse} The mutate item response.
 */
drive.ds.sync.response.ResponseParser.prototype.parseMutateEmptyOnSuccess =
    function(response, itemId) {
  var responseProto = new drive.ds.MutateItemResponse();
  responseProto.setItemId(itemId);

  // Check for errors from the Genoa API.
  var error = response['error'];
  if (error) {
    responseProto.setStatus(drive.ds.Status.GENERIC_ERROR);
    responseProto.setErrorMessage(
        response['error']['code'] + ' ' + response['error']['message']);
  } else {
    responseProto.setStatus(drive.ds.Status.SUCCESS);
  }
  return responseProto;
};


/**
 * Builds a list of installed apps from the drive response.
 * @param {!Object} response The response from the Genoa API.
 * @return {!Array.<!drive.ds.App>} The list of installed apps.
 */
drive.ds.sync.response.ResponseParser.prototype.parseApps = function(response) {
  var appsList = [];

  // Check for errors from the Genoa API.
  var error = response['error'];
  if (!error && response['items'] && response['kind'] ==
      drive.ds.sync.response.ResponseParser.Kind_.APP_LIST) {
    var items = response['items'];
    for (var i = 0; i < items.length; i++) {
      appsList.push(this.parseApp_(items[i]));
    }
  }
  return appsList;
};


/**
 * Builds a UserAccountResponse from the drive response.
 * @param {!Object} response The response from the Genoa API.
 * @return {!drive.ds.UserAccountResponse} The user account response.
 */
drive.ds.sync.response.ResponseParser.prototype.parseAccount =
    function(response) {
  var userAccountResponse = new drive.ds.UserAccountResponse();

  // Check for errors from the Genoa API.
  var error = response['error'];
  if (error) {
    userAccountResponse.setStatus(drive.ds.Status.GENERIC_ERROR);
    userAccountResponse.setErrorMessage(
        response['error']['code'] + ' ' + response['error']['message']);
    return userAccountResponse;
  }

  goog.asserts.assert(response['kind'] ==
      drive.ds.sync.response.ResponseParser.Kind_.ABOUT,
      'Attempted to parse something that is not a Drive About Response');

  var accountProto = new drive.ds.Account();
  if (response['user']) {
    var user = response['user'];
    var userProto = this.parseUser_(user);
    accountProto.setUser(userProto);
  }

  var quotaProto = new drive.ds.UserMetadata.Quota();
  quotaProto.setQuotaBytesTotal(response['quotaBytesTotal']);
  quotaProto.setQuotaBytesUsed(response['quotaBytesUsed']);
  quotaProto.setQuotaBytesUsedAggregate(response['quotaBytesUsedAggregate']);
  quotaProto.setQuotaBytesUsedInTrash(response['quotaBytesUsedInTrash']);

  // TODO(haluk): Parse user preferences when Genoa starts including them.

  var userMetadataProto = new drive.ds.UserMetadata();
  userMetadataProto.setQuota(quotaProto);
  userMetadataProto.setRootFolderId(response['rootFolderId']);
  userMetadataProto.setDomainSharingPolicy(response['domainSharingPolicy']);
  accountProto.setMetadata(userMetadataProto);

  userAccountResponse.setAccount(accountProto);
  userAccountResponse.setStatus(drive.ds.Status.SUCCESS);
  return userAccountResponse;
};


/**
 * Builds an ListRevisionsResponse object from the drive response. This can
 * handle a response of kind drive#revisionList.
 * @param {!Object} response The response from the Genoa API.
 * @return {!drive.ds.ListRevisionsResponse} The revision list response.
 */
drive.ds.sync.response.ResponseParser.prototype.parseRevisions =
    function(response) {
  var responseProto = new drive.ds.ListRevisionsResponse();

  // Check for errors from the Genoa API.
  var error = response['error'];
  if (error) {
    responseProto.setStatus(drive.ds.Status.GENERIC_ERROR);
    responseProto.setErrorMessage(
        response['error']['code'] + ' ' + response['error']['message']);
  } else {
    responseProto.setStatus(drive.ds.Status.SUCCESS);
    responseProto.setRevisionList(this.parseRevisions_(response));
  }
  return responseProto;
};


/**
 * Builds an ListPermissionsResponse object from the drive response. This can
 * handle a response of kind drive#permissionList.
 * @param {!Object} response The response from the Genoa API.
 * @return {!drive.ds.ListPermissionsResponse} The permissions response.
 */
drive.ds.sync.response.ResponseParser.prototype.parsePermissions =
    function(response) {
  var responseProto = new drive.ds.ListPermissionsResponse();

  // Check for errors from the Genoa API.
  var error = response['error'];
  if (error) {
    responseProto.setStatus(drive.ds.Status.GENERIC_ERROR);
    responseProto.setErrorMessage(
        response['error']['code'] + ' ' + response['error']['message']);
  } else {
    responseProto.setStatus(drive.ds.Status.SUCCESS);
    responseProto.setPermissionList(this.parsePermissions_(response));
  }
  return responseProto;
};


/**
 * Builds a list of permissions from the drive response.
 * @param {!Object} response The response from the Genoa API.
 * @return {!Array.<!drive.ds.Permission>} The list of permissions.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parsePermissions_ =
    function(response) {
  goog.asserts.assert(response['kind'] ==
      drive.ds.sync.response.ResponseParser.Kind_.PERMISSION_LIST,
      'Attempted to parse something that is not a Drive Permission List');

  var permissionList = [];
  var permissions = response['items'];
  for (var i = 0; i < permissions.length; i++) {
    var permission = this.parsePermission_(permissions[i]);
    if (permission) {
      permissionList.push(permission);
    }
  }

  return permissionList;
};


/**
 * Builds a permission from the drive response.
 * @param {!Object} response The response from the Genoa API.
 * @return {!drive.ds.Permission} The permission.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parsePermission_ =
    function(response) {
  goog.asserts.assert(response['kind'] ==
      drive.ds.sync.response.ResponseParser.Kind_.PERMISSION,
      'Attempted to parse something that is not a Drive Permission');

  var permission = new drive.ds.Permission();
  permission.setType(
      drive.ds.sync.response.ResponseParser.PermissionType_[response['type']]);
  permission.setId(response['id']);
  permission.setName(response['name']);
  permission.setUnlisted(response['withLink'] || false);
  permission.setPhotoUrl(response['photoLink']);
  permission.setRole(
      drive.ds.sync.response.ResponseParser.Role_[response['role']]);
  permission.setIsMe(response['id'] == this.config_.getGaiaId());

  return permission;
};


/**
 * Builds a list of response changes.
 * @param {!Object} response The response from the Genoa API.
 * @return {!Array.<!drive.ds.ItemChange>} A list of changes.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseChanges_ =
    function(response) {
  goog.asserts.assert(response['kind'] ==
      drive.ds.sync.response.ResponseParser.Kind_.CHANGE_LIST,
      'Attempted to parse something that is not a Drive Change List');

  var changesProto = [];
  if (response['items'] && response['kind'] ==
      drive.ds.sync.response.ResponseParser.Kind_.CHANGE_LIST) {
    var changes = response['items'];
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var changeProto = this.parseChange_(change);
      changesProto.push(changeProto);
    }
  }
  return changesProto;
};


/**
 * Builds a response change item proto.
 * @param {Object} change A change item from the response object.
 * @return {!drive.ds.ItemChange} A change item proto.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseChange_ =
    function(change) {
  goog.asserts.assert(
      change['kind'] == drive.ds.sync.response.ResponseParser.Kind_.CHANGE,
      'Attempted to parse something that is not a Drive Change');

  var changeProto = new drive.ds.ItemChange();
  changeProto.setChangeId(change['id']);
  changeProto.setItemId(change['fileId']);
  if (change['deleted']) {
    changeProto.setDeleted(true);
  }
  if (change['file']) {
    changeProto.setItem(this.parseItem_(change['file']));
  }

  return changeProto;
};


/**
 * Builds a list of response items.
 * @param {!Object} response The response from the Genoa API.
 * @return {!Array.<!drive.ds.Item>} A list of items.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseItems_ =
    function(response) {
  goog.asserts.assert(response['kind'] ==
      drive.ds.sync.response.ResponseParser.Kind_.FILE_LIST ||
          response['kind'] == drive.ds.sync.response.ResponseParser.Kind_.FILE,
      'Attempted to parse something that is not a File/File List');

  var itemsProto = [];
  if (response &&
      response['kind'] == drive.ds.sync.response.ResponseParser.Kind_.FILE) {
    var itemProto = this.parseItem_(response);
    if (itemProto) {
      itemsProto.push(itemProto);
    }
  } else if (response && response['kind'] ==
      drive.ds.sync.response.ResponseParser.Kind_.FILE_LIST &&
      response['items']) {
    var items = response['items'];
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var itemProto = this.parseItem_(item);
      itemsProto.push(itemProto);
    }
  }
  return itemsProto;
};


/**
 * Builds a response item.
 * @param {Object} item An item from the response object.
 * @return {!drive.ds.Item} A proto item.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseItem_ = function(item) {
  goog.asserts.assert(
      item['kind'] == drive.ds.sync.response.ResponseParser.Kind_.FILE,
      'Attempted to parse something that is not a Drive Item');

  var protoItem = new drive.ds.Item();
  protoItem.setId(item['id']);
  protoItem.setParentList(this.parseParents_(item));

  protoItem.setTitle(item['title']);
  protoItem.setMimeType(item['mimeType']);
  protoItem.setOpenUrl(item['alternateLink']);
  protoItem.setHasThumbnail(!!item['thumbnailLink']);
  protoItem.setIconUrl(item['iconLink']);
  protoItem.setDescription(item['description']);
  protoItem.setExplicitlyTrashed(item['explicitlyTrashed']);
  protoItem.setShared(item['shared']);
  protoItem.setQuotaBytesUsed(item['quotaBytesUsed']);
  protoItem.setFileSize(item['fileSize']);
  protoItem.setCopyable(item['copyable']);

  if (item['labels']) {
    var labels = item['labels'];
    protoItem.setStarred(labels['starred']);
    protoItem.setHidden(labels['hidden']);
    protoItem.setTrashed(labels['trashed']);
    protoItem.setRestricted(labels['restricted']);
    protoItem.setViewed(labels['viewed']);
  }

  protoItem.setCreateDateMillis(this.parseDate_(item['createdDate']));
  protoItem.setModifiedDateMillis(this.parseDate_(item['modifiedDate']));
  protoItem.setModifiedByMeDateMillis(
      this.parseDate_(item['modifiedByMeDate']));
  protoItem.setLastViewedByMeDateMillis(
      this.parseDate_(item['lastViewedByMeDate']));
  protoItem.setSharedWithMeDateMillis(
      this.parseDate_(item['sharedWithMeDate']));

  protoItem.setOwnerList(this.parseOwners_(item));

  if (item['lastModifyingUser']) {
    var lastUser = this.parseUser_(item['lastModifyingUser']);
    protoItem.setLastModifyingUser(lastUser);
  }

  if (item['userPermission']) {
    var role = item['userPermission']['role'];
    var roleProto = drive.ds.sync.response.ResponseParser.Role_[role];
    protoItem.setUserRole(roleProto);

    protoItem.setShareable(roleProto == drive.ds.Role.OWNER ||
        (roleProto == drive.ds.Role.WRITER && item['writersCanShare']));
  }

  if (item['imageMediaMetadata']) {
    var image = this.parseImage_(item['imageMediaMetadata']);
    protoItem.setImage(image);
  }

  if (item['expello']) {
    protoItem.setCosmoType(item['expello']['cosmoType']);
    protoItem.setServiceId(item['expello']['serviceId']);
  }

  protoItem.setFolderColor(item['folderColor']);
  protoItem.setSubscribed(item['subscribed']);
  protoItem.setFileExtension(item['fileExtension']);

  // TODO(towong): Use actual primary_sync_parent once Genoa provides it.
  if (item['descendantOfRoot']) {
    protoItem.setPrimarySyncParent(protoItem.getParentList()[0] || '');
  }

  // TODO(towong): Add parsing for user/visibility once Genoa provides it.

  if (item['source']) {
    protoItem.setCreatorAppId(item['source']['client_service_id']);
    protoItem.setCreatorAppValue(item['source']['value']);
  }

  return protoItem;
};


/**
 * @param {string|undefined} date Date time in string form.
 * @return {number|undefined} The date time in milliseconds.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseDate_ = function(date) {
  return goog.isDefAndNotNull(date) ? new Date(date).getTime() : undefined;
};


/**
 * @param {Object} item An item from the response object.
 * @return {!Array.<string>} An array of parent ids.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseParents_ = function(item) {
  var parents = [];
  if (item && item['parents']) {
    var parentsResponse = item['parents'];
    for (var i = 0; i < parentsResponse.length; i++) {
      parents.push(parentsResponse[i]['id']);
    }
  }
  return parents;
};


/**
 * @param {Object} item An item from the response object.
 * @return {!Array.<!drive.ds.Permission>} An array of owner permissions.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseOwners_ = function(item) {
  var owners = [];
  if (item && item['owners']) {
    var ownersResponse = item['owners'];
    for (var i = 0; i < ownersResponse.length; i++) {
      var owner = this.parseUser_(ownersResponse[i]);
      if (owner) {
        owners.push(owner);
      }
    }
  }
  return owners;
};


/**
 * @param {Object} userResponse A user nested object from the response object.
 * @return {!drive.ds.Permission} A user permission proto.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseUser_ =
    function(userResponse) {
  goog.asserts.assert(
      userResponse['kind'] == drive.ds.sync.response.ResponseParser.Kind_.USER,
      'Attempted to parse something that is not a Drive User');

  var user = new drive.ds.Permission();
  user.setType(drive.ds.Permission.Type.USER);
  user.setId(userResponse['permissionId']);
  user.setName(userResponse['displayName']);

  if (userResponse['picture']) {
    user.setPhotoUrl(userResponse['picture']['url']);
  }
  user.setIsMe(userResponse['permissionId'] == this.config_.getGaiaId());

  return user;
};


/**
 * @param {Object} imageResponse A nested image object from the response
 * object.
 * @return {!drive.ds.Image} An image proto.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseImage_ =
    function(imageResponse) {
  var image = new drive.ds.Image();
  image.setWidth(imageResponse['width']);
  image.setHeight(imageResponse['height']);

  if (imageResponse['date']) {
    image.setDateMillis(this.parseExifDate_(imageResponse['date']));
  }

  return image;
};


/**
 * @param {string} dateStr Exif date time in string form.
 * @return {number} The date time in milliseconds.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseExifDate_ =
    function(dateStr) {
  var date = new goog.date.UtcDateTime();
  date.setMilliseconds(0);
  drive.ds.sync.response.ResponseParser.EXIF_PARSER_.parse(dateStr, date);
  return date.getTime();
};


/**
 * Builds an app proto from a Genoa app response.
 * @param {Object} app An app from the response object.
 * @return {!drive.ds.App} An app proto.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseApp_ = function(app) {
  goog.asserts.assert(
      app['kind'] == drive.ds.sync.response.ResponseParser.Kind_.APP,
      'Attempted to parse something that is not a Drive App');

  var appProto = new drive.ds.App();
  appProto.setId(/** @type {string} */ (app['id']));
  appProto.setUseByDefault(app['useByDefault']);
  appProto.setName(app['name']);
  appProto.setOpenUrlTemplate(app['openUrlTemplate']);
  appProto.setPrimaryMimeTypeList(app['primaryMimeTypes']);
  appProto.setSecondaryMimeTypeList(app['secondaryMimeTypes']);
  appProto.setCreateUrl(app['createUrl']);
  appProto.setCreateInFolderTemplate(app['createInFolderTemplate']);
  appProto.setObjectType(app['objectType']);
  appProto.setSupportsCreate(app['supportsCreate']);
  appProto.setSupportsImport(app['supportsImport']);
  appProto.setSupportsMultiOpen(app['supportsMultiOpen']);
  appProto.setInstalled(app['installed']);
  appProto.setAuthorized(app['authorized']);
  appProto.setProductUrl(app['productUrl']);
  appProto.setPrimaryFileExtensionList(app['primaryFileExtensions']);
  appProto.setSecondaryFileExtensionList(app['secondaryFileExtensions']);
  appProto.setShortDescription(app['shortDescription']);
  appProto.setLongDescription(app['longDescription']);
  appProto.setProductId(app['productId']);

  var icons = app['icons'] || [];
  var parsedIcons = [];
  for (var i = 0; i < icons.length; i++) {
    parsedIcons.push(this.parseIcon_(icons[i]));
  }
  appProto.setIconList(parsedIcons);

  return appProto;
};


/**
 * Builds an icon proto from a Genoa icon response.
 * @param {Object} icon An icon from the response object.
 * @return {!drive.ds.Icon} An icon proto.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseIcon_ = function(icon) {
  var iconProto = new drive.ds.Icon();
  iconProto.setUrl(icon['iconUrl']);
  iconProto.setSize(icon['size']);

  if (icon['category']) {
    iconProto.setCategory(
        drive.ds.sync.response.ResponseParser.IconCategory_[icon['category']]);
  }

  return iconProto;
};


/**
 * Builds a list of response revisions.
 * @param {!Object} response The response from the Genoa API.
 * @return {!Array.<!drive.ds.Revision>} A list of response revisions.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseRevisions_ =
    function(response) {
  goog.asserts.assert(response['kind'] ==
      drive.ds.sync.response.ResponseParser.Kind_.REVISION_LIST,
      'Attempted to parse something that is not a Revision List');

  var revsProto = [];
  if (response && response['items']) {
    var items = response['items'];
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var revProto = this.parseRevision_(item);
      revsProto.push(revProto);
    }
  }
  return revsProto;
};


/**
 * Builds a response revision.
 * @param {Object} item An item from the response object.
 * @return {!drive.ds.Revision} A proto revision.
 * @private
 */
drive.ds.sync.response.ResponseParser.prototype.parseRevision_ =
    function(item) {
  goog.asserts.assert(
      item['kind'] == drive.ds.sync.response.ResponseParser.Kind_.REVISION,
      'Attempted to parse something that is not a Drive revision');

  var protoRev = new drive.ds.Revision();
  protoRev.setId(item['id']);
  protoRev.setMimeType(item['mimeType']);
  protoRev.setModifiedDateMillis(this.parseDate_(item['modifiedDate']));
  protoRev.setPinned(item['pinned']);
  protoRev.setDownloadUrl(item['downloadUrl']);
  protoRev.setOriginalItemName(item['originalFilename']);
  protoRev.setFileSize(item['fileSize']);

  var lastUser = this.parseUser_(item['lastModifyingUser']);
  protoRev.setLastModifyingUser(lastUser);

  return protoRev;
};


/**
 * Builds an activity response.
 * @param {Object} object The response from the Explorer activity endpoint.
 * @return {!proto.apps.activity.frontend.ActivityResponse} The response proto.
 */
drive.ds.sync.response.ResponseParser.prototype.parseActivities =
    function(object) {
  var response = object['response'] || {};
  var responseProtoString = response['responseProto'] || null;

  var responseProto = responseProtoString ?
      /** @type {!Array} */ (goog.json.unsafeParse(responseProtoString)) : [];

  var activityProto =
      new proto.apps.activity.frontend.ActivityResponse(responseProto);
  return activityProto;
};


/**
 * Removes the prefix from the JSON meant to prevent XSRF attacks.
 * TODO(jlure): Remove this when Genoa can provide activity data.
 * @param {string} json The protected JSON string.
 * @return {string} The JSON string with prefix removed.
 */
drive.ds.sync.response.ResponseParser.prototype.parseProtectedJson =
    function(json) {
  var prefix = ')]}\'';
  var index = json.indexOf(prefix);
  if (index == 0) {
    json = json.substring(prefix.length);
  }
  return json;
};

//javascript/closure/crypt/arc4.js
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview ARC4 streamcipher implementation.  A description of the
 * algorithm can be found at:
 * http://www.mozilla.org/projects/security/pki/nss/draft-kaukonen-cipher-arcfour-03.txt.
 *
 * Usage:
 * <code>
 *   var arc4 = new goog.crypt.Arc4();
 *   arc4.setKey(key);
 *   arc4.discard(1536);
 *   arc4.crypt(bytes);
 * </code>
 *
 * Note: For converting between strings and byte arrays, goog.crypt.base64 may
 * be useful.
 *
 * @author mschilder@google.com (Marius Schilder)
 * @author maurerj@google.com (Jennifer Maurer) - port to closure
 */

goog.provide('goog.crypt.Arc4');

goog.require('goog.asserts');



/**
 * ARC4 streamcipher implementation.
 * @constructor
 * @final
 */
goog.crypt.Arc4 = function() {
  /**
   * A permutation of all 256 possible bytes.
   * @type {Array.<number>}
   * @private
   */
  this.state_ = [];

  /**
   * 8 bit index pointer into this.state_.
   * @type {number}
   * @private
   */
  this.index1_ = 0;

  /**
   * 8 bit index pointer into this.state_.
   * @type {number}
   * @private
   */
  this.index2_ = 0;
};


/**
 * Initialize the cipher for use with new key.
 * @param {Array.<number>} key A byte array containing the key.
 * @param {number=} opt_length Indicates # of bytes to take from the key.
 */
goog.crypt.Arc4.prototype.setKey = function(key, opt_length) {
  goog.asserts.assertArray(key, 'Key parameter must be a byte array');

  if (!opt_length) {
    opt_length = key.length;
  }

  var state = this.state_;

  for (var i = 0; i < 256; ++i) {
    state[i] = i;
  }

  var j = 0;
  for (var i = 0; i < 256; ++i) {
    j = (j + state[i] + key[i % opt_length]) & 255;

    var tmp = state[i];
    state[i] = state[j];
    state[j] = tmp;
  }

  this.index1_ = 0;
  this.index2_ = 0;
};


/**
 * Discards n bytes of the keystream.
 * These days 1536 is considered a decent amount to drop to get the key state
 * warmed-up enough for secure usage. This is not done in the constructor to
 * preserve efficiency for use cases that do not need this.
 * NOTE: Discard is identical to crypt without actually xoring any data. It's
 * unfortunate to have this code duplicated, but this was done for performance
 * reasons. Alternatives which were attempted:
 * 1. Create a temp array of the correct length and pass it to crypt. This
 *    works but needlessly allocates an array. But more importantly this
 *    requires choosing an array type (Array or Uint8Array) in discard, and
 *    choosing a different type than will be passed to crypt by the client
 *    code hurts the javascript engines ability to optimize crypt (7x hit in
 *    v8).
 * 2. Make data option in crypt so discard can pass null, this has a huge
 *    perf hit for crypt.
 * @param {number} length Number of bytes to disregard from the stream.
 */
goog.crypt.Arc4.prototype.discard = function(length) {
  var i = this.index1_;
  var j = this.index2_;
  var state = this.state_;

  for (var n = 0; n < length; ++n) {
    i = (i + 1) & 255;
    j = (j + state[i]) & 255;

    var tmp = state[i];
    state[i] = state[j];
    state[j] = tmp;
  }

  this.index1_ = i;
  this.index2_ = j;
};


/**
 * En- or decrypt (same operation for streamciphers like ARC4)
 * @param {Array.<number>|Uint8Array} data The data to be xor-ed in place.
 * @param {number=} opt_length The number of bytes to crypt.
 */
goog.crypt.Arc4.prototype.crypt = function(data, opt_length) {
  if (!opt_length) {
    opt_length = data.length;
  }
  var i = this.index1_;
  var j = this.index2_;
  var state = this.state_;

  for (var n = 0; n < opt_length; ++n) {
    i = (i + 1) & 255;
    j = (j + state[i]) & 255;

    var tmp = state[i];
    state[i] = state[j];
    state[j] = tmp;

    data[n] ^= state[(state[i] + state[j]) & 255];
  }

  this.index1_ = i;
  this.index2_ = j;
};

//javascript/closure/crypt/hmac.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Implementation of HMAC in JavaScript.
 *
 * Usage:
 *   var hmac = new goog.crypt.Hmac(new goog.crypt.sha1(), key, 64);
 *   var digest = hmac.getHmac(bytes);
 *
 * @author aa@google.com (Aaron Boodman)
 * @author benyu@google.com (Jige Yu) - port to closure
 */


goog.provide('goog.crypt.Hmac');

goog.require('goog.asserts');
goog.require('goog.crypt.Hash');



/**
 * @constructor
 * @param {!goog.crypt.Hash} hasher An object to serve as a hash function.
 * @param {Array.<number>} key The secret key to use to calculate the hmac.
 *     Should be an array of not more than {@code blockSize} integers in
       {0, 255}.
 * @param {number=} opt_blockSize Optional. The block size {@code hasher} uses.
 *     If not specified, 16.
 * @extends {goog.crypt.Hash}
 * @final
 */
goog.crypt.Hmac = function(hasher, key, opt_blockSize) {
  goog.base(this);

  /**
   * The underlying hasher to calculate hash.
   *
   * @type {!goog.crypt.Hash}
   * @private
   */
  this.hasher_ = hasher;

  /**
   * The block size.
   *
   * @type {number}
   * @private
   */
  this.blockSize_ = opt_blockSize || 16;

  /**
   * The outer padding array of hmac
   *
   * @type {!Array.<number>}
   * @private
   */
  this.keyO_ = new Array(this.blockSize_);

  /**
   * The inner padding array of hmac
   *
   * @type {!Array.<number>}
   * @private
   */
  this.keyI_ = new Array(this.blockSize_);

  this.initialize_(key);
};
goog.inherits(goog.crypt.Hmac, goog.crypt.Hash);


/**
 * Outer padding byte of HMAC algorith, per http://en.wikipedia.org/wiki/HMAC
 *
 * @type {number}
 * @private
 */
goog.crypt.Hmac.OPAD_ = 0x5c;


/**
 * Inner padding byte of HMAC algorith, per http://en.wikipedia.org/wiki/HMAC
 *
 * @type {number}
 * @private
 */
goog.crypt.Hmac.IPAD_ = 0x36;


/**
 * Initializes Hmac by precalculating the inner and outer paddings.
 *
 * @param {Array.<number>} key The secret key to use to calculate the hmac.
 *     Should be an array of not more than {@code blockSize} integers in
       {0, 255}.
 * @private
 */
goog.crypt.Hmac.prototype.initialize_ = function(key) {
  if (key.length > this.blockSize_) {
    this.hasher_.update(key);
    key = this.hasher_.digest();
  }
  // Precalculate padded and xor'd keys.
  var keyByte;
  for (var i = 0; i < this.blockSize_; i++) {
    if (i < key.length) {
      keyByte = key[i];
    } else {
      keyByte = 0;
    }
    this.keyO_[i] = keyByte ^ goog.crypt.Hmac.OPAD_;
    this.keyI_[i] = keyByte ^ goog.crypt.Hmac.IPAD_;
  }
  // Be ready for an immediate update.
  this.hasher_.update(this.keyI_);
};


/** @override */
goog.crypt.Hmac.prototype.reset = function() {
  this.hasher_.reset();
  this.hasher_.update(this.keyI_);
};


/** @override */
goog.crypt.Hmac.prototype.update = function(bytes, opt_length) {
  this.hasher_.update(bytes, opt_length);
};


/** @override */
goog.crypt.Hmac.prototype.digest = function() {
  var temp = this.hasher_.digest();
  this.hasher_.reset();
  this.hasher_.update(this.keyO_);
  this.hasher_.update(temp);
  return this.hasher_.digest();
};


/**
 * Calculates an HMAC for a given message.
 *
 * @param {Array.<number>} message  An array of integers in {0, 255}.
 * @return {!Array.<number>} the digest of the given message.
 */
goog.crypt.Hmac.prototype.getHmac = function(message) {
  this.reset();
  this.update(message);
  return this.digest();
};

//javascript/apps/drive/dataservice/sync/storage/crypt.js
/**
 * @fileoverview A crypto library for the DataService library.
 */
goog.provide('drive.ds.sync.storage.Crypt');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.crypt');
goog.require('goog.crypt.Arc4');
goog.require('goog.crypt.Hmac');
goog.require('goog.crypt.Sha1');


/**
 * The length of salts.
 * @private {number}
 */
drive.ds.sync.storage.Crypt.SALT_LENGTH_BYTES_ = 16;


/**
 * The length of the calculated hmac. Using a SHA1 hash results in a 160 bit (or
 * 20 byte) hash.
 * @private {number}
 */
drive.ds.sync.storage.Crypt.HMAC_LENGTH_BYTES_ = 20;


/**
 * Chunk size for array size when converting from bytes to string.
 * @private {number}
 */
drive.ds.sync.storage.Crypt.CHUNK_SIZE_ = 32768;


/**
 * Encrypts the given string data.
 *
 * @param {string} data The string to encrypt.
 * @param {string} key The encryption key.
 * @return {string} Encrypted string with the encryption salt prepended.
 */
drive.ds.sync.storage.Crypt.encrypt = function(data, key) {
  var salt = [];
  var saltLength = drive.ds.sync.storage.Crypt.SALT_LENGTH_BYTES_;
  for (var i = 0; i < saltLength; i++) {
    salt[i] = Math.floor(Math.random() * 0x100);
  }
  var saltString = goog.crypt.byteArrayToString(salt);

  var hmacString = drive.ds.sync.storage.Crypt.computeHmac_(data, key);

  return saltString.concat(hmacString,
      drive.ds.sync.storage.Crypt.crypt_(saltString, key, data, true));
};


/**
 * Decrypts the given encrypted string data.
 *
 * @param {string} encrypted Encrypted data that includes encrypted data and
 *     its salt.
 * @param {string} key The decryption key.
 * @return {string} Decrypted data string.
 * @throws {string} Mismatch hmac found during decryption!
 */
drive.ds.sync.storage.Crypt.decrypt = function(encrypted, key) {
  var saltLength = drive.ds.sync.storage.Crypt.SALT_LENGTH_BYTES_;
  var salt = encrypted.substring(0, saltLength);

  var hmacLength = drive.ds.sync.storage.Crypt.HMAC_LENGTH_BYTES_;
  var data = encrypted.substring(saltLength + hmacLength);
  var decrypted = drive.ds.sync.storage.Crypt.crypt_(salt, key, data, false);

  var expectedHmacString = encrypted.substring(
      saltLength, saltLength + hmacLength);
  var hmacString = drive.ds.sync.storage.Crypt.computeHmac_(decrypted, key);

  if (expectedHmacString != hmacString) {
    throw Error('Mismatch hmac!');
  }

  return decrypted;
};


/**
 * Computes an hmac string for the data using the given key.
 * @param {string} data The data to calculate an hmac for.
 * @param {string} key The key to use with hmac.
 * @return {string} Decrypted string data.
 * @private
 */
drive.ds.sync.storage.Crypt.computeHmac_ = function(data, key) {
  var hmacer = new goog.crypt.Hmac(
      new goog.crypt.Sha1(), goog.crypt.stringToByteArray(key));
  var bytes = goog.crypt.stringToUtf8ByteArray(data);
  var hmac = hmacer.getHmac(bytes);

  return goog.crypt.byteArrayToString(hmac);
};


/**
 * De/encrypts using ARC4.
 *
 * Note that the ARC4 key MUST be salted, otherwise the keystream generated by
 * ARC4 would be the same each time and an attacker that knew the plaintext of
 * an encrypted row could decrypt any other message encrypted with the same key.
 *
 * For example, say we saved two rows per user and the keys were something like
 * 'UserFoo' and 'UserFooMetadata'. The row with the key 'UserFoo' holds
 * encrypted data. An attacker knows the user Foo has an empty corpus and
 * guesses the raw plaintext. Without a salt, we would simply hash the raw JSON
 * with an encryption key that would also be used for the other metadata row. An
 * attacker could use methods like rainbow tables to find the encryption key and
 * decrypt the metadata row as well. By using salt, no two rows share the same
 * encryption key, even for the same user, and we isolate the attack to just one
 * row.
 *
 * @param {string} salt Salt string to be used to salt the given key.
 * @param {?string} key Key to be used to generate the encryption key.
 * @param {string} value Data to be de/encrypted.
 * @param {boolean} encrypt True for encryption, false for decryption.
 * @return {string} De/encrypted data.
 * @private
 */
drive.ds.sync.storage.Crypt.crypt_ = function(salt, key, value, encrypt) {
  goog.asserts.assert(key);

  var sha1 = new goog.crypt.Sha1();
  sha1.update(salt);
  sha1.update(key);

  var arc4 = new goog.crypt.Arc4();
  arc4.setKey(sha1.digest());
  arc4.discard(1536);

  if (encrypt) {
    var bytes = goog.crypt.stringToUtf8ByteArray(value);
    arc4.crypt(bytes);
    return drive.ds.sync.storage.Crypt.byteArrayToString_(
        goog.asserts.assert(bytes));
  } else {
    var bytes = goog.crypt.stringToByteArray(value);
    arc4.crypt(bytes);
    return goog.crypt.utf8ByteArrayToString(bytes);
  }
};


/**
 * Converts a byte array to a string. Performs chunking to overcome 'Maximum
 * call stack size exceeded' issues with String.fromCharCode.
 * @param {!Array} bytes A byte array.
 * @return {string} The byte array converted to a string.
 * @private
 */
drive.ds.sync.storage.Crypt.byteArrayToString_ =
    function(bytes) {
  var chunkSize = drive.ds.sync.storage.Crypt.CHUNK_SIZE_;
  var result = '';

  for (var i = 0; i * chunkSize < bytes.length; i++) {
    var start = i * chunkSize;
    var end = start + chunkSize > bytes.length ?
        bytes.length : start + chunkSize;
    result += String.fromCharCode.apply(
        null, goog.array.slice(bytes, start, end));
  }

  return result;
};

//javascript/apps/drive/dataservice/sync/storage/dumpelloindexeddb.js
goog.provide('drive.ds.sync.storage.DumpelloIndexedDb');

goog.require('goog.async.Deferred');
goog.require('goog.db');
goog.require('goog.db.Transaction');



/**
 * A Dumpello storage using IndexedDb.
 * @constructor
 */
drive.ds.sync.storage.DumpelloIndexedDb = function() {
  /**
   * The IndexedDB for the Dumpellos.
   * @private {goog.db.IndexedDb}
   */
  this.db_ = null;

  /**
   * @private {!Array.<!Function>}
   */
  this.ops_ = [];
};


/**
 * The IndexedDb name.
 * @private {string}
 */
drive.ds.sync.storage.DumpelloIndexedDb.DATABASE_NAME_ = 'cello_storage';


/**
 * The current version of the IndexedDB.
 * @private {number}
 */
drive.ds.sync.storage.DumpelloIndexedDb.DATABASE_VERSION_ = 1;


/**
 * The name of the Dumpello store.
 * @private {string}
 */
drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_ = 'dumpello';


/**
 * Opens a connection to the IndexedDb and initializes it.
 *
 * @return {!goog.async.Deferred} A deferred object for init.
 */
drive.ds.sync.storage.DumpelloIndexedDb.prototype.initialize = function() {
  var deferred = goog.db.openDatabase(
      drive.ds.sync.storage.DumpelloIndexedDb.DATABASE_NAME_,
      drive.ds.sync.storage.DumpelloIndexedDb.DATABASE_VERSION_,
      goog.bind(this.upgradeDatabase_, this),
      goog.bind(this.handleInitError_, this) /* opt_onBlocked */);
  deferred.addCallbacks(
      this.handleDatabaseOpened_, this.handleInitError_, this);
  return deferred;
};


/**
 * Updates/puts data into the database.
 *
 * @param {string} userId User ID.
 * @param {string} dumpello Dumpello bytes.
 * @param {goog.async.Deferred=} opt_deferred A deferred object to chained after
 *     the deferred object for this transaction. If this is defined, this
 *     deferred object is returned to the caller.
 * @return {!goog.async.Deferred} A deferred object for this transaction.
 */
drive.ds.sync.storage.DumpelloIndexedDb.prototype.put =
    function(userId, dumpello, opt_deferred) {
  if (this.db_) {
    var tx = this.db_.createTransaction(
        [drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_],
        goog.db.Transaction.TransactionMode.READ_WRITE);
    var store = tx.objectStore(
        drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_);
    store.put(dumpello, userId);
    var deferred = tx.wait();
    if (opt_deferred) {
      deferred.chainDeferred(opt_deferred);
      return opt_deferred;
    }
    return deferred;
  } else {
    // The database is not set up yet. Queue this operation and return the
    // deferred object for this operation.
    var deferred = new goog.async.Deferred();
    this.ops_.push(goog.bind(this.put, this, userId, dumpello, deferred));
    return deferred;
  }
};


/**
 * Gets data from the database.
 *
 * @param {string} userId User ID.
 * @param {goog.async.Deferred=} opt_deferred A deferred object to chained after
 *     the deferred object for this transaction. If this is defined, this
 *     deferred object is returned to the caller.
 * @return {!goog.async.Deferred} A deferred object for this transaction.
 */
drive.ds.sync.storage.DumpelloIndexedDb.prototype.get =
    function(userId, opt_deferred) {
  if (this.db_) {
    var tx = this.db_.createTransaction(
        [drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_]);
    var store = tx.objectStore(
        drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_);
    var deferred = store.get(userId);
    if (opt_deferred) {
      deferred.chainDeferred(opt_deferred);
      return opt_deferred;
    }
    return deferred;
  } else {
    // The database is not set up yet. Queue this operation and return the
    // deferred object for this operation.
    var deferred = new goog.async.Deferred();
    this.ops_.push(goog.bind(this.get, this, userId, deferred));
    return deferred;
  }
};


/**
 * Removes data from the database. No-op if not found.
 *
 * @param {string} userId User ID.
 * @param {goog.async.Deferred=} opt_deferred A deferred object to chained after
 *     the deferred object for this transaction. If this is defined, this
 *     deferred object is returned to the caller.
 * @return {!goog.async.Deferred} A deferred object for this transaction.
 */
drive.ds.sync.storage.DumpelloIndexedDb.prototype.remove =
    function(userId, opt_deferred) {
  if (this.db_) {
    var tx = this.db_.createTransaction(
        [drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_],
        goog.db.Transaction.TransactionMode.READ_WRITE);
    var store = tx.objectStore(
        drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_);
    store.remove(userId);
    var deferred = tx.wait();
    if (opt_deferred) {
      deferred.chainDeferred(opt_deferred);
      return opt_deferred;
    }
    return deferred;
  } else {
    // The database is not set up yet. Queue this operation and return the
    // deferred object for this operation.
    var deferred = new goog.async.Deferred();
    this.ops_.push(goog.bind(this.remove, this, userId, deferred));
    return deferred;
  }
};


/**
 * Clears the Dumpello store in the database.
 *
 * @param {goog.async.Deferred=} opt_deferred A deferred object to chained after
 *     the deferred object for this transaction. If this is defined, this
 *     deferred object is returned to the caller.
 * @return {!goog.async.Deferred} A deferred object for this transaction.
 */
drive.ds.sync.storage.DumpelloIndexedDb.prototype.clear =
    function(opt_deferred) {
  if (this.db_) {
    var tx = this.db_.createTransaction(
        [drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_],
        goog.db.Transaction.TransactionMode.READ_WRITE);
    var store = tx.objectStore(
        drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_);
    store.clear();
    var deferred = tx.wait();
    if (opt_deferred) {
      deferred.chainDeferred(opt_deferred);
      return opt_deferred;
    }
    return deferred;
  } else {
    // The database is not set up yet. Queue this operation and return the
    // deferred object for this operation.
    var deferred = new goog.async.Deferred();
    this.ops_.push(goog.bind(this.clear, this, deferred));
    return deferred;
  }
};


/**
 * Handler for initialization failure.
 * @private
 */
drive.ds.sync.storage.DumpelloIndexedDb.prototype.handleInitError_ =
    function() {
  throw Error('Failed to initialize Dumpello IndexedDb');
};


/**
 * Creates the database if it doesn't exist.
 * @param {!goog.db.IndexedDb.VersionChangeEvent} evt The version change event.
 * @param {!goog.db.IndexedDb} db The IndexedDB.
 * @param {!goog.db.Transaction} tx The current transaction.
 * @private
 */
drive.ds.sync.storage.DumpelloIndexedDb.prototype.upgradeDatabase_ =
    function(evt, db, tx) {
  if (db.getObjectStoreNames().contains(
      drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_)) {
    db.deleteObjectStore(
        drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_);
  }

  db.createObjectStore(drive.ds.sync.storage.DumpelloIndexedDb.DUMPELLO_STORE_);
};


/**
 * Saves the opened database.
 * @param {!goog.db.IndexedDb} db The opened database.
 * @private
 */
drive.ds.sync.storage.DumpelloIndexedDb.prototype.handleDatabaseOpened_ =
    function(db) {
  this.db_ = db;

  // Run any queued operations.
  while (this.ops_.length > 0) {
    this.ops_.pop().call();
  }
};

//javascript/apps/drive/dataservice/sync/storage/encrypteddumpello.js
goog.provide('drive.ds.sync.storage.EncryptedDumpello');

goog.require('drive.ds.sync.storage.Crypt');
goog.require('drive.ds.sync.storage.DumpelloIndexedDb');



/**
 * A Dumpello storage that uses IndexedDb and encrypts data.
 * @constructor
 */
drive.ds.sync.storage.EncryptedDumpello = function() {
  /** @private {!drive.ds.sync.storage.DumpelloIndexedDb} */
  this.db_ = new drive.ds.sync.storage.DumpelloIndexedDb();
};


/**
 * Initializes the underlying IndexedDb.
 *
 * @return {!goog.async.Deferred} A deferred object for init.
 */
drive.ds.sync.storage.EncryptedDumpello.prototype.initialize = function() {
  return this.db_.initialize();
};


/**
 * Encrypts the dumpello before putting it into the database.
 *
 * @param {string} userId User ID.
 * @param {string} dumpello Raw Dumpello bytes.
 * @param {string} key The encryption key.
 * @return {!goog.async.Deferred} A deferred object for this transaction.
 */
drive.ds.sync.storage.EncryptedDumpello.prototype.put =
    function(userId, dumpello, key) {
  return this.db_.put(
      userId, drive.ds.sync.storage.Crypt.encrypt(dumpello, key));
};


/**
 * Gets encrypted dumpello data from the database and decrypts it.
 *
 * @param {string} userId User ID.
 * @param {string} key The decryption key.
 * @return {!goog.async.Deferred} A deferred object for this transaction.
 */
drive.ds.sync.storage.EncryptedDumpello.prototype.get = function(userId, key) {
  var deferred = this.db_.get(userId);
  deferred.addCallback(function(encrypted) {
    try {
      return drive.ds.sync.storage.Crypt.decrypt(encrypted, key);
    } catch (e) {
      // Integrity check failed.
      return undefined;
    }
  }, this);
  return deferred;
};


/**
 * Removes an entry with the given user ID.
 *
 * @param {string} userId User ID.
 * @return {!goog.async.Deferred} A deferred object for this transaction.
 */
drive.ds.sync.storage.EncryptedDumpello.prototype.remove = function(userId) {
  return this.db_.remove(userId);
};


/**
 * Clears all Dumpello data in the database.
 *
 * @return {!goog.async.Deferred} A deferred object for this transaction.
 */
drive.ds.sync.storage.EncryptedDumpello.prototype.clear = function() {
  return this.db_.clear();
};

//javascript/apps/drive/dataservice/sync/storage/fakeencrypteddumpello.js
goog.provide('drive.ds.sync.storage.FakeEncryptedDumpello');

goog.require('drive.ds.sync.storage.Crypt');
goog.require('drive.ds.sync.storage.EncryptedDumpello');
goog.require('goog.async.Deferred');
goog.require('goog.object');



/**
 * A fake Dumpello storage that uses an in-memory store in place of IndexedDB.
 * This storage responds to requests synchronously.
 * @constructor
 * @extends {drive.ds.sync.storage.EncryptedDumpello}
 */
drive.ds.sync.storage.FakeEncryptedDumpello = function() {
  /** @private {!Object.<string, string>} Map of user id to dumpello. */
  this.userIdToDumpello_ = {};
};
goog.inherits(drive.ds.sync.storage.FakeEncryptedDumpello,
    drive.ds.sync.storage.EncryptedDumpello);


/** @override */
drive.ds.sync.storage.FakeEncryptedDumpello.prototype.initialize =
    function() {};


/** @override */
drive.ds.sync.storage.FakeEncryptedDumpello.prototype.put =
    function(userId, dumpello, key) {
  this.userIdToDumpello_[userId] =
      drive.ds.sync.storage.Crypt.encrypt(dumpello, key);
  return goog.async.Deferred.succeed();
};


/** @override */
drive.ds.sync.storage.FakeEncryptedDumpello.prototype.get =
    function(userId, key) {
  var encrypted = this.userIdToDumpello_[userId];

  try {
    return goog.async.Deferred.succeed(
        drive.ds.sync.storage.Crypt.decrypt(encrypted, key));
  } catch (e) {
    // Integrity check failed.
    return goog.async.Deferred.succeed(undefined);
  }
};


/** @override */
drive.ds.sync.storage.FakeEncryptedDumpello.prototype.remove =
    function(userId) {
  goog.object.remove(this.userIdToDumpello_, userId);
  return goog.async.Deferred.succeed();
};


/** @override */
drive.ds.sync.storage.FakeEncryptedDumpello.prototype.clear = function() {
  goog.object.clear(this.userIdToDumpello_);
  return goog.async.Deferred.succeed();
};

//javascript/apps/drive/dataservice/sync/context.js
goog.provide('drive.ds.sync.Context');

goog.require('drive.ds.sync.SyncedConfig');
goog.require('drive.ds.sync.cache.FullCorpusQueryCache');
goog.require('drive.ds.sync.cache.InMemoryCache');
goog.require('drive.ds.sync.cache.InMemoryMetadataStore');
goog.require('drive.ds.sync.cache.InMemoryQueryCache');
goog.require('drive.ds.sync.cache.IndexedDbCache');
goog.require('drive.ds.sync.cache.IndexedDbMetadataStore');
goog.require('drive.ds.sync.response.ResponseParser');
goog.require('drive.ds.sync.storage.EncryptedDumpello');
goog.require('drive.ds.sync.storage.EncryptedDumpelloUpdater');
goog.require('goog.Disposable');
goog.require('goog.array');



/**
 * A context for common synced dataservice components.
 * TODO(towong): Move additional shared components into the context.
 * @param {!drive.ds.sync.cache.MetadataStore} metadataStore The app metadata
 *     store.
 * @param {!drive.ds.sync.cache.Cache} cache The item cache.
 * @param {!drive.ds.sync.cache.QueryCache} queryCache The query cache.
 * @param {!Array.<!drive.ds.Field>} fields The complete set of fields
 *     that the client could potentially need.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item config.
 * @param {!drive.ds.sync.response.ResponseParser} responseParser The response
 *     parser.
 * @constructor
 * @extends {goog.Disposable}
 */
drive.ds.sync.Context = function(
    metadataStore, cache, queryCache, fields, config, responseParser) {
  /** @private {!drive.ds.sync.cache.MetadataStore} The app metadata store. */
  this.metadataStore_ = metadataStore;

  /** @private {!drive.ds.sync.cache.Cache} The item cache. */
  this.cache_ = cache;

  /** @private {!drive.ds.sync.cache.QueryCache} The query cache */
  this.queryCache_ = queryCache;

  /**
   * The complete set of fields that the client could potentially need.
   * @private {!Array.<!drive.ds.Field>}
   */
  this.fields_ = fields;

  /**
   * The synced item service config.
   * @protected {!drive.ds.sync.SyncedConfig} config The synced item config.
   */
  this.config = config;

  /**
   * The encrypted dumpello if available.
   * @private {drive.ds.sync.storage.EncryptedDumpello}
   */
  this.encryptedDumpello_ = this.createEncryptedDumpello();

  /** @private {drive.ds.sync.storage.EncryptedDumpelloUpdater} */
  this.encryptedDumpelloUpdater_ =
      new drive.ds.sync.storage.EncryptedDumpelloUpdater(this);

  /**
   * Whether the cache was successfully initialized using dumpello data.
   * @private {boolean}
   */
  this.initViaDumpello_ = false;

  /** @private {!drive.ds.sync.response.ResponseParser} */
  this.responseParser_ = responseParser;
};
goog.inherits(drive.ds.sync.Context, goog.Disposable);


/**
 * Creates the encrypted dumpello as needed.
 * @return {drive.ds.sync.storage.EncryptedDumpello}
 * @protected
 */
drive.ds.sync.Context.prototype.createEncryptedDumpello = function() {
  var useEncryptedDumpello = this.config.getDumpelloEncryption() &&
      this.config.getIndexedDbKeys().length > 0;
  var encryptedDumpello = useEncryptedDumpello ?
      new drive.ds.sync.storage.EncryptedDumpello() : null;

  if (encryptedDumpello) {
    encryptedDumpello.initialize();
  }

  return encryptedDumpello;
};


/**
 * @return {!drive.ds.sync.cache.MetadataStore} The app metadata store.
 */
drive.ds.sync.Context.prototype.getMetadataStore = function() {
  return this.metadataStore_;
};


/** @return {!drive.ds.sync.cache.Cache} The item cache. */
drive.ds.sync.Context.prototype.getCache = function() {
  return this.cache_;
};


/** @return {!drive.ds.sync.cache.QueryCache} The query cache */
drive.ds.sync.Context.prototype.getQueryCache = function() {
  return this.queryCache_;
};


/** Tells the context that the full corpus has been cached by Cello. */
drive.ds.sync.Context.prototype.setFullCorpusCached = function() {
  this.queryCache_ = new drive.ds.sync.cache.FullCorpusQueryCache();
};


/**
 * @return {!Array.<!drive.ds.Field>} The complete set of fields that the
 *     client could potentially need.
 */
drive.ds.sync.Context.prototype.getFields = function() {
  return this.fields_;
};


/** @return {!drive.ds.sync.SyncedConfig} The synced item service config. */
drive.ds.sync.Context.prototype.getConfig = function() {
  return this.config;
};


/**
 * The encrypted dumpello if available.
 * @return {drive.ds.sync.storage.EncryptedDumpello}
 */
drive.ds.sync.Context.prototype.getEncryptedDumpello = function() {
  return this.encryptedDumpello_;
};


/**
 * The encrypted dumpello updater.
 * @return {drive.ds.sync.storage.EncryptedDumpelloUpdater}
 */
drive.ds.sync.Context.prototype.getEncryptedDumpelloUpdater = function() {
  return this.encryptedDumpelloUpdater_;
};


/** @return {boolean} Whether the cache was initialized via dumpello. */
drive.ds.sync.Context.prototype.getInitViaDumpello = function() {
  return this.initViaDumpello_;
};


/**
 * Set whether the cache was initialized via dumpello.
 * @param {boolean} initViaDumpello Set whether the cache was initialized via
 *     dumpello.
 */
drive.ds.sync.Context.prototype.setInitViaDumpello = function(initViaDumpello) {
  this.initViaDumpello_ = initViaDumpello;
};


/** @return {!drive.ds.sync.response.ResponseParser} The response parser */
drive.ds.sync.Context.prototype.getResponseParser = function() {
  return this.responseParser_;
};


/** @override */
drive.ds.sync.Context.prototype.disposeInternal = function() {
  goog.base(this, 'disposeInternal');

  delete this.fields_;

  goog.dispose(this.cache_);
  delete this.cache_;
};


/**
 * Builds a Context instance with the given parameters.
 *
 * @param {!Array.<!drive.ds.Field>} fields The complete set of fields
 *     that the client could potentially need.
 * @param {drive.ds.sync.SyncedConfig=} opt_config The synced item service
 *     config.
 * @return {!drive.ds.sync.Context} Context built out of given parameters.
 */
drive.ds.sync.Context.buildContext = function(fields, opt_config) {
  var config = opt_config || new drive.ds.sync.SyncedConfig();

  // Validate since we're going to depend on the config to build other context
  // parameters here.
  config.validate();

  var fieldsList = goog.array.clone(fields);
  var responseParser = new drive.ds.sync.response.ResponseParser(config);
  var metadataStore = config.getUseIndexedDb() ?
      new drive.ds.sync.cache.IndexedDbMetadataStore() :
      new drive.ds.sync.cache.InMemoryMetadataStore();
  var cache = config.getUseIndexedDb() ?
      new drive.ds.sync.cache.IndexedDbCache(
          fieldsList, config, metadataStore, responseParser) :
      new drive.ds.sync.cache.InMemoryCache(
          fieldsList, config, metadataStore, responseParser);
  var queryCache = new drive.ds.sync.cache.InMemoryQueryCache(config);

  return new drive.ds.sync.Context(
      metadataStore, cache, queryCache, fieldsList, config, responseParser);
};

//javascript/apps/drive/dataservice/sync/deltaitem.js
/**
 * @fileoverview Helper for creating DeltaItem proto objects.
 */
goog.provide('drive.ds.sync.DeltaItem');

goog.require('drive.ds.DeltaItem');
goog.require('drive.ds.DeltaType');


/**
 * Creates a DeltaItem that represent an insert into the query result set.
 * @param {!drive.ds.Item} item The item to insert.
 * @param {number} position The position at which to insert an item.
 * @return {!drive.ds.DeltaItem} A delta item representing an an insert into the
 *     query result set.
 */
drive.ds.sync.DeltaItem.createInsert = function(item, position) {
  var delta = new drive.ds.DeltaItem();
  delta.setType(drive.ds.DeltaType.INSERT);
  delta.setItem(item);
  delta.setPosition(position);

  return delta;
};


/**
 * Creates a DeltaItem that represent a delete from the query result set.
 * @param {!drive.ds.Item} item The deleted item.
 * @param {number} position The position at which to delete an item.
 * @return {!drive.ds.DeltaItem} A delta item representing an a delete from the
 *     query result set.
 */
drive.ds.sync.DeltaItem.createDelete = function(item, position) {
  var delta = new drive.ds.DeltaItem();
  delta.setType(drive.ds.DeltaType.DELETE);
  delta.setPosition(position);
  delta.setItem(item);

  return delta;
};


/**
 * Creates a DeltaItem that represent a move within the query result set.
 * @param {number} prevPosition The position at which to remove the item.
 * @param {number} position The position at which to insert the item.
 * @return {!drive.ds.DeltaItem} A delta item representing an a move in the
 *     query result set.
 */
drive.ds.sync.DeltaItem.createMove = function(prevPosition, position) {
  var delta = new drive.ds.DeltaItem();
  delta.setType(drive.ds.DeltaType.MOVE);
  delta.setPrevPosition(prevPosition);
  delta.setPosition(position);

  return delta;
};


/**
 * Creates a DeltaItem that represent an update in the query result set.
 * @param {!drive.ds.Item} item The update item.
 * @param {number} position The position at which to update the item.
 * @return {!drive.ds.DeltaItem} A delta item representing an an update to a
 *     particular item in the query result set.
 */
drive.ds.sync.DeltaItem.createUpdate = function(item, position) {
  var delta = new drive.ds.DeltaItem();
  delta.setType(drive.ds.DeltaType.UPDATE);
  delta.setItem(item);
  delta.setPosition(position);

  return delta;
};

//javascript/apps/drive/dataservice/sync/itemmap.js
goog.provide('drive.ds.sync.ItemMap');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.object');



/**
 * A datastructure that converts between a map and an array representation of a
 * collection of items.
 * @param {!Array.<!drive.ds.Item>} items The items to store in the map.
 * @constructor
 */
drive.ds.sync.ItemMap = function(items) {
  /** @private {Array.<!drive.ds.Item>} The items. */
  this.items_ = null;
  this.setItems(items);

  /** @private {Object.<!drive.ds.Item>} The map of item IDs to items. */
  this.itemMap_ = null;
};


/**
 * Gets a item from the current results by ID.
 * @param {string} itemId The ID of the item to find.
 * @return {drive.ds.Item} The item if found in the current results, otherwise
 *     null.
 */
drive.ds.sync.ItemMap.prototype.get = function(itemId) {
  var itemMap = this.getItemMap();
  return itemMap[itemId] || null;
};


/**
 * Sets the items in this map.
 * @param {!Array.<!drive.ds.Item>} items The items to store in the map.
 */
drive.ds.sync.ItemMap.prototype.setItems = function(items) {
  this.items_ = items;
  this.itemMap_ = null;
};


/**
 * Sets a item in this map.
 * @param {!drive.ds.Item} item The item to store in the map.
 */
drive.ds.sync.ItemMap.prototype.set = function(item) {
  this.getItemMap()[item.getId()] = item;
  this.items_ = null;
};


/**
 * Gets the array of items from the map.
 * @return {!Array.<!drive.ds.Item>} The array of items held in this map.
 */
drive.ds.sync.ItemMap.prototype.getItemArray = function() {
  if (!this.items_) {
    goog.asserts.assert(this.itemMap_,
        'Can\'t create the items array because the map is null');
    this.items_ = this.createItemArray();
  }
  return this.items_;
};


/**
 * Creates the item array for the map. The map is guaranteed to exist before
 * this is called.
 * @return {!Array.<!drive.ds.Item>} The array of items held in this map.
 * @protected
 */
drive.ds.sync.ItemMap.prototype.createItemArray = function() {
  return goog.object.getValues(this.getItemMap());
};


/**
 * Gets the internal item map.  Recreates the map on-demand if it is null.
 * @return {!Object.<!drive.ds.Item>} The map of itemIds to items.
 */
drive.ds.sync.ItemMap.prototype.getItemMap = function() {
  if (!this.itemMap_) {
    goog.asserts.assert(this.items_,
        'Can\'t create map because the items array is null');
    this.itemMap_ = drive.ds.sync.ItemMap.createItemMap(this.items_);
  }
  return this.itemMap_;
};


/**
 * Creates an object that acts as a map of item Ids to item objects.
 * @param {!Array.<!drive.ds.Item>} items The items to create the map from.
 * @return {!Object.<!drive.ds.Item>} The map of itemIds to items.
 */
drive.ds.sync.ItemMap.createItemMap = function(items) {
  return goog.array.toObject(items, function(item) {
    return item.getId();
  });
};

//javascript/apps/drive/dataservice/sync/deltacalculator.js
goog.provide('drive.ds.sync.DeltaCalculator');

goog.require('drive.ds.DeltaType');
goog.require('drive.ds.sync.DeltaItem');
goog.require('drive.ds.sync.ItemMap');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug.Logger');



/**
 * Calculates the set of positional changes between originalItems and
 * updatedItems.
 * TODO(towong): Integrate with change log to improve diffing performance.
 * @param {!Array.<!drive.ds.Item>} originalItems
 * @param {!Array.<!drive.ds.Item>} updatedItems
 * @constructor
 */
drive.ds.sync.DeltaCalculator = function(originalItems, updatedItems) {
  /** @private {!Array.<!drive.ds.Item>} */
  this.originalItems_ = originalItems;

  /** @private {!Array.<!drive.ds.Item>} */
  this.updatedItems_ = updatedItems;
};


/**
 * Defines an offset and a range where the offset should be applied.
 * @typedef {{offset: number, start: number, end: number}}
 * @private
 */
drive.ds.sync.DeltaCalculator.OffsetRange_;


/** @private {!goog.debug.Logger} */
drive.ds.sync.DeltaCalculator.logger_ =
    goog.debug.Logger.getLogger('drive.ds.sync.DeltaCalculator');


/**
 * Gets a list of deltas.
 * @return {!Array.<!drive.ds.DeltaItem>} The set of item deltas.
 */
drive.ds.sync.DeltaCalculator.prototype.getDeltas = function() {
  // A set of changes that represent all of the positional differences in the
  // list of items. This is an ordered list of insertions, removals, and moves
  // with positions.
  var listChanges = this.createListDeltas_();

  // A set of updates for items that are in both the original and updated
  // lists (same itemId, but some different in properties).
  var itemChanges = this.createItemDeltas_();

  return goog.array.concat(listChanges, itemChanges);
};


/**
 * Creates the item changes from the original and updated items.
 * @return {!Array.<!drive.ds.DeltaItem>} The set of item changes.
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.createItemDeltas_ = function() {
  var changes = [];
  var originalItemMap = new drive.ds.sync.ItemMap(this.originalItems_);
  for (var i = 0; i < this.updatedItems_.length; i++) {
    var updatedItem = this.updatedItems_[i];
    var originalItem = originalItemMap.get(updatedItem.getId());
    if (originalItem && !jspb.Message.equals(originalItem, updatedItem)) {
      changes.push(drive.ds.sync.DeltaItem.createUpdate(updatedItem, i));
    }
  }
  return changes;
};


/**
 * Calculates a set of changes that represent all of the differences between the
 * two arrays of items.
 * @return {!Array.<!drive.ds.DeltaItem>} The set of changes found.
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.createListDeltas_ = function() {
  // Narrow the range of items that we need to calculate differences on by
  // ignoring the matching items at the beginning and end of the arrays.
  var offsetFromStart = this.getOffsetFromStart_();

  if (offsetFromStart == -1) {
    // no changes were found within the bounds of both arrays.
    if (this.originalItems_.length == this.updatedItems_.length) {
      // There are no differences.
      return [];
    } else if (this.originalItems_.length > this.updatedItems_.length) {
      // There are only removals from the end.
      return this.createRemovalsFromEnd_();
    } else if (this.originalItems_.length < this.updatedItems_.length) {
      // There are only insertions at the end.
      return this.createInsertionsToEnd_();
    }
  }

  // TODO(markcollins): Before starting the full diff, ignore items that
  // were just inserted or deleted from the end of the array.  This will
  // typically happen if a few items are inserted or deleted in the array and a
  // few items were inserted to or deleted from the bottom of the array to
  // maintain a data window.  Eliminating these extraneous changes from the end
  // of the array can greatly reduce the area that we need to look at with the
  // full diff which runs in O(mn).

  // There are changes and we need a diff.
  return this.calculateListChanges_(offsetFromStart);
};


/**
 * Gets the offset from the start of the item arrays of the first items
 * that don't match.
 * @return {number}
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.getOffsetFromStart_ = function() {
  var compareItemIds = drive.ds.sync.DeltaCalculator.compareItemIds_;
  var numToCompare =
      Math.min(this.originalItems_.length, this.updatedItems_.length);
  for (var i = 0; i < numToCompare; i++) {
    if (!compareItemIds(this.originalItems_[i], this.updatedItems_[i])) {
      return i;
    }
  }
  return -1;
};


/**
 * Gets the offset from the end of the item arrays of the first items
 * that don't match.
 * @return {number}
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.getOffsetFromEnd_ = function() {
  var compareItemIds = drive.ds.sync.DeltaCalculator.compareItemIds_;
  var i = this.originalItems_.length - 1;
  var j = this.updatedItems_.length - 1;
  for (; i >= 0 && j >= 0; i--, j--) {
    if (!compareItemIds(this.originalItems_[i], this.updatedItems_[j])) {
      break;
    }
  }
  return (this.originalItems_.length - 1) - i;
};


/**
 * Within the subset of the arrays that have differences, find the changes to
 * the list (insertions, removals and moves) between the original array and the
 * updated array.
 * @param {number} offsetFromStart The offset from the start of the item
 *     arrays to the first pair of items that don't match.
 * @return {!Array.<drive.ds.DeltaItem>} A list of changes that can
 *     be applied to originalItems to transform it into updatedItems.
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.calculateListChanges_ =
    function(offsetFromStart) {
  // start by taking the subset of original and updated items to compare.
  var offsetFromEnd = this.getOffsetFromEnd_();
  var end = this.originalItems_.length - offsetFromEnd;
  var originalItems = this.originalItems_.slice(offsetFromStart, end);
  end = this.updatedItems_.length - offsetFromEnd;
  var updatedItems = this.updatedItems_.slice(offsetFromStart, end);

  var changes = this.calculateInsertsAndRemoves_(originalItems, updatedItems);
  drive.ds.sync.DeltaCalculator.logger_.finer(
      'Raw Inserts/Deletes:\n' + changes);
  changes = this.collapseMoves_(changes);
  changes = this.adjustIndices_(changes, offsetFromStart);
  return changes;
};


/**
 * Within the subset of the arrays that have differences, find the insertions
 * and removals between the two arrays using the dynamic programming solution to
 * the Longest Common Subsequence problem.
 * http://en.wikipedia.org/wiki/Longest_common_subsequence
 *
 * Returns the set of insertions and removals between the original array and the
 * updated array. At this point, a move just looks like the removal of a
 * item from the original array and the insertion of the same item to the
 * updated array.  These pairs of insert/delete changes for the same itemId will
 * be combined into moves later.
 *
 * @param {!Array.<!drive.ds.Item>} originalItems
 * @param {!Array.<!drive.ds.Item>} updatedItems
 * @return {!Array.<!drive.ds.DeltaItem>} A list of changes (inserts and
 *     deletes only) that represent all of the differences between the two lists
 *     of items.
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.calculateInsertsAndRemoves_ =
    function(originalItems, updatedItems) {
  var i = 0;
  var j = 0;

  // We will only compare itemIds because the items themselves may have been
  // updated, but the itemId should be the same.
  var compare = drive.ds.sync.DeltaCalculator.compareItemIds_;

  // initialize the 0th row and column.
  var table = [];
  for (i = 0; i < originalItems.length + 1; i++) {
    table[i] = [];
    table[i][0] = 0;
  }
  for (j = 0; j < updatedItems.length + 1; j++) {
    table[0][j] = 0;
  }

  // fill in the table
  for (i = 1; i <= originalItems.length; i++) {
    for (j = 1; j <= updatedItems.length; j++) {
      if (compare(originalItems[i - 1], updatedItems[j - 1])) {
        table[i][j] = table[i - 1][j - 1] + 1;
      } else {
        table[i][j] = Math.max(table[i - 1][j], table[i][j - 1]);
      }
    }
  }

  // backtrack to find the insertions and removals.
  var changes = [];
  i = originalItems.length;
  j = updatedItems.length;
  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && compare(originalItems[i - 1], updatedItems[j - 1])) {
      j--; i--;
    } else if (j > 0 && (i == 0 || table[i][j - 1] > table[i - 1][j])) {
      var item = updatedItems[j - 1];
      changes.unshift(drive.ds.sync.DeltaItem.createInsert(item, i));
      j--;
    } else if (i > 0 && (j == 0 || table[i][j - 1] <= table[i - 1][j])) {
      changes.unshift(drive.ds.sync.DeltaItem.createDelete(
          originalItems[i - 1], i - 1));
      i--;
    }
  }
  return changes;
};


/**
 * Adjust the positions of the insertions/removals with an offset based on
 * previous insertions/removals and the offsetFromStart.  The offsetFromStart
 * compensates for the fact that we are comparing a subset of the items and
 * the offset allows for "playback" of the changes to work correctly.
 * @param {!Array.<drive.ds.DeltaItem>} changes The list of changes
 *     to be adjusted.
 * @param {number} offsetFromStart The offset from the start of the item
 *     arrays to the first pair of items that don't match.
 * @return {!Array.<!drive.ds.DeltaItem>} A list of changes after the
 *     indices have been adjusted.
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.adjustIndices_ =
    function(changes, offsetFromStart) {
  /** @type {!Array.<!drive.ds.sync.DeltaCalculator.OffsetRange_>} */
  var offsets = [];

  if (goog.isDefAndNotNull(changes)) {
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];

      // store the positions so that we have the original values after we adjust
      // the values.
      var position = change.getPosition() || 0;
      var prevPosition = change.getPrevPosition() || 0;

      // Adjust the position (and previous position for moves) by inserting the
      // current offset of the position and the offset from the start
      // of the real arrays.
      change.setPosition((change.getPosition() || 0) +
          this.calculateOffset_(offsets, change.getPosition() || 0));
      changes[i].setPosition((changes[i].getPosition() || 0) + offsetFromStart);
      if (changes[i].getType() == drive.ds.DeltaType.MOVE) {
        change.setPrevPosition((change.getPrevPosition() || 0) +
            this.calculateOffset_(offsets, change.getPrevPosition() || 0));
        changes[i].setPrevPosition(
            (changes[i].getPrevPosition() || 0) + offsetFromStart);
      }

      // add to offsets that affect subsequent changes.
      offsets.push(this.createOffsetRange_(
          change.getType(), position, prevPosition));
    }
  }

  return changes;
};


/**
 * Calculate the offset at a given position by looking at the offsets introduced
 * by previous changes and whether the position falls within the range affected
 * by each change.
 * @param {!Array.<!drive.ds.sync.DeltaCalculator.OffsetRange_>} offsets The
 *     offsets and ranges for the changes that have already been applied.
 * @param {number} position The position where the offset will be calculated.
 * @return {number} The offset that applies to the position.
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.calculateOffset_ =
    function(offsets, position) {
  var offset = 0;
  for (var i = 0; i < offsets.length; i++) {
    if (offsets[i].start <= position && position <= offsets[i].end) {
      offset += offsets[i].offset;
    }
  }
  return offset;
};


/**
 * Creates an object describing how the current change affects the offset of
 * subsequent changes and the range of positions that are affected.
 * @param {drive.ds.DeltaType} type The type of change.
 * @param {number} position The position of the change.
 * @param {number} prevPosition The previous position of the change.
 * @return {!drive.ds.sync.DeltaCalculator.OffsetRange_}
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.createOffsetRange_ =
    function(type, position, prevPosition) {
  switch (type) {
    case drive.ds.DeltaType.INSERT:
      return {offset: 1, start: position, end: Number.MAX_VALUE};

    case drive.ds.DeltaType.DELETE:
      return {offset: -1, start: position, end: Number.MAX_VALUE};

    case drive.ds.DeltaType.MOVE:
      return (position > prevPosition) ?
          {offset: -1, start: prevPosition, end: position} :
          {offset: 1, start: position, end: prevPosition};

    default:
      // should never happen, but makes the compiler happy.
      return {offset: 0, start: -1, end: -1};
  }
};


/**
 * Collapse insert/delete pairs for the same item into a single move.
 * @param {!Array.<!drive.ds.DeltaItem>} changes The list of changes
 *     that may contain insert/delete pairs to be collapsed.
 * @return {!Array.<!drive.ds.DeltaItem>} A list of changes after the
 *     pairs have been collapsed into moves.
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.collapseMoves_ = function(changes) {
  var changesByItem = {};
  for (var i = 0; i < changes.length; i++) {
    var itemId = changes[i].getItem().getId();
    if (goog.isDef(changesByItem[itemId])) {
      // collapse into a move.
      var existingIndex = changesByItem[itemId];
      var combinedChange =
          this.combineChanges_(changes[existingIndex], changes[i]);
      if (combinedChange) {
        changes[existingIndex] = combinedChange;
        changes.splice(i, 1);
        i--;
      }
    } else {
      changesByItem[itemId] = i;
    }
  }
  return changes;
};


/**
 * Combines a pair of changes (one insert, one delete) for the same item into a
 * single move with the updated and previous information.
 * @param {!drive.ds.DeltaItem} change1
 * @param {!drive.ds.DeltaItem} change2
 * @return {drive.ds.DeltaItem} A single move change.  Null if we
 *      didn't get one insert and one delete.
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.combineChanges_ =
    function(change1, change2) {
  var changeType = drive.ds.DeltaType;
  goog.asserts.assert(
      (change1.getType() == changeType.INSERT &&
       change2.getType() == changeType.DELETE) ||
      (change1.getType() == changeType.DELETE &&
       change2.getType() == changeType.INSERT),
      'there should be one insert and one delete');

  var updatedChange =
      (change1.getType() == changeType.INSERT) ? change1 : change2;
  var prevChange = (change1.getType() == changeType.DELETE) ? change1 : change2;
  return this.createMove_(prevChange, updatedChange);
};


/**
 * Combines a pair of changes (one insert, one delete) for the same item into a
 * single move with the updated and previous information.
 * @param {!drive.ds.DeltaItem} prevChange
 * @param {!drive.ds.DeltaItem} updatedChange
 * @return {!drive.ds.DeltaItem} A single move change.
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.createMove_ =
    function(prevChange, updatedChange) {
  var updatedPosition = updatedChange.getPosition() || 0;
  if (updatedPosition > (prevChange.getPosition() || 0)) {
    // for moves to a higher index in the list, adjust the new position down by
    // one to take into account the delete from the previous position.
    updatedPosition -= 1;
  }
  return drive.ds.sync.DeltaItem.createMove(
      prevChange.getPosition() || 0, updatedPosition);
};


/**
 * Creates a list of changes for the case where there are no differences found,
 * but the updated list is shorter than the original list, meaning that all of
 * the changes are removals from the end of the original list.
 * @return {!Array.<!drive.ds.DeltaItem>} A list of removals, one for
 * each item deleted from the end of the original list.
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.createRemovalsFromEnd_ = function() {
  var listChanges = [];
  var endPosition = this.updatedItems_.length;
  for (var i = endPosition; i < this.originalItems_.length; i++) {
    listChanges.push(drive.ds.sync.DeltaItem.createDelete(
        this.originalItems_[i], endPosition));
  }
  return listChanges;
};


/**
 * Creates a list of changes for the case where there are no differences found,
 * but the updated list is longer than the original list, meaning that all of
 * the changes are insertions to the end of the original list.
 * @return {!Array.<!drive.ds.DeltaItem>} A list of insertions, one
 * for each item inserted to the end of the original list.
 * @private
 */
drive.ds.sync.DeltaCalculator.prototype.createInsertionsToEnd_ = function() {
  var listChanges = [];
  for (var i = this.originalItems_.length; i < this.updatedItems_.length; i++) {
    var item = this.updatedItems_[i];
    listChanges.push(drive.ds.sync.DeltaItem.createInsert(item, i));
  }
  return listChanges;
};


/**
 * Compares two items by itemId.
 * @param {!drive.ds.Item} item1
 * @param {!drive.ds.Item} item2
 * @return {boolean} True if the items have the same itemId, false
 *     otherwise.
 * @private
 */
drive.ds.sync.DeltaCalculator.compareItemIds_ = function(item1, item2) {
  return (item1.getId() == item2.getId());
};

//javascript/apps/drive/dataservice/itemservice.js
/**
 * @fileoverview The interface for for clients to sending queries and mutations
 * against.
 */

goog.provide('drive.ds.ItemService');

/** @suppress {extraRequire} Force inclusion of the typedef for typechecking. */
goog.require('drive.ds.sync.mutate.MutationRequest');



/**
 * Interface for item service implementations.
 * @interface
 */
drive.ds.ItemService = function() {};


/**
 * Performs a search for items in the user's corpus matching the criteria. This
 * returns a ItemQueryLiveList object that keeps up to date with the latest data
 * and fires events to notify the client on changes.
 * TODO(towong): Push the opt_maxResults into the request proto.
 * @param {!drive.ds.ItemQueryRequest} request The criteria for the
 *     query.
 * @param {number=} opt_maxResults Initial max number of results client is
 *     interested in.
 * @return {!drive.ds.ItemQueryLiveList} The results for this query. The results
 *     are a live list of items that updates as changes are processed.
 */
drive.ds.ItemService.prototype.query = function(request, opt_maxResults) {};


/**
 * Performs a search for activities of items in the user's corpus matching the
 * criteria. This returns a ActivityQueryLiveList object that keeps up to date
 * with the latest data and fires events to notify the client on changes.
 * @param {!drive.ds.ActivityQueryRequest} request The criteria for the query.
 * @param {number=} opt_maxResults Initial max number of results client is
 *     interested in.
 * @return {!drive.ds.ActivityQueryLiveList} The results for this query. The
 *     results are a live list of items that updates as changes are processed.
 */
drive.ds.ItemService.prototype.activityQuery =
    function(request, opt_maxResults) {};


/**
 * Performs a request for permissions of an item in the user's corpus matching
 * the request criteria. This returns a PermissionQueryLiveList object that
 * keeps up to date with the latest data and fires events to notify the client
 * on changes.
 * @param {!drive.ds.ListPermissionsRequest} request The criteria for the query.
 * @param {number=} opt_maxResults Initial max number of results client is
 *     interested in.
 * @return {!drive.ds.PermissionQueryLiveList} The results for this query. The
 *     results are a live list that updates as changes are processed.
 */
drive.ds.ItemService.prototype.permissionQuery =
    function(request, opt_maxResults) {};


/**
 * Performs a mutate request on an item in the user's corpus. This returns a
 * deferred object whose callback or errback function is called with a
 * MutateItemResponse once a response is available.
 * @param {!drive.ds.sync.mutate.MutationRequest} request The mutation request.
 * @return {!goog.async.Deferred.<!drive.ds.MutateItemResponse>} The deferred
 *     object whose callback or errback function is called with a
 *     MutateItemResponse once a response is available.
 */
drive.ds.ItemService.prototype.mutate = function(request) {};


/**
 * Performs a query to retrieve a list of applications that the user has
 * installed in their Drive.
 * @return {!goog.async.Deferred.<!drive.ds.AppSettingsResponse>} The deferred
 *     object whose callback or errback function is called with an
 *     AppSettingsResponse once a response is available.
 */
drive.ds.ItemService.prototype.getApps = function() {};


/**
 * Performs a query to retrieve the user's account information and preferences.
 * @return {!goog.async.Deferred.<!drive.ds.UserAccountResponse>} The deferred
 *     object whose callback or errback function is called with an
 *     UserAccountResponse once a response is available.
 */
drive.ds.ItemService.prototype.getUserAccount = function() {};


/**
 * Adds a set of change logs to be processed. This should only be used for
 * Expello to allow us to accept browser channel events as change logs events.
 * Change logs are processed as soon as Dumpello is initialized and Genoa change
 * logs have been processed to catch up Dumpello.
 * @param {!drive.ds.ListChangesResponse} listChanges List of changes to be
 *     processed.
 */
drive.ds.ItemService.prototype.addChange = function(listChanges) {};


/**
 * Performs a query to retrieve a list of permissions for a specified item.
 * This returns a deferred object whose callback or errback function is called
 * with a ListPermissionsResponse once a response is available.
 * @param {!drive.ds.ListPermissionsRequest} request The permissions request
 * @return {!goog.async.Deferred.<!drive.ds.ListPermissionsResponse>} The
 *     deferred object whose callback or errback function is called with a
 *     ListPermissionsResponse once a response is available.
 */
drive.ds.ItemService.prototype.getPermissions = function(request) {};


/**
 * Performs a query to retrieve a list of revisions matching a specified item.
 * This returns a deferred object whose callback or errback function is called
 * with a ListRevisionsResponse once a response is available.
 * @param {!drive.ds.ListRevisionsRequest} request The revision request
 * @return {!goog.async.Deferred.<!drive.ds.ListRevisionsResponse>} The
 *     deferred object whose callback or errback function is called with a
 *     ListRevisionsResponse once a response is available.
 */
drive.ds.ItemService.prototype.getRevisions = function(request) {};


/**
 * Loads an initial dumpello using data passed in by the client. The client
 * should generate this data via the {@code DumpelloGenerator}. This feature is
 * only enabled when the dumpello_client_provided flag is true.
 * @param {string} initialDumpello The initial dumpello as a json string.
 */
drive.ds.ItemService.prototype.loadInitialDumpello =
    function(initialDumpello) {};

//javascript/closure/debug/console.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Simple logger that logs to the window console if available.
 *
 * Has an autoInstall option which can be put into initialization code, which
 * will start logging if "Debug=true" is in document.location.href
 *
 * @author uidude@google.com (Evan Gilbert)
 */

goog.provide('goog.debug.Console');

goog.require('goog.debug.LogManager');
goog.require('goog.debug.Logger.Level');
goog.require('goog.debug.TextFormatter');



/**
 * Create and install a log handler that logs to window.console if available
 * @constructor
 */
goog.debug.Console = function() {
  this.publishHandler_ = goog.bind(this.addLogRecord, this);

  /**
   * Formatter for formatted output.
   * @type {!goog.debug.TextFormatter}
   * @private
   */
  this.formatter_ = new goog.debug.TextFormatter();
  this.formatter_.showAbsoluteTime = false;
  this.formatter_.showExceptionText = false;

  this.isCapturing_ = false;
  this.logBuffer_ = '';

  /**
   * Loggers that we shouldn't output.
   * @type {!Object.<boolean>}
   * @private
   */
  this.filteredLoggers_ = {};
};


/**
 * Returns the text formatter used by this console
 * @return {!goog.debug.TextFormatter} The text formatter.
 */
goog.debug.Console.prototype.getFormatter = function() {
  return this.formatter_;
};


/**
 * Sets whether we are currently capturing logger output.
 * @param {boolean} capturing Whether to capture logger output.
 */
goog.debug.Console.prototype.setCapturing = function(capturing) {
  if (capturing == this.isCapturing_) {
    return;
  }

  // attach or detach handler from the root logger
  var rootLogger = goog.debug.LogManager.getRoot();
  if (capturing) {
    rootLogger.addHandler(this.publishHandler_);
  } else {
    rootLogger.removeHandler(this.publishHandler_);
    this.logBuffer = '';
  }
  this.isCapturing_ = capturing;
};


/**
 * Adds a log record.
 * @param {goog.debug.LogRecord} logRecord The log entry.
 */
goog.debug.Console.prototype.addLogRecord = function(logRecord) {

  // Check to see if the log record is filtered or not.
  if (this.filteredLoggers_[logRecord.getLoggerName()]) {
    return;
  }

  var record = this.formatter_.formatRecord(logRecord);
  var console = goog.debug.Console.console_;
  if (console) {
    switch (logRecord.getLevel()) {
      case goog.debug.Logger.Level.SHOUT:
        goog.debug.Console.logToConsole_(console, 'info', record);
        break;
      case goog.debug.Logger.Level.SEVERE:
        goog.debug.Console.logToConsole_(console, 'error', record);
        break;
      case goog.debug.Logger.Level.WARNING:
        goog.debug.Console.logToConsole_(console, 'warn', record);
        break;
      default:
        goog.debug.Console.logToConsole_(console, 'debug', record);
        break;
    }
  } else if (window.opera) {
    // window.opera.postError is considered an undefined property reference
    // by JSCompiler, so it has to be referenced using array notation instead.
    window.opera['postError'](record);
  } else {
    this.logBuffer_ += record;
  }
};


/**
 * Adds a logger name to be filtered.
 * @param {string} loggerName the logger name to add.
 */
goog.debug.Console.prototype.addFilter = function(loggerName) {
  this.filteredLoggers_[loggerName] = true;
};


/**
 * Removes a logger name to be filtered.
 * @param {string} loggerName the logger name to remove.
 */
goog.debug.Console.prototype.removeFilter = function(loggerName) {
  delete this.filteredLoggers_[loggerName];
};


/**
 * Global console logger instance
 * @type {goog.debug.Console}
 */
goog.debug.Console.instance = null;


/**
 * The console to which to log.  This is a property so it can be mocked out in
 * this unit test for goog.debug.Console.
 * @type {Object}
 * @private
 */
goog.debug.Console.console_ = window.console;


/**
 * Sets the console to which to log.
 * @param {!Object} console The console to which to log.
 */
goog.debug.Console.setConsole = function(console) {
  goog.debug.Console.console_ = console;
};


/**
 * Install the console and start capturing if "Debug=true" is in the page URL
 */
goog.debug.Console.autoInstall = function() {
  if (!goog.debug.Console.instance) {
    goog.debug.Console.instance = new goog.debug.Console();
  }

  if (window.location.href.indexOf('Debug=true') != -1) {
    goog.debug.Console.instance.setCapturing(true);
  }
};


/**
 * Show an alert with all of the captured debug information.
 * Information is only captured if console is not available
 */
goog.debug.Console.show = function() {
  alert(goog.debug.Console.instance.logBuffer_);
};


/**
 * Logs the record to the console using the given function.  If the function is
 * not available on the console object, the log function is used instead.
 * @param {!Object} console The console object.
 * @param {string} fnName The name of the function to use.
 * @param {string} record The record to log.
 * @private
 */
goog.debug.Console.logToConsole_ = function(console, fnName, record) {
  if (console[fnName]) {
    console[fnName](record);
  } else {
    console.log(record);
  }
};

//javascript/apps/drive/dataservice/activityquerylivelist.js
goog.provide('drive.ds.ActivityQueryLiveList');



/**
 * Interface for a live list item implementation.
 * @extends {drive.ds.LiveList.<drive.ds.ActivityQueryResponse,drive.ds.ActivityQueryDeltaResponse>}
 * @interface
 */
drive.ds.ActivityQueryLiveList = function() {};

//javascript/apps/drive/dataservice/sync/syncedactivityquerylivelist.js
goog.provide('drive.ds.sync.SyncedActivityQueryLiveList');

goog.require('drive.ds.ActivityQueryLiveList');
goog.require('drive.ds.ActivityQueryResponse');
goog.require('drive.ds.LiveList');
goog.require('drive.ds.sync.ExponentialBackoff');
goog.require('drive.ds.sync.api.Activities');
goog.require('drive.ds.sync.response.ResponseHandler');
goog.require('goog.array');
goog.require('goog.async.Deferred');
goog.require('goog.events.Event');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');



/**
 * A live list request for activities that dispatches events on changes when
 * active.
 * @param {!drive.ds.ActivityQueryRequest} request The activity query request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {number=} opt_maxActivities The maximum number of results that the
 *     client is interested in. Defaults to 50. This can be increased as clients
 *     needs additional data.
 * @implements {drive.ds.ActivityQueryLiveList}
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.SyncedActivityQueryLiveList = function(
    request, context, opt_maxActivities) {
  goog.base(this);

  /** @private {!goog.events.EventHandler} */
  this.eventHandler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.eventHandler_);

  /** @private {!drive.ds.ActivityQueryRequest} The activity query request. */
  this.request_ = request;

  /** @private {!drive.ds.sync.Context} The app context. */
  this.context_ = context;

  /** @private {boolean} Whether this live activity request is active. */
  this.active_ = false;

  /**
   * The maximum number of results that the client is interested in.
   * @private {number}
   */
  this.maxActivities_ = opt_maxActivities || 50;

  /**
   * The prev set of items matching the query criteria. This is used with the
   * items_ list to calculate diffs.
   * @private {!Array.<!proto.apps.activity.frontend.ActivityEvent>}
   */
  this.prevActivities_ = [];

  /**
   * The most recent set of data matching the query criteria.
   * @private {!Array.<!proto.apps.activity.frontend.ActivityEvent>}
   */
  this.activities_ = [];

  /**
   * Whether there are more activities that fulfill the query that haven't been
   * loaded by the livelist.
   * @private {boolean}
   */
  this.hasMoreActivities_ = true;

  /** @private {string} The continuation token. */
  this.token_ = '';

  /**
   * Exponential backoff used for time between polling queries.
   * @private {!drive.ds.sync.ExponentialBackoff}
   */
  this.backoff_ = new drive.ds.sync.ExponentialBackoff();


  /** @private {boolean} Whether a query is running. */
  this.pendingQuery_ = false;
};
goog.inherits(
    drive.ds.sync.SyncedActivityQueryLiveList, goog.events.EventTarget);


/** @override */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.activate = function() {
  this.active_ = true;

  this.request_.getOmitNewActivity() ? this.page_() : this.poll_();
};


/** @override */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.deactivate = function() {
  this.active_ = false;
};


/** @override */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.getData = function() {
  var response = new drive.ds.ActivityQueryResponse();

  response.setActivityList(this.activities_.slice(0, this.maxActivities_));
  this.prevActivities_ = goog.array.clone(this.activities_);

  return response;
};


/** @override */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.getDeltaData = function() {
  throw Error('getDeltaData is currently unsupported!');
};


/** @override */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.hasMoreData = function() {
  return this.hasMoreActivities_;
};


/** @override */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.incrementMaxCount =
    function(opt_increment) {
  if (!this.active_) {
    // TODO(jlure): Pass back a real error.
    return goog.async.Deferred.fail(null);
  }

  var prevMaxActivities = this.maxActivities_;
  this.maxActivities_ += opt_increment || 50;

  if (this.activities_.length > prevMaxActivities) {
    // More activity events have been loaded than have been returned, so
    // dispatch an event immediately.
    this.setHasMoreAndDispatchChanged_();
  }

  var deferred = new goog.async.Deferred();
  if (this.hasMoreActivities_ && !this.pendingQuery_) {
    this.page_(deferred);
    return deferred;
  }

  return goog.async.Deferred.succeed();
};


/**
 * Handles any errors returned by the server. Dispatches an error event to
 * notify the clients.
 * @param {!drive.ds.LiveList.ErrorEvent} errorEvent The event that contains the
 *     error information.
 * @private
 */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.handleErrorResponse_ =
    function(errorEvent) {
  this.dispatchEvent(errorEvent);
  this.pendingQuery_ = false;
};


/**
 * Handles a page response by appending the results to the current list,
 * updating any necessary fields, and dispatching a CHANGED event.
 * @param {!goog.async.Deferred|undefined} deferred Optional deferred that will
 *     succeed with no payload when sufficient pages are loaded. Note we define
 *     the optional parameter before non-optional parmaeters because the
 *     deferred passes in the response object which becomes the last parameter
 *     to this function.
 * @param {!proto.apps.activity.frontend.ActivityResponse} response The query
 *     response.
 * @private
 */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.handlePageResponse_ =
    function(deferred, response) {
  this.activities_ = this.activities_.concat(response.getEventList());
  this.token_ = response.getWebSafeContinuationToken() || '';
  this.setHasMoreAndDispatchChanged_();
  this.page_(deferred);
};


/**
 * Handles a poll response by replacing the current activity list, updating
 * any necessary fields, and dispatching a CHANGED event.
 * @param {!proto.apps.activity.frontend.ActivityResponse} response The query
 *     response.
 * @private
 */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.handlePollResponse_ =
    function(response) {
  var newActivities = response.getEventList();
  if (this.activitiesChanged_(
      this.activities_.slice(0, newActivities.length), newActivities)) {
    this.activities_ = newActivities;
    this.token_ = response.getWebSafeContinuationToken() || '';
    this.setHasMoreAndDispatchChanged_();
    this.page_();
  } else {
    this.pendingQuery_ = false;
    this.continuePolling_();
  }
};


/**
 * Checks if the specified array of items are different.
 * @param {!Array.<proto.apps.activity.frontend.ActivityEvent>} activitiesA The
 *     list of activities to check.
 * @param {!Array.<proto.apps.activity.frontend.ActivityEvent>} activitiesB The
 *     list of activities to check.
 * @return {boolean} Whether the list of items is different.
 * @private
 */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.activitiesChanged_ =
    function(activitiesA, activitiesB) {
  if (activitiesA.length != activitiesB.length) {
    return true;
  }

  for (var i = 0; i < activitiesA.length; i++) {
    if (!jspb.Message.equals(activitiesA[i], activitiesB[i])) {
      return true;
    }
  }

  return false;
};


/**
 * Fetches additional pages of data until maxActivities is reached or there is
 * no more data. Does not fetch new items.
 * @param {!goog.async.Deferred=} opt_deferred Optional deferred that will
 *     succeed with no payload when sufficient pages are loaded.
 * @private
 */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.page_ =
    function(opt_deferred) {
  if (!this.active_) {
    // Set in case the live list is deactivated while a query is pending.
    this.pendingQuery_ = false;
    return;
  }

  this.pendingQuery_ = true;
  if (this.hasMoreActivities_ &&
      this.activities_.length < this.maxActivities_) {
    var deferred = new goog.async.Deferred().addCallbacks(
        goog.partial(this.handlePageResponse_, opt_deferred),
        this.handleErrorResponse_, this);

    drive.ds.sync.api.Activities.list(this.request_, this.context_.getConfig(),
        goog.partial(
            drive.ds.sync.response.ResponseHandler.handleActivitiesResponse,
            deferred, this.context_), this.token_);
  } else {
    // There are no more activities or enough have been retrieved.
    this.pendingQuery_ = false;

    if (opt_deferred) {
      opt_deferred.callback();
    }

    this.continuePolling_();
  }
};


/**
 * Continuously polls for new activities.
 * @private
 */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.poll_ = function() {
  if (this.active_) {
    this.pendingQuery_ = true;
    var deferred = new goog.async.Deferred().addCallbacks(
        this.handlePollResponse_, this.handleErrorResponse_, this);

    drive.ds.sync.api.Activities.list(this.request_, this.context_.getConfig(),
        goog.partial(
            drive.ds.sync.response.ResponseHandler.handleActivitiesResponse,
            deferred, this.context_));
  }
};


/**
 * Sets {@code this.hasMoreActivities_} and dispatches a CHANGED event.
 * @private
 */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.
    setHasMoreAndDispatchChanged_ = function() {
  this.hasMoreActivities_ = this.activities_.length > this.maxActivities_ ||
      !!this.token_;

  this.dispatchEvent(new goog.events.Event(
      drive.ds.LiveList.EventType.CHANGED, this));
};


/**
 * Continues polling, increasing the back off, as necessary.
 * @private
 */
drive.ds.sync.SyncedActivityQueryLiveList.prototype.continuePolling_ =
    function() {
  if (!this.request_.getOmitNewActivity()) {
    this.backoff_.backoff();
    goog.global.setTimeout(goog.bind(this.poll_, this),
        this.backoff_.getValue());
  }
};

//javascript/apps/drive/dataservice/itemquerylivelist.js
goog.provide('drive.ds.ItemQueryLiveList');



/**
 * Interface for a live list item implementation.
 * @extends {drive.ds.LiveList.<drive.ds.ItemQueryResponse,drive.ds.ItemQueryDeltaResponse>}
 * @interface
 */
drive.ds.ItemQueryLiveList = function() {};

//javascript/apps/drive/dataservice/sync/synceditemquerylivelist.js
/**
 * @fileoverview A live item request query. Clients provide the query that
 * they are interested in and the number of results that they are interested in.
 * As results are retrieved that affect the data that the client is interested
 * in, events are dispatched to update clients with the latest data set. Clients
 * can ask for additional items by increasing the size of items that they
 * interested in.
 */

goog.provide('drive.ds.sync.SyncedItemQueryLiveList');

goog.require('drive.ds.DeltaType');
goog.require('drive.ds.Field');
goog.require('drive.ds.ItemQueryDeltaResponse');
goog.require('drive.ds.ItemQueryLiveList');
goog.require('drive.ds.ItemQueryResponse');
goog.require('drive.ds.LiveList');
goog.require('drive.ds.Status');
goog.require('drive.ds.sync.DeltaCalculator');
goog.require('drive.ds.sync.FolderUtil');
goog.require('drive.ds.sync.cache.Cache');
goog.require('drive.ds.sync.query.QueryEventType');
goog.require('goog.array');
goog.require('goog.async.Deferred');
goog.require('goog.events.Event');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');



/**
 * A live item request that dispatches events on changes.
 * @param {!drive.ds.ItemQueryRequest} request The item query request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!drive.ds.sync.query.QueryManager} queryManager The query manager.
 * @param {number=} opt_maxItems The maximum number of results that the client
 *     is interested in. Defaults to 50. This can be increased as clients needs
 *     additional data.
 * @implements {drive.ds.ItemQueryLiveList}
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.SyncedItemQueryLiveList = function(
    request, context, queryManager, opt_maxItems) {
  goog.base(this);

  /** @private {!goog.events.EventHandler} */
  this.eventHandler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.eventHandler_);

  /** @private {!drive.ds.ItemQueryRequest} The item query request. */
  this.request_ = request;

  /** @private {!drive.ds.sync.Context} The app context. */
  this.context_ = context;

  /** @private {drive.ds.sync.query.QueryRunner} The query runner. */
  this.queryRunner_ = queryManager.getQueryRunner(this.request_);

  /** @private {boolean} Whether this live item request is active. */
  this.active_ = false;

  /**
   * The maximum number of results that the client is interested in.
   * @private {number}
   */
  this.maxItems_ = opt_maxItems || 50;

  /**
   * The prev set of items matching the query criteria. This is used with the
   * items_ list to calculate diffs.
   * @private {!Array.<!drive.ds.Item>}
   */
  this.prevItems_ = [];

  /**
   * The most recent set of data matching the query criteria.
   * @private {!Array.<!drive.ds.Item>}
   */
  this.items_ = [];

  /**
   * Whether there are more items that fulfill the query that haven't been
   * loaded by the livelist.
   * @type {boolean}
   * @private
   */
  this.hasMoreItems_ = true;

  /** @private {boolean} Initial change event dispatched. */
  this.initialChangeDispatched_ = false;

  if (this.queryRunner_) {
    this.queryRunner_.setMaxItemsAndRun(this.maxItems_);
  }

  this.initListeners_();
};
goog.inherits(drive.ds.sync.SyncedItemQueryLiveList, goog.events.EventTarget);


/** @override */
drive.ds.sync.SyncedItemQueryLiveList.prototype.activate = function() {
  this.active_ = true;

  this.checkAndDispatchChanged_();
};


/** @override */
drive.ds.sync.SyncedItemQueryLiveList.prototype.deactivate = function() {
  this.active_ = false;
};


/** @override */
drive.ds.sync.SyncedItemQueryLiveList.prototype.getData = function() {
  var response = new drive.ds.ItemQueryResponse();
  response.setStatus(drive.ds.Status.SUCCESS);
  response.setItemList(this.items_);
  this.updatePermissions_(this.prevItems_, this.items_);

  this.prevItems_ = goog.array.clone(this.items_);

  return response;
};


/** @override */
drive.ds.sync.SyncedItemQueryLiveList.prototype.getDeltaData = function() {
  var deltaCalc =
      new drive.ds.sync.DeltaCalculator(this.prevItems_, this.items_);
  var deltaItems = deltaCalc.getDeltas();
  this.updatePermissionsViaDelta_(deltaItems);

  var response = new drive.ds.ItemQueryDeltaResponse();
  response.setStatus(drive.ds.Status.SUCCESS);
  response.setDeltaItemList(deltaItems);

  this.prevItems_ = goog.array.clone(this.items_);

  return response;
};


/**
 * For new or updated items, we query Genoa for permissions information. Takes a
 * set of prev and new items.
 * TODO(towong): Remove permissions related logic once files.list/changes.list
 *     provides permissions information. This isn't the most efficient solution,
 *     but is a stop gap until Genoa can provide this information (b/11186978).
 * @param {!Array.<drive.ds.Item>} prevItems The previous set of items.
 * @param {!Array.<drive.ds.Item>} newItems The new set of items.
 * @private
 */
drive.ds.sync.SyncedItemQueryLiveList.prototype.updatePermissions_ =
    function(prevItems, newItems) {
  if (!goog.array.contains(
      this.context_.getFields(), drive.ds.Field.VISIBILITIES)) {
    return;
  }

  var deltaCalc = new drive.ds.sync.DeltaCalculator(prevItems, newItems);
  this.updatePermissionsViaDelta_(deltaCalc.getDeltas());
};


/**
 * For new or updated items, we query Genoa for permissions information. Takes a
 * set of delta items.
 * @param {!Array.<drive.ds.DeltaItem>} deltaItems The delta items.
 * @private
 */
drive.ds.sync.SyncedItemQueryLiveList.prototype.updatePermissionsViaDelta_ =
    function(deltaItems) {
  if (!goog.array.contains(
      this.context_.getFields(), drive.ds.Field.VISIBILITIES)) {
    return;
  }

  var ids = [];
  for (var i = 0; i < deltaItems.length; i++) {
    var deltaItem = deltaItems[i];
    if (deltaItem.getType() != drive.ds.DeltaType.INSERT &&
        deltaItem.getType() != drive.ds.DeltaType.UPDATE) {
      continue;
    }

    if (!drive.ds.sync.FolderUtil.isFolder(deltaItem.getItem())) {
      continue;
    }

    ids.push(deltaItem.getItem().getId());
  }

  this.context_.getCache().requestPermissions(ids);
};


/** @override */
drive.ds.sync.SyncedItemQueryLiveList.prototype.hasMoreData = function() {
  return this.hasMoreItems_;
};


/** @override */
drive.ds.sync.SyncedItemQueryLiveList.prototype.incrementMaxCount =
    function(opt_increment) {
  this.maxItems_ += opt_increment || 50;

  // Try to fullfill query from existing results in the cache.
  this.checkAndDispatchChanged_();

  // If cache wasn't able to fully fulfill the request, check with query runner
  // for more.
  if (this.items_.length < this.maxItems_ && this.queryRunner_) {
    return this.queryRunner_.setMaxItemsAndRun(this.maxItems_);
  } else {
    return goog.async.Deferred.succeed();
  }
};


/**
 * Initializes listeners.
 * @private
 */
drive.ds.sync.SyncedItemQueryLiveList.prototype.initListeners_ =
    function() {
  // Listen for cache updates.
  this.eventHandler_.listen(this.context_.getCache(),
      drive.ds.sync.cache.Cache.EventType.CHANGED,
      this.checkAndDispatchChanged_);

  // Listen for errors from the query runner.
  if (this.queryRunner_) {
    this.eventHandler_.listen(this.queryRunner_,
        drive.ds.sync.query.QueryEventType.ERROR,
        this.handleQueryError_);
  }
};


/**
 * Handles the query errors from the Query runner. Dispatches an error
 * event to notify the clients.
 * @param {drive.ds.sync.query.QueryErrorEvent} errorEvent The event that
 *     contains the error information.
 * @private
 */
drive.ds.sync.SyncedItemQueryLiveList.prototype.handleQueryError_ =
    function(errorEvent) {
  this.dispatchEvent(new drive.ds.LiveList.ErrorEvent(
      errorEvent.error,
      errorEvent.retryCount,
      this.context_.getConfig().getReturnJsErrors()));
};


/**
 * Checks the latest dataset from the cache, if the data has changed, dispatch
 * an event to notify clients to fetch new data.
 * @private
 */
drive.ds.sync.SyncedItemQueryLiveList.prototype.checkAndDispatchChanged_ =
    function() {
  if (this.active_) {
    this.query_().addCallback(this.handleQueryResponse_, this);
  }
};


/**
 * Looks at the latest data from the cache and fires change events as needed.
 * @param {!drive.ds.ItemQueryResponse} response The query response.
 * @private
 */
drive.ds.sync.SyncedItemQueryLiveList.prototype.handleQueryResponse_ =
    function(response) {
  var allItems = response.getItemList();
  this.hasMoreItems_ = this.maxItems_ < allItems.length ||
      (!!this.queryRunner_ && this.queryRunner_.hasMoreItems());

  // Get the latest matching result set from the cache.
  var items = goog.array.slice(allItems, 0, this.maxItems_);
  if (this.itemsChanged_(items)) {
    this.initialChangeDispatched_ = true;
    this.items_ = items;
    this.dispatchEvent(new goog.events.Event(
        drive.ds.LiveList.EventType.CHANGED, this));
  }

  // If this query has no results, dispatch an initial CHANGED event to inform
  // clients who wait for an initial result before populating the UI.
  if (!this.items_.length && !this.initialChangeDispatched_ &&
      (!this.queryRunner_ || (!this.queryRunner_.hasMoreItems() &&
      !this.queryRunner_.isFetching()))) {
    this.initialChangeDispatched_ = true;
    this.dispatchEvent(new goog.events.Event(
        drive.ds.LiveList.EventType.CHANGED, this));
  }
};


/**
 * Checks if the specified array of items is different from the existing array
 * of items.  Serves as a quick check to determine whether we need to fire a
 * CHANGED event to our clients.
 * @param {!Array.<drive.ds.Item>} items The list of items to check.
 * @return {boolean} Whether the list of items is different.
 * @private
 */
drive.ds.sync.SyncedItemQueryLiveList.prototype.itemsChanged_ =
    function(items) {
  if (this.items_.length != items.length) {
    return true;
  }

  for (var i = 0; i < this.items_.length; i++) {
    if (!jspb.Message.equals(this.items_[i], items[i])) {
      return true;
    }
  }

  return false;
};


/**
 * Gets the latest result matching the result set. We go to the cache if the
 * query is supported, otherwise we check with the query runner for matching
 * ids and get the latest metadata from an item from the cache.
 * @return {!goog.async.Deferred.<!drive.ds.ItemQueryResponse>}
 *     The query response.
 * @private
 */
drive.ds.sync.SyncedItemQueryLiveList.prototype.query_ = function() {
  // Note: We query with maxItems + 1 to help us determine whether there are
  // more items, see #handleQueryResponse_
  if (this.context_.getCache().isRequestSupported(this.request_)) {
    return this.context_.getCache().query(this.request_, this.maxItems_ + 1);
  } else {
    // TODO(towong) These query runners could potentially be stale, figure out a
    // re-query strategy.
    var ids = this.queryRunner_.getIds();
    return this.context_.getCache().queryByIds(
        this.request_, ids, this.maxItems_ + 1);
  }
};

//javascript/apps/drive/dataservice/permissionquerylivelist.js
goog.provide('drive.ds.PermissionQueryLiveList');



/**
 * Interface for a live list item implementation.
 * @extends {drive.ds.LiveList.<drive.ds.ListPermissionsResponse,undefined>}
 * @interface
 */
drive.ds.PermissionQueryLiveList = function() {};

//javascript/apps/drive/dataservice/sync/syncedpermissionquerylivelist.js
goog.provide('drive.ds.sync.SyncedPermissionQueryLiveList');

goog.require('drive.ds.ListPermissionsResponse');
goog.require('drive.ds.LiveList');
goog.require('drive.ds.PermissionQueryLiveList');
goog.require('drive.ds.sync.ExponentialBackoff');
goog.require('drive.ds.sync.api.Permissions');
goog.require('drive.ds.sync.response.ResponseHandler');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.async.Deferred');
goog.require('goog.events.Event');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');



/**
 * A live list request for permissions that dispatches events on changes when
 * active.
 * TODO(jlure): Add unit tests and delta calculation.
 * @param {!drive.ds.ListPermissionsRequest} request The permissions request.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {number=} opt_maxPermissions The maximum number of results that the
 *     client is interested in. Defaults to 50. This can be increased as clients
 *     needs additional data.
 * @implements {drive.ds.PermissionQueryLiveList}
 * @extends {goog.events.EventTarget}
 * @constructor
 */
drive.ds.sync.SyncedPermissionQueryLiveList = function(
    request, context, opt_maxPermissions) {
  goog.base(this);

  /** @private {!goog.events.EventHandler} */
  this.eventHandler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.eventHandler_);

  /** @private {!drive.ds.ListPermissionsRequest} The permissions request. */
  this.request_ = request;

  /** @private {!drive.ds.sync.Context} The app context. */
  this.context_ = context;

  /** @private {boolean} Whether this live list is active. */
  this.active_ = false;

  /**
   * The maximum number of results that the client is interested in.
   * @private {number}
   */
  this.maxPermissions_ = opt_maxPermissions || 50;

  /**
   * The prev set of permissions matching the query criteria. This is used with
   * the permissions_ list to calculate diffs.
   * @private {!Array.<!drive.ds.Permission>}
   */
  this.prevPermissions_ = [];

  /**
   * The most recent set of data matching the query criteria.
   * @private {!Array.<!drive.ds.Permission>}
   */
  this.permissions_ = [];

  /**
   * Whether there are more permissions that fulfill the query that haven't been
   * loaded by the livelist.
   * @private {boolean}
   */
  this.hasMorePermissions_ = true;

  /**
   * Exponential backoff used for time between polling queries.
   * @private {!drive.ds.sync.ExponentialBackoff}
   */
  this.backoff_ = new drive.ds.sync.ExponentialBackoff();


  /**
   * Optional error of the most recent permissions request.
   * @private {drive.ds.LiveList.ErrorEvent}
   */
  this.errorEvent_ = null;
};
goog.inherits(
    drive.ds.sync.SyncedPermissionQueryLiveList, goog.events.EventTarget);


/** @override */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.activate = function() {
  this.active_ = true;
  this.query_();
};


/** @override */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.deactivate = function() {
  this.active_ = false;
};


/** @override */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.getData = function() {
  var response = new drive.ds.ListPermissionsResponse();
  response.setPermissionList(this.permissions_.slice(0, this.maxPermissions_));
  this.prevPermissions_ = goog.array.clone(this.permissions_);

  return response;
};


/** @override */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.getDeltaData =
    function() {
  throw Error('getDeltaData is currently unsupported!');
};


/** @override */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.hasMoreData = function() {
  return this.hasMorePermissions_;
};


/** @override */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.incrementMaxCount =
    function(opt_increment) {
  if (!this.active_ || this.errorEvent_) {
    // TODO(jlure): Pass back a real error.
    return goog.async.Deferred.fail(null);
  }

  var prevMaxPermissions = this.maxPermissions_;
  this.maxPermissions_ += opt_increment || 50;

  if (this.permissions_.length > prevMaxPermissions) {
    // More permissions have been loaded than have been returned, so
    // dispatch an event immediately.
    this.setHasMoreAndDispatchChanged_();
  }

  return goog.async.Deferred.succeed();
};


/**
 * Queries the Genoa API for list of permissions.
 * @return {!goog.async.Deferred} deferred The deferred that fires upon
 *     completion of the request.
 * @private
 */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.query_ =
    function() {
  var deferred = new goog.async.Deferred();
  deferred.addCallbacks(this.handleQueryResponse_, this.handleErrorResponse_,
      this);

  drive.ds.sync.api.Permissions.list(this.request_.getId(), goog.partial(
      drive.ds.sync.response.ResponseHandler.handlePermissionsResponse,
      deferred, this.context_));
  return deferred;
};


/**
 * Handles any errors returned by the server. Dispatches an error event to
 * notify the clients.
 * @param {!drive.ds.ListPermissionsResponse} errorResponse The response proto
 *     that contains the error information.
 * @private
 */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.handleErrorResponse_ =
    function(errorResponse) {
  var error = drive.ds.sync.response.ResponseErrorParser.parse(errorResponse);
  goog.asserts.assert(error != null);

  var errorEvent = new drive.ds.LiveList.ErrorEvent(
      error, 0, this.context_.getConfig().getReturnJsErrors());
  this.dispatchEvent(errorEvent);
  this.errorEvent_ = errorEvent;

  this.continuePolling_();
};


/**
 * Handles the query response. Dispatches a changed event to notify the clients.
 * @param {!drive.ds.ListPermissionsResponse} response The persmissions response
 *     returned from the Genoa API.
 * @private
 */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.handleQueryResponse_ =
    function(response) {
  this.errorEvent_ = null;
  var newPermissions = response.getPermissionList();
  if (this.permissionsChanged_(this.permissions_, newPermissions)) {
    this.permissions_ = newPermissions;
    this.setHasMoreAndDispatchChanged_();
  }

  this.continuePolling_();
};


/**
 * Checks if the specified array of items are different.
 * @param {!Array.<!drive.ds.Permission>} permissionsA The list of permissions.
 * @param {!Array.<!drive.ds.Permission>} permissionsB The list of permissions.
 * @return {boolean} Whether the list of permissions is different.
 * @private
 */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.permissionsChanged_ =
    function(permissionsA, permissionsB) {
  if (permissionsA.length != permissionsB.length) {
    return true;
  }

  for (var i = 0; i < permissionsA.length; i++) {
    if (!jspb.Message.equals(permissionsA[i], permissionsB[i])) {
      return true;
    }
  }

  return false;
};


/**
 * Sets {@code this.hasMorePermissions_} and dispatches a CHANGED event.
 * @private
 */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.
    setHasMoreAndDispatchChanged_ = function() {
  this.hasMorePermissions_ = this.permissions_.length > this.maxPermissions_;

  this.dispatchEvent(new goog.events.Event(
      drive.ds.LiveList.EventType.CHANGED, this));
};


/**
 * Continues polling for new permission data with increased timeout.
 * @private
 */
drive.ds.sync.SyncedPermissionQueryLiveList.prototype.continuePolling_ =
    function() {
  this.backoff_.backoff();
  goog.global.setTimeout(goog.bind(this.query_, this),
      this.backoff_.getValue());

};

//javascript/closure/net/jsloader.js
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility to load JavaScript files via DOM script tags.
 * Refactored from goog.net.Jsonp. Works cross-domain.
 *
 * @author majewski@google.com (Bo Majewski)
 * @author mikepurvis@google.com (Mike Purvis)
 * @author vivi@google.com (Octavian Costache)
 * @author ebixon@google.com (Erez Bixon)
 */

goog.provide('goog.net.jsloader');
goog.provide('goog.net.jsloader.Error');
goog.provide('goog.net.jsloader.ErrorCode');
goog.provide('goog.net.jsloader.Options');

goog.require('goog.array');
goog.require('goog.async.Deferred');
goog.require('goog.debug.Error');
goog.require('goog.dom');
goog.require('goog.dom.TagName');


/**
 * The name of the property of goog.global under which the JavaScript
 * verification object is stored by the loaded script.
 * @type {string}
 * @private
 */
goog.net.jsloader.GLOBAL_VERIFY_OBJS_ = 'closure_verification';


/**
 * The default length of time, in milliseconds, we are prepared to wait for a
 * load request to complete.
 * @type {number}
 */
goog.net.jsloader.DEFAULT_TIMEOUT = 5000;


/**
 * Optional parameters for goog.net.jsloader.send.
 * timeout: The length of time, in milliseconds, we are prepared to wait
 *     for a load request to complete. Default it 5 seconds.
 * document: The HTML document under which to load the JavaScript. Default is
 *     the current document.
 * cleanupWhenDone: If true clean up the script tag after script completes to
 *     load. This is important if you just want to read data from the JavaScript
 *     and then throw it away. Default is false.
 *
 * @typedef {{
 *   timeout: (number|undefined),
 *   document: (HTMLDocument|undefined),
 *   cleanupWhenDone: (boolean|undefined)
 * }}
 */
goog.net.jsloader.Options;


/**
 * Scripts (URIs) waiting to be loaded.
 * @type {Array.<string>}
 * @private
 */
goog.net.jsloader.scriptsToLoad_ = [];


/**
 * Loads and evaluates the JavaScript files at the specified URIs, guaranteeing
 * the order of script loads.
 *
 * Because we have to load the scripts in serial (load script 1, exec script 1,
 * load script 2, exec script 2, and so on), this will be slower than doing
 * the network fetches in parallel.
 *
 * If you need to load a large number of scripts but dependency order doesn't
 * matter, you should just call goog.net.jsloader.load N times.
 *
 * If you need to load a large number of scripts on the same domain,
 * you may want to use goog.module.ModuleLoader.
 *
 * @param {Array.<string>} uris The URIs to load.
 * @param {goog.net.jsloader.Options=} opt_options Optional parameters. See
 *     goog.net.jsloader.options documentation for details.
 */
goog.net.jsloader.loadMany = function(uris, opt_options) {
  // Loading the scripts in serial introduces asynchronosity into the flow.
  // Therefore, there are race conditions where client A can kick off the load
  // sequence for client B, even though client A's scripts haven't all been
  // loaded yet.
  //
  // To work around this issue, all module loads share a queue.
  if (!uris.length) {
    return;
  }

  var isAnotherModuleLoading = goog.net.jsloader.scriptsToLoad_.length;
  goog.array.extend(goog.net.jsloader.scriptsToLoad_, uris);
  if (isAnotherModuleLoading) {
    // jsloader is still loading some other scripts.
    // In order to prevent the race condition noted above, we just add
    // these URIs to the end of the scripts' queue and return.
    return;
  }

  uris = goog.net.jsloader.scriptsToLoad_;
  var popAndLoadNextScript = function() {
    var uri = uris.shift();
    var deferred = goog.net.jsloader.load(uri, opt_options);
    if (uris.length) {
      deferred.addBoth(popAndLoadNextScript);
    }
  };
  popAndLoadNextScript();
};


/**
 * Loads and evaluates a JavaScript file.
 * When the script loads, a user callback is called.
 * It is the client's responsibility to verify that the script ran successfully.
 *
 * @param {string} uri The URI of the JavaScript.
 * @param {goog.net.jsloader.Options=} opt_options Optional parameters. See
 *     goog.net.jsloader.Options documentation for details.
 * @return {!goog.async.Deferred} The deferred result, that may be used to add
 *     callbacks and/or cancel the transmission.
 *     The error callback will be called with a single goog.net.jsloader.Error
 *     parameter.
 */
goog.net.jsloader.load = function(uri, opt_options) {
  var options = opt_options || {};
  var doc = options.document || document;

  var script = goog.dom.createElement(goog.dom.TagName.SCRIPT);
  var request = {script_: script, timeout_: undefined};
  var deferred = new goog.async.Deferred(goog.net.jsloader.cancel_, request);

  // Set a timeout.
  var timeout = null;
  var timeoutDuration = goog.isDefAndNotNull(options.timeout) ?
      options.timeout : goog.net.jsloader.DEFAULT_TIMEOUT;
  if (timeoutDuration > 0) {
    timeout = window.setTimeout(function() {
      goog.net.jsloader.cleanup_(script, true);
      deferred.errback(new goog.net.jsloader.Error(
          goog.net.jsloader.ErrorCode.TIMEOUT,
          'Timeout reached for loading script ' + uri));
    }, timeoutDuration);
    request.timeout_ = timeout;
  }

  // Hang the user callback to be called when the script completes to load.
  // NOTE(ebixon): This callback will be called in IE even upon error. In any
  // case it is the client's responsibility to verify that the script ran
  // successfully.
  script.onload = script.onreadystatechange = function() {
    if (!script.readyState || script.readyState == 'loaded' ||
        script.readyState == 'complete') {
      var removeScriptNode = options.cleanupWhenDone || false;
      goog.net.jsloader.cleanup_(script, removeScriptNode, timeout);
      deferred.callback(null);
    }
  };

  // Add an error callback.
  // NOTE(ebixon): Not supported in IE.
  script.onerror = function() {
    goog.net.jsloader.cleanup_(script, true, timeout);
    deferred.errback(new goog.net.jsloader.Error(
        goog.net.jsloader.ErrorCode.LOAD_ERROR,
        'Error while loading script ' + uri));
  };

  // Add the script element to the document.
  goog.dom.setProperties(script, {
    'type': 'text/javascript',
    'charset': 'UTF-8',
    // NOTE(mikepurvis): Safari never loads the script if we don't set
    // the src attribute before appending.
    'src': uri
  });
  var scriptParent = goog.net.jsloader.getScriptParentElement_(doc);
  scriptParent.appendChild(script);

  return deferred;
};


/**
 * Loads a JavaScript file and verifies it was evaluated successfully, using a
 * verification object.
 * The verification object is set by the loaded JavaScript at the end of the
 * script.
 * We verify this object was set and return its value in the success callback.
 * If the object is not defined we trigger an error callback.
 *
 * @param {string} uri The URI of the JavaScript.
 * @param {string} verificationObjName The name of the verification object that
 *     the loaded script should set.
 * @param {goog.net.jsloader.Options} options Optional parameters. See
 *     goog.net.jsloader.Options documentation for details.
 * @return {!goog.async.Deferred} The deferred result, that may be used to add
 *     callbacks and/or cancel the transmission.
 *     The success callback will be called with a single parameter containing
 *     the value of the verification object.
 *     The error callback will be called with a single goog.net.jsloader.Error
 *     parameter.
 */
goog.net.jsloader.loadAndVerify = function(uri, verificationObjName, options) {
  // Define the global objects variable.
  if (!goog.global[goog.net.jsloader.GLOBAL_VERIFY_OBJS_]) {
    goog.global[goog.net.jsloader.GLOBAL_VERIFY_OBJS_] = {};
  }
  var verifyObjs = goog.global[goog.net.jsloader.GLOBAL_VERIFY_OBJS_];

  // Verify that the expected object does not exist yet.
  if (goog.isDef(verifyObjs[verificationObjName])) {
    // TODO(ebixon): Error or reset variable?
    return goog.async.Deferred.fail(new goog.net.jsloader.Error(
        goog.net.jsloader.ErrorCode.VERIFY_OBJECT_ALREADY_EXISTS,
        'Verification object ' + verificationObjName + ' already defined.'));
  }

  // Send request to load the JavaScript.
  var sendDeferred = goog.net.jsloader.load(uri, options);

  // Create a deferred object wrapping the send result.
  var deferred = new goog.async.Deferred(
      goog.bind(sendDeferred.cancel, sendDeferred));

  // Call user back with object that was set by the script.
  sendDeferred.addCallback(function() {
    var result = verifyObjs[verificationObjName];
    if (goog.isDef(result)) {
      deferred.callback(result);
      delete verifyObjs[verificationObjName];
    } else {
      // Error: script was not loaded properly.
      deferred.errback(new goog.net.jsloader.Error(
          goog.net.jsloader.ErrorCode.VERIFY_ERROR,
          'Script ' + uri + ' loaded, but verification object ' +
          verificationObjName + ' was not defined.'));
    }
  });

  // Pass error to new deferred object.
  sendDeferred.addErrback(function(error) {
    if (goog.isDef(verifyObjs[verificationObjName])) {
      delete verifyObjs[verificationObjName];
    }
    deferred.errback(error);
  });

  return deferred;
};


/**
 * Gets the DOM element under which we should add new script elements.
 * How? Take the first head element, and if not found take doc.documentElement,
 * which always exists.
 *
 * @param {!HTMLDocument} doc The relevant document.
 * @return {!Element} The script parent element.
 * @private
 */
goog.net.jsloader.getScriptParentElement_ = function(doc) {
  var headElements = doc.getElementsByTagName(goog.dom.TagName.HEAD);
  if (!headElements || goog.array.isEmpty(headElements)) {
    return doc.documentElement;
  } else {
    return headElements[0];
  }
};


/**
 * Cancels a given request.
 * @this {{script_: Element, timeout_: number}} The request context.
 * @private
 */
goog.net.jsloader.cancel_ = function() {
  var request = this;
  if (request && request.script_) {
    var scriptNode = request.script_;
    if (scriptNode && scriptNode.tagName == 'SCRIPT') {
      goog.net.jsloader.cleanup_(scriptNode, true, request.timeout_);
    }
  }
};


/**
 * Removes the script node and the timeout.
 *
 * @param {Node} scriptNode The node to be cleaned up.
 * @param {boolean} removeScriptNode If true completely remove the script node.
 * @param {?number=} opt_timeout The timeout handler to cleanup.
 * @private
 */
goog.net.jsloader.cleanup_ = function(scriptNode, removeScriptNode,
                                      opt_timeout) {
  if (goog.isDefAndNotNull(opt_timeout)) {
    goog.global.clearTimeout(opt_timeout);
  }

  scriptNode.onload = goog.nullFunction;
  scriptNode.onerror = goog.nullFunction;
  scriptNode.onreadystatechange = goog.nullFunction;

  // Do this after a delay (removing the script node of a running script can
  // confuse older IEs).
  if (removeScriptNode) {
    window.setTimeout(function() {
      goog.dom.removeNode(scriptNode);
    }, 0);
  }
};


/**
 * Possible error codes for jsloader.
 * @enum {number}
 */
goog.net.jsloader.ErrorCode = {
  LOAD_ERROR: 0,
  TIMEOUT: 1,
  VERIFY_ERROR: 2,
  VERIFY_OBJECT_ALREADY_EXISTS: 3
};



/**
 * A jsloader error.
 *
 * @param {goog.net.jsloader.ErrorCode} code The error code.
 * @param {string=} opt_message Additional message.
 * @constructor
 * @extends {goog.debug.Error}
 * @final
 */
goog.net.jsloader.Error = function(code, opt_message) {
  var msg = 'Jsloader error (code #' + code + ')';
  if (opt_message) {
    msg += ': ' + opt_message;
  }
  goog.base(this, msg);

  /**
   * The code for this error.
   *
   * @type {goog.net.jsloader.ErrorCode}
   */
  this.code = code;
};
goog.inherits(goog.net.jsloader.Error, goog.debug.Error);

//javascript/apps/drive/dataservice/sync/syncedeventtype.js
/**
 * @fileoverview Listing of synced event types.
 */

goog.provide('drive.ds.sync.SyncedEventType');


/**
 * Synced service events.
 * @enum {string}
 */
drive.ds.sync.SyncedEventType = {
  LOADED: 'loaded'
};

//javascript/apps/drive/dataservice/sync/syncedserviceloader.js
goog.provide('drive.ds.sync.SyncedServiceLoader');

goog.require('drive.ds.Error');
goog.require('drive.ds.ErrorUtil');
goog.require('drive.ds.sync.SyncedConfig');
goog.require('drive.ds.sync.SyncedEventType');
goog.require('goog.Uri');
goog.require('goog.asserts');
goog.require('goog.async.Deferred');
goog.require('goog.debug.Logger');
goog.require('goog.events.Event');
goog.require('goog.events.EventTarget');
goog.require('goog.net.jsloader');



/**
 * The synced client Loader which handles browser auth and loading of the
 * Genoa API.
 * @param {!goog.async.Deferred} deferred Deferred object to call on load
 *     completion or fatal error.
 * @constructor
 * @extends {goog.events.EventTarget}
 */
drive.ds.sync.SyncedServiceLoader = function(deferred) {
  goog.base(this);

  /** @private {boolean} Whether the client has been loaded. */
  this.loaded_ = false;

  /** @private {!drive.ds.sync.SyncedConfig} Synced item service config. */
  this.config_ = new drive.ds.sync.SyncedConfig();

  /** @private {!number} Number of retries for Drive API loading so far. */
  this.apiLoadRetries_ = 0;

  /** @private {!number} Number of retries for third-party auth. */
  this.thirdPartyAuthRetries_ = 0;

  /**
   * Deferred object to call on for load completion or fatal error.
   * @private {!goog.async.Deferred}
   */
  this.deferred_ = deferred;
};
goog.inherits(drive.ds.sync.SyncedServiceLoader, goog.events.EventTarget);


/**
 * Singleton getter for this class that takes its constructor parameters.
 * Note that only the first call to this method can specify the constructor
 * parameters and subsequent calls cannot.
 *
 * @param {goog.async.Deferred=} opt_deferred Deferred object to call on load
 *     completion or fatal error.
 * @return {!drive.ds.sync.SyncedServiceLoader} A singleton instance of
 *     SyncedServiceLoader.
 */
drive.ds.sync.SyncedServiceLoader.getInstance = function(opt_deferred) {
  if (drive.ds.sync.SyncedServiceLoader.instance_) {
    goog.asserts.assert(!opt_deferred);
    return drive.ds.sync.SyncedServiceLoader.instance_;
  }
  goog.asserts.assert(opt_deferred);
  return drive.ds.sync.SyncedServiceLoader.instance_ =
      new drive.ds.sync.SyncedServiceLoader(opt_deferred);
};


/** @private {string} Current stable Drive API version string. */
drive.ds.sync.SyncedServiceLoader.CURRENT_STABLE_ = 'v2';


/** @private {string} Current internal Drive API version string. */
drive.ds.sync.SyncedServiceLoader.CURRENT_INTERNAL_ = 'v2internal';


/**
 * Version string mappings for firsrt-party clients.
 * @private {!Object.<drive.ds.sync.SyncedConfig.FirstPartyClientId, string>}
 */
drive.ds.sync.SyncedServiceLoader.clientIdToApiVersion_ = {};


// Populates the CLIENT_ID_TO_API_VER_ map with all version mappings.
(function() {
  var verMap = {};
  var ids = drive.ds.sync.SyncedConfig.FirstPartyClientId;
  for (var client in ids) {
    var clientId = ids[client];
    if (clientId == ids.EXPLORER || clientId == ids.TESLA) {
      verMap[clientId] = drive.ds.sync.SyncedServiceLoader.CURRENT_INTERNAL_;
    } else {
      verMap[clientId] = drive.ds.sync.SyncedServiceLoader.CURRENT_STABLE_;
    }
  }
  drive.ds.sync.SyncedServiceLoader.clientIdToApiVersion_ = verMap;
})();


/** @private {string} GAPI url. */
drive.ds.sync.SyncedServiceLoader.GAPI_URL_ =
    'https://apis.google.com/js/client.js';


/** @private {string} Cello's client api key. */
drive.ds.sync.SyncedServiceLoader.CLIENT_API_KEY_ =
    'AIzaSyAC6W_CrGAAGkIS1bIn7q57iRp6BzOOj-c';


/** @private {string} Cello's client api key for qual cosmo. */
drive.ds.sync.SyncedServiceLoader.CLIENT_API_KEY_QUAL_ =
    'ANVavNIPIj4qL5VxNJaiWPLoUke7tovAukfdN48';


/** @private {string} URL for accessing qual cosmo. */
drive.ds.sync.SyncedServiceLoader.API_URL_QUAL_ =
    'https://content-googleapis-test.sandbox.google.com';


/** @private {!Array.<string>} Scope of auths used by cello. */
drive.ds.sync.SyncedServiceLoader.SCOPES_ = [
  'https://www.googleapis.com/auth/drive',
  'https://www.googleapis.com/auth/drive.apps.readonly'
];


/**
 * Client initialization parameters.
 * @enum {string}
 * @private
 */
drive.ds.sync.SyncedServiceLoader.Params_ = {
  CLIENT_ID: 'client_id',
  IMMEDIATE: 'immediate',
  ONLOAD: 'onload',
  SCOPE: 'scope'
};


/** @private {string} Gapi loaded callback. */
drive.ds.sync.SyncedServiceLoader.GAPI_LOADED_CALLBACK_ = 'gapiLoadedCallback';


/** @private {string} First party authentication key. */
drive.ds.sync.SyncedServiceLoader.FIRST_PARTY_AUTH_KEY_ =
    'googleapis.config/auth/useFirstPartyAuth';


/** @private {string} Gaia session id key. */
drive.ds.sync.SyncedServiceLoader.FIRST_PARTY_SESSION_KEY_ =
    'googleapis.config/sessionIndex';


/** @private {number} Maximum number of retries for Drive client loading. */
drive.ds.sync.SyncedServiceLoader.MAX_NUM_LOAD_RETRIES_ = 3;


/** @private {number} Maximum number of retries for authentication. */
drive.ds.sync.SyncedServiceLoader.MAX_NUM_AUTH_RETRIES_ = 3;


/** @private {!goog.debug.Logger} */
drive.ds.sync.SyncedServiceLoader.LOGGER_ =
    goog.debug.Logger.getLogger('drive.ds.sync.SyncedServiceLoader');


/** @private {string} Error message for GAPI Javascript load failure. */
drive.ds.sync.SyncedServiceLoader.GAPI_JS_LOAD_ERR_MSG_ =
    'Failed to load GAPI Javascript code.';


/** @private {string} Error message for Drive API load failure. */
drive.ds.sync.SyncedServiceLoader.DRIVE_API_LOAD_ERR_MSG_ =
    'Failed to load Drive API.';


/** @private {string} Error message for third-party authentication failure. */
drive.ds.sync.SyncedServiceLoader.THIRD_PARTY_AUTH_ERR_MSG_ =
    'Failed to authenticate third-party.';


/**
 * Loads GAPI if it isn't loaded yet.
 * @param {!drive.ds.sync.SyncedConfig} config The synced item service config.
 */
drive.ds.sync.SyncedServiceLoader.prototype.loadGapi = function(config) {
  this.config_ = config;

  if (!this.loaded_ && !window['gapi'] || !window['gapi.client']) {
    var uri = new goog.Uri(drive.ds.sync.SyncedServiceLoader.GAPI_URL_);
    uri.setParameterValue(drive.ds.sync.SyncedServiceLoader.Params_.ONLOAD,
        drive.ds.sync.SyncedServiceLoader.GAPI_LOADED_CALLBACK_);
    goog.net.jsloader.load(uri.toString()).addErrback(function(error) {
      this.reportError_(
          drive.ds.sync.SyncedServiceLoader.GAPI_JS_LOAD_ERR_MSG_,
          null, error);
    }, this);
  }
};


/**
 * Loads the Drive API.
 */
drive.ds.sync.SyncedServiceLoader.prototype.loadDriveClient = function() {
  if (!this.loaded_) {
    var root = this.config_.getUseQualCosmo() ?
        drive.ds.sync.SyncedServiceLoader.API_URL_QUAL_ : null;

    // Note: Discussed with jlhicks@, discovery is disabled on the v2internal
    // api to prevent codes names, etc. from leaking. Request methods must be
    // registered manually when we want use APIs from v2internal.
    var ver = drive.ds.sync.SyncedServiceLoader.clientIdToApiVersion_[
        this.config_.getFirstPartyClientId()];
    if (ver == drive.ds.sync.SyncedServiceLoader.CURRENT_INTERNAL_) {
      var params = { 'apiVersion': ver };

      if (root) {
        params['root'] = root;
      }

      gapi.client.register('drive.apps.list', params);
      gapi.client.register('drive.about.get', params);
      gapi.client.register('drive.changes.list', params);
      gapi.client.register('drive.files.copy', params);
      gapi.client.register('drive.files.emptyTrash', params);
      gapi.client.register('drive.files.get', params);
      gapi.client.register('drive.files.insert', params);
      gapi.client.register('drive.files.list', params);
      gapi.client.register('drive.files.update', params);
    }

    gapi.client.load('drive', drive.ds.sync.SyncedServiceLoader.CURRENT_STABLE_,
        goog.bind(this.handleDriveClientLoad_, this), root);
  }
};


/**
 * Handle the loading of the Drive API.
 * @private
 */
drive.ds.sync.SyncedServiceLoader.prototype.handleDriveClientLoad_ =
    function() {
  if (!gapi.client.drive) {
    if (this.apiLoadRetries_++ <
        drive.ds.sync.SyncedServiceLoader.MAX_NUM_LOAD_RETRIES_) {
      // TODO(paulcheong): Track this failure on server side and page oncall if
      // this happens too frequently. b/9497778.
      drive.ds.sync.SyncedServiceLoader.LOGGER_.severe(
          'Failed to load Drive API. Retrying...');
      this.loadDriveClient();
    } else {
      drive.ds.sync.SyncedServiceLoader.LOGGER_.severe(
          'Failed to load Drive API too many times. Giving up.');
      this.reportError_(
          drive.ds.sync.SyncedServiceLoader.DRIVE_API_LOAD_ERR_MSG_);
    }
  } else {
    if (this.config_.getUseThirdPartyAuth()) {
      this.doThirdPartyAuth_();
    } else {
      this.doFirstPartyAuth_();
    }
  }
};


/**
 * Callback that enables first party auth and dispatches an event to notify
 * that the Drive client has been loaded.
 * @private
 */
drive.ds.sync.SyncedServiceLoader.prototype.doFirstPartyAuth_ =
    function() {
  gapi.config.update(
      drive.ds.sync.SyncedServiceLoader.FIRST_PARTY_AUTH_KEY_, true);
  gapi.config.update(
      drive.ds.sync.SyncedServiceLoader.FIRST_PARTY_SESSION_KEY_,
      this.config_.getGaiaSessionId());
  gapi.client.setApiKey(this.config_.getUseQualCosmo() ?
      drive.ds.sync.SyncedServiceLoader.CLIENT_API_KEY_QUAL_ :
      drive.ds.sync.SyncedServiceLoader.CLIENT_API_KEY_);

  // TODO(paulcheong): Figure out a way to confirm authentication.
  this.setLoaded_();
};


/**
 * Callback that performs third party auth.
 * @private
 */
drive.ds.sync.SyncedServiceLoader.prototype.doThirdPartyAuth_ =
    function() {
  var loader = drive.ds.sync.SyncedServiceLoader;

  var authParams = {};
  authParams[loader.Params_.CLIENT_ID] = this.config_.getClientId();
  authParams[loader.Params_.SCOPE] = loader.SCOPES_;
  authParams[loader.Params_.IMMEDIATE] = false;

  gapi.auth.authorize(authParams,
      goog.bind(this.handleThirdPartyAuthResult_, this));
};


/**
 * Handles the third party auth result, dispatches an event to nofity that the
 * Drive client has been loaded, or retries on error.
 * @param {gapi.auth.OAuth20TokenObject} authResult The auth result.
 * @private
 */
drive.ds.sync.SyncedServiceLoader.prototype.handleThirdPartyAuthResult_ =
    function(authResult) {
  if (authResult['access_token']) {
    this.setLoaded_();
  } else if (this.thirdPartyAuthRetries_++ <
      drive.ds.sync.SyncedServiceLoader.MAX_NUM_AUTH_RETRIES_) {
    this.doThirdPartyAuth_();
  } else {
    this.reportError_(
        drive.ds.sync.SyncedServiceLoader.THIRD_PARTY_AUTH_ERR_MSG_);
  }
};


/**
 * Sets the client as loaded and dispatches an event to notify that the Drive
 * client has been loaded.
 * @private
 */
drive.ds.sync.SyncedServiceLoader.prototype.setLoaded_ = function() {
  this.loaded_ = true;
  this.deferred_.callback();
};


/**
 * Creates a load error and reports it.
 * @param {string=} opt_errorMessage Error message.
 * @param {?string=} opt_errorDetail Detailed error message.
 * @param {Error=} opt_error Native Javascript Error to return if the client
 *     has requested to receive native Errors. If this is null, and the client
 *     has requested native Errors, then a new Error is created and returned.
 * @private
 */
drive.ds.sync.SyncedServiceLoader.prototype.reportError_ =
    function(opt_errorMessage, opt_errorDetail, opt_error) {
  var loadError = new drive.ds.Error();
  loadError.setType(drive.ds.Error.Type.LOAD);
  if (opt_errorMessage) {
    loadError.setMessage(opt_errorMessage);
  }
  if (opt_errorDetail) {
    loadError.setDetail(opt_errorDetail);
  }
  this.deferred_.errback(drive.ds.ErrorUtil.buildError(
      loadError, this.config_.getReturnJsErrors(), opt_error));
};


/**
 * Callback function once gapi has completely loaded.
 */
var gapiLoadedCallback = function() {
  drive.ds.sync.SyncedServiceLoader.getInstance().loadDriveClient();
};
goog.exportSymbol(drive.ds.sync.SyncedServiceLoader.GAPI_LOADED_CALLBACK_,
    gapiLoadedCallback);

//javascript/apps/drive/dataservice/sync/synceditemservice.js
/**
 * @fileoverview An implementation of the item service interface using offline
 * storage with Genoa.
 */

goog.provide('drive.ds.sync.SyncedItemService');

goog.require('drive.ds.Field');
goog.require('drive.ds.ItemService');
goog.require('drive.ds.sync.SyncedActivityQueryLiveList');
goog.require('drive.ds.sync.SyncedConfig');
goog.require('drive.ds.sync.SyncedItemQueryLiveList');
goog.require('drive.ds.sync.SyncedPermissionQueryLiveList');
goog.require('drive.ds.sync.SyncedServiceLoader');
goog.require('drive.ds.sync.api.RequestManager');
goog.require('drive.ds.sync.cache.CachePopulatorManager');
goog.require('drive.ds.sync.query.QueryManager');
goog.require('drive.ds.sync.sort.ItemSorter');
goog.require('drive.ds.sync.stat.StatMonitor');
goog.require('goog.Disposable');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.async.Deferred');
goog.require('goog.debug.Console');
goog.require('goog.events.EventHandler');



/**
 * Drive client responsible for communicating with the Drive API. Handles
 * initialization of the client and requests from the client. Clients
 * provide a deferred object to call upon completion of initialization.
 * @param {!goog.async.Deferred} deferred Deferred function to call on client
 *     initialization completion.
 * @param {!drive.ds.sync.Context} context The app context.
 * @param {!drive.ds.sync.change.ChangeManager} changeManager manager to handle
 *     changes.
 * @extends {goog.Disposable}
 * @implements {drive.ds.ItemService}
 * @constructor
 */
drive.ds.sync.SyncedItemService = function(deferred, context, changeManager) {
  /** @protected {!drive.ds.sync.Context} */
  this.context = context;

  if (this.context.getConfig().getDebugMode()) {
    goog.debug.Console.autoInstall();
    drive.ds.sync.stat.StatMonitor.getInstance().setEnabled(true);
  }

  this.validateFields_(this.context.getFields(),
      this.context.getConfig().getFirstPartyClientId());

  /** @protected {!goog.events.EventHandler} */
  this.handler = new goog.events.EventHandler(this);
  this.registerDisposable(this.handler);

  /** @protected {!drive.ds.sync.change.ChangeManager} */
  this.changeManager = changeManager;

  /** @private {!drive.ds.sync.query.QueryManager} */
  this.queryManager_ = new drive.ds.sync.query.QueryManager(this.context);

  /** @protected {drive.ds.sync.cache.CachePopulatorManager} */
  this.cachePopulatorManager = new drive.ds.sync.cache.CachePopulatorManager(
      this.context, this.queryManager_);

  this.initialize(deferred);
};
goog.inherits(drive.ds.sync.SyncedItemService, goog.Disposable);


/**
 * Initializes the synced item service. By default this performs Genoa auth and
 * calls postClientAuth on success.
 * @param {!goog.async.Deferred} deferred Deferred function to call on client
 *     initialization completion.
 * @protected
 */
drive.ds.sync.SyncedItemService.prototype.initialize = function(deferred) {
  // Initialize the drive client and handle client loaded event.
  var loaderDeferred = new goog.async.Deferred();
  loaderDeferred.addCallbacks(
      goog.bind(this.postClientAuth, this, deferred),
      goog.bind(deferred.errback, deferred));
  var loader = drive.ds.sync.SyncedServiceLoader.getInstance(loaderDeferred);
  loader.loadGapi(this.context.getConfig());
};


/**
 * Handles post client authorization initializations.
 * Calls the deferred callback success once we're ready to handle client
 * requests.
 * @param {!goog.async.Deferred} deferred The deferred function to call
 *     on client initialization completion.
 * @protected
 */
drive.ds.sync.SyncedItemService.prototype.postClientAuth = function(deferred) {
  // Initialize request manager to begin processing Genoa requests.
  drive.ds.sync.api.RequestManager.getInstance().initialize();

  this.changeManager.initialize().addCallbacks(
      goog.bind(this.postChangeManagerInitialization_, this),
      goog.bind(deferred.errback, deferred));
};


/**
 * Handles post client manager initializations. By default this initializes
 * various caches and managers used by the synced item service.
 * @private
 */
drive.ds.sync.SyncedItemService.prototype.postChangeManagerInitialization_ =
    function() {
  this.cachePopulatorManager.markGenoaLoaded();
  this.changeManager.initialize();
};


/** @override */
drive.ds.sync.SyncedItemService.prototype.query = function(
    request, opt_maxResults) {
  this.validateItemQuery_(request);
  return new drive.ds.sync.SyncedItemQueryLiveList(request.cloneMessage(),
      this.context, this.queryManager_, opt_maxResults);
};


/** @override */
drive.ds.sync.SyncedItemService.prototype.activityQuery = function(
    request, opt_maxResults) {
  return new drive.ds.sync.SyncedActivityQueryLiveList(request.cloneMessage(),
      this.context, opt_maxResults);
};


/** @override */
drive.ds.sync.SyncedItemService.prototype.permissionQuery = function(
    request, opt_maxResults) {
  return new drive.ds.sync.SyncedPermissionQueryLiveList(request.cloneMessage(),
      this.context, opt_maxResults);
};


/** @override */
drive.ds.sync.SyncedItemService.prototype.mutate = function(request) {
  throw Error('mutate is unsupported!');
};


/** @override */
drive.ds.sync.SyncedItemService.prototype.getApps = function() {
  throw Error('getApps is unsupported!');
};


/** @override */
drive.ds.sync.SyncedItemService.prototype.getUserAccount = function() {
  throw Error('getUserAccount is unsupported!');
};


/** @override */
drive.ds.sync.SyncedItemService.prototype.addChange = function(listChanges) {
  throw Error('addChange is unsupported!');
};


/** @override */
drive.ds.sync.SyncedItemService.prototype.getPermissions = function(request) {
  throw Error('getPermissions is unsupported!');
};


/** @override */
drive.ds.sync.SyncedItemService.prototype.getRevisions = function(request) {
  throw Error('getRevisions is unsupported!');
};


/** @override */
drive.ds.sync.SyncedItemService.prototype.loadInitialDumpello =
    function(initialDumpello) {
  var config = this.context.getConfig();
  goog.asserts.assert(
      config.getUseDumpello() && config.getDumpelloClientProvided(),
      'Flags use_dumpello and dumpello_client_provided must be set to true!');

  this.cachePopulatorManager.loadInitialDumpello(initialDumpello);
};


/**
 * Performs validation on fields used to initialize the client.
 * @param {!Array.<!drive.ds.Field>} fields The fields to validate.
 * @param {!drive.ds.sync.SyncedConfig.FirstPartyClientId} firstPartyClientId
 *     The first-party client ID.
 * @private
 */
drive.ds.sync.SyncedItemService.prototype.validateFields_ =
    function(fields, firstPartyClientId) {
  var clientId = drive.ds.sync.SyncedConfig.FirstPartyClientId;

  goog.asserts.assert(fields.length > 0,
      'A field list is required on client initialization.');
  goog.asserts.assert(firstPartyClientId == clientId.EXPLORER ||
          !(goog.array.contains(fields, drive.ds.Field.COSMO_TYPE) ||
          goog.array.contains(fields, drive.ds.Field.SERVICE_ID)),
      'Explorer-only fields detected and the client ID is not Explorer.');
  goog.asserts.assert(firstPartyClientId == clientId.EXPLORER ||
          firstPartyClientId == clientId.TESLA ||
          !goog.array.contains(fields, drive.ds.Field.FOLDER_COLOR),
      'V2-internal fields detected but the client ID is not whitelisted.');
  if (goog.array.contains(fields, drive.ds.Field.SHAREABLE)) {
    goog.asserts.assert(goog.array.contains(fields, drive.ds.Field.USER_ROLE),
        'USER_ROLE field must be requested when SHAREABLE field is.');
  }

  // Add minimum required fields for Cello code to work.
  fields.push(drive.ds.Field.ID);
  fields.push(drive.ds.Field.OWNERS);
  fields.push(drive.ds.Field.LAST_MODIFYING_USER);
  goog.array.removeDuplicates(fields);
};


/**
 * Performs sanity checks on incoming requests.
 * @param {!drive.ds.ItemQueryRequest} request The criteria for the query.
 * @private
 */
drive.ds.sync.SyncedItemService.prototype.validateItemQuery_ =
    function(request) {
  goog.asserts.assert(
      request.getFieldList() && request.getFieldList().length > 0,
      'A field list is required on an ItemQueryRequest.');

  // If we're performing a sort by field, verify the field is available.
  var sort = request.getSort();
  var field = sort && drive.ds.sync.sort.ItemSorter.getFieldFromSort(sort);
  if (field) {
    this.validateFieldSpecified_(request, field);
  }
};


/**
 * Performs validation to check that a required field is specified.
 * @param {!drive.ds.ItemQueryRequest} request The criteria for the query.
 * @param {!drive.ds.Field} field The field to check.
 * @private
 */
drive.ds.sync.SyncedItemService.prototype.validateFieldSpecified_ =
    function(request, field) {
  goog.asserts.assert(goog.array.contains(this.context.getFields(), field),
      'Unable to sort on a field that was not specified on service init.');

  var fields = request.getFieldList() || [];
  goog.asserts.assert(goog.array.contains(fields, field),
      'Unable to sort on a field that was not specified on the request.');
};

//javascript/apps/drive/dataservice/sync/explorersynceditemservice.js
goog.provide('drive.ds.sync.ExplorerSyncedItemService');

goog.require('drive.ds.sync.SyncedConfig');
goog.require('drive.ds.sync.SyncedItemService');
goog.require('drive.ds.sync.cache.CachePopulatorManager');
goog.require('drive.ds.sync.change.ChangeManager');
goog.require('drive.ds.sync.change.ClientChangeManager');
goog.require('goog.asserts');



/**
 * Drive client for Explorer responsible for communicating with the Drive API.
 * Handles initialization of the client and requests from the client. Accepts
 * browser channel updates from Explorer instead of relying on Tango. Performs
 * Expello specific optimizations to improve initialization time by performing
 * some initializations earlier (ex. immediately Dumpello load) and
 * forgoes some unused initializations (ex. no app settings cache). Clients
 * provide a deferred object to call upon completion of initialization.
 *
 * WARNING: Temporary and Explorer-only. This will be removed once Explorer is
 *     shut down.
 * TODO(paulcheong): Remove when no longer needed.
 *
 * @param {!goog.async.Deferred} deferred Deferred function to call on client
 *     initialization completion.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.SyncedItemService}
 * @constructor
 */
drive.ds.sync.ExplorerSyncedItemService = function(deferred, context) {
  var config = context.getConfig();
  goog.asserts.assert(config.getUseDumpello(), 'Dumpello must be enabled!');
  goog.asserts.assert(config.getFirstPartyClientId() ==
      drive.ds.sync.SyncedConfig.FirstPartyClientId.EXPLORER,
      'Client change manager is only available for Explorer');
  goog.asserts.assert(!config.getDumpelloEncryption(),
      'Dumpello encryption is not currently available for Explorer');

  goog.base(this, deferred, context,
      new drive.ds.sync.change.ClientChangeManager(context));
};
goog.inherits(drive.ds.sync.ExplorerSyncedItemService,
    drive.ds.sync.SyncedItemService);


/** @override */
drive.ds.sync.ExplorerSyncedItemService.prototype.initialize =
    function(deferred) {
  // If dumpello_include_changes is enabled, we can skip Genoa auth.
  if (!this.context.getConfig().getDumpelloIncludeChanges()) {
    goog.base(this, 'initialize', deferred);
  }

  this.initializeInternal_(deferred);
};


/**
 * Handles the initialization for the ClientChangeProcessor by listening for
 * dumpello completion and firing the deferred object once the catch-up change
 * logs have finished running.
 * @param {!goog.async.Deferred} deferred Deferred function to call on client
 *     initialization completion.
 * @private
 */
drive.ds.sync.ExplorerSyncedItemService.prototype.initializeInternal_ =
    function(deferred) {
  /**
   * Expello must have a complete snapshot of data before processing any client
   * requests/brower channel changes. This means Dumpello must successfully
   * complete and Genoa catch-up change logs are processed before we fire
   * deferred.callback(). If Dumpello fails (ex. empty Dumpello) we fire
   * deferred.errback().
   *
   * If dumpello_include_changes is enabled, we skip the catch up change log
   * processing completely.
   */

  // Notify change manager when Dumpello has loaded. Or if
  // dumpello_include_changes is enabled, we can success immediately.
  this.handler.listenOnce(this.cachePopulatorManager,
      drive.ds.sync.cache.CachePopulatorManager.EventType.COMPLETE,
      function() {
        if (this.context.getConfig().getDumpelloIncludeChanges()) {
          deferred.callback();
        } else {
          this.changeManager.markDumpelloLoaded();
        }
      });

  // Notify client if Dumpello errors out.
  this.handler.listenOnce(this.cachePopulatorManager,
      drive.ds.sync.cache.CachePopulatorManager.EventType.ERROR,
      function() {
        deferred.errback();
      });

  // Notify our clients once change managers have started processing and
  // we're ready to handle requests.
  this.handler.listenOnce(this.changeManager,
      drive.ds.sync.change.ChangeManager.EventType.PROCESSING,
      function() {
        deferred.callback();
      });

  this.cachePopulatorManager.initialize();
  this.cachePopulatorManager.run();
};


/** @override */
drive.ds.sync.ExplorerSyncedItemService.prototype.addChange =
    function(listChanges) {
  if (this.changeManager) {
    /** @type {!drive.ds.sync.change.ClientChangeManager} */
    (this.changeManager).addChange(listChanges);
  }
};

//javascript/apps/drive/dataservice/useraccount/useraccountmanager.js
goog.provide('drive.ds.sync.useraccount.UserAccountManager');

goog.require('drive.ds.sync.CommandManager');
goog.require('drive.ds.sync.cache.InMemoryUserAccountCache');
goog.require('drive.ds.sync.cache.UserAccountCache');
goog.require('goog.events.EventHandler');



/**
 * A user account manager responsible for maintaining a queue of pending user
 * account requests that need to be processed.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.CommandManager.<undefined>}
 * @constructor
 */
drive.ds.sync.useraccount.UserAccountManager = function(context) {
  goog.base(this);

  /** @private {!goog.events.EventHandler} */
  this.handler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.handler_);

  /** @private {!drive.ds.sync.cache.UserAccountCache} */
  this.userAccountCache_ =
      new drive.ds.sync.cache.InMemoryUserAccountCache(context);
};
goog.inherits(drive.ds.sync.useraccount.UserAccountManager,
    drive.ds.sync.CommandManager);


/**
 * Trigger user account cache initialization.
 */
drive.ds.sync.useraccount.UserAccountManager.prototype.initialize = function() {
  this.handler_.listenOnce(this.userAccountCache_,
      drive.ds.sync.cache.UserAccountCache.EventType.INITIALIZED,
      goog.bind(this.handleUserAccountCacheInitialized_, this));

  this.userAccountCache_.initialize();
};


/**
 * Handles app settings cache initialization completion.
 * @private
 */
drive.ds.sync.useraccount.UserAccountManager.prototype.
    handleUserAccountCacheInitialized_ = function() {
  this.markInitialized();
};


/** @override */
drive.ds.sync.useraccount.UserAccountManager.prototype.processCommand =
    function(commandWrapper) {
  // Processes the user account request.
  var deferred = commandWrapper.getDeferred();
  deferred.callback(this.userAccountCache_.getAccount());
};

//javascript/apps/drive/dataservice/sync/genericsynceditemservice.js
goog.provide('drive.ds.sync.GenericSyncedItemService');

goog.require('drive.ds.sync.SyncedConfig');
goog.require('drive.ds.sync.SyncedItemService');
goog.require('drive.ds.sync.api.Permissions');
goog.require('drive.ds.sync.api.Revisions');
goog.require('drive.ds.sync.appsettings.AppSettingsManager');
goog.require('drive.ds.sync.cache.Cache');
goog.require('drive.ds.sync.cache.CachePopulatorManager');
goog.require('drive.ds.sync.change.RemoteChangeManager');
goog.require('drive.ds.sync.mutate.MutationFactory');
goog.require('drive.ds.sync.response.ResponseHandler');
goog.require('drive.ds.sync.useraccount.UserAccountManager');
goog.require('goog.asserts');
goog.require('goog.async.Deferred');



/**
 * Drive client backed by Tango responsible for communicating with the Drive
 * API. Handles initialization of the client and requests from the client. Uses
 * Tango for change updates. Clients provide a deferred object to call upon
 * completion of initialization.
 *
 * TODO(towong): Merge with SyncedItemService once we no longer have
 *     ExplorerSyncedItemService.
 *
 * @param {!goog.async.Deferred} deferred Deferred function to call on client
 *     initialization completion.
 * @param {!drive.ds.sync.Context} context The app context.
 * @extends {drive.ds.sync.SyncedItemService}
 * @constructor
 */
drive.ds.sync.GenericSyncedItemService = function(deferred, context) {
  var config = context.getConfig();
  goog.asserts.assert(config.getFirstPartyClientId() !=
      drive.ds.sync.SyncedConfig.FirstPartyClientId.EXPLORER,
      'GenericSyncedItemService is not available for Explorer!');

  goog.base(this, deferred, context,
      new drive.ds.sync.change.RemoteChangeManager(context));

  /** @private {!drive.ds.sync.appsettings.AppSettingsManager} */
  this.appSettingsManager_ =
      new drive.ds.sync.appsettings.AppSettingsManager(context);

  /** @private {!drive.ds.sync.useraccount.UserAccountManager} */
  this.userAccountManager_ =
      new drive.ds.sync.useraccount.UserAccountManager(context);

  /** @private {!drive.ds.sync.mutate.MutationFactory} */
  this.mutationFactory_ = new drive.ds.sync.mutate.MutationFactory(context);
};
goog.inherits(drive.ds.sync.GenericSyncedItemService,
    drive.ds.sync.SyncedItemService);


/** @override */
drive.ds.sync.GenericSyncedItemService.prototype.initialize =
    function(deferred) {
  goog.base(this, 'initialize', deferred);

  this.initializeInternal_(deferred);
};


/**
 * Starts the cache populator manager. We start this early so that dumpello can
 * begin processing earlier.
 * @param {!goog.async.Deferred} deferred Deferred function to call on client
 *     initialization completion.
 * @private
 */
drive.ds.sync.GenericSyncedItemService.prototype.initializeInternal_ =
    function(deferred) {
  var eventType = drive.ds.sync.cache.CachePopulatorManager.EventType;

  /**
   * If Dumpello is enabled, we wait on it to complete before we process change
   * logs from Genoa. If Dumpello is enabled but fails, the
   * RemoteChangeManager will start with the latest Genoa ID instead of
   * the metadata store change id.
   */
  if (this.context.getConfig().getUseDumpello()) {
    // Notify change managers when Dumpello has loaded or failed.
    this.handler.listenOnce(this.cachePopulatorManager,
        [eventType.COMPLETE, eventType.ERROR],
        function() {
          this.changeManager.markDumpelloLoaded();
        });
  }

  /**
   * If Dumpello or Persistello is enabled, the DataService layer is ready to
   * serve requests as soon as the dumpello is loaded from Persistello.
   */
  if (this.context.getConfig().getUseDumpello() ||
      this.context.getEncryptedDumpello()) {
    this.handler.listenOnce(this.cachePopulatorManager,
        eventType.COMPLETE,
        goog.partial(this.handleDataServiceReady_, deferred));
  }

  this.cachePopulatorManager.initialize();
  this.cachePopulatorManager.run();
};


/** @override */
drive.ds.sync.GenericSyncedItemService.prototype.postClientAuth =
    function(deferred) {
  goog.base(this, 'postClientAuth', deferred);

  this.context.getCache().initialize();
  this.appSettingsManager_.initialize();

  this.handler.listenOnce(this.context.getCache(),
      drive.ds.sync.cache.Cache.EventType.INITIALIZED,
      goog.partial(this.handleDataServiceReady_, deferred));
};


/**
 * Notifies clients that Cello is ready to process requests.
 * @param {!goog.async.Deferred} deferred Deferred function to call on client
 *     initialization completion.
 * @private
 */
drive.ds.sync.GenericSyncedItemService.prototype.handleDataServiceReady_ =
    function(deferred) {
  if (!deferred.hasFired()) {
    deferred.callback();
  }
};


/** @override */
drive.ds.sync.GenericSyncedItemService.prototype.mutate = function(request) {
  var deferred = new goog.async.Deferred();
  var mutation = this.mutationFactory_.create(request, deferred);
  mutation.applyRemotely();
  return deferred;
};


/** @override */
drive.ds.sync.GenericSyncedItemService.prototype.getApps = function() {
  return this.appSettingsManager_.enqueue(undefined);
};


/** @override */
drive.ds.sync.GenericSyncedItemService.prototype.getUserAccount = function() {
  return this.userAccountManager_.enqueue(undefined);
};


/** @override */
drive.ds.sync.GenericSyncedItemService.prototype.getPermissions =
    function(request) {
  var deferred = new goog.async.Deferred();
  drive.ds.sync.api.Permissions.list(request.getId(), goog.partial(
      drive.ds.sync.response.ResponseHandler.handlePermissionsResponse,
      deferred, this.context));
  return deferred;
};


/** @override */
drive.ds.sync.GenericSyncedItemService.prototype.getRevisions =
    function(request) {
  var deferred = new goog.async.Deferred();
  drive.ds.sync.api.Revisions.list(request, goog.partial(
      drive.ds.sync.response.ResponseHandler.handleRevisionsResponse,
      deferred, this.context));
  return deferred;
};

